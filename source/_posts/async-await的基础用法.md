---
title: async/await的基础用法
date: 2019-07-14 22:47:48
categories:
- 前端
tags:
- javascript
---

# async/await的基础用法

> 参考：https://www.jianshu.com/p/ffa5cbe9ab29
>
> 推荐阅读：https://segmentfault.com/a/1190000007535316
>
> 
>
> 另外补充：进程、线程和协程的理解
>
> 参考https://blog.csdn.net/hairetz/article/details/16119911

## 进程、线程和协程

|      |  堆  |  栈  |          调度          |
| :--: | :--: | :--: | :--------------------: |
| 进程 | 独立 | 独立 |        操作系统        |
| 线程 | 共享 | 独立 |        操作系统        |
| 协程 | 共享 | 独立 | 程序员在代码中显式调度 |

- 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
- 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。
- 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。

进程和其他两个的区别还是很明显的。

协程和线程的区别是：**协程避免了无意义的调度，由此可以提高性能**，但也因此，程序员必须自己承担调度的责任，同时，**协程也失去了标准线程使用多CPU的能力**。

## async/await的特点

- `Promise`主要用then函数的链式调用，一直点点点，是一种从左向右的横向写法。
  `async/await`从上到下，顺序执行，就像写同步代码一样。这更符合人编写代码的习惯
- `Promise`的then函数只能传递一个参数，虽然可以通过包装成对象，但是这会导致传递冗余信息，频繁的解析又重新组合参数，比较麻烦。
  `async/await`没有这个限制，就当做普通的局部变量来处理好了，用let或者const定义的块级变量，想怎么用就怎么用，想定义几个就定义几个，完全没有限制，也没有冗余的工作。
- `Promise`在使用的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰。
  `async/await`整个书写习惯都是同步的，不需要纠结同步和异步的区别。当然，异步过程需要包装成一个`Promise`对象，放在`await`关键字后面，这点还是要牢记的。
- `Promise`是根据函数式编程的范式，对异步过程进行了一层封装。
  `async/await`是基于协程的机制，是真正的“保存上下文，控制权切换 ... ... 控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述。
- `async/await`是基于`Promise`的，是进一步的一种优化。不过再写代码的时候，`Promise`本身的API出现得很少，很接近同步代码的写法。

## **await关键字使用的注意点**

- 只能放在`async`函数内部使用，不能放在普通函数里面，否则会报错。

- 后面放`Promise`对象，在`Pending`状态时，相应的协程会交出控制权，进入等待状态。这个是本质。

- `await`是`async wait`的意思，`wait`的是`resolve(data)`消息，并把数据`data`返回。比如，下面代码中，当`Promise`对象由`Pending`变为`Resolved`的时候，变量`a`就等于`data`；然后再顺序执行下面的语句`console.log(a);`
  这真的是等待，真的是顺序执行，表现和同步代码几乎一模一样。

  ```js
  const a = await new Promise((resolve, reject) => {
      // async process ...
      return resolve(data);
  });
  console.log(a);
  
  ```

- `await`后面也可以跟同步代码，不过系统会自动转化成一个`Promise`对象。
  比如
  `const a = await 'hello world';`
  其实就相当于
  `const a = await Promise.resolve('hello world');`
  这跟同步代码
  `const a = 'hello world';`是一样的，还不如省点事，去掉这里的`await`关键字。

- `await`只关心异步过程成功的消息`resolve(data)`，拿到相应的数据`data`。至于失败消息`reject(error)`，不关心，不处理。
  当然对于错误消息的处理，有以下几种方法供选择：
  （1）让`await`后面的`Promise`对象自己`catch`
  （2）也可以让外面的`async`函数返回的`Promise`对象统一`catch`
  （3）像同步代码一样，放在一个`try...catch`结构中

## async关键字使用的注意点

- 有了这个`async`关键字，只是表明里面可能有异步过程，里面可以有`await`关键字。当然，全部是同步代码也没关系。当然，这时候这个`async`关键字就显得多余了。不是不能加，而是不应该加。
- `async`函数，如果里面有异步过程，会等待；
  但是`async`函数本身会马上返回，不会阻塞当前线程。

> 可以简单认为，`async`函数工作在主线程，同步执行，不会阻塞界面渲染。
> `async`函数内部由`async`关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回。

- `async`函数的返回值是一个`Promise`对象，这个是和普通函数本质不同的地方。这也是使用时重点注意的地方
  （1）`return newPromise();`这个符合`async`函数本意；
  （2）`return data;`这个是同步函数的写法，这里是要特别注意的。这个时候，其实就相当于`Promise.resolve(data);`还是一个`Promise`对象。
  在调用`async`函数的地方通过简单的`=`是拿不到这个`data`的。
  那么怎么样拿到这个`data`呢？
  很简单，返回值是一个`Promise`对象，用`.then(data => { })`函数就可以。
  （3）如果没有返回，相当于返回了`Promise.resolve(undefined);`
- `await`是不管异步过程的`reject(error)`消息的，`async`函数返回的这个`Promise`对象的`catch`函数就负责统一抓取内部所有异步过程的错误。
  `async`函数内部只要有一个异步过程发生错误，整个执行过程就中断，这个返回的`Promise`对象的`catch`就能抓到这个错误。
- `async`函数执行和普通函数一样，函数名带个()就可以了，参数个数随意，没有限制；也需要有`async`关键字。
  只是返回值是一个`Promise`对象，可以用then函数得到返回值，用catch抓去整个流程中发生的错误。