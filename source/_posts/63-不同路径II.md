---
title: 63.不同路径II
date: 2019-09-04 21:20:26
categories:
- 算法
tags:
- leetcode
- 动态规划
---

# 63.不同路径II

原题目如下：

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
> 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
>
> ![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)
>
> 网格中的障碍物和空位置分别用 1 和 0 来表示。
>
> 说明：m 和 n 的值均不超过 100。
>
> 示例 1:
>
> 输入:
> [
>   [0,0,0],
>   [0,1,0],
>   [0,0,0]
> ]
>
> 输出: 2
>
> 解释:
> 3x3 网格的正中间有一个障碍物。
> 从左上角到右下角一共有 2 条不同的路径：
>
> ```
> 1. 向右 -> 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右 -> 向右
> ```
>
> 
>
> 来源：力扣（LeetCode）
>
> 链接：https://leetcode-cn.com/problems/unique-paths-ii
> 著作权归领扣网络所有。



## 解题思路

这道题与[前一道题](https://chph.xyz/2019/09/04/62-不同路径/)的区别只在于输入的二维数组增加了障碍物这一限制条件，只要在之前的思路（详见前面的链接）上稍作修改即可，用m和n分别表示输入的数组的行和列，我自己当时的解题思路如下：

- 采用自底向上的递推方式，还是采用一位数组来降低空间开销，将dp数组初始化为包含m个元素的数组，然后将最后一个元素设置为1，原因是从最底层走，不考虑障碍物的情况下，只有一条路径能够到达目的地（*后来发现出现的问题就是，如果目的地就是障碍物的话，这样是无法AC的，所以在开始推导的最开始直接排除了这种情况`if(obstacleGrid[m-1][n-1]==1) return 0;`，省事*）
- 推导的核心公式是`dp[j] = dp[j]+dp[j+1];`，所以存在边界的问题，因此限定`0 ≤ j ≤ m-2`，而`j = m-1`的情况（即最底层）单独判断：如果在点`obstacleGrid[m-1][i]`遇到障碍物，则将dp数组的最后一个元素设置为0，表示从最底层小于等于点i的开始走，必然无法走到目的地
- 如果不是在最底层遇到障碍物（设为点`obstacleGrid[j][i]`），则只需要将`dp[j]`设置为0，表示从该点开始走，无法走到目的地，对其他路径的贡献为0

所以最终的解决方案如下：

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        if(obstacleGrid[m-1][n-1]==1) return 0;
        vector<long> dp(m-1, 0);
        dp.push_back(1);
        for(int i = n-1;i>=0;i--){
            if(obstacleGrid[m-1][i]==1){
                dp[m-1] = 0;
            }
            for(int j = m-2;j>=0;j--){
                if(obstacleGrid[j][i]==0){
                    dp[j] = dp[j]+dp[j+1];
                }else{
                    dp[j] = 0;
                }
            }
        }
        return dp[0];
    }
};
```

提交之后，虽然AC了，但是感觉有点不够优雅：

![](https://i.loli.net/2019/09/04/3RYpKZCPfHU4bDE.png)

<u>*ps：这里有个坑是大数组的输入，如果使用`vector<int>`会溢出，改用`vector<long>`就可以了，这个也是没办法的*</u>



## 题解

### 思路一

学习了leetcode官方的题解后发现自己的思路局限在了自底向上的角度，实际上自顶向下和自底向上最终的 结果是一样的，但使用自顶向下似乎更有助于思考问题。

最关键的问题还是集中在遇到障碍物时采取的措施上，因为题目没有要求输入数据不能修改，可以直接使用obstacleGrid作为dp数组，达到最优化空间复杂度，这样dp递推方程就变成了：

```cpp
obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
```

而当`obstacleGrid[i][j]`是障碍物时，可直接将其置0：

> 如果这个点有障碍物，设值为 `0` ，这可以保证不会对后面的路径产生贡献。

这个可以体现在上面的递推方程上。即使是这样，还是避免不了边界条件的处理，这里就不展开了。

### 思路二

归根结底，解法不优雅的根源是边界问题的处理，所以也可以通过在原有的数组行列上各添加一维全0的数据，这样就比较优雅了。