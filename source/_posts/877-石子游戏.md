---
title: 877.石子游戏
date: 2019-07-14 23:22:39
categories:
- 算法
tags:
- leetcode
- 动态规划
---

# 877. 石子游戏

原题目如下：

> 亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。
>
> 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。
>
> 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。
>
> 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。
>
> 
>
> 示例：
>
> 输入：[5,3,4,5]
>
> 输出：true
>
> 解释：
>
> 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。
>
> 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
>
> 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。
>
> 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。
>
> 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。
>
> 提示：
>
> 2 <= piles.length <= 500
> piles.length 是偶数。
> 1 <= piles[i] <= 500
> sum(piles) 是奇数。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/stone-game
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 一个TLE的解法

举个栗子，假设初始堆是：[1，2，3，4，5]，那么第一回合（即两个各拿一堆）后，会出现三种状态：

- 亚4,李1，剩下[2，3]

  ps：这里其实会出现“亚1,李4，剩下[2，3]”的情况，但是想想就知道，这两种情况的子问题都是[2，3]，如果“亚4,李1”不能保证亚赢的话，那“亚1,李4”就更不可能了，所以这种情况可以排除了

- 亚4,李3，剩下[1，2]

- 亚1,李2，剩下[3，4]

然后接下来就是递归求解了，最后当剩下两堆时，可以保证亚取得最优解，直接返回两人的分差（亚-李）；然后递归计算完上面三个子问题之后，取最优的一种情况返回，最优的情况指的是两人得分差别最大的那种取法

代码不仅冗长，甚至还超时了orz：

```js
/**
 * @param {number[]} piles
 * @return {boolean}
 */

const sub = (left, right, piles)=>{
    const l = piles[left], r = piles[right];
    if(right-left == 1){
        if(l>r) return [l, r];
        else return [r, l];
    }else{
        const subRes1 = sub(left+1,right-1,piles);
        if (l>r){
            subRes1[0] += l;
            subRes1[1] += r;
        }else{
            subRes1[0] += r;
            subRes1[1] += l;
        }
        
        const subRes2 = sub(left+2, right, piles);
        subRes2[0] += l;
        subRes2[1] += piles[left+1];

        const subRes3 = sub(left, right-2, piles);
        subRes3[0] += r;
        subRes3[1] += piles[right-1];

        let res = subRes1;
        if (subRes2[0]-subRes2[1]>res[0]-res[1]) res = subRes2;
        if (subRes3[0]- subRes3[1]>res[0]-res[1]) res = subRes3;
        return res;
    }
};

var stoneGame = function(piles) {
    const res = sub(0, piles.length-1, piles);
    return res[0]>res[1];
};	
```

## 题解

让我们来见证一下真正的动态规划长啥样

> 参考：https://leetcode-cn.com/problems/stone-game/solution/dong-tai-gui-hua-by-cliant/

首先将问题转换为**先手所能拿到的石子总数减去对手能拿到的石子总数是否为正数**，用f(i,j)来表示第i堆到第j堆的石子，先手比对手多拿的石子总数，那么有如下的递推关系式：
$$
\begin{equation}
	\left\{
		\begin{array}{}
        f(i,j)=max(piles[i]-f(i+1,j),\;piles[j]-f(i,j-1)),&i\ne j \\
        f(i,j)=f(i),&i==j
\end{array}
	\right.
\end{equation}
$$
所以问题的解决过程就变成了已知对角线值的二维数组的填表，二维数组用dp\[i][j]表示，dp\[0][n-1]即为问题的解，n是石子的堆数

（1）初始条件，只有对角线的值已知，且是各堆石子的个数

![](https://i.loli.net/2019/07/07/5d219d5f0c51e87849.png)

（2）数组值的生成关系如图，红色星号是问题的解：

![](https://i.loli.net/2019/07/07/5d219e07a8f2a48616.png)

（3）最终的计算顺序如红色箭头所示：

![](https://i.loli.net/2019/07/07/5d219e70b890489832.png)

这样是为了保证不会产生重复计算问题，也便于编码

（4）代码如下：

```js
var stoneGame = function(piles) {
    const dp = [];
    for(let i = piles.length-1;i>=0;i--){
        dp[i] = [];
        dp[i][i] = piles[i];

        // 填表
        for(let j = i+1;j<piles.length;j++){
            dp[i][j] = Math.max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1])
        }
    }
    return dp[0][piles.length-1]>0;
};
```

（5）这里其实可以优化一下，因为这个二维数组其实只有一半有数，而且随着填表的进行，之前的值不会再被使用到了：

```js
var stoneGame = function(piles) {
    const dp = [];
    for(let i = piles.length-1;i>=0;i--){
        dp[i] = piles[i];

        // 填表
        for(let j = i+1;j<piles.length;j++){
            dp[j] = Math.max(piles[i]-dp[j], piles[j]-dp[j-1])
        }
    }
    return dp[piles.length-1]>0;
};

```

主要的思想是，第i-1行的值可以覆盖到第i行上去，因为一旦第i-1行计算出来，第i行就不再需要了，计算i-2行只用到了第i-1行和第i-2行；所以填表的那个循环，只是单纯将dp数组与i有关的索引去掉

```js
原来的：dp[i][j] = Math.max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1])
优化后：dp   [j] = Math.max(piles[i]-dp     [j], piles[j]-dp   [j-1])

```

## 歪门邪道

~~这道题可以钻空子，直接`return true`就可以AC了，不要问我为什么。。。~~

其实这是数学规律来的，leetcode官方已经给出了解释，但我还是根据自己的理解说一下：

- 首先只有两堆（假设是x1，y1）的时候，一定可以保证先手胜（假设x1>y1，那么先手可选x1）
- 然后当有四堆（假设是y2，x1，y1，x2）的时候，那么先手一定可以保证取到y1+y2或者x1+x2（因为取y2时，可以保证y1可以取到，x同理），所以先手只需取总和最大的一组即可
- 那么显然，先手可以保证取到奇数位置的堆或者偶数位置的堆，先手从总和大的堆下手即可保证稳赢，所以结果是true