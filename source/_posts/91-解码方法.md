---
title: 91.解码方法
date: 2019-09-06 19:29:49
categories:
- 算法
tags:
- leetcode
- 动态规划
---

# 91.解码方法

原题目如下：

> 一条包含字母 A-Z 的消息通过以下方式进行了编码：
>
> 'A' -> 1
> 'B' -> 2
> ...
> 'Z' -> 26
>
> 给定一个只包含数字的非空字符串，请计算解码方法的总数。
>
> 示例 1:
>
> 输入: "12"
>
> 输出: 2
>
> 解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
>
> 示例 2:
>
> 输入: "226"
>
> 输出: 3
>
> 解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
>
> 
>
> 来源：力扣（LeetCode）
>
> 链接：https://leetcode-cn.com/problems/decode-ways著作权归领扣网络所有。



## 解题思路

这道题刚开始做的时候思路是挺清晰的，就是动态规划，从左往右遍历一遍即可。对于一个长度为n的串s，由于编码只有一位数和两位数这两种可能，因此很容易得出

```c++
numDecodings(s[1:n]) = numDecodings(s[1:n-1]) + numDecodings(s[1:n-2])
```

当然不是直接相加那么简单，这要分情况讨论一下：

（1）如果s[i]非0（由题可知，0不是合法的编码），s[1:n]一定可以按照在s[1:n-1]的所有解码方式后面加上s[i]来解码

（2）如果s[i-1]s[i]是合法的编码（**即10<=int(s[i-1]s[i])<=26，大于等于10的是因为01、02等待这种以0开头的两位数不是合法的编码**），那么s[1:n]也一定可以按照在s[1:n-2]的所有解码方式后面加上s[i-1]s[i]来得到

（3）否则上面两种情况都不符合，那么s[1:n]无论如何也无法进行解码，比如出现连续两个0的情况

我当时做的时候，因为没有考虑编码串中出现0的情况，所以出现了偏差。另外，由于前面做题的惯性思维，动态规划问题老是想构造数组，后来细细想这道题才发现根本不需要那么大的空间开销，只需要记录dp[i-1]和dp[i-2]即可计算出dp[i]。最终的解决方案如下：

```cpp
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        if(s.empty()) return 0;
        if(n==1) return s[0]!='0';
        unsigned long long prev = 1, target = s[0]=='0'?0:1;
        for(int i = 1;i<n;i++){
            unsigned long long  temp = 0;
            if(s[i]!='0') temp = target;
            // int val = (s[i-1]-'0')*10+(s[i]-'0');
            // if(val>=10&&val<=26) temp+=prev;
            if(s[i-1]=='1'||s[i-1]=='2'&&(s[i]<='6'))temp+=prev;
            
            prev = target;
            target = temp;
        }
        return target;
    }
};
```

测评的结果如下，然后我看了一下最高分的解答，思路跟我的差不多，就没必要去优化了

![](https://i.loli.net/2019/09/06/YuE7XgBWSrZz51w.png)



## 题解

题解没什么比较新的角度，跟我的想法差不多，就不再赘述
