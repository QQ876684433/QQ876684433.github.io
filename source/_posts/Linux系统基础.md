---
title: Linux系统基础
date: 2019-07-25 09:34:24
categories:
- linux
tags:
- linux
---

# Linux系统基础

> 此文章是根据南大软院曾老师的《Linux系统基础》课程ppt的学习笔记整理

**推荐：http://man.linuxde.net/ ，关于Linux命令大全的实用网站**

## 认识Linux系统

### Linux系统的组成

Linux系统一般有4个主要部分：内核、Shell、文件系统 和 应用程序

#### 内核

内核是操作系统的核心，Linux内核的主要模块包括：存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等几个部分

#### shell

Shell是系统的用户界面，提供了**用户**与**内核**进行交互操作的一种接口，它接收用户输入的命令并把它送入内核去执行

#### 文件系统

文件系统是文件存放在磁盘等存储设备上的组织方法，Linux系统能支持多种目前流行的文件系统，如ext3、 ext4、 FAT、 FAT32、VFAT和ISO9660等

#### 应用程序

包括文本编辑器、编程语言、 X Window、办公软件、 Internet工具和数据库等的程序集

### Linux系统与Windows系统的比较

#### 共性

- 多用户操作系统

  > ​	这里补充一点，摘录自https://blog.csdn.net/yangkuiwu/article/details/53224239
  >
  > ​	1.**单用户、多用户**。根据在同一时间使用计算机用户的多少，操作系统可分为单用户操作系统和多用户操作系统。单用户操作系统是指一台计算机在同一时间只能由一个用户使用，*<u>一个用户独自享用系统的全部硬件和软件资源</u>，*而如果在同一时间允许多个用户同时使用计算机，则称为多用户操作系统。
  >
  > ​	2.**单任务、多任务**。用户在同一时间可以运行多个应用程序（每个应用程序被称作一个任务），则这样的操作系统被称为多任务操作系统。如果一个用户在同一时间只能运行一个应用程序，则对应的操作系统称为单任务操作系统。
  >
  > ​	现代操作系统一般属于多用户、多任务的操作系统，也就是说，同一台机器可以为多个用户建立各自的账户，也允许拥有这些账户的用户同时登录这台计算机，每个账号可以同时运行多个程序。
  >
  > ​    多个用户能够同时访问和使用同一台计算机，其中的一个用户具有管理所有这些用户账户和整个计算机的资源的权限，在Windows上，这个具有管理其他用户和计算机资源的用户一般叫administrator，而在Linux上一般叫做root。
  >
  > ​    个人计算机操作系统早期一般都是单用户操作系统，其主要特点是在某一时间为单个用户服务。早期的DOS操作系统是单用户单任务操作系统，Windows XP则是单用户多任务操作系统。Linux、UNIX是多用户多任务操作系统。现在常用的Windows操作系统都是多用户、多任务的操作系统，使用最广泛的win7，win10都是多用户，多任务操作系统。

- 支持多种文件系统

- 支持多种端口和设备

- 支持联网功能

- 服务

#### 区别

![](https://i.loli.net/2019/07/25/5d390b6c0f41545469.png)

总结一下，Linux独有的特点如下：

- 定位于网络操作系统，Linux的系统配置文件和数据都以文本为基础
- 可选图形化界面
- Linux系统不使用文件扩展名来识别文件的类型，而是使用文件的头内容来识别其类型
- 除了Linux内核，其他软件的安装、启动、停止和重新配置都不用重新引导系统（即不需要重启）
- Linux系统下的命令、文件和口令等都区分大小写

### Linux版本

Linux的版本号分为两部分，即**内核版本**与**发行版本**

#### Linux内核版本

内核版本号由3个数字组成： r.x.y

- r：目前发布的内核主版本。
- x：偶数表示稳定版本；奇数表示开发版本。
- y：错误修补的次数。

#### Linux发行版本

一些组织和厂家，将Linux系统的内核、应用软件和文档包装起来，并提供一些系统安装界面、系统配置设定管理工具，就构成了Linux发行版本最著名的便是**Red Hat公司开发的Red Hat系列**以及**社区组织开发的Debian系列发行版本**

## Linux系统的安装与删除

### Linux系统下硬盘的基本知识

#### 分区命名方案

Linux系统使用**字母和数字的组合**来指代硬盘分区，命名方案是**基于文件**的，文件名的格式为/dev/xxyN

- /dev/：这是Linux系统下**所有设备文件**所在的目录名。
- xx：分区名的前两个字母表示分区所在设备的类型，通常是hd（ IDE硬盘）或sd（ SCSI硬盘）。
- y：这个字母表示分区**所在的设备**。
- N：最后的数字N代表分区。

例如：/dev/sda1表示这个分区在sd类型的设备上，如果有多个sd类型设备，那么该分区是在编号为a的设备上的分区1中

#### 磁盘分区和挂载目录

分区是Linux系统上一组文件和目录的存储区，它通过挂载来实现，**挂载**是**将分区关联到某一目录的过程**，挂载分区使起始于这个指定目录（通称为挂载目录）的存储区能够被使用

- /boot分区：用来存放与Linux系统启动有关的程序，比如启动引导装载程序等
- /usr分区：用来存放Linux系统中的应用程序
- /var分区：用来存放Linux系统中经常变化的数据以及日志文件
- /分区： Linux系统的根目录，所有的目录都挂在这个目录下面
- SWAP分区：实现虚拟内存
- /home分区：存放普通用户的数据，是普通用户的宿主目录

## Linux字符界面操作

命令行界面可以通过字符界面、图形界面下的终端以及虚拟控制台等多种方式进入

### 字符界面

很多Linux发行版系统启动默认进入的是图形化界面，可以通过如下指令修改：

```shell
ln -sf
```

重启后生效，默认进入字符界面，进入字符界面后，超级用户登录后提示符是“ #”，而其他用户登录后提示符是“ $”

### 虚拟控制台

Linux系统提供了虚拟控制台的访问方式使得允许多个用户同时登录，还允许用户进行多次登录

- 在**字符界面**下，虚拟控制台的切换可以通过按下[Alt+ F1]~ [Alt+ F6]键来实现
- 在**图形界面**下，可以使用[Ctrl+Alt+F2]~[Ctrl+Alt+F6]键切换不同的字符虚拟控制台，再使用[Ctrl+Alt+F1]可以切换回图形界面

### 关闭和重启系统

#### shutdown

> 参考原文：https://blog.csdn.net/xmc281141947/article/details/61191212 

在Linux中可以用Shutdown命令实现自动定时关机的功能，它在Linux系统关闭之前给系统上的所有登录用户提示一条警告信息

命令语法：shutdown [选项] [时间] [警告信息]

- -h 关闭计算机
- -r 重启计算机
- -c 取消正在等待的shutdown命令

**精确时间**的格式是hh:mm，表示小时和分钟。 
**时间段（延迟）**由“+” 和“分钟数”表示。 
系统执行该命令后会自动进行数据同步的工作。时间部分如果是`now`，则上述命令则立即执行，否则延迟默认60s或者设定的时间

具体例子：

1、Shutdown -r now 关机后重启

2、Shutdown -h now 关机后不重启

3、Shutdown -r +11 11分钟后重启

4、Shutdown -r 11:00 11点钟重启

5、Shutdown -h +11 11分钟后关机

6、Shutdown -h 11:00 11点钟关机

#### halt

“ halt” 命令就是调用“ shutdown
–h”命令执行关闭系统，它是立即执行

#### reboot

“reboot”命令就是调用“shutdown -r”命令来重启系统，它是立即执行

#### init

“ init” 命令是所有进程的祖先，它的进程号始终为“ 1” ，所以发送“ TERM” 信号给“ init” 会终止所有的用户进程和守护进程等。“ shutdown” 命令就是使用这种机制。“init”定义了7个运行级别：

- 0    Halt    Shuts down the system.
- 1    Single-user mode    Mode for administrative tasks.（注意这里，说明系统返回的shell有root权限）
- 2    Multi-user mode    Does not configure network interfaces and does not export networks services.
- 3    Multi-user mode with networking    Starts the system normally.
- <u>4    Not used/user-definable    For special purposes.</u>
- 5    Start the system normally with appropriate display manager (with GUI)    Same as runlevel 3 + display manager.
- 6    Reboot    Reboots the system.

### 系统运行级别

Linux系统的运行级别由列在/etc/rc.d/rc\<x>.d目录中的服务来定义，其中\<x>是代表运行级别的符号，七种运行级别的定义如下：

- 0：停止运行，所有进程中止，关闭系统。
- 1：单用户模式，用于维护系统，只有少数进程运行。
- 2：多用户模式，除了NFS服务没有启动外，其他和运行级别3一样。
- **3：完整的多用户模式，进入Linux系统的字符界面。**
- 4：没有使用（可由用户定义）。
- **5：完整的多用户模式（带有基于X Window的图形界面）。**
- 6：重新引导计算机。

可以在使用`runlevel`命令查看当前的运行级别

```shell
steve@ubuntu-17-10:~$ runlevel 
N 5
```

表示当前运行级别是5，N表示没有上一次运行级别

### 其他一些常用命令

#### man

获取shell命令的帮助手册，命令语法：man [选项] [命令名称]

#### help

可以通过help来获取shell命令的用法，命令语法：[命令] ––help

#### which, whereis, locate, find

> 来源：https://zhuanlan.zhihu.com/p/35727707

- **which**：常用于查找**可直接执行的命令**。只能查找可执行文件，该命令基本**只在$PATH路径中搜索**，查找范围最小，查找速度快。**默认只返回第一个匹配的文件路径**，通过选项 *-a* 可以返回所有匹配结果。
- **whereis**：不只可以查找命令，其他文件类型都可以（man中说只能查命令、源文件和man文件，实际测试可以查大多数文件）。在$PATH路径基础上增加了一些系统目录的查找，查找范围比which稍大，查找速度快。<u>可以通过 *-b* 选项，限定只搜索二进制文件</u>。
- **locate**：超快速查找任意文件。它会**从linux内置的索引数据库查找文件的路径**，索引速度超快。刚刚新建的文件可能需要一定时间才能加入该索引数据库，可以通过执行updatedb命令来强制更新一次索引，这样确保不会遗漏文件。该命令通常会返回大量匹配项，可以**使用 *-r* 选项通过正则表达式来精确匹配**。
- **find**：直接搜索整个文件目录，**默认直接从根目录开始搜索**，建议在以上命令都无法解决问题时才用它，功能最强大但速度超慢。除非你指定一个很小的搜索范围。通过 *-name* 选项指定要查找的文件名，支持通配符。

### Shell基础

通俗地讲，Shell就是位于内核和操作者之间的一层使用者界面。一个Shell命令可能含有一些可选项和参数，其一般格式为：[Shell命令] [可选项] [参数]。目前流行的Shell有sh， csh， ksh， tcsh
和bash等。

#### 开始使用bash

Shell命令可分为如下两大类：

（1） bash内置的命令

（2）应用程序

##### 通配符

![](https://i.loli.net/2019/07/25/5d39652fb49c266836.png)

##### 特殊字符和引号

![](https://i.loli.net/2019/07/25/5d3964b167a0847483.png)

##### 常用控制组合键

![](https://i.loli.net/2019/07/25/5d39656a7607c78493.png)

说明：

- & 使命令在后台运行，不阻塞当前控制台
- CTRL+Z停止进程并放入后台
- jobs 显示当前暂停的进程
- bg %N 使第N个任务在后台运行（%前有空格）（<u>好像也会阻塞控制台？不太懂，在Ubuntu17.10上测试就是，bg执行后，控制台也被占用，但可以使用Ctr+S和Ctr+Q来暂停和恢复屏幕输出</u>）
- fg %N 使第N个任务在前台运行，阻塞当前控制台
- 默认bg，fg不带%N时表示对最后一个进程操作！
- Ctr+U是清空当前输入的命令行

补充：

- 控制台可以使用Ctr+Shift+C/V来执行复制粘贴功能

### Shell实用功能

#### 命令的排列

如果希望一次执行多个命令， Shell允许在不同的命令之间，放上特殊的排列字符

- 使用“; ”

  使用“; ”命令时先执行命令1，不管命令1是否出错，接下来就执行命令2。**命令语法：命令1; 命令2**

- 使用“ &&”

  使用“ &&”命令时**只有当命令1正确运行完毕**后，才能执行命令2。**命令语法：命令1&&命令2**

#### 命令替换

有两种方式：

- 命令1 $(命令2)
- 命令1 \`命令2`

意思是将命令2的输出结果与命令1拼接成新的命令执行，例如：

```shell
pidof less //查看less的进程号，假如为4163
kill -9 4163
```

等价于

```shell
kill -9 $(pidof less)
// 或者
kill -9 `pidof less`
```

#### 命令别名

alias命令用来设置指令的别名。我们可以使用该命令可以将一些较长的命令进行简化。使用alias时，用户必须使用单引号`''`将原来的命令引起来，防止特殊字符导致错误。命令语法：

**alias [别名]＝[需要定义别名的命令]**

alias命令的作用**只局限于该次登入的操作**。若要每次登入都能够使用这些命令别名，则可将相应的alias命令存放到bash的初始化文件`/etc/bashrc`中。

要删除一个别名，可以使用 [unalias](http://man.linuxde.net/unalias) 命令，如 unalias l。

#### 文件名匹配和输出重定向

##### 文件名匹配

- “*” 可匹配任意一个或多个字符
- “?” 可以匹配任意一个字符

##### 管道

管道可以将某个命令的输出信息当作某个命令的输入，由管道符号“|” 来标识，命令语法：

**[命令1]|[ 命令2]|[ 命令3]**

例如：`alias tr='cd / && tree | more && cd ~'`，就是将tree的输出内容作为more的输入，more的作用是将输出内容分页显示

##### 重定向文件

重定向有5种方式，分别是：输出重定向、输入重定向、错误重定向、追加重定向以及同时实现输出和错误的重定向

- 输出重定向

  将command命令的输出保存到文件file中，如果存在相同的文件，则**覆盖file文件中的内容**。

  **命令语法：command > file**

  可以实用echo和输出重定向来创建文本文件：`echo hello > hello.txt`，即创建文件hello.txt并写入内容“hello”

- 输入重定向

  将文件file的内容作为command命令的输入。

  **命令语法：command < file**

- 错误重定向

  将command命令执行的出错信息输出到文件file中。

  **命令语法：command 2> file**

- 追加重定向

  将command命令执行的输出添加到已存在的文件file中。

  **命令语法：command >> file**

  补充：错误重定向和追加重定向可以组合使用，command 2>> file表示command的错误信息追加到file末尾

- 同时实现输出和错误的重定向

  可以同时实现输出重定向和错误重定向的功能。

  **命令语法：command &> file**

  补充：同理，该命令可以和追加重定向组合使用，command &>> file表示command的输出和错误信息追加到file末尾

### vi编辑器基本使用

#### vim和vi的区别

> 摘录自：https://blog.csdn.net/allenlinrui/article/details/7269481 

简单来说一下vi和vim的区别与联系

首先，它们都是多模式编辑器，但vim是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性。总的来说，vim比vi更具优势的地方在于：

- 多级撤消

  在vi的命令模式里，**按 u只能撤消上次命令，而在vim里可以无限制的撤消**，几乎等同于windows下的ctrl+z了

- 多操作系统支持

  vi只能运行于unix中，而vim不仅可以运行于unix,还有windows ,mac等操作系统上

- 语法加亮

  作为一名程序员，我觉得这个效果用处最大了- vim可以对代码进行多颜色的语法加亮

- 可视化操作

  因为vim不仅可以在终端运行，也可以运行于x window、 mac os、 windows， 所以说他“可视化”

- 对vi的完全兼容

  某些情况下，vim可以完全被当成vi来使用

#### vi的工作模式

vi编辑器有3种基本工作模式，分别是命令行模式、插入模式和末行模式

![](https://i.loli.net/2019/07/26/5d3a5d5e57a2f97173.png)

- 命令行模式：控制屏幕光标的移动，字符、字或行的删除，移动、复制某区域，该模式下是不能输入文本数据的
- 插入模式：只有在插入模式下，才可以做文字输入，按“ Esc” 键可回到命令行模式
- 末行模式：将文件保存或退出vi编辑器，也可以设置编辑环境，如寻找字符串、列出行号等

#### vi基本操作

##### 进入插入模式

- 按“ i” ：从光标当前位置开始输入文件
- 按“ I” ：在光标所在行的行首插入
- 按“ a” ：从目前光标所在位置的下一个位置开始输入文字
- 按“ A” ：在光标所在行的行末插入
- 按“ o” ：在光标所在的行的下面插入一行，从行首开始输入文字
- 按“ O” ：在光标所在的行的上面插入一行
- 按“ s” ：删除光标位置的一个字符，然后进入插入模式
- 按“ S” ：删除光标所在的行，然后进入插入模式

##### 从插入模式切换为命令行模式

从插入模式切换为命令行模式只需按“ Esc” 键

##### 移动光标

可以使用键盘的方向键移动光标，也可以使用vi定义的移动命令：**h、j、k、l分别表示←、↓、↑、→移动一格**。如果需要翻页：

- 按[Ctrl+b]：屏幕往前移动一页（back）
- 按[Ctrl+f]：屏幕往后移动一页（front）
- 按[Ctrl+u]：屏幕往前移动半页（up）
- 按[Ctrl+d]：屏幕往后移动半页（down）

其他的：

- 按“ G” ：移动到文本的最后一行
- 按“ $” ：移动到光标所在行的行尾（助记：正则表达式的$）
- 按“ ^” 或数字“ 0”：移动到光标所在行的行首（助记：正则表达式的^）
- 按“ w” ：光标跳到下个字的开头
- 按“ e” ：光标跳到下个字的字尾
- 按“ b” ：光标回到上个字的开头

解释："e"和"b"的“下个字”和“上个字”的含义是当前光标停在某个字上，即当前字；而“w”的“下个字”真的就是下一个字，不是当前光标停留的字。举个例子：

```shell
word----
↑
```

箭头指向的是当前光标位置，如果按"w"，那么结果是：

```shell
word----
    ↑
// 因为当前字是word，那么对"w"来说，下一个字就是"----"，因此光标指向"-"
```

而如果按的是"e"，那么结果将是：

```shell
word----
   ↑
// 因为当前字是word，那么对"e"来说，下一个字就是"word"，因此光标指向"d"
```

##### 删除文字

- “ x” ：每按一次，删除光标所在位置的一个字符
- “ nx” ：例如， “ 6x” 表示删除光标所在位置开始的6个字符<u>（包括当前位置的字符）</u>
- “ X” ：大写的X，每按一次，删除光标所在位置的前面一个字符
- “ nX”：例如， “ 20X”表示删除光标所在位置前面20个字符<u>（不包括当前位置的字符）</u>
- “ dd” ：删除光标所在行
- “ ndd”：从光标所在行开始删除n行。例如， “ 4dd” 表示删除从光标所在行开始的4行字符<u>（包括当前行）</u>
- ”dG“：删除当前后之后的全部行<u>（包括当前行）</u>

##### 复制

- “ yw” ：将光标所在之处到字尾的字符复制到缓冲区中（复制的是一个字的内容）
- “ nyw” ：复制n个字到缓冲区<u>（包括当前字）</u>
- “ yy” ：复制光标所在行到缓冲区
- “nyy” ：例如， “6yy” 表示复制从光标所在行开始的6行字符
- “p” ：将缓冲区内的内容写到光标所在的**后一个位置**（原ppt这里错了，这里写的才是正确的）
- ”P“：将缓冲区内的内容写到光标所在的前一个位置

**解释：”p“后一个位置有两种含义，如果复制的是字，那么写在光标所在位置的后面；如果复制的是行内容，那么写在光标所在行的下一行**；”P“同理，替换成上一个位置或者上一行

##### 替换

- “ r” ：替换光标所在处的字符
- “ R” ：替换光标所到之处的字符，直到按下“ Esc” 键为止

##### 撤销

- “ u” ：如果误执行一个命令，可以马上按下“ u” ，回到上一个操作。
- 按多次“ u” 可以执行多次撤销

补充：vi兼容模式下，多次”u“并不能多次撤销，原因是后一次”u“会把上一次”u“当做操作来撤销，即撤销”撤销操作“，所以”uu“会恢复原样

##### 跳至指定行

- [Ctrl+g]：列出光标所在行的行号
- “nG” ：例如， “ 15G” ，表示移动光标至该文本的第15行行首

##### 存盘退出

- “ZZ” ：存盘退出

##### 不保存退出

- “ZQ” ：不存盘退出

#### 末行模式操作

在使用末行模式之前，先按“ Esc”键确定已经处于命令行模式后，再按冒号“:”
即可进入末行模式

##### 列出行号

“set nu” ：在文件中的每一行前面列出行号

##### 取消列出行号

“set nonu” ：取消文件中的每一行前面列出的行号

##### 跳到文件中的某一行

“n”：输入行号n后回车，光标会跳转到文本的指定行——第n行的行首

##### 查找字符

- “/关键字”：向后查找关键字，可以按n往后查找下一个匹配的关键字
- “?关键字”：向前查找关键字，可以按n往前查找下一个匹配的关键字

##### 运行Shell命令

“!命令” ：运行Shell命令

##### 替换字符

- “s /a/b” ：将光标所在行第一个a替换为b
- “s /a/b/g” ：将光标所在行所有的a替换为b

##### 保存文件

“w” ：在冒号后输入字母“w” 就可以将文件保存起来

##### 退出vi

- “q” ：按“q” 即退出vi，如果无法离开vi，可以在“q” 后跟一个“!” 强制符离开vi
- “wq” ：一般建议离开时，搭配“w” 一起使用，这样在退出的时候还可以保存文件

## 文件和目录

Linux系统中**以目录的形式挂载文件系统**，其目录结构是一个**分层的树形结构**。链接是一种在共享文件和访问它的用户的若干目录项之间建立联系的方法， Linux系统中包括**硬链接和软链接**两种方式

### Linux文件

如果一个文件没有扩展名，或者与它的扩展名不相符时，可以使用file命令查看该文件的类型，例如：

```shell
steve@ubuntu-17-10:~$ file db.json 
db.json: UTF-8 Unicode text, with very long lines, with no line terminators
steve@ubuntu-17-10:~$ file _config.yml 
_config.yml: UTF-8 Unicode text
steve@ubuntu-17-10:~$ file package-lock.json 
package-lock.json: ASCII text
```

### Linux文件类型

Linux文件类型常见的有：普通文件、目录文件、字符设备文件、块设备文件和符号链接文件等，可以用` ls -lh`命令查看某个文件的属性

- 普通文件

  类似“ -rw-r--r--”的属性符号，其**属性第一个符号是“ -”**，这样的文件在Linux系统中就是普通文件

- 目录文件（**d**irectory）

  类似“ drwxr-xr-x”的属性符号，其**属性第一个符号是“ d”**，这样的文件在Linux系统中就是目录文件

- 设备文件

  Linux系统下的/dev目录中有大量的设备文件

  - 块设备文件（**b**lock）

    块设备的主要特点是可以随机读写，而最常见的块设备就是磁盘，如/dev/hda1、/dev/sda2等

    类似“ brw-rw----”的属性符号，其**属性第一个符号是“ b”**，这样的文件在Linux系统中就是块设备文件

  - 字符设备文件（**c**haracter）

    最常见的字符设备文件是打印机和终端，可以接收字符流。 /dev/null是一个非常有用的字符设备文件，送入这个设备的所有内容都被忽略

    类似“ crw-r-----”的属性符号，其**属性第一个符号是“ c”**，这样的文件在Linux系统中就是字符设备文件

- 管道文件（**p**ipe）

  管道文件有时候也被叫做FIFO文件（ FIFO是先进先出的意思），管道文件就是从一头流入，从另一头流出

  类似“ prw-------”的属性符号，其**属性第一个符号是“ p”**，这样的文件在Linux系统中就是管道文件

- 链接文件（**l**ink）

  链接文件有点类似于Windows系统中的快捷方式，链接有两种方式：软链接和硬链接

  - 软链接文件
  
    软链接（也叫符号链接），文件**用户数据块中存放的内容是另一文件的路径名的指向**。软链接就是一个普通文件，只是数据块内容有点特殊。**软链接可对文件或目录创建**。删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接就变成了死链接
  
    类似“ lrwxrwxrwx”的属性符号，其**属性第一个符号是“ l”**，这样的文件在Linux系统中就是软链接文件
  
  - 硬链接文件
  
    硬链接就是同一个文件使用了多个别名（他们**有共同的 inode**）。由于**硬链接是有着相同inode**
    **号仅文件名不同的文件**，因此，删除一个硬链接文件并不影响其他有相同 inode 号的文件。硬链接**不能对目录进行创建，只可对文件创建**
  
    用“ ls -l”命令查看某个文件的属性，可以看到**第二列的文件硬链接数大于1** ，这样的文件在Linux系统中就是硬链接文件

### Linux目录结构

Linux系统都有根文件系统，它包含**系统引导和使其他文件系统得以挂载所必要的文件**，根文件系统需要有**单用户状态所必须的足够的内容**，还应该包括**修复损坏系统、恢复备份等工具**。

Linux系统的目录结构是分层的树形结构，都是挂载在根文件系统“ /” 下

### 文件和目录操作

- pwd：显示当前用户所处的工作目录的绝对路径

- cd：更改工作目录路径，工作目录路径可以使用绝对或相对路径名，绝对路径从/（根）开始，然后循序到所需的目录下；相对路径从当前目录开始

  **命令语法：cd [目录名]**

- ls：对于目录而言将列出其中的所有子目录与文件信息；对于文件而言将输出其文件名以及所要求的其他信息

  **命令语法：ls [选项] [目录或是文件]**

  ls命令显示的详细信息：

  ![ls命令显示的详细信息](https://i.loli.net/2019/07/26/5d3ab0c1d837547899.png)

- touch：创建空文件以及更改文件或目录的时间，其中时间格式为MMDDHHmm

  **命令语法：touch [-acfm] [-d <日期时间>] [-r <参考 文件或目录>] [-t <日期时间>] [文件]**

- mkdir：在Linux系统中创建目录，其默认权限为rwxr-xr-x（ 755）

  **命令语法：mkdir [选项] [目录名]**

  -m 可以在创建目录时设置其权限，例如mkdir -m 777 newdir，其权限是rwxrwxrwx（ 777）

- rmdir：删除空目录

  **命令语法：rmdir [选项] [目录名]**

  -p或--parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除

- cp：复制文件和目录到其他目录中

  **命令语法：cp [选项] [源文件或目录] [目标文件或目录]**

- mv：对<u>文件和目录更改名称</u>以及移动文件和目录的路径

  **命令语法：mv [选项] [源文件或目录] [目标文件或目录]**

- rm：删除系统中的文件或目录

  **命令语法：rm [选项] [文件或目录]**

  -r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；-f：强制删除文件或目录；-i：在删除文件之前提示信息

- wc：统计指定文件中的行数、单词数或字节数，并将统计结果显示输出到屏幕

  **命令语法：wc [选项] [文件]**

  选项部分可以有-lwc，即将行数、单词数和字节数都显示出来

### 链接文件

在Linux系统中，内核为每一个新创建的文件分配一个inode（索引节点）号，文件属性保存在索引节点里，在访问文件时，索引节点被复制到内存里，从而实现文件的快速访问

#### 硬链接

硬链接是一个指针，指向文件索引节点，系统并不为它重新分配inode，可以用ln命令来建立硬链接。硬链接节省空间，也是Linux系统整合文件系统的传统方式。硬链接文件有两个限制：

（ 1）不允许给目录创建硬链接

（ 2）只有在同一文件系统中的文件之间才能创建链接

#### 软链接

软链接又称为符号链接，这个文件包含了另一个文件的路径名

#### 硬链接和软链接的区别

**硬链接记录的是目标的inode**，**软链接记录的是目标的路径**。**软链接就像是快捷方式，而硬链接就像是备份**。软链接可以做跨分区的链接，而硬链接由于inode的缘故，只能在本分区中做链接。所以，软链接的使用频率要高得多

#### 创建链接

ln命令可以创建链接文件（包括软链接文件和硬链接文件）

**命令语法：ln [选项] [源文件名] [链接文件名]**，默认创建的是硬链接，加上-s后创建的是软链接

使用rm删除源文件后，硬链接文件依然能打开，而软链接变成死链接

## Linux常用操作命令

*这部分挺琐碎的，直接参考http://man.linuxde.net/即可 ，关于Linux命令大全的实用网站*

### 文本显示和处理

cat，more，less，head，tail，sort，uniq，cut，comm以及diff等

### 文件和命令查找

grep，find，locate，whereis，file，whatis以及which等

### 系统信息显示

uname， hostname， dmesg， cal以及date等

### 信息交流

echo， mesg， wall以及write等

### 其他命令

clear， sync， uptime以及last等

## Shell编程

### 语法基础

Shell程序由开头部分、注释部分以及语句执行部分组成

#### 开头

Shell程序必须以下面的行开始（必须放在文件的第一行）

```shell
#!/bin/bash
```

符号“ #!” 用来告诉系统它后面的参数是**用来执行该文件的程序**，在这个例子中使用/bin/bash来执行程序。当编辑好脚本时，如果要执行该脚本，还必须**使其可执行**（即赋予可执行权限）：

```shell
chmod u+x [文件名]
```

如果不设置可执行权限的话，可以手动受用bash命令告诉系统它是一个可执行的脚本，这样也可以执行：

```shell
bash file.sh		
```

#### 注释

以“ #” 开头的句子表示注释，直到这一行的结束

#### 执行部分

例子：

```shell
#!/bin/bash
#filename:welcome
first()
{
echo "=========================================="
echo "Hello! Everyone! Welcome to the Linux world."
echo "=========================================="
}

second()
{
echo "******************************************"
}

first
second
second
first
```

输出：

```shell
==========================================
Hello! Everyone! Welcome to the Linux world.
==========================================
******************************************
******************************************
==========================================
Hello! Everyone! Welcome to the Linux world.
==========================================
```

### 变量

对Shell来讲，**所有变量的取值都是一个字符**， Shell程序采用“ $var” 的形式来引用名为var的变量的值

#### Shell定义的环境变量

Shell在开始执行时就已经定义了一些与系统的工作环境有关的变量，用户还可以重新定义这些变量，常见的环境变量如下：

- HOME：用于保存用户宿主目录的完全路径名
- PATH：默认命令搜索路径
- TERM：终端的类型
- UID：当前用户的识别号
- PWD：当前工作目录的绝对路径名
- PS1： 用户平时的提示符
- PS2： 第一行没输完，等待第二行输入的提示符

#### 用户定义的变量

语法规则：`变量名=变量值`

在定义变量时，**变量名前不应加符号“ $”** ；在引用变量的内容时，则应**在变量名前加符号“ $”或“ ${变量名}”** 。在给变量**赋值时，等号两边一定不能留空格**，若**变量中本身就包含了空格，则整个字符串都要用双引号括起来**。在编写Shell程序时，为了使变量名和命令名相区别，**建议所有的变量名都用大写字母来表示**。

有时需要在说明一个变量并对它设置为一个特定值后就不再改变它的值时，可以用下面的命令来保证一个变量的只读性：`readonly 变量名`。

在任何时候创建的变量都**只是当前Shell的局部变量**，所以不能被Shell运行的其他命令或Shell程序所利用，而export命令可以将一个局部变量提供给Shell命令使用，其格式是：`export 变量名`。也可以在给变量赋值的同时使用export命令：`export 变量名=变量值`。

#### 位置参数

位置参数是一种在调用Shell程序的命令行中按照各自的位置决定的变量，**是在程序名之后输入的参数**。位置参数之间用空格分隔，Shell取第一个位置参数替换程序文件中的$1，第二个替换$2，依次类推。**$0是一个特殊的变量，它的内容是当前这个Shell程序的文件名**，所以， $0不是一个位置参数，在显示当前所有的位置参数时是不包括$0的

#### 预定义变量

预定义变量和环境变量相类似，也是在Shell一开始时就定义了的变量。所不同的是，用户只能根据Shell的定义来使用这些变量，所有预定义变量都是**由符号“ $” 和另一个符号组成**的。常见的预定义变量如下：

- $#：位置参数的数量
- $*：所有位置参数的内容
- $?：命令执行后返回的状态
- $$：当前进程的进程号
- $!：后台运行的最后一个进程号
- $0：当前执行的进程名。

#### 参数置换的变量

Shell提供了参数置换功能以便用户可以根据不同的条件来给变量赋不同的值，下面Variable是变量名， value代表一个具体的值：

- ${variable:-value}: 如果变量variable存在，则返回variable的值，否则返回值value
- ${variable:=value}: 如果变量variable存在，则返回variable的值，否则，先将值value赋给变量variable，然后返回值value
- ${variable:+value}: 如果变量variable存在，则返回value的值，否则返回空值
- ${variable:?value}: 如果变量variable存在，则返回variable的值，否则将value送到标准错误输出显示并退出shell程序，这里value通常为一个错误提示消息
- ${variable:offset[:length]}:其中offset和length为整数数字，中括号代表可选部分。此引用方式表示返回从变量variable的第(offset+1)个字符开始的、长度为length的子串。如果中括号内的部分省略，则返回其后的所有子串

### 变量表达式

首先要注意的是，**这些表达式符号前后都需要有空格**，否则会出错

#### 字符串比较

测试字符串是否相等，长度是否为零，字符串是否为NULL：

- =：比较两个字符串是否相同，相同则为“是” （结果显示0）
- !=：比较两个字符串是否相同，不同则为“是”（结果显示0）
- -n：比较字符串的长度是否大于0，如果大于0则为“是” （结果显示0）
- -z：比较字符串的**长度是否等于0**，如果等于0则为“是” （结果显示0）

补充：

- 直接测试时，控制台是不会有输出结果的，需要使用`$?`来获取输出结果

- 如果变量字符串含有空格，需要使用双引号，否则会出错

  ```shell
  steve@ubuntu-17-10:~/$ str1="ab cd"
  steve@ubuntu-17-10:~/$ test $str1 = ab
  bash: test: 参数太多
  steve@ubuntu-17-10:~/$ test "$str1" = ab
  steve@ubuntu-17-10:~/$ echo $?
  1
  steve@ubuntu-17-10:~/$ test "$str1" = ab cd
  bash: test: 参数太多
  steve@ubuntu-17-10:~/$ test "$str1" = "ab cd"
  steve@ubuntu-17-10:~/$ echo $?
  0
  ```

#### 数字比较

test语句不使用`>?` 类似的符号来表达大小的比较，而是用参数来表示：

- -eq：相等
- -ge：大于等于
- -le：小于等于
- -ne：不等于
- -gt：大于
- -lt：小于

#### 逻辑测试

- !：与一个逻辑值相反的逻辑值
- -a与（ and）：两个逻辑值都为“是” 返回值才为“是” ，反之为“否”
- -o或（ or）：两个逻辑值有一个为“是” ，返回值就为“是” 

例子：

```shell
[root@PC-LINUX ~]# test -r empty -a -s empty
[root@PC-LINUX ~]# echo $?
1
// 结果显示1表示文件empty存在且只读以及长度为非0是不对的
```

#### 文件操作

文件测试表达式通常是为了测试文件的文件操作逻辑：

- -d：对象存在且为目录，则返回值为“是” 
- -f：对象存在且为文件，则返回值为“是” 
- -L：对象存在且为符号连接，则返回值为“是” 
- -r：对象存在且可读，则返回值为“ 是”
- -s：对象存在且**长度非0**，则返回值为“是” 
- -w：对象存在且可写，则返回值为“是” 
- -x：对象存在且可执行，则返回值为“是” 
- !：测试条件的否定

### Shell程序的执行和跟踪

#### Shell程序的执行和调试

程序的第一行一般为`#!/bin/bash` ，其中“ #” 表示该行是注释，感叹号“ ！ ” 表示Shell运行感叹号之后的命令**并用文档的其余部分作为输入**，也就是运行/bin/bash并让/bin/bash去执行Shell程序的内容

##### Shell程序的执行

有如下三种方式运行shell程序：

```shell
steve@ubuntu-17-10:~/$ vim exe.sh
steve@ubuntu-17-10:~/$ bash < exe.sh 
hello world
steve@ubuntu-17-10:~/$ bash exe.sh 
hello world
steve@ubuntu-17-10:~/$ chmod u+x exe.sh 
steve@ubuntu-17-10:~/$ ./exe.sh 
hello world
```

<u>发现一个问题：使用`bash < exe.sh`运行程序时，read指令好像不生效，控制台不会等待标准输入，具体原因还不知道</u>

##### Shell程序的调试

调用bash的形式是：`bash [选项] [Shell程序文件名]`

- -v：当读入Shell输入行时，把它们显示出来（输出的命令是**未经执行的源程序命令**）
- -x：执行命令时把命令和它们的参数显示出来（输出的命令是**解释后实际执行的命令**）

示例：

```shell
steve@ubuntu-17-10:~/$ vim exe.sh ; cat exe.sh 
#!/bin/bash
echo "shell file name is $0"
echo "hello world"
echo $1
echo $2
steve@ubuntu-17-10:~/$ bash -x exe.sh a b
+ echo 'shell file name is exe.sh'
shell file name is exe.sh
+ echo 'hello world'
hello world
+ echo a
a
+ echo b
b
steve@ubuntu-17-10:~/$ bash -v exe.sh a b
#!/bin/bash
echo "shell file name is $0"
shell file name is exe.sh
echo "hello world"
hello world
echo $1
a
echo $2
b
```

### Shell流程控制语句

与传统语言不同的是， Shell用于指定条件值的不是布尔运算式，而是命令和字符串

#### 条件判断

##### if条件语句

> 可以参考：https://blog.csdn.net/doiido/article/details/43966819

Shell程序中的条件分支有如下两种方式：

- if-then语句

  语法如下：

  ```shell
  if [ 命令行1 ];then
  	命令行2
  fi
  ```

  需要注意的是，在 **'['后面** 和 **']'前面** 都必须要有空格，不然会出错，例如要`[ $a=a ]`

- if-then-else语句

  语法如下：

  ```shell
  if [ 命令行1 ]
  then
  	命令行2
  else
  	命令行3
  fi
  ```

##### case条件语句

Shell通过计算字符串string的值，将其结果依次与运算式exp-1和exp-2等进行比较，直到找到一个匹配的运算式为止。如果找到了匹配项，则执行它下面的命令直到遇到一对分号`;;`为止，语法格式：

```shell
case string in
exp-1)
	若干个命令行1
;;
exp-2)
	若干个命令行2
;;
……
*)
	其他命令行
esac
```

在case运算式中也可以使用Shell的通配符（ `*` ， `?` ， `[]`）。通常用`*`作为case命令的最后运算式以便在前面找不到任何相应的匹配项时执行“其他命令行” 的命令，样例：

```shell
steve@ubuntu-17-10:~/$ cat menu.sh 
#!/bin/bash
echo _
echo "1 Restore"
echo "2 Backup"
echo "3 Unload"
echo 
echo -n "Enter Choice: "
read CHOICE
case "$CHOICE" in
1) echo "Restore";;
2) echo "Backup";;
3) echo "Unload";;
*) echo "Sorry $CHOICE is not a valid choice."
exit 1
esac
```

#### 循环控制

##### for循环语句

```shell
for 变量名 [in数值列表]
do
	若干个命令行
done
```

- 如果变量名是var，则在in之后给出的数值将顺序替换循环命令列表中的“ $var” 
- 如果省略了in，则变量var的取值将是位置参数

例子：

```shell
steve@ubuntu-17-10:~/$ vim mm.sh ; cat mm.sh
#!/bin/bash 
for ab in 1 2 3 4
do
	echo $ab
done
```

输出：

```shell
steve@ubuntu-17-10:~/$ bash mm.sh 
1
2
3
4
```

求和示例：

```shell
steve@ubuntu-17-10:~/$ cat qqq.sh 
#!/bin/bash 
sum=0
for INT in $*;do
	sum=`expr $sum + $INT`
done 
echo $sum
steve@ubuntu-17-10:~/$ bash qqq.sh 1 2 3 4 
10
```

要注意，原ppt中expr指令使用的是单引号`''`括起来的，这样不对，应该使用反单引号``才能执行后面的加法计算

##### while循环语句

语法格式：

```
while
	若干个命令行1
do
	若干个命令行2
done
```

只要while的“若干个命令行1” 中**最后一个命令的返回状态为真**， while循环就继续执行“ do...done” 之间的“ 若干个命令行2”，示例：

```shell
steve@ubuntu-17-10:~/桌面$ cat zx.sh 
#!/bin/bash 
int=1
while [ $int -le 5 ]; do
	sq=`expr $int \* $int`
	echo $sq
	int=`expr $int + 1`
done
echo "Job completed!"
steve@ubuntu-17-10:~/桌面$ bash zx.sh 
1
4
9
16
25
Job completed!
```

##### until循环语句

语法格式：

```shell
until
	若干个命令行1
do
	若干个命令行2
done
```

until循环和while循环的区别在于：**while循环在条件为真时继续执行循环，而until则是在条件为假时继续执行循环**。Shell还提供了true和false两条命令用于创建无限循环结构，它们的返回状态分别是总为0或总为非0

##### break和continue语句

用法和传统C语言中的用法无异

##### source语句

source命令用法：`source FileName`

作用：在**当前bash环境下**读取并执行FileName中的命令。

注：该命令**通常用命令“ .”来替代**。如： source .bash_rc 与 . .bash_rc 是等效的。

source命令与shell scripts的区别是， **source在当前bash环境下执行命令**，而**scripts是启动一个子shell来执行命令**。这样如果把设置环境变量（或alias等等）的命令写进scripts中，就只会影响子shell,无法改变当前的BASH,所以**通过文件设置环境变量时，要用source 命令。**

source命令(从 C Shell 而来)是bash shell的内置命令。点命令(从Bourne Shell而来) 是source的另一名称。 **source(或点)命令通常用于重新执行刚修改的初始化文档**，如 .bash_profile 和
.profile 等等。

### 函数

**所有函数在使用前必须定义**。函数的调用，只需要使用函数名就可以调用已经定义好的函数。

```shell
# 定义：
[function] 函数名()
{
	命令
}
# 引用：
函数名 [ 参数1 参数2 ...参数n ]
```

在函数中得到函数返回值可以使用以下两种方法：

- 在函数末尾加return，从函数中返回，用最后的**命令状态**决定返回值（`$?`）
- 返回一个数值，如0或1。格式如： return 0或者return 1

示例：

```shell
steve@ubuntu-17-10:~/桌面$ cat func.sh 
#!/bin/bash 
function func(){
	echo "hello"
	echo "world"
}
func
echo $?
```

输出：

```shell
steve@ubuntu-17-10:~/桌面$ bash func.sh 
hello
world
0
```

说明获取的是**命令状态**而不是命令的输出值

## 用户和组群账户管理

### 用户账户管理

#### Linux用户账户概述

用户在Linux系统中是分角色的，用户的角色是通过UID（用户ID号）来标识的，每个用户的UID都是不同的。在Linux系统中主要有**root用户、虚拟用户和普通用户**这3类用户。

- root用户

  root用户是Linux系统的内置用户，在系统中的权限最高，也被称之为超级管理用户。在系统中的每个文件、目录和进程都归属于某一个用户，没有用户许可，**除root用户外**的其它普通用户无法进行操作

- 虚拟用户

  这类用户也被称为伪用户或假用户，**这类用户不具有登录系统的能力**，但却是系统运行不可缺少的用户，比如bin， daemon， adm，ftp以及mail等用户账户，这类用户都是Linux系统的**内置用户**

- 普通用户

  这类用户是由系统管理员创建，并且能登录Linux系统。只能操作自己目录内的文件，权限有限

#### Linux用户账户配置文件

用户管理主要是**通过修改用户配置文件完成**的，使用用户管理控制工具的最终目的也是为了修改用户配置文件。

##### /etc/passwd文件

/etc/passwd是系统识别用户的一个文件，Linux系统中所有的用户都记录在该文件中。**任何用户**都可以读取该文件内容，在/etc/passwd文件中，**每一行表示的是一个用户账户信息**，**一行有7个段位，每个段位用“:”分隔**。

![](https://i.loli.net/2019/07/29/5d3ea1207389631335.png)

每个用户都对应一个唯一的UID，Linux的用户UID值是非负整数， root的UID是0，拥有系统最高权限。UID的唯一性关系到系统的安全，比如在/etc/passwd文件中把用户zhangsan的UID改为0后， zhangsan这个用户会被确认为root用户。

**UID是确认用户权限的标识，用户登录系统所处的角色是通过UID来实现的，而不是用户名**。

##### /etc/shadow文件

/etc/shadow文件是/etc/passwd文件的影子文件，这个文件并不是由/etc/passwd文件产生，这两个文件是**对应互补**的。/etc/shadow文件内容包括**用户及被加密的口令**及**其他/etc/passwd不能包括的信息，比如用户账户的有效期限**等。/etc/shadow文件的内容包括9个段位，每个段位之间用“ :”分隔：

![](https://i.loli.net/2019/07/29/5d3ea44904bdc53896.png)

#### 字符界面下用户账户的设置

##### 创建新账户

创建用户账户就是在系统中创建一个新账户，然后为新账户分配<u>用户UID、用户组群、主目录和登录Shell</u>等资源，新创建的用户账户**默认是被锁定的，无法使用**，需要**使用passwd命令设置密码**以后才能使用。使用useradd命令可以在Linux系统下创建用户账户。

##### 修改账户

使用usermod命令能更改用户的Shell类型、所属的用户组群、用户口令的有效期，还能更改用户的登录名

##### 删除用户账户

使用userdel命令可以在Linux系统下删除用户账户：`userdel [-r][用户名]`，其中-r是指在删除该用户的同时一起删除主目录

### 组群账户管理

#### Linux组群账户配置文件

/etc/gshadow是/etc/group的加密信息文件

##### /etc/group文件

/etc/group文件的内容包括用户组群名、用户组群口令、 GID及该用户组群所包含的用户，每个用户组群都有一条记录。一行有4个段位，每个段位用“:” 分隔。

![](https://i.loli.net/2019/07/29/5d3eae591ea3b22405.png)

组群GID和UID类似，是一个从0开始的非负整数， **GID为0的组群是root组群**。Fedora 17系统会预留1000个GID号给系统虚拟用户组群使用，创建的新组群GID是从1000开始的。

##### /etc/gshadow文件

/etc/gshadow文件是/etc/group的加密文件，比如**用户组群管理口令**就是存放在这个文件中。/etc/gshadow文件中每个用户组群都有一条记录。一行有4个段位，每个段位之间用“ :”分隔。

![](https://i.loli.net/2019/07/29/5d3eb098a186369791.png)

#### 字符界面下组群账户的设置

在Linux系统字符界面下创建、修改以及删除组群账户主要使用groupadd，groupmod
和groupdel这3个命令。

##### 创建组群账户

命令语法：`groupadd [-g gid [-o]] [-f] [组群名]`

默认创建的是用户群组，即默认分配的GID大于等于1000，可以通过-g指定GID；-r选项可以创建系统群组，即默认分配的GID小于1000

##### 修改组群账户

命令语法：`groupmod [-g <组群识别码> <-o>]
[-n <新组群名称>] [组群名称]`

##### 删除组群账户

命令语法：`groupdel [组群名称]`

### 账户相关文件或目录

#### /etc/skel目录

/etc/skel目录是存放用户启动文件的目录，这个目录由root用户管理，当管理员创建新用户时，这个目录下的文件会自动复制到新创建的用户的主目录下。/etc/skel目录下的文件都是隐藏文件，也就是类似“ .file” 格式的，可以通过添加、修改和删除/etc/skel目录下的文件，来为用户提供一个统一、标准和默认的用户环境。

#### /etc/login.defs配置文件

/etc/login.defs文件规定了**创建新用户时的一些默认设置**，比如创建用户时是否需要主目录、 UID和GID的范围、用户账户口令的期限等，这个文件可以通过root用户来修改

#### /etc/default/useradd文件

/etc/default/useradd文件是在使用useradd命令创建用户账户时的规则文件

### 用户和组群维护命令

#### 账户维护命令

##### passwd命令

使用passwd命令可以设置或修改用户的口令，普通用户和超级权限用户都可以运行passwd。**普通用户只能更改自己的用户口令**，root用户可以设置或修改任何用户的口令。如果passwd命令后面**不接任何选项或用户名，则表示修改当前用户的口令**。

命令语法：`passwd [选项] [用户名]`

可以使用-l选项来锁住某个用户的口令，这样该用户就无法登录，但是可以从其他用户中通过su切换到被锁定的用户，被锁定的用户口令前面有`!`标识（Ubuntu系统，其他系统可能会有差异，比如Fedora17系统上是双感叹号`!!`）：

```
test:!$6$N8tiFTQb$ViLVGgYXVKoOIdIcoXVfmug5tOfzwIVoeKia4uY6Wtw6n0sIEs1uTf9Ff6DI1.iOPX6/jzs.CDus8h.x6AonJ.:18106:0:99999:7:::
```

可以使用-u选项来解锁某用户的口令；-d是直接删除某用户的口令，使其无法登录系统。

##### gpasswd命令

使用gpasswd命令可以设置一个组群的组群密码，或是在组群中添加、删除用户。

命令语法：`gpasswd [-r|-R][组群名]` ` gpasswd [选项][用户名][组群名]`