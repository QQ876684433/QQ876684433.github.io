---
title: 64.最小路径和
date: 2019-07-14 23:23:52
categories:
- 算法
tags:
- leetcode
- 动态规划
---

# 64. 最小路径和

原题目如下：

> 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
>
> 说明：每次只能向下或者向右移动一步。
>
> 示例:
>
> 输入:
> [
> [1,3,1],
> [1,5,1],
> [4,2,1]
> ]
>
> 输出: 7
>
> 解释: 因为路径 1→3→1→1→1 的总和最小。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/minimum-path-sum
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 我的解法

这道题比较简单，也是填表的问题，递推公式如下：
$$
dp[i][j] = dp[i][j]+min\{dp[i+1][j]+dp[i][j+1]\}
$$
意思是：从点(i, j)到终点有两个选择，从下边(i+1, j)或者右边(i, j+1)走，所以最短路径是下边或者右边走的最小值加上当前点的值，因此可以从右下角开始填表，注意处理好边界条件：

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    for(let i = grid.length-1;i>=0;i--){
        for(let j = grid[0].length-1;j>=0;j--){
            if(i==grid.length-1 && j==grid[0].length-1) continue;
            let right = Infinity, bottom = Infinity;
            if(i!=grid.length-1) bottom = grid[i+1][j];
            if(j!=grid[0].length-1) right = grid[i][j+1];
            grid[i][j] = grid[i][j]+Math.min(bottom, right);
        }
    }
    return grid[0][0];
};

```

**复杂度分析**

- 时间复杂度 ：O(m*n)。遍历整个矩阵恰好一次。
- 空间复杂度 ：O(1)*O*(1)。不需要额外空间。

## 题解

官方给的题解其实思路都差不多，只是具体实现有区别

- 比如递归暴力解法，也是上面的思路，只是空间和时间开销巨大，我刚开始想的时候就直接拒绝了这种不优雅的做法；

- 二维数组动态规划和我的解法的唯一区别是它另外开辟了新的数组，这在一定情况下是必要的，当要求不能修改原数组时，就只能这么做；

- 针对二维数组动态规划的优化算法就是官解给出的一维动态规划，从我自己的解法中已经可以看出，我是从最下面一层开始往上面填表的，填完之后，下面的行就不再需要用了，所以可以复用一下：

  ```js
  var minPathSum = function(grid){
      const res = grid[grid.length-1];
      for(let i = grid.length-1;i>=0;i--){
          for(let j = grid[0].length-1;j>=0;j--){
              if(i==grid.length-1 && j==grid[0].length-1) continue;
              let right = Infinity, bottom = Infinity;
              if(i!=grid.length-1) bottom = res[j];
              if(j!=grid[0].length-1) right = res[j+1];
              res[j] = grid[i][j]+Math.min(bottom, right);
          }
      }
      return res[0];
  };
  
  ```

#### 