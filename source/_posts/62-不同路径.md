---
title: 62.不同路径
date: 2019-09-04 19:37:53
categories:
- 算法
tags:
- leetcode
- 动态规划
---

# 62.不同路径

原题目如下：

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
>
> 问总共有多少条不同的路径？
>
> ![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)
>
> 例如，上图是一个7 x 3 的网格。有多少可能的路径？
>
> 说明：m 和 n 的值均不超过 100。
>
> 示例 1:
>
> 输入: m = 3, n = 2
>
> 输出: 3
>
> 解释:
> 从左上角开始，总共有 3 条路径可以到达右下角。
>
> 1. 向右 -> 向右 -> 向下
> 2. 向右 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向右
>
> 示例 2:
>
> 输入: m = 7, n = 3
>
> 输出: 28
>
> 
>
> 来源：力扣（LeetCode）
>
> 链接：https://leetcode-cn.com/problems/unique-paths
> 



## 解题思路

这道题一看就是很典型的动态规划问题，一般来说都可以从填表入手，动态规划方程：

```c++
dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

所以可以从初始状态开始（即finish处开始）推导填表，最后得到的就是问题的解。举个简单的例子，m=7，n=3（其实m和n是可以互换的对结果没有影响）：

![](https://i.loli.net/2019/09/04/VC6Ub3IFT95xPNg.jpg)

这样就可以通过一个二维数组来解决问题。一般来说二维数组开销太大，而且往往都能够通过压缩成一维数组来解决，因为`dp[i][j]`计算出来之后，`dp[i-1][j]`和`dp[i][j-1]`的值就不再需要了，所以最终的解答如下：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(m, 1);
        for(int i = 1;i<n;i++){
            for(int j = 1;j<m;j++){
                dp[j] = dp[j]+dp[j-1];
            }   
        }
        return dp[m-1];
    }
};
```

一次AC，惊喜满满：

![](https://i.loli.net/2019/09/04/BDZc7A9of1GuiNS.png)



## 题解

题解给出的方案和我的差不多，这里就没必要展开了，但是里面提供了一个数学角度的解决方案：

> 思路：排列组合
>
> 因为机器到底右下角，向下几步，向右几步都是固定的，
>
> 比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。
>
> 所以有 C_{m+n-2}^{m-1}C 
> m+n−2
> m−1
> 	
>
> 
>
> 作者：powcai
>
> 链接：https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/
>
> 来源：力扣（LeetCode）