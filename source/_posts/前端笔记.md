---
title: 前端笔记
date: 2019-07-14 21:49:44
tags: 
- 前端
categories:
- 笔记
---

# 前端笔记摘要

## React

### PureComponent

> 参考：https://juejin.im/entry/5934c9bc570c35005b556e1a

#### 为什么使用？

React15.3中新加了一个 `PureComponent` 类，顾名思义， `pure` 是纯的意思，`PureComponent` 也就是纯组件，取代其前身 `PureRenderMixin` ,`PureComponent` 是优化 `React` 应用程序最重要的方法之一，易于实施，只要把继承类从 `Component` 换成 `PureComponent` 即可，可以减少不必要的 `render` 操作的次数，从而提高性能，而且可以少写 `shouldComponentUpdate` 函数，节省了点代码。

#### 原理

当组件更新时，如果组件的 `props` 和 `state` 都没发生改变，`render` 方法就不会触发，省去 `Virtual DOM` 的生成和比对过程，达到提升性能的目的。具体就是 `React` 自动帮我们做了一层浅比较：

```js
if (this._compositeType === CompositeTypes.PureClass) {
  shouldUpdate = !shallowEqual(prevProps, nextProps)
  || !shallowEqual(inst.state, nextState);
}
```

而 `shallowEqual` 又做了什么呢？会比较 `Object.keys(state | props)` 的长度是否一致，每一个 `key`是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。

## React Redux



## React Router

### 区别React-Router中match的path和url

> 参考：https://blog.51cto.com/zhuxianzhong/2120738

官方描述如下：

- path - (string) The path pattern used to match. Useful for building nested \<Route>s
- url - (string) The matched portion of the URL. Useful for building nested \<Link>s

path用来标识路由匹配的URL部分。React Router使用了Path-to-RegExp库将路径字符串转为正则表达式。然后正则表达式会匹配当前路径。

**当路由路径和当前路径成功匹配，会生成一个对象match**。match对象有更多关于URL和path的信息。这些信息可以通过它的属性获取，如下所示：

- **match.url.返回URL中匹配部分的字符串。用于创建嵌套的\<Link>很有用。**
- **match.path.用于匹配路径模式。用来创建嵌套的\<Route>。**
- match.isExact.返回布尔值，如果准确（没有任何多余字符）匹配则返回true。
- match.params.返回一个对象包含Path-to-RegExp包从URL解析的键值对。

### withRouter的作用和用法

> 参考：https://www.cnblogs.com/luowenshuai/p/9526341.html

#### **作用**

把不是通过路由切换过来的组件中，将react-router 的 history、location、match 三个对象传入props对象上

默认情况下必须是经过路由匹配渲染的组件才存在this.props，才拥有路由参数，才能使用编程式导航的写法，执行this.props.history.push('/detail')跳转到对应路由的页面

然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用withRouter就可以给此组件传入路由参数，此时就可以使用this.props

#### **如何使用withRouter**

比如app.js这个组件，一般是首页，不是通过路由跳转过来的，而是直接从浏览器中输入地址打开的，如果不使用withRouter此组件的this.props为空，没法执行props中的history、location、match等方法。

我就通过在App.js组件中使用withRouter来简单介绍一下：

设置withRouter很简单只需要两步：（1）引入  （2）将App组件 withRouter() 一下

```jsx
import React,{Component} from 'react'
import {Switch,Route,NavLink,Redirect,withRouter} from 'react-router-dom' //引入withRouter
import One from './One'
import NotFound from './NotFound'
class App extends Component{
    //此时才能获取this.props,包含（history, match, location）三个对象
    console.log(this.props);  //输出{match: {…}, location: {…}, history: {…}, 等}
    render(){return (<div className='app'>
            <NavLink to='/one/users'>用户列表</NavLink>
            <NavLink to='/one/companies'>公司列表</NavLink>
            <Switch>
                <Route path='/one/:type?' component={One} />
                <Redirect from='/' to='/one' exact />
                <Route component={NotFound} />
            </Switch>
        </div>)
    }
}
export default withRouter(App);  //这里要执行一下WithRouter
```

#### **介绍一个简单应用**

可以根据路由切换浏览器的title属性，对props.history进行监听，切换路由的时候获取当前的路由路径，同时可以根据不同的路由设置不同的浏览器title标题。

仍然是App.js组件：

```jsx
import React,{Component} from 'react'
import {Switch,Route,NavLink,Redirect,withRouter} from  'react-router-dom'
import One from './One'
import NotFound from './NotFound'
class App extends Component{
        constructor(props){
                super(props);
                props.history.listen((location)=>{  //在这里监听location对象
                        console.log(location.pathname);  //切换路由的时候输出"/one/users"和"/one/companies"
                        switch(location.pathname){   //根据路径不同切换不同的浏览器title
                                case '/one/users' : document.title = '用户列表'; break;
                                case '/one/companies' : document.title = '公司列表'; break;
                                default : break;
                        }
                })
        }
        render(){
                return (<div className='app'>
                        <NavLink to='/one/users'>用户列表</NavLink>
                        <NavLink to='/one/companies'>公司列表</NavLink>
                        <Switch>
                                <Route path='/one/:type?'  component={One} />
                                <Redirect from='/' to='/one' exact />
                                <Route component={NotFound} />
                        </Switch>
                </div>)
        }
}
export default withRouter(App);
```

#### **如果使用编程式导航**

this.props.history.push('/detail') 去跳转页面，但是报 this.props.history 错误 undefined，请在此组件中使用 withRouter 将 history 传入到 props上。



## HTML



## CSS

### 传统css

#### css中常见的选择符

> 参考：https://yanhaijing.com/css/2014/01/04/the-30-css-selectors-you-must-memorize/
>
> 官网：https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors#Simple_selectors

##### 基本选择器

- Type（类型）选择器

  这种基本选择器会选择所有匹配给定元素名的元素。 

  **语法：**`elename` 

  **例子：**input 将会选择所有的 input 元素。

- Class（类）选择器

  这种基本选择器会基于类属性的值来选择元素。 

  **语法：** `.classname` 

  **例子：** `.index` 会匹配所有包含 `index 类的元素` (由类似于`class="index"`这样的属性定义的).

- ID选择器

  这种基本选择器会选择所有id属性与之匹配的元素。需要注意的是一个文档中每个id都应该是唯一的。 

  **语法：**`#idname` 

  **例子：**`#toc` 将会匹配所有id属性为 toc 的元素 (类似于这样的定义 `id="toc"`).

- 通用选择器

  这个基本选择器选择所有节点。它也常常和一个名词空间配合使用，用来选择该空间下的所有元素。 

  **语法：** `* ns|* *|*` 

  **例子：**`*` （通配符）将会选择所有元素。

- 属性选择器

  这个基本的选择器根据元素的属性来进行选择。（具体参考：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors） 

  **语法：**`[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value]` 

  **例子：**`[autoplay]` 将会选择所有具有 autoplay 属性的元素（不论这个属性的值是什么）

##### 组合选择器

- 紧邻兄弟选择器

  `'+'` 操作符选择相邻元素，即第二个节点**紧邻着第一个节点**，并且**拥有共同的父节点**。

  **语法:** `A + B`

  **例子:** `ul + li` 会匹配任何 ul 元素后紧邻的 li 元素。

- 一般兄弟选择器

  `'~'` 操作符选择兄弟元素，也就是说，第二个节点在第一个节点**后面的任意位置**，并且这俩**节点的父节点相同**。

  **语法:** `A ~ B`

  **例子:** `p ~ span` 将会匹配同一父元素下，p 元素后的所有 span 元素。

- 子选择器

  `'>'` 操作符选择第一个元素的**直接子节点**。

  **语法:** `A > B`

  **例子:** `ul > li` 将会匹配直接嵌套在 ul 元素内的所有 li 元素。

- 后代选择器

  `' '`  (空格) 操作符将选择第一个元素的**子代节点**。

  **语法:** `A B`

  **例子:** `div span` 将匹配 div 元素内所有的 span 元素。

### Sass (Syntactically Awesome StyleSheets)



### Less(Leaner Style Sheets)

#### 一个变量多次定义

首先**一个变量不需要在使用之前就定义**，而且也**可以在不同地方重复定义同一个变量**，下面两个编译的结果一样：

```less
.lazy-eval{
    width: @var;
}

@var:@a;
@a:9%;
```

```less
.lazy-eval{
    width: @var;
    @a:9%;
}

@var:@a;
@a:100%;

// 定义在块级作用域里的@a(9%)覆盖了全局作用域里的@a(100%)
```

编译出来的css是：

```css
.lazy-eval {
  width: 9%;
}
```

官网里的原话是：

> When defining a variable twice, the last definition of the variable is used, **searching from the current scope upwards**. This is similar to css itself where the last property inside a definition is used to determine the value.

更经典的例子是：

```less
@var: 0;
.class {
  @var: 1;
  .brass {
    @var: 2;
    three: @var;
    @var: 3;
  }
  one: @var;
}
```

编译结果：

```css
.class {
  one: 1;
}
.class .brass {
  three: 3;
}
```

可以看出，three首先被赋值`@var: 2;`，然后被下面定义的`@var: 3;`覆盖；而one的作用域内看不到`@var: 2;`和`@var: 3;`，因此最后被赋值为1

#### 父选择器&

&指的是所有的父选择器，而不单单指最近的一个父选择器：

```

```



## JavaScript

### async/await的基础用法

> 参考：https://www.jianshu.com/p/ffa5cbe9ab29
>
> 推荐阅读：https://segmentfault.com/a/1190000007535316
>
> 
>
> 另外补充：进程、线程和协程的理解
>
> 参考https://blog.csdn.net/hairetz/article/details/16119911

#### 进程、线程和协程

|      |  堆  |  栈  |          调度          |
| :--: | :--: | :--: | :--------------------: |
| 进程 | 独立 | 独立 |        操作系统        |
| 线程 | 共享 | 独立 |        操作系统        |
| 协程 | 共享 | 独立 | 程序员在代码中显式调度 |

- 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
- 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。
- 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。

进程和其他两个的区别还是很明显的。

协程和线程的区别是：**协程避免了无意义的调度，由此可以提高性能**，但也因此，程序员必须自己承担调度的责任，同时，**协程也失去了标准线程使用多CPU的能力**。

#### async/await的特点

- `Promise`主要用then函数的链式调用，一直点点点，是一种从左向右的横向写法。
  `async/await`从上到下，顺序执行，就像写同步代码一样。这更符合人编写代码的习惯
- `Promise`的then函数只能传递一个参数，虽然可以通过包装成对象，但是这会导致传递冗余信息，频繁的解析又重新组合参数，比较麻烦。
  `async/await`没有这个限制，就当做普通的局部变量来处理好了，用let或者const定义的块级变量，想怎么用就怎么用，想定义几个就定义几个，完全没有限制，也没有冗余的工作。
- `Promise`在使用的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰。
  `async/await`整个书写习惯都是同步的，不需要纠结同步和异步的区别。当然，异步过程需要包装成一个`Promise`对象，放在`await`关键字后面，这点还是要牢记的。
- `Promise`是根据函数式编程的范式，对异步过程进行了一层封装。
  `async/await`是基于协程的机制，是真正的“保存上下文，控制权切换 ... ... 控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述。
- `async/await`是基于`Promise`的，是进一步的一种优化。不过再写代码的时候，`Promise`本身的API出现得很少，很接近同步代码的写法。

#### **await关键字使用的注意点**

- 只能放在`async`函数内部使用，不能放在普通函数里面，否则会报错。

- 后面放`Promise`对象，在`Pending`状态时，相应的协程会交出控制权，进入等待状态。这个是本质。

- `await`是`async wait`的意思，`wait`的是`resolve(data)`消息，并把数据`data`返回。比如，下面代码中，当`Promise`对象由`Pending`变为`Resolved`的时候，变量`a`就等于`data`；然后再顺序执行下面的语句`console.log(a);`
  这真的是等待，真的是顺序执行，表现和同步代码几乎一模一样。

  ```js
  const a = await new Promise((resolve, reject) => {
      // async process ...
      return resolve(data);
  });
  console.log(a);
  
  ```

- `await`后面也可以跟同步代码，不过系统会自动转化成一个`Promise`对象。
  比如
  `const a = await 'hello world';`
  其实就相当于
  `const a = await Promise.resolve('hello world');`
  这跟同步代码
  `const a = 'hello world';`是一样的，还不如省点事，去掉这里的`await`关键字。

- `await`只关心异步过程成功的消息`resolve(data)`，拿到相应的数据`data`。至于失败消息`reject(error)`，不关心，不处理。
  当然对于错误消息的处理，有以下几种方法供选择：
  （1）让`await`后面的`Promise`对象自己`catch`
  （2）也可以让外面的`async`函数返回的`Promise`对象统一`catch`
  （3）像同步代码一样，放在一个`try...catch`结构中

#### async关键字使用的注意点

- 有了这个`async`关键字，只是表明里面可能有异步过程，里面可以有`await`关键字。当然，全部是同步代码也没关系。当然，这时候这个`async`关键字就显得多余了。不是不能加，而是不应该加。
- `async`函数，如果里面有异步过程，会等待；
  但是`async`函数本身会马上返回，不会阻塞当前线程。

> 可以简单认为，`async`函数工作在主线程，同步执行，不会阻塞界面渲染。
> `async`函数内部由`async`关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回。

- `async`函数的返回值是一个`Promise`对象，这个是和普通函数本质不同的地方。这也是使用时重点注意的地方
  （1）`return newPromise();`这个符合`async`函数本意；
  （2）`return data;`这个是同步函数的写法，这里是要特别注意的。这个时候，其实就相当于`Promise.resolve(data);`还是一个`Promise`对象。
  在调用`async`函数的地方通过简单的`=`是拿不到这个`data`的。
  那么怎么样拿到这个`data`呢？
  很简单，返回值是一个`Promise`对象，用`.then(data => { })`函数就可以。
  （3）如果没有返回，相当于返回了`Promise.resolve(undefined);`
- `await`是不管异步过程的`reject(error)`消息的，`async`函数返回的这个`Promise`对象的`catch`函数就负责统一抓取内部所有异步过程的错误。
  `async`函数内部只要有一个异步过程发生错误，整个执行过程就中断，这个返回的`Promise`对象的`catch`就能抓到这个错误。
- `async`函数执行和普通函数一样，函数名带个()就可以了，参数个数随意，没有限制；也需要有`async`关键字。
  只是返回值是一个`Promise`对象，可以用then函数得到返回值，用catch抓去整个流程中发生的错误。

### ES6、ES7、ES8、ES9、ES10新特性一览

> 参考：https://juejin.im/post/5ca2e1935188254416288eb2



## 前端项目

### 将React项目部署到Github Pages

> 参考：https://segmentfault.com/a/1190000019290048

一些注意事项：

（1）Github Pages自定义域名问题

- 往gh-pages分支添加CNAME记录

  ![](https://i.loli.net/2019/07/04/5d1e10ad9b6d873438.png)

- 将要添加的域名写入CNAME，但是注意不要加入`http://`

  ![](https://i.loli.net/2019/07/04/5d1e110ab54e333768.png)

- 这里还有个问题就是，由于gh-pages分支是将编译之后的内容上传的，如果直接在gh-pages分支添加CNAME文件，会导致出现重新部署的时候CNAME被删除，这时后如果再次访问自定义域名，就会出现Content Security Policy问题（参见：https://stackoverflow.com/questions/54380373/content-security-policy-while-deploying-to-github-pages-using-gatsby）

  ```cmd
  Refused to load the image 'http://www.alexingberg.com/favicon.ico' because it violates the following Content Security Policy directive: "img-src data:".
  
  ```

  你可以按照stackoverflow上面的方案解决（我没试过），但我这里提供一个简单的解决方案，就是将CNAME添加在项目的public文件夹下面，编译之后CNAME就会在build目录生成，这样就不会出现Content Security Policy问题了

  ![](https://i.loli.net/2019/07/04/5d1e126fab25166732.png)

（2）自定义域名后出现资源路径不正确的问题

- 网上一些教程都是教你把Github Pages生成的那一串链接地址设置到`"homepages"`中

  ![](https://i.loli.net/2019/07/04/5d1e1359bcf0850375.png)

  这样会出现的问题就是，编译完成后，会在静态资源的路径前面都加上`/chph-blog`，这样肯定是找不到对应的资源的

- 可以通过把`"homepages"`设置成`"./"`即可

  ![](https://i.loli.net/2019/07/04/5d1e13f324be160749.png)

### Github开源项目license选择问题

简单一点，借用阮一峰博客上面的一张图：

![](http://www.ruanyifeng.com/blogimg/asset/201105/bg2011050101.png)

### 在React项目中使用Docz遇到的问题

（1）按照官网的Getting Start添加依赖后执行`yarnpkg add docz`，出现的问题如下：

```js
Failed to compile.

./node_modules/docz/dist/index.esm.js 23:38
Module parse failed: Unexpected token (23:38)
Failed to compile.

./node_modules/docz/dist/index.esm.js 23:38
Module parse failed: Unexpected token (23:38)
You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders
| import { MDXProvider } from '@mdx-js/react';
| 
> const BasePlayground = loadable(() => import('./Playground.esm.js'));
| const Playground = props => typeof window !== 'undefined' ? createElement(Suspense, {
|   fallback: null

```

Github上面的相关issue是：https://github.com/pedronauck/docz/issues/596

最关键的是这一个：

![](https://i.loli.net/2019/07/05/5d1f4b5aed0f933839.png)

他给出的解决方案是对webpack降级：

```cmd
npm i -D webpack@4.28.4

```

问题解决！

![](https://i.loli.net/2019/07/05/5d1f4ba8678ff64652.png)

然而，事情远远没有那么简单，当再次运行`yarn start`启动项目时，爆炸了：

![](https://i.loli.net/2019/07/07/5d21d9ed878d544757.png)

显然是docz和creact-react-app的webpack版本冲突了，我又在github搜罗了一番，解决方案是给docz单独指定一个webpack版本：

![](https://i.loli.net/2019/07/07/5d21dacbda01361621.png)

启动成功，舒服了

### 在React中使用Scss

> 参考：https://segmentfault.com/a/1190000016571839





## 前端工具使用

### webpack