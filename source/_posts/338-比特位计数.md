---
title: 338.比特位计数
date: 2019-07-14 23:20:49
categories:
- 算法
tags:
- 动态规划
- leetcode
---

# 338. 比特位计数

原题目如下：

> 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
>
> 示例 1:
>
> 输入: 2
>
> 输出: [0,1,1]
>
> 示例 2:
>
> 输入: 5
>
> 输出: [0,1,1,2,1,2]
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/counting-bits
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



## 解题思路

其实这道题还算简单，看到题目的第一个想法就是首先列举一下，找找规律：

```js
二进制	十进制 1的个数
0000	0	0
0001	1	1

0010	2	1
0011	3	2

0100	4	1
0101	5	2
0110	6	2
0111	7	3

1000	8	1
...
```

我给上面的结果分了个组，其实很容易看出来，**每组的1的个数就是该组前面所有数的1的个数加一**，所以答案已经很明显了：

```js
/**
 * @param {number} num
 * @return {number[]}
 */
var countBits = function(num) {
    let res = [0];
    for(let i =0;i<num;i++){
        let j = 0;
        const len = res.length;
        for(;j<len;j++){
            if(res.length==num+1) return res;
            res.push(res[j]+1);
        }
    }
    return res;
};
```

这是我的第一个版本的代码，一次过：

> 执行结果：
>
> 通过
>
> 显示详情
>
> 执行用时 :116 ms, 在所有 JavaScript 提交中击败了100.00%的用户
>
> 内存消耗 :39.9 MB, 在所有 JavaScript 提交中击败了30.30%的用户

## 其他解法

然后我看了一下其他的答案，感觉还是有些地方可以学习的

```js
// 奇数一定比上一个偶数多个 1，多的就是最低位的 1 
// 偶数中 1 的个数一定和除以 2 之后的那个数一样多。
// 因为最低位是0，除以 2 就是右移一位，也就是把那个0抹掉而已，所以1的个数是不变的。
var countBits = function (num) {
    let result = []
    result[0] = 0;
    for (let i = 1; i <= num; i++) {
        if (i % 2 === 1) {
            result[i] = result[i - 1] + 1;
        }
        else {
            result[i] = result[i / 2];
        }
    }

    return result;
}
```

上面这个解释的已经很清晰了，就不多说了，这位老哥还提供了另一个更优化的解法：

```js
// Time: O(n), Space: O(1)
// i & (i-1) 消除二进制最低位的 1 
var countBits = function (num) {
    let result = []
    result[0] = 0
    for (let i = 1; i <= num; i++) {
        result[i] = result[i & (i - 1)] + 1;
    }

    return result;
}
```

我发现有不少解法里有这个东西：`i & (i - 1)`，他说的消除二进制最低位的1是什么意思？举两个例子：

- 当i是奇数（例如xxx111），`i & (i - 1)`很显然就是类似`xxx111 & xxx110 = xxx110`，把xxx111的最低位1消去，效果相当于-1，和上上一个解法的这个说法

  > 奇数一定比上一个偶数多个 1

  道理一样

- 当i是偶数（例如xxx110），`i & (i - 1)`类似于`xxx110 & xxx101 = xxx100`，也是把最低位的1消掉，xxx110中1的个数和xxx100中1的个数相差1，这个是和上上个解法

  > 偶数中 1 的个数一定和除以 2 之后的那个数一样多

  有点不一样