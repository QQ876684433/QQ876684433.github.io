---
title: 软件系统设计02-质量属性策略
date: 2019-09-09 20:37:15
categories:
- 笔记
- 软件系统设计
tags:
- 架构
---

# 软件系统设计02-质量属性策略

## 第四章 理解质量属性

### 质量属性定义

**质量属性（Quality Attribute，QA）**：它是一个系统可度量或者可测试的属性，用来指示系统在多大程度上满足了它的利益相关者的需求

![](https://i.loli.net/2019/09/09/Dmh8IoW5f4c2MF3.png)

### 架构和需求

#### 需求的分类

- **功能性需求（Functional Requirements）**：描述了系统必须做的事情（必须实现的功能），以及在运行时接受外部刺激时系统应该表现出的行为或者反应
- **质量属性需求（Quality Attribute Requirements）**：它是功能性需求或者整个产品的质量或者限定条件——对于功能性需求来说，它描述了系统响应有多快或者在接受错误输入时必须具备多大的弹性等；对于整个系统来说，它描述了产品的部署需要的时间或者对运营成本的限制
- **约束（Constraints）**：约束条件是**具有零自由度的设计决策**，即是说它是一个已经做出的设计决策，不能再修改。例如系统使用的编程语言或者要依赖的指定模块等

![](https://i.loli.net/2019/09/09/jdH9W4NpQTciDoX.png)

#### 不同种类的需求在架构中的体现

- 功能性需求：通过整个设计中合适的职责分配来满足
- 质量属性需求：通过设计到架构中的各种结构以及填充这些结构的元素的行为和交互来满足
- 约束：通过接受设计决策并将其与其他受影响的设计决策进行协调来满足约束条件

![](https://i.loli.net/2019/09/09/sAGFdjfNtq1pyU5.png)

### 功能性需求

功能性需求**不能决定架构**。原因是对于一个给定的功能性需求集合，我们可以有很多不同的方法来将功能性需求划分到不同的架构模块中；事实上，即使我们不划分模块，甚至内部毫无架构结构可言，也依旧有可能将功能性需求实现。

我们进行架构设计是为了使得系统更加易于理解，以便支持各种各样的**其他目的——即质量属性需求**。

尽管功能性需求**独立于特定的系统结构**，但是它是通过将系统的职责分配到不同的架构元素中来实现的；虽然职责可以被任意分配到某一个模块中，但是当质量属性占很重要地位的时候，软件架构会约束系统职责的分配。

![](https://i.loli.net/2019/09/09/1k7jC4bmetfMHdS.png)

### 质量属性考量

功能性需求和质量属性都不是自身独立的。

从架构师的角度，系统质量属性会有以下三个问题：

- 某个质量属性的定义是不可测试的
- 对质量属性的讨论通常侧重于特定问题所属的质量，而且这个问题往往在不同的质量属性范围中有重叠
- 每个质量社区都发展出了自己的属性词汇

前两个问题可以通过才用“质量属性场景”这个工具来区分不同的质量属性；第三个问题可以通过对每一个属性的多个社区词汇进行讨论，寻找出某个质量属性的不通社区词汇之间最本质最基础的概念

![](https://i.loli.net/2019/09/09/ARi5bKTxBnFCMLz.png)

![](https://i.loli.net/2019/09/09/VNMErefpAtXSTcy.png)

#### 质量属性分类

- 系统运行时的属性：可用性（Availability）、性能（Performance）、易用性（Usability）等
- 系统开发时的属性：可修改性（Modifiability）、可测试性（Testability）

![](https://i.loli.net/2019/09/09/zIuGqswZ8JO3tvi.png)

在复杂的系统中，质量属性相互之间不可能是独立开的，一个质量属性的实现对其他质量属性产生或积极或负面的影响，因此在架构设计时需要在这些设计决策之间作出合适的权衡。

### 制定质量属性需求

质量属性需求应当是**明确的和可测试的**。质量属性表达的常用形式包含这些部分：

- **刺激（Stimulus）**：到达系统的事件，例如易用性中的用户操作，安全性中的外部攻击，可修改性中的修改需求，可测试性中的某个开发阶段的完成等
- **刺激源（Stimulus source）**：不同的刺激源，系统对待和处理的方式会不一样，例如受信任用户和不受信任用户经历的审查是不一样的
- **响应（Response）**：对于刺激，系统应当采取的措施，例如在可修改性的场景中，一个修改需求的到达要求开发者将这个修改需求实现、测试并部署所作出的修改
- **响应度量（Response measure）**：判断系统的响应是否满足需求，例如性能的度量可以是延迟或者吞吐量，可修改性的度量可以是工作量或者修改、测试和部署修改所需的时间等
- **环境（Environment）**：需求的环境是一系列场景发生情况的集合，它充当了刺激的限定词，例如对待代码冻结以发布前后发生的错误，处理的方式是不一样的
- **工件（Artifact）**：它是系统中需求适用的部分，不同的问题，它可能影响整个系统，也有可能只影响系统的某一个部分，例如数据库出错和元数据库出错的处理方式是不一样的，用户接口的修改需求和中间件的修改需求所需要的时间也是不一样的，等等

![](https://i.loli.net/2019/09/09/PYTGwBznM42QHN8.png)

![](https://i.loli.net/2019/09/10/NZ4BG2OqXTiDuzw.png)

质量属性需求可以划分为六个场景，它们可能单独发生，也有可能伴随发生，特别是系统架构设计初期

![](https://i.loli.net/2019/09/10/Q8yB2pgMoIGvmDt.png)

#### 质量属性场景示例图

![](https://i.loli.net/2019/09/10/xOyBMiYCUJd1jXz.png)

![](https://i.loli.net/2019/09/10/YLOvhojfMnNRxpB.png)



### 通过策略来实现质量属性需求

#### 架构策略（Architectural Tactics）

架构策略是用来实现需要的质量属性的技术，它是一种设计决策，会影响质量属性响应的实现以及会直接影响系统对某些刺激的响应。**策略赋予一种设计可移植性，将性能传递给另一种设计，并将可集成性传递给第三种设计**。

![](https://i.loli.net/2019/09/10/D9BrKmp7Fjqgwfb.png)



### 指导设计决策

**架构是应用设计决策集合的结果**。设计决策可以分为七个类别，在设计架构的时候可以分别从某个设计决策的维度进行设计考量，降低架构设计的复杂度：

- **职责分配（Allocation of Responsibilities）**

  涉及职责分配的决策包括：

  - 识别重要的职责（基础系统功能、架构基础设施、质量属性的满足）
  - 决定如何将这些职责分配到运行时和非运行时元素

  制定如上决策的策略有：功能分解、对真实世界对象建模、基于操作的主要模式分组、基于相似的质量属性分组

  ![](https://i.loli.net/2019/09/16/X47xSvL1yr589FV.png)

- **协作模型（Coordination Model）**

  软件架构中各个元素之间相互交互的设计机制就是协作模型，它包括如下方面：

  - 识别系统中必须协作或者禁止协作的元素
  - 确定协作的属性，例如时间线、完成度、正确性和一致性等
  - 选择实现上面协作属性的通信机制，例如有状态的和无状态的、同步的和异步的、保证交付和不保证交付的，以及与性能相关的属性（吞吐量，延迟等）

- **数据模型（Data Model）**

  每个系统必须以某种内部方式表示系统范围内的数据，这就是数据模型。有关数据模型的决策如下：

  - 选择主要的数据抽象（属性与相应的操作）。它包括数据的创建、初始化、访问、持久化、操作、解释和销毁
  - 编译一致解释数据所需的元数据
  - 组织数据，包括数据是否要存储在关系型数据库、对象集合中，或者两者兼有。如果两者兼有，则还得确定两个不同位置之间的映射

- **资源管理（Management of Resource）**

  软件架构必须仲裁系统中共享资源的使用，包括硬件资源（CPU、存储、电源、硬件缓冲、系统时钟和I/O端口等）和软件资源（系统锁、软件缓冲、线程池，以及非线程安全的代码），资源管理决策包括如下方面：

  - 识别必须被管理的资源，确定每种资源的限度
  - 确定每种资源是由哪个系统元素管理的
  - 当资源存在竞争时，要确定资源的共享方式以及采取的仲裁策略
  - 确定各种资源饱和时会造成的影响，例如随着CPU负载的增加，系统的性能会相应地下降；当内存逐渐耗尽，会在某个点开始密集地分页/交换，随之而来的是性能突然下降甚至崩溃

- **架构元素之间的映射（Mapping among Architectural Elements）**

  - 不同类型架构之间的映射

    例如开发单元（模块）到执行单元（线程或者进程）的映射

  - 软件元素和环境元素之间的映射

    例如进程到特定CPUs的映射

  一般有如下比较实用的映射：

  - **开发模块**与**运行时元素**之间的相互映射，即运行时元素是由每个模块创建出来的，开发模块包含了对应每个运行时元素的代码
  - **运行时元素**到**处理器**的分配
  - **数据模型**到**数据存储**的分配
  - **开发模块和运行时元素**到**交付单元**之间的映射

- **绑定时间决策（结合时间决策，Binding Time Decision）**

  > **Binding time** is an important, yet underestimated viewpoint in software architecture and design. It defines the latest time during the software life cycle when something flexible becomes decided and fixed. This heavily impacts the flexibility of a software design and the resulting application. A terminology for describe binding time is established and an analysis is carried out in form of side-by-side comparisons for patterns and mechanisms from the creational, structural, and behavioral domains. These terminology and synoptic comparisons with the binding time considerations can aid software architects and developers in selecting patterns and taking correct architectural decisions for their binding time requirements.
  >
  > ——Abstract from Paper “<u>Describing binding time in software design patterns</u>”

  绑定时间是软件架构和设计中一个重要但却被低估的观点，它定义了软件生命周期中具备灵活性的元素变成确定的和固定的状态时的最迟时间。它会深刻影响软件设计以及最终应用程序的灵活性。

  其他六种决策也都和结合时间决策有关联：

  - 对于职责分配，可以在构建编译时通过参数化的makefile来选择模块
  - 对于协作模型的选择，可以设计一个运行时通信协议进行协作
  - 对于资源管理，可以设计一个机制，使得系统能够允许在运行时接受新的外围设备插入，紧接着识别设备并自动下载安装相应的驱动程序
  - 对于技术选型，可以构建app store方式来为已经购买app的用户自动下载适合版本的app等

  在制定结合时间决策时，要考虑**实现这种决策的开销**，以及**后续修改这种决策实现的开销**。例如考虑到代码开发完成后有迁移系统平台的可能性，那么就应该在设计时通过一些额外的开销来将自己的开发工作变得平台独立，以便后续的平台移植。

- **技术选择（Choice of Technology）**

  技术选择是这七种决策的约束，因此我们必须选择合适的技术来实现这七种决策。技术选型决策包含以下方面：

  - 确定哪些技术能够实现其他六种决策
  - 确定是否有合适的开发工具（IDEs，模拟器，测试工具，等等）来支持开发活动
  - 确定内部人员对技术的熟悉程度，以及外部资源对技术的支持程度（例如课程、手册、示例，以及能够提供紧急情况专业知识的承包商的可用性）
  - 确定所选技术的副作用，例如技术限制的协作迷行、资源管理等
  - 确定一个新的技术是否和现有的技术栈兼容




## 第五章 可用性

**Availability=detect+correct+restart**

当系统提供的服务与相应的服务规格不一致的时候，我们认为该系统失效（Failure）了，这种失效是可以被系统的用户直接观测到的 

**可用性损失期**（从发生故障到发现故障，修复故障，最后到系统重启恢复到故障发生前的状态）由以下方面决定：

- Time to **detect** failure
- Time to **correct** failure 
- Time to **restart** application

**单点故障**

单点故障（英语：single point of failure，缩写SPOF）是指系统中一旦失效，就会让整个系统无法运作的部件，换句话说，单点故障即会整体故障。

高可用性的一些策略：

- 消除单点失效（单点故障）
- 复制（备份机制，例如checkpoint等）、故障转移（快速恢复）
- 自动检测和重启机制

**可恢复性**

在应用程序或系统发生故障后重新建立性能级别并恢复受影响数据的能力

**可用性的计算方式**

可用性可以计算为在**指定时间间隔内**在**指定范围内**提供**指定服务**的**概率**，一般表示为%形式，如下图所示：

![](https://i.loli.net/2019/09/20/4B6Ae2q9hjCuKHE.png)

要注意的是，由于系统维护的原因，在计算可用性时不会考虑定期的关机时间。

根据上面的公式，可以想到的提高可用性的措施：

- 缩短系统修复时间
- 延长系统两次失败之间的时间间隔

**Outage, Failure, Fault, and Error**

- Fault：系统出错或者故障，他是系统失效（failure）的原因，但是此时系统还是可用的
- Failure：系统失效，它是系统状态可以被观测到的特征，往往当系统Failure时，这个系统已经不能为用户提供系统预期的服务了，甚至有可能系统已经宕机了
- Error：是由Fault变成可观测的系统Failure的中间状态
- Outage：指的是系统停机或者停止服务时间，它包括系统失效/出故障这种非正常的情况，也包括定期维护而停止服务的时间；提高可用性就是通过减少系统出错（Fault），从而缩短系统停止服务（Outage）的时间



为了使系统更加安全和高可用，首先需要对这两方面进行分析：**自己定系统最容易发生错误**，以及**每种错误发生后最有能造成的后果**。为了进行这种分析，可以才用如下方法：

- **危害分析（Hazard Analysis）**

  可以根据严重性来对每种危害进行分类，例如：

  - **灾难性的（Catastrophic）**：这种失效会导致整个系统直接崩溃，后果最严重
  - **赌运气的（冒险的，Hazardous）**：这种失效对系统的安全或者性能有很大概率的负面影响
  - **重大的（Major）**：危害也很重大，但是程度比上面两种稍微轻一些
  - **轻微的（Minor）**：这种失效是显而易见的，但是危害程度小很多
  - **没有影响（No Effect）**：这种失效没有任何影响

- **故障树分析（Fault Tree Analysis）**

- 失效模式，效果和临界性/危害性分析（Failure Mode, Effects, and Criticality Analysis）

### 可用性通用场景

![](https://i.loli.net/2019/09/20/aY7wED59RkPS3FO.png)



![](https://i.loli.net/2019/09/20/Li73lgVMjRrfcmG.png)





### 可用性策略（Tactis for Availability）

由于系统出错（Fault）有可能导致系统失效（Failure），因此我们应该采取一些策略来**防止出错（Fault）演变成失效（Failure**），或者至少**限制出错的影响范围然后尽可能修复**。

![](https://i.loli.net/2019/09/20/6gajKyc8shDd5Ye.png)

（题外话：<u>这些策略有可能以软件基础设施的形式提供（例如中间件工具包），所以架构师的职责之一是选择和使用（而不是实现它）适合的可用性策略以及正确的策略组合</u>）

![](https://i.loli.net/2019/09/20/vRDBag8P3GhYspi.png)

#### 错误检测（Detect Faults）

- **Ping/Echo**

  - 它是节点间异步的请求/响应消息对，通常用来确定**可达性**和**往返延迟**，同时echo节点也能够通过ping来确定发出ping的组件是存活的、能够正确响应的 
  - 通常来说**ping是由监控节点主动发出的**，用来确认某个或者某些节点是可达的以及往返延迟是多少
  - Ping/Echo需要预设一个时间阈值，这个阈值用来告诉监控节点：在接收到echo之前，监控节点会等待多长时间，超时之后才会认为被监控的节点已经失效

- **Monitor（监视器）**

  监视器是用来监视系统中多个部分健康状况的组件，例如监控：处理器、进程、IO、存储等待

- **HeartBeat（心跳机制）**

  - HeartBeat在系统监视器以及被监视的进程之间周期性地交互消息以检测是否有错误发生

  - 例子：

    ![](https://i.loli.net/2019/09/20/PHsiaK7hrEX2jDB.png)

    被监控的进程周期性地主动发送心跳消息到监视器以重置watch dog中的计时器，防止计时器超时而使得监视器错误地发出一个错误信号标识被监控的进程失效

  - HeartBeat vs Ping/Echo：区别主要在于负责初始化健康监测机制的组件是谁，监视器还是被监控的组件自身，HeartBeat中是被监控的进程主动发出心跳信号，而Ping/Echo中是监视器主动发出ping信号来监测被监控组件的健康状态

- **Timestamp（时间戳）**

  主要用于监测**不正确的时间序列**，一般用在分布式消息传递系统中。可以通过**在事件发生时立即将本地时间附加到事件消息中**来实现时间戳机制；如果具体的时间信息不重要的话，可以直接使用序列数字作为时间戳（<u>但这样的话似乎需要一个集中发放序列号的组件？</u>）

- **Sanity Checking（健全检测）**

  它通常是用来监测某个特定操作或者某个组件的输出的**有效性或者合理性**，这种策略通常基于系统内部设计、系统的状态或者正在审议中的信息等；它经常在接口中采用，用来检验特定的信息流

- **Condition Monitoring（条件监控）**

  它通常是用来监测一个进程或者设备的条件状态、或者验证设计时做出的假设的有效性。例如常见的方法是校验和checksum。但是监控组件自身必须足够简单以避免引入新的软件错误

- **Voting（投票）**

  这种策略最常见的实现方式是**三重模块化冗余（triple modular redundancy，TMR）**，使用是三个组件来做同样的事情，每个组件都接受相同的输入，然后将它们的输出转发到**投票逻辑单元（voting logic）**中检验三个输出状态的一致性

  当遇到输出状态不一致的时候，投票器会报告出错状态，但同时它也还需要决定输出结果是什么，一般可以采用**多数人规则（majority rule）**或者**对离散结果取平均**，这些策略都取决于具体的投票逻辑。并且，投票逻辑应该被实现为一个简单、经过严格审查和测试的单例，以降低引入新的错误的概率

  - Replication：各个组件是相互之间的克隆，通过相同组件的拷贝可以防止硬件的随机错误，但是不能避免软件或者硬件在设计或者实现上的错误，因为这种策略的各个组件没有差异化的设计
  - Functional Redundancy（功能冗余）：这些组件是差异化设计和实现的，但是它们对相同的输入，总是应该给出相同的输出
  - Analytic Redundancy（分析冗余）：这种策略中，不仅组件内部的实现是差异化的，他们的输入输出也是差异化的。这种策略的目的是通过使用单独的需求规范来容忍设计规范的错误。在嵌入式系统中，有些输入源可能失效，这时候分析冗余就可以生效了。

- **Exception Detection（异常检测）**

  它通常是监测改变了正常执行流的系统条件，可以分为以下几种：

  - 系统异常（system exception）：不同的处理器硬件架构会有不同的系统异常，例如除零、总线和地址出错、非法程序指令等等
  - 参数围栏（the parameter fence）：它包括一个先验的数据模式（例如0xDEADBEEF），它被放在一个对象的变长参数的后面，这允许在运行时监测到分配给一个对象的变长参数的内存是否被overwrite
  - 参数类型（the parameter typing）：使用一个基类来定义函数，例如add、find等，然后派生类使用基类的函数接口，根据自身不同的参数结构来实现不同的功能。使用强类型来构建和解析消息，比简单的把消息看作一串字节，更能够减少出错、提高可用性，当然也会因此使得系统演化变得复杂
  - 超时（timeout）：当组件没有在时间限制内完成的话，该策略会抛出一个超时异常

  **一般来说异常检测策略是在一个进程内部操作的，而ping/echo以及heartbeat时在不同进程键进程操作的**

- **Self-test（自检）**

  组件可以运行一个进程来监测自身操作的正确性，这个自检进程可以由组件自身初始化，也可以由系统监视器初始化。自检技术包括校验和checksum等



#### 错误恢复（Recover from Faults）

##### 预备和恢复策略（Preparation and Repair）

- **Active Redundancy（hot spare，主动冗余，热备份）**

  它将所有的节点（主动节点和冗余备份节点）配置在一个保护组中，它们并行地接收和处理相同的输入（只会才用主动节点的输出，其他的输出会被舍弃），这样可以使得冗余备份节点和主动节点保持同步的状态，因此它们可以在主动节点失效的时候立刻切换和接管工作。最简单的实现方式是1+1冗余（一个主动节点+一个冗余备份节点）。主动冗余可以用来作为基础设施北湖，例如活跃的网络链路和支援的网络链路一起使用可以提高网络连接的高可用性

- **Passive Redundancy（warm spare，被动冗余，热备用）**

  在保护组中只有主动成员才处理输入流量，同时给保护组中的冗余备份节点提供**周期性的状态更新**。当主动节点出错的时候，系统必须确定冗余备份节点的备份状态足够新（即足够接近主动节点出故障时的状态）才能够被作为替补恢复到正常的系统服务体系中，因此恢复的时间可能比主动冗余要慢

- **Spare（cold spare，候补，冷备用）**

  这个策略下冗余备份节点在主动节点发生故障前都是不提供服务的，因此当备份节点需要替换到正常系统体系中前，它需要启动一个power-on-reset进程来将自身的状态更新到主动节点出故障前的状态。由于它糟糕的恢复性能，它一般更适用于只有高可靠性需求（而对高可用性需求不高）的系统中

- **Exception Handling（异常处理）**

  一旦检测到系统异常，系统必须以某种方式进行处理。异常处理的方式很大程度上取决于所使用的开发环境，从简单的函数返回状态码/错误码，到使用包含了对错误纠正有用的信息的异常类，例如异常的名字、异常源头以及异常的原因，软件可以利用这些信息来掩盖出错，一般来说是**纠正出错的原因**然后**重新尝试操作**

- **Rollback（回退）**

  

- 

##### 重新引入策略（Reintroduction）

这个部分关注将一个失效（但是已经恢复）的组件引入到正常的系统体系中