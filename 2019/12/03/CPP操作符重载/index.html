<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>CPP操作符重载 | 至繁归于至简 - chph&#39;s blog | steve_chph personal website</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="C++,操作符重载">
    <meta name="description" content="C++操作符重载基本概念 重载的运算符是具有特殊名字的函数：函数的名字由关键字operator和其后要定义的运算符号共同组成  重载运算符函数的参数数量与该运算符作用的运算对象的数量一样多  除了重载的函数调用运算符operator()之外，其他的重载运算符不能含有默认实参  当一个重载的运算符是成员函数时，this对象指针绑定到左侧运算对象（即运算符重载函数的第一个参数）  不能重载内置类型的运">
<meta name="keywords" content="C++,操作符重载">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP操作符重载">
<meta property="og:url" content="http://QQ876684433.github.io/2019/12/03/CPP操作符重载/index.html">
<meta property="og:site_name" content="至繁归于至简 - chph&#39;s blog">
<meta property="og:description" content="C++操作符重载基本概念 重载的运算符是具有特殊名字的函数：函数的名字由关键字operator和其后要定义的运算符号共同组成  重载运算符函数的参数数量与该运算符作用的运算对象的数量一样多  除了重载的函数调用运算符operator()之外，其他的重载运算符不能含有默认实参  当一个重载的运算符是成员函数时，this对象指针绑定到左侧运算对象（即运算符重载函数的第一个参数）  不能重载内置类型的运">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2019/12/03/hTq6WVGOiKXpnft.png">
<meta property="og:image" content="https://i.loli.net/2019/12/03/PzaKcW3mkhQ7jMU.png">
<meta property="og:image" content="https://i.loli.net/2019/12/03/cmJEn5YrWvPfaMj.png">
<meta property="og:image" content="https://i.loli.net/2019/12/16/DY4N2BxTgMSlyRr.png">
<meta property="og:image" content="https://i.loli.net/2019/12/16/Fg6t7Sh5xK2WQ8U.png">
<meta property="og:image" content="https://i.loli.net/2019/12/16/FVMQjZd35KwIubG.png">
<meta property="og:image" content="https://i.loli.net/2019/12/16/InHA5YWrR1tThzo.png">
<meta property="og:image" content="https://i.loli.net/2019/12/16/si3NSTIUp5QCmA7.png">
<meta property="og:image" content="https://i.loli.net/2019/12/16/MaeSfgPIu7NRnL8.png">
<meta property="og:image" content="https://i.loli.net/2019/12/17/fyW1Qhpu7Si4LvK.png">
<meta property="og:image" content="https://i.loli.net/2019/12/17/lVL9w1cHvq3TR7W.png">
<meta property="og:image" content="https://i.loli.net/2019/12/17/4ujQnv3BXtACMEf.png">
<meta property="og:image" content="https://i.loli.net/2019/12/17/D3qI6fjSTumyeLv.png">
<meta property="og:image" content="https://i.loli.net/2019/12/17/NByJ3iCsPmFtHUv.png">
<meta property="og:image" content="https://i.loli.net/2019/12/17/gYrFMBqdl9NUO5G.png">
<meta property="og:image" content="http://qq876684433.github.io/home/steve/.config/Typora/typora-user-images/1576547582277.png">
<meta property="og:updated_time" content="2020-01-07T07:11:41.913Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CPP操作符重载">
<meta name="twitter:description" content="C++操作符重载基本概念 重载的运算符是具有特殊名字的函数：函数的名字由关键字operator和其后要定义的运算符号共同组成  重载运算符函数的参数数量与该运算符作用的运算对象的数量一样多  除了重载的函数调用运算符operator()之外，其他的重载运算符不能含有默认实参  当一个重载的运算符是成员函数时，this对象指针绑定到左侧运算对象（即运算符重载函数的第一个参数）  不能重载内置类型的运">
<meta name="twitter:image" content="https://i.loli.net/2019/12/03/hTq6WVGOiKXpnft.png">
    
        <link rel="alternate" type="application/atom+xml" title="至繁归于至简 - chph&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">steve_chph</h5>
          <a href="mailto:chph13420146901@gmail.com" title="chph13420146901@gmail.com" class="mail">chph13420146901@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/QQ876684433" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://107.182.188.221:23333/"  >
                <i class="icon icon-lg icon-link"></i>
                Project(HTTP)
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://107.182.188.221:23334/"  >
                <i class="icon icon-lg icon-demo"></i>
                Project(HTTPS)
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">CPP操作符重载</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">CPP操作符重载</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-12-03T08:12:10.000Z" itemprop="datePublished" class="page-time">
  2019-12-03
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#C-操作符重载"><span class="post-toc-number">1.</span> <span class="post-toc-text">C++操作符重载</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#基本概念"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">基本概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#某些运算符不应该被重载"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">某些运算符不应该被重载</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用与内置类型一致的含义"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">使用与内置类型一致的含义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#选择作为成员或者非成员"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">选择作为成员或者非成员</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#输入输出运算符"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">输入输出运算符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#重载输出运算符-lt-lt"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">重载输出运算符&lt;&lt;</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#输出运算符尽量减少格式化操作"><span class="post-toc-number">1.2.1.1.</span> <span class="post-toc-text">输出运算符尽量减少格式化操作</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#输入输出运算符必须是非成员函数"><span class="post-toc-number">1.2.1.2.</span> <span class="post-toc-text">输入输出运算符必须是非成员函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#重载输入运算符-gt-gt"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">重载输入运算符&gt;&gt;</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#输入时的错误"><span class="post-toc-number">1.2.2.1.</span> <span class="post-toc-text">输入时的错误</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#标示错误"><span class="post-toc-number">1.2.2.2.</span> <span class="post-toc-text">标示错误</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#算术和关系运算符"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">算术和关系运算符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#相等运算符"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">相等运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#关系运算符"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">关系运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#赋值运算符"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">赋值运算符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#复合赋值运算符"><span class="post-toc-number">1.3.3.1.</span> <span class="post-toc-text">复合赋值运算符</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#下标运算符"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">下标运算符</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#递增和递减运算符"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">递增和递减运算符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义前置递增-递减运算符"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">定义前置递增/递减运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#区分前置和后置运算符"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">区分前置和后置运算符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#显式调用前置-后置运算符"><span class="post-toc-number">1.5.3.</span> <span class="post-toc-text">显式调用前置/后置运算符</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#成员访问运算符"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">成员访问运算符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#重载要求："><span class="post-toc-number">1.6.0.1.</span> <span class="post-toc-text">重载要求：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对箭头运算符返回值的限定"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">对箭头运算符返回值的限定</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#函数调用运算符"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">函数调用运算符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#lambda是函数对象"><span class="post-toc-number">1.7.1.</span> <span class="post-toc-text">lambda是函数对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#标准库定义的函数对象"><span class="post-toc-number">1.7.2.</span> <span class="post-toc-text">标准库定义的函数对象</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可调用对象与function"><span class="post-toc-number">1.7.3.</span> <span class="post-toc-text">可调用对象与function</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#不同类型可能具有相同的调用形式"><span class="post-toc-number">1.7.3.1.</span> <span class="post-toc-text">不同类型可能具有相同的调用形式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#标准库function类型"><span class="post-toc-number">1.7.3.2.</span> <span class="post-toc-text">标准库function类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#重载的函数与function"><span class="post-toc-number">1.7.3.3.</span> <span class="post-toc-text">重载的函数与function</span></a></li></ol></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-CPP操作符重载"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">CPP操作符重载</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-12-03 16:12:10" datetime="2019-12-03T08:12:10.000Z"  itemprop="datePublished">2019-12-03</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="C-操作符重载"><a href="#C-操作符重载" class="headerlink" title="C++操作符重载"></a>C++操作符重载</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>重载的运算符是具有特殊名字的函数：函数的名字由关键字operator和其后要定义的运算符号共同组成</p>
</li>
<li><p>重载运算符函数的参数数量与该运算符作用的运算对象的数量一样多</p>
</li>
<li><p>除了重载的函数调用运算符operator()之外，其他的重载运算符不能含有默认实参</p>
</li>
<li><p>当一个重载的运算符是成员函数时，this对象指针绑定到左侧运算对象（即运算符重载函数的第一个参数）</p>
</li>
<li><p>不能重载内置类型的运算符</p>
</li>
<li><p>我们只能重载已有的运算符</p>
</li>
<li><p>对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符一致</p>
<p>即<code>x == (y + z)</code>永远等价于<code>x == (y + z)</code></p>
</li>
</ul>
<p>其中<code>::</code>、<code>.*</code>、<code>.</code>和<code>?:</code>不能被重载：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/03/hTq6WVGOiKXpnft.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<ul>
<li><p>运算符重载函数是可以像普通函数一样被显式调用的</p>
<ul>
<li><p>非成员函数运算符重载函数的等价调用</p>
<p><img src="https://i.loli.net/2019/12/03/PzaKcW3mkhQ7jMU.png" alt></p>
</li>
<li><p>成员函数运算符重载函数的等价调用</p>
<p><img src="https://i.loli.net/2019/12/03/cmJEn5YrWvPfaMj.png" alt></p>
</li>
</ul>
</li>
</ul>
<h3 id="某些运算符不应该被重载"><a href="#某些运算符不应该被重载" class="headerlink" title="某些运算符不应该被重载"></a>某些运算符不应该被重载</h3><p>某些运算符指定了运算对象的求值顺序，使用重载的运算符本质上是一次函数调用，所以这些关于<strong>运算符对象求值顺序的规则</strong>无法应用到重载的运算符上：逻辑与运算符（&amp;&amp;）、逻辑或运算符（||）和逗号运算符的运算对象求值顺序规则无法保留下来；此外逻辑与运算符（&amp;&amp;）、逻辑或运算符（||）的<strong>短路求值属性</strong>也无法保留，两个运算对象总是会被求值</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/16/DY4N2BxTgMSlyRr.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h3 id="使用与内置类型一致的含义"><a href="#使用与内置类型一致的含义" class="headerlink" title="使用与内置类型一致的含义"></a>使用与内置类型一致的含义</h3><p>重载运算符的<strong>返回类型</strong>通常情况下应该<strong>与其内置版本的返回类型兼容</strong>：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回<u><em>左侧运算对象</em></u>的一个引用</p>
<h3 id="选择作为成员或者非成员"><a href="#选择作为成员或者非成员" class="headerlink" title="选择作为成员或者非成员"></a>选择作为成员或者非成员</h3><ul>
<li><p>作为成员</p>
<p>（或者说，单目运算符多是作为成员？）</p>
<ul>
<li><strong>赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）运算符</strong>必须是成员</li>
<li>复合赋值运算符（+=、-=、*=、/=、%=等）一般来说是成员</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员</li>
</ul>
</li>
<li><p>作为普通的非成员</p>
<ul>
<li>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数</li>
</ul>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/16/Fg6t7Sh5xK2WQ8U.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="输入输出运算符"><a href="#输入输出运算符" class="headerlink" title="输入输出运算符"></a>输入输出运算符</h2><h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><ul>
<li>输出运算符的第一个形参是一个<strong>非常量</strong>ostream对象的<strong>引用</strong><ul>
<li>非常量：向流写入内容会改变其内容</li>
<li>引用：我们无法直接复制一个ostream对象</li>
</ul>
</li>
<li>第二个形参一般来说是一个<strong>常量</strong>的<strong>引用</strong><ul>
<li>常量：通常情况下打印对象不会改变对象的内容</li>
<li>引用：我们希望避免复制实参</li>
</ul>
</li>
<li>operator&lt;&lt; 一般要<strong>返回它的ostream形参</strong>（是一个引用）</li>
</ul>
<h4 id="输出运算符尽量减少格式化操作"><a href="#输出运算符尽量减少格式化操作" class="headerlink" title="输出运算符尽量减少格式化操作"></a>输出运算符尽量减少格式化操作</h4><p>输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符<strong>不应该打印换行符</strong></p>
<h4 id="输入输出运算符必须是非成员函数"><a href="#输入输出运算符必须是非成员函数" class="headerlink" title="输入输出运算符必须是非成员函数"></a>输入输出运算符必须是非成员函数</h4><p>如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数；由于通常要读取类的非公有数据成员，所以<strong>IO运算符一般被声明成友元</strong></p>
<h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><ul>
<li>输入运算符的第一个形参是运算符将要读取的流的引用</li>
<li>第二个形参是将要读入到<strong>（非常量）对象</strong>的<strong>引用</strong><ul>
<li>非常量（必须）：因为输入运算符本身的目的就是将数据读入到这个对象（修改其内部状态）</li>
</ul>
</li>
<li>运算符通常会返回某个给定流的引用</li>
</ul>
<p><u><em>输入运算符必须处理 输入可能失败的情况，而输出运算符不需要</em></u></p>
<h4 id="输入时的错误"><a href="#输入时的错误" class="headerlink" title="输入时的错误"></a>输入时的错误</h4><ul>
<li>当<strong>流含有错误类型的数据</strong>时读取操作可能失败，那么读取操作和后续对流的使用都将失败</li>
<li>当<strong>读取操作到达文件末尾或者遇到输入流的其他错误</strong>时也会失败</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/16/FVMQjZd35KwIubG.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="标示错误"><a href="#标示错误" class="headerlink" title="标示错误"></a>标示错误</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/16/InHA5YWrR1tThzo.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><ul>
<li>通常将算术和关系运算符定义为<strong>非成员函数</strong>以<strong>允许对左侧或右侧的运算对象进行转换</strong></li>
<li>形参都是<strong>常量的引用</strong>，因为这些<strong>运算符通常不需要改变运算对象的状态</strong></li>
</ul>
<p>算术运算符通常会计算两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量内，操作完成后返回该局部变量的副本作为其结果</p>
<p>一般来说可以<strong>使用复合赋值符来定义算术运算符</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data</span><br><span class="line"><span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	Sales_data sum = lhs;</span><br><span class="line">	sum += rhs;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/16/si3NSTIUp5QCmA7.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>C++中的类通常通过定义一个相等运算符来检验两个对象是否相等：它会比较对象的每个数据成员，只有当所有对应的成员都相等时才认为两个对象相等</p>
<ul>
<li>相等运算符应该具有传递性：如果a==b和b==c都为真，那么应该有a==c为真</li>
<li>如果类定义了operator==，则这个类也应该定义operator!=</li>
<li>相等运算符和不相等运算符中的一个应该把工作委托给另一个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;</span><br><span class="line">			lhs.units_sold == units_sold &amp;&amp;</span><br><span class="line">			lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>通常情况下关系运算符应该：</p>
<ul>
<li>定义顺序关系，令其与关联容器对关键字的要求一致</li>
<li>如果类同时也含有==运算符的话，则定义一种关系令其与==保持一致；特别是，如果两个对象是!=的，那么一个对象应该&lt;另一个</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><h4 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h4><ul>
<li>倾向于把包括复合赋值在内的赋值运算都定义在类的内部</li>
<li>另一个参数通常是<strong>常量的引用</strong>，因为复合赋值运算符往往不会改变另一个参数的值，并且可以避免引起拷贝</li>
<li>为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要<strong>返回其左侧运算对象的引用</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data &amp;Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">	units_sold += rhs.units_sold;</span><br><span class="line">	revenue += rhs.revenue;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>下标运算符<strong>必须是成员函数</strong></p>
<ul>
<li><p>通常以<strong>所访问元素的引用</strong>作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端</p>
</li>
<li><p>我们最好同时定义下标运算符的常量版本和非常量版本，以便作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值</p>
<ul>
<li><p>一个返回普通引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span><br><span class="line">&#123; <span class="keyword">return</span> elements[n]; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个是类的常量成员并且返回常量引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> elements[n]; &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>由于递增递减运算符改变的是所操作对象的状态，所以建议将其设定为成员函数</p>
<h3 id="定义前置递增-递减运算符"><a href="#定义前置递增-递减运算符" class="headerlink" title="定义前置递增/递减运算符"></a>定义前置递增/递减运算符</h3><p>为了与内置版本保持一致，前置运算符<strong>应该返回递增或递减后对象的引用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="区分前置和后置运算符"><a href="#区分前置和后置运算符" class="headerlink" title="区分前置和后置运算符"></a>区分前置和后置运算符</h3><p>普通的重载版本无法区分这两种情况，它们使用的是同一个符号，意味着其重载版本所用的名字将是相同的，并且运算对象的数量和类型也相同</p>
<ul>
<li>为了解决这个问题，<strong>后置版本接受一个额外的（不被使用）int类型的形参</strong>；当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参</li>
<li>为了与内置版本保持一致，后置运算符应该<strong>返回对象的原值（递增或递减之前的值）</strong>，返回形式是<strong>一个值而非引用</strong></li>
<li>因此在递增对象之前需要<strong>首先记录对象的状态</strong></li>
<li>可以使用前置运算符来实现后置运算符（委托）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递增/递减对象的值但是返回原值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此处无须检查有效性，调用前置递增运算符时才需要检查</span></span><br><span class="line">        StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 向前移动一个元素，前置++需要检查递增的有效性</span></span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 返回之前记录的值</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">        --*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前置递增运算符首先检查递增/递减操作是否安全，根据检查的结果<strong>抛出一个异常</strong>或者<strong>执行递增/递减操作</strong></p>
<h3 id="显式调用前置-后置运算符"><a href="#显式调用前置-后置运算符" class="headerlink" title="显式调用前置/后置运算符"></a>显式调用前置/后置运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;</span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);	<span class="comment">// 调用后置版本</span></span><br><span class="line">p.<span class="keyword">operator</span>++();		<span class="comment">// 调用前置版本</span></span><br></pre></td></tr></table></figure>

<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><blockquote>
<h4 id="重载要求："><a href="#重载要求：" class="headerlink" title="重载要求："></a>重载要求：</h4><p>  1、箭头运算符必须是类的成员函数。解引用运算符一般也应该声明为类的成员函数，但不是必须。</p>
<p>  2、箭头用算符<strong>返回值必须是一个指针</strong>，或者是一个<strong>重载了箭头运算符的对象</strong>。</p>
<p>​     a）如果返回的是一个指针将调用内置的箭头运算符。执行相当于<code>(*(p.operator-&gt;()).mem;</code>的操作。</p>
<p>​     b）如果返回是一个重载了箭头运算符的对象，则继续对该对象调用其重载了的箭头运算符，直到返回的是一个指针，将对该指针调用a)的操作。操作相当于<code>(*(p.operator-&gt;().operator-&gt;())).mem;</code></p>
<p>   总的来说<strong>重载的箭头运算符就是为了改变从哪个对象中获取成员</strong></p>
<p>——来源：<a href="https://my.oschina.net/flylxl/blog/603114" target="_blank" rel="noopener">https://my.oschina.net/flylxl/blog/603114</a></p>
</blockquote>
<p>在实际中可以通过解引用运算符（*）来实现箭头运算符（-&gt;）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">    &#125;</span><br><span class="line">    str::<span class="built_in">string</span>* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>箭头运算符必须是类的成员</li>
<li>解引用运算符通常是类的成员，但并非必须如此</li>
</ul>
<h3 id="对箭头运算符返回值的限定"><a href="#对箭头运算符返回值的限定" class="headerlink" title="对箭头运算符返回值的限定"></a>对箭头运算符返回值的限定</h3><ul>
<li><p>解引用运算符可以返回任意值，但是箭头运算符不是这样：它永远不能丢掉<strong>成员访问</strong>这个最基本的含义</p>
</li>
<li><p>当我们重载箭头时，<strong>可以改变的是从哪个对象中获取成员</strong>，而箭头获取成员这一事实则永远不变</p>
</li>
<li><p>对于形如<code>point-&gt;mem</code>表达式来说，point必须是<strong>指向类对象的指针</strong>或是一个<strong>重载了operator-&gt;的类的对象</strong>；也即是说，重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*point).mem;				<span class="comment">// point是一个内置的指针类型</span></span><br><span class="line">point.<span class="keyword">operator</span>()-&gt;mem;		<span class="comment">// point是类的一个对象</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>point-&gt;mem</code>的执行过程：</p>
<ol>
<li><p>如果point是指针，则我们应用内置的箭头运算符，表达式等价于<code>(*point).mem</code>；首先解引用该指针，然后从所得的对象中获取指定的成员</p>
</li>
<li><p>如果point是定义了operator-&gt;的类的一个对象，则我们使用<code>point.operator-&gt;()</code>的结果来获取mem</p>
<ul>
<li>如果该结果是一个指针，则重复第1步</li>
<li>如果该结果本身含有重载的<code>operator-&gt;()</code>，则重复调用步骤2</li>
</ul>
<p>最终当这一过程结束时，程序或者返回了所需的内容，或者返回一些表示程序错误的消息</p>
</li>
</ol>
<p>注意：如果重载的operator-&gt;返回值是对象自身，会导致无限递归，编译器报错；但是如果返回的是对象自身的指针（例如this指针），编译器不会报错</p>
<p>（因为如果返回值是类的指针，那么编译器会进行步骤1，直接在对应的对象内部查找成员；而如果返回值是对象自身的值，那么编译器会反复调用步骤2，造成无限递归）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/16/MaeSfgPIu7NRnL8.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象；这样的类同时能够存储状态，所以比普通函数更加灵活</p>
<p><strong>函数调用运算符必须是成员函数</strong>；一个类可以定义多个不同版本的函数调用运算符，相互之间应该在参数数量或者类型上有区别</p>
<p>如果类定义了调用运算符，则该类的对象称作<strong>函数对象</strong>；函数对象通常作为泛型算法的实参</p>
<h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><p>（先跳过）</p>
<h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>（先跳过）</p>
<h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><p>C++中可调用对象的种类：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类</p>
<ul>
<li>lambda有它自己唯一的（未命名）类类型</li>
<li>函数及函数指针的类型则由其返回值类型和实参类型决定</li>
</ul>
<p>两个不同类型的可调用对象可能共享一种<strong>调用形式（call signature）</strong>：它指明了调用<strong>返回的类型</strong>以及<strong>传递给调用的实参类型</strong>；例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>是一个调用形式，接受两个int，返回一个int</p>
<h4 id="不同类型可能具有相同的调用形式"><a href="#不同类型可能具有相同的调用形式" class="headerlink" title="不同类型可能具有相同的调用形式"></a>不同类型可能具有相同的调用形式</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/17/fyW1Qhpu7Si4LvK.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>例如上面的三个函数类型具有相同的调用形式：<code>int(int, int)</code></p>
<p>但是具有相同的调用形式却不一定可以看作是相同的类型：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/17/lVL9w1cHvq3TR7W.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>（《Primer C++ 5th》中说mod不是一个函数指针，不能添加到funcTable中，但是我在Linux g++下面是可以编译运行的，emmm）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/17/4ujQnv3BXtACMEf.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="标准库function类型"><a href="#标准库function类型" class="headerlink" title="标准库function类型"></a>标准库function类型</h4><p>标准类型function定义在头文件functional中</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/17/D3qI6fjSTumyeLv.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>在调用时在尖括号中提供调用形式即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; func;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个function对象func，可接受的调用形式是<code>int(int,int)</code></p>
<p>这样的func可以接受的可调用对象包括函数指针、lambda或者函数对象等</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/17/NByJ3iCsPmFtHUv.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="重载的函数与function"><a href="#重载的函数与function" class="headerlink" title="重载的函数与function"></a>重载的函数与function</h4><p>不能直接将重载函数的名字存入function类型对象中，即使这个重载函数的调用形式不同：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/17/gYrFMBqdl9NUO5G.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>解决方法有两种：</p>
<ul>
<li>通过函数指针给重载函数的其中一个版本定义新名字</li>
<li>使用lambda包装要存储的重载版本</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/home/steve/.config/Typora/typora-user-images/1576547582277.png" alt="1576547582277" title>
                </div>
                <div class="image-caption">1576547582277</div>
            </figure>
























        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2020-01-07T07:11:41.913Z" itemprop="dateUpdated">2020-01-07 15:11:41</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2019/12/03/CPP操作符重载/" target="_blank" rel="external">http://QQ876684433.github.io/2019/12/03/CPP操作符重载/</a>
        
    </div>
    
    <footer>
        <a href="http://QQ876684433.github.io">
            <img src="/img/avatar.jpg" alt="steve_chph">
            steve_chph
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作符重载/">操作符重载</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://QQ876684433.github.io/2019/12/03/CPP操作符重载/&title=《CPP操作符重载》 — 至繁归于至简 - chph's blog&pic=http://QQ876684433.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://QQ876684433.github.io/2019/12/03/CPP操作符重载/&title=《CPP操作符重载》 — 至繁归于至简 - chph's blog&source=the blog website of steve_chph, steve_chph的个人博客网站" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://QQ876684433.github.io/2019/12/03/CPP操作符重载/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《CPP操作符重载》 — 至繁归于至简 - chph's blog&url=http://QQ876684433.github.io/2019/12/03/CPP操作符重载/&via=http://QQ876684433.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://QQ876684433.github.io/2019/12/03/CPP操作符重载/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/12/04/数据库-函数依赖和范式/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">数据库-函数依赖和范式</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/11/29/编译原理课堂笔记/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">编译原理课堂笔记</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢你~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>steve_chph &copy; 2015 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://QQ876684433.github.io/2019/12/03/CPP操作符重载/&title=《CPP操作符重载》 — 至繁归于至简 - chph's blog&pic=http://QQ876684433.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://QQ876684433.github.io/2019/12/03/CPP操作符重载/&title=《CPP操作符重载》 — 至繁归于至简 - chph's blog&source=the blog website of steve_chph, steve_chph的个人博客网站" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://QQ876684433.github.io/2019/12/03/CPP操作符重载/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《CPP操作符重载》 — 至繁归于至简 - chph's blog&url=http://QQ876684433.github.io/2019/12/03/CPP操作符重载/&via=http://QQ876684433.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://QQ876684433.github.io/2019/12/03/CPP操作符重载/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKElEQVR42u3a0Y7jIAwF0P7/T2dfR9pt5l7TrhQ4PFUVoZxUsozx6xWP68f4+c3fc/L597/1+sbAwMB4LOO6He/m3D97z0vWzPeGgYFxDuM+8CXBNAnHCTgJ0xgYGBj3jHajeRKJgYGB8VnGfXqXr5+khhgYGBj5ITZZrl1tFo4xMDBOY7TF+v/5+Sv3GxgYGI9iXOVoV0u2lYfXt7vCwMDYmpEHuKRwNrvsXH9lGBgYezOSx9oWivUyXLLCP/4HDAyMrRntMTIJu/nrSBLEXxo+MDAwDmAUoa1MAVt8+4IwMDDOZKwHwfYomz/7yykcAwNjU0b7WD4nb9Fog/XbEIyBgXEAoy2HtaW3WaGtqKdhYGAcwGgPpTNYnurd7yHKczEwMLZgtMWypHkiD5rJCkW3CAYGxtaMlZ+ZBdD1dLM+E2NgYDyckYe8WeLYFuzqwhwGBsbWjJXyVt4K1r6UutkCAwNja0ZxUBy1hX079cTAwDiBkWx6dkmQN5ytF+8wMDDOZLQXijkpTyLbpzAwMM5h5AWvfLtJQJ8dcYcxHgMD47GMvEA2K9xfwVgK3xgYGJsyrnLkadwsNA/XxMDA2JqRj5Y6TO/KC9QahoGB8VjGN4JsG3BXLkExMDDOYbSBr22SSA63s9CPgYGB0TLyOe0VaXExgIGBcTzjU00SOTWaj4GBcQBjlvCtlM9mTRsfOItjYGA8kJEfHVeautqLzLZIh4GBsSnjDzRMslCXJauGAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'chph个人博客';
            clearTimeout(titleTime);
        } else {
            document.title = 'Welcome to chph's blog';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
