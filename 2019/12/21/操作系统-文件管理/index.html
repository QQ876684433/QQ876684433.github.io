<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>操作系统-文件管理 | 至繁归于至简 - chph&#39;s blog | steve_chph personal website</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="操作系统,文件管理">
    <meta name="description" content="文件管理 参考资料：  操作系统教程（第5版） - 费翔林 骆斌 编著   文件 简单内容直接阅读第5章PPT1和2，这里略过  文件存取方法存取方法是指读写文件存储器上的物理记录的方法，常见的有：  顺序存取 无论是无结构的字节流文件，还是有结构的记录式文件，存取操作都是在上次操作的基础上进行；系统设置两个位置指针，指向要读出或写入的字节位置或记录位置，并且根据读出或写入的字节个数或记录号，系统">
<meta name="keywords" content="操作系统,文件管理">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-文件管理">
<meta property="og:url" content="http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/index.html">
<meta property="og:site_name" content="至繁归于至简 - chph&#39;s blog">
<meta property="og:description" content="文件管理 参考资料：  操作系统教程（第5版） - 费翔林 骆斌 编著   文件 简单内容直接阅读第5章PPT1和2，这里略过  文件存取方法存取方法是指读写文件存储器上的物理记录的方法，常见的有：  顺序存取 无论是无结构的字节流文件，还是有结构的记录式文件，存取操作都是在上次操作的基础上进行；系统设置两个位置指针，指向要读出或写入的字节位置或记录位置，并且根据读出或写入的字节个数或记录号，系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2019/12/22/ZwJyBzePbiRCmh1.png">
<meta property="og:image" content="https://i.loli.net/2019/12/21/6XEkFPW1wevdTgf.png">
<meta property="og:image" content="https://i.loli.net/2019/12/21/IoDBnNhpJj4gqls.png">
<meta property="og:image" content="https://i.loli.net/2019/12/21/NEgRdVjxPnputFQ.png">
<meta property="og:image" content="https://i.loli.net/2019/12/21/h7LFORyQCvXgcor.png">
<meta property="og:image" content="https://i.loli.net/2019/12/21/K4lrXEDNZqnFgP9.png">
<meta property="og:image" content="https://i.loli.net/2019/12/22/6QODen4TdhIFw8b.png">
<meta property="og:image" content="https://i.loli.net/2019/12/22/qSvgWB6NfaHJzoe.png">
<meta property="og:image" content="https://i.loli.net/2019/12/22/52UKSW8lLQxtBiz.png">
<meta property="og:image" content="https://i.loli.net/2019/12/22/8lvHEbzBA5xIRwL.png">
<meta property="og:image" content="https://i.loli.net/2019/12/22/TXoclJjB9NnHstf.png">
<meta property="og:image" content="https://i.loli.net/2019/12/22/aWEPZ8sGt4VMfxU.png">
<meta property="og:image" content="https://i.loli.net/2019/12/22/JhzL8tV6rBlET3Q.png">
<meta property="og:image" content="https://i.loli.net/2019/12/22/WwAPBOTlCEsYXrS.png">
<meta property="og:image" content="https://i.loli.net/2019/12/22/Ou71wjqHrQix8tk.png">
<meta property="og:image" content="https://i.loli.net/2019/12/22/819AOQTwPXvrftm.png">
<meta property="og:image" content="https://i.loli.net/2019/12/22/5OdNqk1m7hE4LzX.png">
<meta property="og:updated_time" content="2019-12-22T09:10:25.702Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统-文件管理">
<meta name="twitter:description" content="文件管理 参考资料：  操作系统教程（第5版） - 费翔林 骆斌 编著   文件 简单内容直接阅读第5章PPT1和2，这里略过  文件存取方法存取方法是指读写文件存储器上的物理记录的方法，常见的有：  顺序存取 无论是无结构的字节流文件，还是有结构的记录式文件，存取操作都是在上次操作的基础上进行；系统设置两个位置指针，指向要读出或写入的字节位置或记录位置，并且根据读出或写入的字节个数或记录号，系统">
<meta name="twitter:image" content="https://i.loli.net/2019/12/22/ZwJyBzePbiRCmh1.png">
    
        <link rel="alternate" type="application/atom+xml" title="至繁归于至简 - chph&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">steve_chph</h5>
          <a href="mailto:chph13420146901@gmail.com" title="chph13420146901@gmail.com" class="mail">chph13420146901@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/QQ876684433" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">操作系统-文件管理</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">操作系统-文件管理</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-12-21T10:17:13.000Z" itemprop="datePublished" class="page-time">
  2019-12-21
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/操作系统/">操作系统</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/操作系统/笔记/">笔记</a></li></ul></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#文件管理"><span class="post-toc-number">1.</span> <span class="post-toc-text">文件管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文件"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件存取方法"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">文件存取方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件的安全与保护"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">文件的安全与保护</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文件目录"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">文件目录</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件控制块、文件目录与目录文件"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">文件控制块、文件目录与目录文件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#层次目录结构"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">层次目录结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#一级目录结构"><span class="post-toc-number">1.2.2.1.</span> <span class="post-toc-text">一级目录结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#二级目录结构"><span class="post-toc-number">1.2.2.2.</span> <span class="post-toc-text">二级目录结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#树形目录结构"><span class="post-toc-number">1.2.2.3.</span> <span class="post-toc-text">树形目录结构</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件目录检索"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">文件目录检索</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文件组织与数据存储"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">文件组织与数据存储</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件逻辑结构"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">文件逻辑结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#流式文件"><span class="post-toc-number">1.3.1.1.</span> <span class="post-toc-text">流式文件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#记录式文件"><span class="post-toc-number">1.3.1.2.</span> <span class="post-toc-text">记录式文件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#成组和分解"><span class="post-toc-number">1.3.1.3.</span> <span class="post-toc-text">成组和分解</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件物理结构"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">文件物理结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#顺序文件"><span class="post-toc-number">1.3.2.1.</span> <span class="post-toc-text">顺序文件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#连接文件"><span class="post-toc-number">1.3.2.2.</span> <span class="post-toc-text">连接文件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#直接文件"><span class="post-toc-number">1.3.2.3.</span> <span class="post-toc-text">直接文件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#索引文件"><span class="post-toc-number">1.3.2.4.</span> <span class="post-toc-text">索引文件</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#文件系统功能及实现"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">文件系统功能及实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件类系统调用"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">文件类系统调用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Linux文件系统磁盘结构"><span class="post-toc-number">1.4.1.1.</span> <span class="post-toc-text">Linux文件系统磁盘结构</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#文件的创建"><span class="post-toc-number">1.4.1.2.</span> <span class="post-toc-text">文件的创建</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#文件的删除"><span class="post-toc-number">1.4.1.3.</span> <span class="post-toc-text">文件的删除</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#文件的打开"><span class="post-toc-number">1.4.1.4.</span> <span class="post-toc-text">文件的打开</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#文件的关闭"><span class="post-toc-number">1.4.1.5.</span> <span class="post-toc-text">文件的关闭</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#文件读"><span class="post-toc-number">1.4.1.6.</span> <span class="post-toc-text">文件读</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#文件写"><span class="post-toc-number">1.4.1.7.</span> <span class="post-toc-text">文件写</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#文件随机存取"><span class="post-toc-number">1.4.1.8.</span> <span class="post-toc-text">文件随机存取</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件共享"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">文件共享</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#文件静态共享"><span class="post-toc-number">1.4.2.1.</span> <span class="post-toc-text">文件静态共享</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#文件动态共享"><span class="post-toc-number">1.4.2.2.</span> <span class="post-toc-text">文件动态共享</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#文件符号链接共享"><span class="post-toc-number">1.4.2.3.</span> <span class="post-toc-text">文件符号链接共享</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件空间管理"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">文件空间管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#磁盘空闲空间管理方法"><span class="post-toc-number">1.4.3.1.</span> <span class="post-toc-text">磁盘空闲空间管理方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内存映射文件"><span class="post-toc-number">1.4.4.</span> <span class="post-toc-text">内存映射文件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#文件系统的实现层次"><span class="post-toc-number">1.4.5.</span> <span class="post-toc-text">文件系统的实现层次</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-操作系统-文件管理"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">操作系统-文件管理</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-12-21 18:17:13" datetime="2019-12-21T10:17:13.000Z"  itemprop="datePublished">2019-12-21</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/操作系统/">操作系统</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/操作系统/笔记/">笔记</a></li></ul></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><blockquote>
<p>参考资料：</p>
<ul>
<li>操作系统教程（第5版） - 费翔林 骆斌 编著</li>
</ul>
</blockquote>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><blockquote>
<p>简单内容直接阅读第5章PPT1和2，这里略过</p>
</blockquote>
<h3 id="文件存取方法"><a href="#文件存取方法" class="headerlink" title="文件存取方法"></a>文件存取方法</h3><p>存取方法是指<strong>读写文件存储器上的物理记录</strong>的方法，常见的有：</p>
<ul>
<li><p>顺序存取</p>
<p>无论是无结构的字节流文件，还是有结构的记录式文件，存取操作都是<strong>在上次操作的基础上进行</strong>；系统设置两个位置指针，指向要读出或写入的字节位置或记录位置，并且根据读出或写入的字节个数或记录号，系统自动修改相应的指针值</p>
<p>允许对固定长度记录的顺序文件采用随机访问（类似于数组访问）</p>
<p>顺序存取主要用于<strong>磁带文件</strong>，但也适用于<strong>磁盘上的顺序文件</strong></p>
</li>
<li><p>直接存取（随机存取）</p>
<p>可以<strong>非顺序地</strong>从文件中的<strong>任何位置</strong>存取文件内容</p>
<p>为了实现直接存取，一个文件可以看作由顺序编号的物理块组成，这些块划分成等长，作为定位和存取的最小单位</p>
</li>
<li><p>索引存取</p>
<p>基于索引文件的存取方法，由于文件中的记录<strong>不按位置而是按其记录名或记录键来编址</strong>，因此用户提供记录名或记录键之后，先按名搜索，再查找所需要的记录</p>
<p>在实际系统中，大都采用<strong>多级索引</strong>以加速记录的查找过程</p>
</li>
</ul>
<h3 id="文件的安全与保护"><a href="#文件的安全与保护" class="headerlink" title="文件的安全与保护"></a>文件的安全与保护</h3><p>文件是计算机系统的重要资源， 因此， 要求文件系统具有保障文件安全的手段， 提供文件保密的措施， 有效地实现文件的共享</p>
<ul>
<li><p><strong>文件共享</strong>是指不同用户共同使用某些文件</p>
</li>
<li><p><strong>文件保护</strong>是指防止文件被破坏</p>
<p>常用的文件保护办法</p>
<ol>
<li><p>文件副本：文件系统必须要有<strong>防止硬软件故障</strong>，<strong>保存信息完整性</strong>的能力</p>
<p>文件副本是主要实现机制</p>
<ul>
<li><p>动态多副本技术：在多个介质上维持同一内容的文件， 并且在更新内容时同时进行</p>
<p>这种方法需要增加设备费用和系统负载一般适用<strong>于容量较小且较为重要</strong>的文件， 例如不需更新的系统文件及专用文件， 当文件发生故障时只要切换到备用设备就可</p>
</li>
<li><p>转储、 备份与恢复：定时把文件复制转储到其它介质上， 当某介质上出现故障时， 复原转储文件</p>
<p>转储又可分成两种方式：</p>
<ul>
<li>在一定时间间隔或一个单位处理结束时， 系统自动复写更新过的文件和数据</li>
<li>每天或每周把文件信息全部复写一遍，需要时再通过装入转储文件来恢复系统，诸如BACKUP、 RESTORE等命令</li>
</ul>
</li>
</ul>
</li>
<li><p>文件存取矩阵与文件存取表</p>
<p>系统为每个用户设置访问每个文件对象的存取属性；系统的全部用户对全部文件的存取属性就组成的一个二维矩阵， 称为存取控制矩阵</p>
<p><img src="https://i.loli.net/2019/12/22/ZwJyBzePbiRCmh1.png" alt></p>
<p>由于操作系统拥有很多用户和众多文件，存取控制矩阵是一个稀疏矩阵， 可以将其简化为一张存取控制表；每行包括： 用户、 文件、 存取属性；存取控制表<strong>仅登记那些对文件拥有存取属性的部分</strong></p>
<p>系统通过查阅(矩阵/表)核对用户对文件的存取权限</p>
<p>文件属主使用GRANT、 REVOKE等命令进行授权， 甚至把授权权转授给他信任的用户</p>
<p>系统管理用户（超级用户） 等同于文件属主权限， 并获得对系统文件的授访问权权限；系统管理员/系统用户对文件的访问身份都是<strong>以文件属主的身份</strong>访问</p>
</li>
<li><p>文件属性</p>
<p>存取控制表的一种<strong>简化方法</strong>是用户分类（用户分类： 属主、 合作者、 其他），再针对每类用户规定文件属性（文件属性： 读、 写、 执行、 …）</p>
<p>文件属性可以<strong>放在文件目录项</strong>中， 管理大为简化；用户使用文件时， 通过核对文件属性，实现保护</p>
</li>
</ol>
</li>
<li><p><strong>文件保密</strong>则是指文件及其内容不能被未经文件主授权的其他用户窃取</p>
<p>文件的保密措施有以下几种：</p>
<ol>
<li>隐蔽文件目录</li>
<li>设置口令</li>
<li>使用密码</li>
</ol>
</li>
</ul>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><ul>
<li>文件目录是实现文件的<strong>按名存取</strong>的关键数据结构</li>
<li>文件系统的基本功能之一就是负责文件目录的建立、 维护和检索， 要求编排的目录便于查找、 防止冲突</li>
<li>文件目录需要永久保存， 因此也组织成文件存放在磁盘上， 称<strong>目录文件</strong></li>
</ul>
<h3 id="文件控制块、文件目录与目录文件"><a href="#文件控制块、文件目录与目录文件" class="headerlink" title="文件控制块、文件目录与目录文件"></a>文件控制块、文件目录与目录文件</h3><p>文件控制块（File Control Block, FCB）是操作系统为每个文件建立的唯一数据结构，于是一个文件由两部分组成：FCB和文件体（文件信息）；有了FCB就可以方便地实现文件的按名存取</p>
<p>为了加快文件查找速度，通常把FCB汇集和组织在一起形成文件目录，文件目录包含许多目录项，目录项有两种，分别用来<strong>描述子目录</strong>和<strong>描述文件</strong>，全部的目录项所构成的文件称为目录文件，并保存在外存上，查找文件时调入内存工作区</p>
<p>目录文件永远不会空，它至少包含两个目录项：当前目录项<code>.</code>和父目录项<code>..</code></p>
<p>文件目录的作用是将文件名转换成文件信息在磁盘上的物理位置</p>
<h3 id="层次目录结构"><a href="#层次目录结构" class="headerlink" title="层次目录结构"></a>层次目录结构</h3><h4 id="一级目录结构"><a href="#一级目录结构" class="headerlink" title="一级目录结构"></a>一级目录结构</h4><p>所有FCB排列在一张线性表中，与每个文件的相关属性占用一个目录项， 构成了一级目录结构</p>
<p>缺点：文件重名和文件共享问题难以解决</p>
<h4 id="二级目录结构"><a href="#二级目录结构" class="headerlink" title="二级目录结构"></a>二级目录结构</h4><ul>
<li>第一级为主文件目录， 它用于管理所有用户文件目录， 它的目录项登记了<strong>系统接受的用户的名字</strong>及<strong>该用户文件目录的地址</strong></li>
<li>第二级为用户的文件目录， 它为该用户的每个文件保存一个登记栏， 其内容与一级目录的目录项相同</li>
<li><strong>每一用户只允许查看自己的文件目录</strong></li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/21/6XEkFPW1wevdTgf.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>特点：</p>
<ul>
<li>采用二级目录管理文件时， 因为任何文件的存取都通过主文件目录， 于是可以<strong>检查访问文件者的存取权限</strong>， 避免一个用户未经授权就存取另一个用户的文件， 使用户文件的私有性得到保证， 实现了对文件的保密和保护</li>
<li>特别是不同用户具有同名文件时， 由于各自有不同的用户文件目录而不会导致混乱</li>
<li>对于同一个用户而言， 同样存在文件多、 容易重名问题</li>
</ul>
<h4 id="树形目录结构"><a href="#树形目录结构" class="headerlink" title="树形目录结构"></a>树形目录结构</h4><ul>
<li><p>每一级目录可以登记下一级目录， 也可以登记文件， 从而形成了层次文件目录结构</p>
</li>
<li><p>层次目录结构通常采用树形目录结构，它是一棵倒向的有根树， 树根是根目录； 从根向下， 每一个<strong>树分叉是一个子目录</strong>； 而<strong>树叶是文件</strong></p>
</li>
</ul>
<p>特点：</p>
<ul>
<li>较好地反映现实世界中<strong>具有层次关系的数据集合</strong>和较确切地反映<strong>系统内部文件的组织结构</strong></li>
<li>不同文件可以重名， 只要它们不位于同一末端的子目录中</li>
<li>易于规定<strong>不同层次或子树中文件的不同存取权限</strong>， 便于文件的保护、 保密和共享</li>
</ul>
<p>一个<strong>文件的全名</strong>包括从根目录开始到文件为止， 通路上遇到的所有子目录路径， 又称为路径名</p>
<p>如果每个文件都只有一个父目录，那么称为纯树型目录结构</p>
<p>有向无环图目录结构中一个文件可能有多个父目录，<strong>需要为每个文件维护一个引用计数</strong>，用来记录文件的父目录个数，当且仅当引用计数值为1时，删除操作才移去文件，否则仅仅把相关记录从父目录中删除，引用计数减1</p>
<h3 id="文件目录检索"><a href="#文件目录检索" class="headerlink" title="文件目录检索"></a>文件目录检索</h3><p>每个目录在创建时都自动含有两个特殊目录项：</p>
<ul>
<li><code>.</code>项指出目录自身的inode入口</li>
<li><code>..</code>项指出其父目录的inode入口</li>
</ul>
<p>当<code>.</code>和<code>..</code>都指向同一个inode时，说明当前目录是根目录</p>
<h2 id="文件组织与数据存储"><a href="#文件组织与数据存储" class="headerlink" title="文件组织与数据存储"></a>文件组织与数据存储</h2><h3 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h3><ul>
<li><p>逻辑文件， 又称为文件的逻辑结构</p>
<ul>
<li><p>独立于物理环境的， 用户概念中的抽象信息组织方式</p>
</li>
<li><p>用户能观察到的， 并加以处理的数据集合</p>
</li>
</ul>
</li>
<li><p>文件的逻辑结构分为两种形式</p>
<ul>
<li>一种是流式文件</li>
<li>一种是记录式文件</li>
</ul>
</li>
</ul>
<h4 id="流式文件"><a href="#流式文件" class="headerlink" title="流式文件"></a>流式文件</h4><p>文件内的数据不再组成记录， 只是由一串依次的字节组成的信息流序列，称为字节流文件；这种文件常常<strong>按长度来读取所需信息</strong>，也可以用插入的特殊字符作为分界</p>
<h4 id="记录式文件"><a href="#记录式文件" class="headerlink" title="记录式文件"></a>记录式文件</h4><p>一种有结构的文件， 它是<strong>若干逻辑记录信息所组成的记录流文件</strong>，<strong>逻辑记录</strong>是文件中按信息在逻辑上的独立含义所划分的信息单位</p>
<p>逻辑纪录是文件内独立的最小信息单位，每次总是为使用者存储、检索或更新一条逻辑记录，通过文件的记录位置来对文件信息进行访问</p>
<p>记录式问有两种常见的记录组织和使用方法：</p>
<ul>
<li><p>记录式顺序文件</p>
<p>文件的记录顺序生成并被顺序访问</p>
</li>
<li><p>记录式索引顺序文件</p>
<p>使用索引表，表项包含<strong>记录键和索引指针</strong>；记录键由应用程序确定，<strong>索引指针便指向相应的记录</strong>；它可对特定记录进行存取，也保持顺序访问记录的功能</p>
</li>
</ul>
<h4 id="成组和分解"><a href="#成组和分解" class="headerlink" title="成组和分解"></a>成组和分解</h4><ul>
<li>逻辑记录是按信息在逻辑上的独立含义由用户划分的单位</li>
<li>块是系统划分的存储介质上连续信息所组成的区域</li>
</ul>
<p>一条逻辑记录被存放到文件存储器的存储介质上时，可能占用一块或多块，或者一个物理块包含多条逻辑记录</p>
<p>记录成组</p>
<ul>
<li>若干个逻辑记录合并成一组， 写入一个块叫记录的成组；每块中的逻辑记录数称<strong>块因子</strong></li>
<li>成组操作先在系统输出缓冲区上进行，凑满一块后才将缓冲区的信息写到存储介质上</li>
</ul>
<p>记录分解</p>
<ul>
<li>当存储介质上的<strong>一个物理记录</strong>读进输入缓冲区后， <strong>把逻辑记录从块中分离出来</strong>的操作叫记录的分解操作</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/21/IoDBnNhpJj4gqls.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>优点：</p>
<ul>
<li><p>节省存储空间</p>
<p>不会由于逻辑记录比物理记录小而导致物理空间的浪费</p>
</li>
<li><p>减少输入输出操作次数， 提高系统效率</p>
<p>一次读取一个物理记录，然后将物理记录中的逻辑记录分解出来传输给用户空间，而不需要每次读取一条逻辑记录就发起一次I/O操作；</p>
<p>当一个写请求所传送的逻辑记录刚好填满系统缓冲区时，文件管理才发出一次I/O请求，将填满的系统缓冲区内容写到存储介质相应的块中</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要软件进行<strong>成组和分解的额外操作</strong></li>
<li>需要能<strong>容纳最大块长的系统I/O缓冲区</strong></li>
</ul>
<p>记录成组与分解处理带来的新特征：</p>
<ul>
<li>用户读请求， 导致包含该逻辑记录的物理块读入输入缓冲区； 这一操作可能读入了多个逻辑记录， 这一现象称为<strong>提前读</strong></li>
<li>用户写请求， 首先是写入输出缓冲区， 只有当该缓冲区中的逻辑记录满后才会引起实际输出， 这一现象称为<strong>推迟写</strong></li>
</ul>
<h3 id="文件物理结构"><a href="#文件物理结构" class="headerlink" title="文件物理结构"></a>文件物理结构</h3><ul>
<li><strong>文件的物理结构</strong>和组织是指文件在<strong>物理存储空间</strong>中的存放方法和组织关系（这时的文件看作物理文件，即相关物理块的集合）</li>
<li>文件的存储结构涉及块的划分、 记录的排列、 索引的组织、 信息的搜索等许多问题，其优劣直接影响文件系统的性能</li>
</ul>
<p>有两种构造文件物理结构的方法：</p>
<ul>
<li><p>计算法：对记录键进行计算转换成对应的物理地址，从而找到所需的记录；包括直接寻址文件、计算寻址文件、顺序文件等</p>
<p>存取效率高，不必增加存储空间存放附加控制信息，能够把分布范围较广的键均匀地映射到一个存储区域</p>
</li>
<li><p>指针法：设置专门的指针，指明<strong>相应记录的物理地址</strong>或<strong>表达各记录之间的关联</strong>；索引文件、顺序索引文件、连接文件等均属此类</p>
<p>优点：可将文件信息的逻辑次序与在存储介质上的物理排列依次完全分开，便于随机存取，便于更新，加快存取速度</p>
<p>缺点：指针要占用较多存储空间，大型文件的索引查找要耗费较多处理器时间</p>
</li>
</ul>
<h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p>将一个文件中<strong>逻辑上连续的信息</strong>存放到<strong>存储介质的依次相邻的块中</strong>便形成顺序结构， 这类文件叫顺序文件， 又称连续文件；FCB中只需要保存<strong>文件的第一个物理块地址</strong>和<strong>文件信息块的总块数</strong></p>
<p>优点： 顺序存取记录时速度较快</p>
<ul>
<li>批处理文件， 系统文件用得最多</li>
<li>采用磁带存放顺序文件时， 总可以保持快速存取的优点</li>
</ul>
<p>缺点：</p>
<ul>
<li>建立文件前需要能<strong>预先确定文件长度</strong>，以便分配存储空间</li>
<li><strong>修改、 插入和增加文件记录有困难</strong></li>
<li>对变长记录的处理很困难</li>
<li>对磁盘作连续分配会造成空闲块的浪费</li>
</ul>
<h4 id="连接文件"><a href="#连接文件" class="headerlink" title="连接文件"></a>连接文件</h4><p>使用<strong>连接字（又称为指针）</strong>来表示文件中各个物理块之间的先后次序，称为连接文件或者串联文件，输入井、输出井都是用此类文件</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/21/NEgRdVjxPnputFQ.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>文件信息存放在磁盘的若干物理块中，<strong>第一块文件信息的物理地址由FCB给出</strong>，而每块的连接字指出文件的下一个物理块的位置；连接字内容为0时， 表示文件至本块结束</p>
<p>优点：</p>
<ul>
<li>易于对文件记录做增、 删、 改， 易于动态增长记录</li>
<li>不必预先确知文件长度</li>
<li>存储空间利用率高</li>
</ul>
<p>缺点：</p>
<ul>
<li>必须将连接字与数据信息混合存放，破坏数据块的完整性</li>
<li>存放指针需额外的存储空间</li>
<li>由于存取须通过缓冲区， 待获得连接字后， 才能找到下一物理块的地址，因而<strong>仅适用于顺序存取</strong></li>
</ul>
<h4 id="直接文件"><a href="#直接文件" class="headerlink" title="直接文件"></a>直接文件</h4><p>在直接存取存储设备上，利用哈希法<strong>将记录的关键字与其地址之间建立某种对应关系</strong>，以便实现快速存取的文件叫做直接文件（散列文件或哈希文件）</p>
<p>计算寻址结构可能出现‘冲突’ ， 即不同的关键字可能变换出相同的地址来， 解决办法有拉链法、 循环探查法、二次散列法、 溢出区法等</p>
<h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p>系统为每个文件建立索引表（index table），可以有不同的索引形式：</p>
<ul>
<li><p>记录组成文件的磁盘块号，这种索引表只是磁盘块号的序列，适用于流式文件</p>
<p><img src="https://i.loli.net/2019/12/21/h7LFORyQCvXgcor.png" alt></p>
</li>
<li><p>其索引表项包含记录键及其磁盘块号，适用于记录式文件</p>
<p><img src="https://i.loli.net/2019/12/21/K4lrXEDNZqnFgP9.png" alt></p>
</li>
</ul>
<p>利用索引表来搜索记录的文件称为索引文件，<strong>索引表可以存放在FCB中</strong>，查阅索引表先找到相应记录键(或逻辑记录号)， 然后获得数据存储地址，大文件的索引表会很大；有些文件系统将索引表置于<strong>单独的物理块</strong>中，且可以驻留在磁盘上，<strong>FCB仅包含索引表的地址</strong></p>
<p>索引文件访问方式</p>
<ul>
<li>索引文件在文件存储器上分两个区：<strong>索引区</strong>和<strong>数据区</strong></li>
<li>访问索引文件需两步操作： 第一步查找索引表， 第二步获得记录物理地址</li>
<li>需要两次访问辅助存储器， 若文件索引已预先调入主存储器， 那么就可减少一次内外存信息交换</li>
</ul>
<p>优点：</p>
<ul>
<li>具有连接文件的优点</li>
<li>记录可以散列存储</li>
<li>具有直接读写任意记录的能力</li>
<li>便于信息的增、删、改</li>
</ul>
<p>缺点：</p>
<ul>
<li>（大文件）索引表的空间开销和查找时间的开销大</li>
</ul>
<p>索引的组织：</p>
<ul>
<li>一级索引</li>
<li>两级索引</li>
<li>多级索引<ul>
<li>缺点：多次间接索引会降低查找速度</li>
</ul>
</li>
</ul>
<p>考虑到不同文件大小不一，而且差别很大的情况，一般来说都是混合使用直接索引、一级间接索引、二级间接索引和多级间接索引（不对称多级索引），这样既能够降低索引表的空间开销，同时提供了小文件的快速存取（如果都采用三级索引，对于小文件来说磁盘的I/O开销大，因此要多次索引才能找到物理记录的地址）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/22/6QODen4TdhIFw8b.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>Unix最初的设计中, 直接地址存10个， 现代Linux系统改为15个；如图中所示，一般来说一个物理块512B，而每个盘块号占4B，因此一个盘快可以存放128个物理盘块号（Linux中不提供记录式文件，都是流式文件，因此索引中只需存储物理盘块号而不需要存储记录键）</p>
<p>例题：</p>
<p>在UNIX系统中， 每个i节点中分别含有10个直接地址的索引和一、 二、 三级间接索引。 若每个盘块放128个盘块地址， 则一个1MB的文件分别占用多少各级索引所使用的数据物理块？ 20MB的文件呢？ 设每个盘块有512B</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/22/qSvgWB6NfaHJzoe.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="文件系统功能及实现"><a href="#文件系统功能及实现" class="headerlink" title="文件系统功能及实现"></a>文件系统功能及实现</h2><p>文件系统通常采用分层结构实现：</p>
<ul>
<li><p>文件管理</p>
<p>实现文件的逻辑结构，为用户提供各种文件系统调用及文件访问权限的设置等</p>
</li>
<li><p>目录管理</p>
<p>负责查找文件描述符，进而找到需要访问的文件，并进行访问权限检查等工作，此外还需完成目录的添加、删除、重排等操作</p>
</li>
<li><p>磁盘管理</p>
<p>管理文件空间，将文件的逻辑地址转成磁盘的物理地址（即由逻辑块号找到柱面号、磁头号和扇区号）</p>
</li>
</ul>
<p>文件系统的信息空间可认为是由一系列的逻辑块所组成的，每个逻辑块长度通常为512B（一个扇区的大小）的整数倍</p>
<h3 id="文件类系统调用"><a href="#文件类系统调用" class="headerlink" title="文件类系统调用"></a>文件类系统调用</h3><p>文件系统提供给用户程序的一组系统调用， 包括： 创建、 删除、 打开、 关闭、 读、 写和控制， 通过这些系统调用用户能获得文件系统的各种服务</p>
<p>在为应用程序服务时， <strong>文件系统需要沿路径查找目录以获得该文件的各种信息（FCB）</strong>， 这往往<strong>要多次访问文件存储器， 使访问速度减慢</strong>， 若把所有文件目录都复制到主存， 访问速度可加快， 但却又增加主存开销</p>
<p>解决方案：把<strong>常用</strong>和<strong>正在使用的</strong>那些文件目录复制进主存</p>
<p>好处：既不增加太多主存开销， 又可明显减少查找时间</p>
<p>过程：</p>
<ul>
<li>系统为<strong>每个用户进程</strong>建立一张<strong>活动文件表</strong>， 用户使用文件之前先通过“ 打开” 操作， 把该文件的文件目录复制到指定主存区域</li>
<li>当不再使用该文件时， 使用“ 关闭” 操作切断和该文件目录的联系， 这样， 文件被打开后， 可被用户多次使用， 直至文件被关闭或撤销， 大大减少访盘次数， 提高文件系统的效率。</li>
</ul>
<h4 id="Linux文件系统磁盘结构"><a href="#Linux文件系统磁盘结构" class="headerlink" title="Linux文件系统磁盘结构"></a>Linux文件系统磁盘结构</h4><p>内核将磁盘作为主要的文件存储器，磁盘按扇区编号，扇区序列分成三个部分：</p>
<ul>
<li><p>超级块： 占用1#号块，存放文件系统结构和管理信息，如记录：</p>
<ul>
<li>inode表所占盘块数、</li>
<li>文件数据所占盘块数、</li>
<li>主存中登记的空闲盘块数、</li>
<li>主存中登记的空闲块物理块号、</li>
<li>主存中登记的空闲inode数、</li>
<li>主存中登记的空闲inode编号，</li>
<li>及其他文件管理控制信息，</li>
</ul>
<p>可见超级块既有<strong>盘位示图的功能</strong>， 又<strong>记录整个文件卷的控制数据</strong>。<br>每当一个块设备作为文件卷被安装时， 该设备的<strong>超级块就要复制到主存系统区中备用</strong>， 而拆卸文件卷时， <strong>修改过的超级块需复制回磁盘的超级块中</strong></p>
</li>
<li><p>索引节点区：2#～k+1#块</p>
<p>存放inode表， 每个文件都有各种属性， 它们被记录在称为<strong>索引节点inode的结构</strong>中； 所有inode都有相同大小， 且inode表是inode结构的列表， 文件系统中的<strong>每个文件在该表中都有一个inode</strong>。 又分：</p>
<ul>
<li><strong>磁盘inode表</strong></li>
<li><strong>主存活动inode表</strong></li>
</ul>
<p>后者解决频繁访问磁盘inode表的效率问题</p>
</li>
<li><p>数据区： k+2#～n#为数据块</p>
<p>文件的内容保存在这个区域， 磁盘上所有物理块的大小是一样的， 如果文件包含超过一块的数据， 则文件内容会存放在多个盘块中</p>
</li>
</ul>
<p>重要数据结构：</p>
<ul>
<li><p>用户打开文件表：<br>进程的<strong>PCB结构中保留一个files_struct</strong>， 称为用户打开文件表或文件描述符表， <strong>表项的序号为文件描述符fd</strong>， 该登记项内登记系统打开文件表的一个入口指针fp， 通过此系统打开文件表项连接到打开文件的活动inode</p>
</li>
<li><p>系统打开文件表：</p>
<p>是为解决<strong>多用户进程共享文件、 父子进程共享文件</strong>而设置的系统数据结构file_struct， 主存专门开辟最多可登记<strong>256项</strong>的系统打开文件表区， 当打开一个文件时， 通过此表项<strong>把用户打开文件表的表项与文件活动inode联接起来</strong>， 以实现数据的访问和信息的共享</p>
</li>
<li><p>主存活动inode表：<br>为解决频繁访问磁盘索引节点inode表的效率问题， 系统开辟的主存区， <strong>正在使用的文件的inode被调入主存活动索引节点inode中</strong>， 以加快文件访问速度</p>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/22/52UKSW8lLQxtBiz.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/22/8lvHEbzBA5xIRwL.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="文件的创建"><a href="#文件的创建" class="headerlink" title="文件的创建"></a>文件的创建</h4><p>系统调用C语言格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd, mode;</span><br><span class="line"><span class="keyword">char</span> *filenamep;</span><br><span class="line">fd = create (filenamep, mode);</span><br></pre></td></tr></table></figure>

<ul>
<li>为新文件分配<strong>索引节点（磁盘inode）和活动索引节点（活动inode）</strong>， 并把索引节点编号（inode号）与文件分量名（即不包含路径的文件名）组成新目录项， 记到目录中</li>
<li>在新文件所对应的活动索引节点（活动inode）中置初值， 如置存取权限i_mode， 连接计数i_nlink等</li>
<li>分配<strong>用户打开文件表项</strong>和<strong>系统打开文件表项</strong>， 置表项初值，读写位移f_offset清“0”</li>
<li>把用户打开文件表项、系统打开文件表项以及文件对应的活动inode用指针连接起来， 把文件描述字fd返回给调用者</li>
</ul>
<h4 id="文件的删除"><a href="#文件的删除" class="headerlink" title="文件的删除"></a>文件的删除</h4><ul>
<li><p>删除把指定文件从所在的目录文件中除去。</p>
</li>
<li><p>如果没有连接用户(i_nlink 为“1”)， 还要把文件占用的存储空间释放。 删除系统调用形式为： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink (filenamep);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在执行删除时， 必须要求用户对该文件具有“写”操作权</p>
</li>
</ul>
<h4 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h4><p>调用方式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd, mode;</span><br><span class="line"><span class="keyword">char</span> * filenamep;</span><br><span class="line">fd = open (filenamep, mode);</span><br></pre></td></tr></table></figure>

<p>文件在使用之前必须先打开，以建立进程与文件之间的联系，而<strong>文件描述符唯一地标识这种连接</strong>，其任务是<strong>把文件的磁盘inode复制到内存活动inode表中</strong>，同时建立一个独立的读写文件的数据结构，即系统打开文件表的一个表项</p>
<p>执行过程：</p>
<ul>
<li>检索目录，要求打开的文件应该是已经创建的文件，它应该登记在文件目录中，否则出错；检索到文件后，把它的外存索引节点（磁盘inode）复制到活动索引节点inode表中</li>
<li>根据参数mode与活动inode中在创建文件时所记录的文件访问权限进行比较， 如果非法， 则这次打开失败</li>
<li>当“打开” 合法时， 为文件分配<strong>用户打开文件表项</strong>和<strong>系统打开文件表项</strong>， 并为后者设置初值。 通过指针建立这些表项与活动索引节点inode之间的联系， 把文件描述字fd， 即用户打开文件表中相应文件表项的序号返回给调用者</li>
</ul>
<p>可见，不论是打开成功还是失败（例如权限不符合），对应的磁盘inode都会被复制到活动inode表中</p>
<p>另外要注意：如果在执行文件打开过程之前，其他用户已经打开同一文件，则活动inode表中已经有此文件的inode，于是不需要再进行inode复制工作，而仅仅把活动inode的计数器i_count加1即可；i_count表示<strong>通过不同系统打开文件表项来共享同一活动inode</strong>的进程数目，它是以后执行文件关闭操作时活动inode能够被释放的依据</p>
<h4 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h4><p>文件使用完毕，执行关闭系统调用来切断应用程序与文件的联系，调用方式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">close (fd);</span><br></pre></td></tr></table></figure>

<p>显然要关闭的文件先前已打开，故文件描述符fd一定存在，执行过程如下：</p>
<ul>
<li>根据fd找到用户打开文件表项， 再找到系统打开文件表项；释放用户打开文件表项</li>
<li>把对应系统打开文件表项中的f_count减“1”， 如果非“0”， 说明还有<strong>进程共享这一表项</strong>， 不用释放直接返回；否则释放表项，并找到与之连接的活动inode</li>
<li>把活动inode中的i_count减“1”， 若不为“0”， 表明还有<strong>用户进程正在使用该文件</strong>， 不用释放而直接返回，否则把该活动inode中的内容复制回文件卷上的相应磁盘inode中， 释放该活动inode</li>
</ul>
<p>f_count（系统打开文件表中）和i_count（活动inode表中）分别反映进程动态地共享一个文件的两种方式：</p>
<ul>
<li>f_count反映不同进程通过同一个系统打开文件表项共享一个文件的情况</li>
<li>i_count反映不同进程通过不同系统打开文件表项共享一个文件的情况</li>
</ul>
<p>通过两种方式， 进程之间既可用<strong>相同的位移指针f_offset</strong>，也可用<strong>不同位移指针f_offset</strong>共享同一个文件</p>
<h4 id="文件读"><a href="#文件读" class="headerlink" title="文件读"></a>文件读</h4><p>文件读指文件的内容读入用户数据区，由系统打开文件表项的f_offset决定从哪个逻辑位置读入数据</p>
<p>调用的形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nr, fd, count;</span><br><span class="line"><span class="keyword">char</span> buf [ ]</span><br><span class="line">nr = read (fd, buf, count);</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/22/TXoclJjB9NnHstf.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>说明：i_addr[…]对应于Linux中的i_data[…]？</p>
<p>文件读执行过程：</p>
<ul>
<li>系统根据f_flag中的信息， 检查读操作合法性，</li>
<li>如果合法，再根据活动inode中i_addr指出的文件物理块存放地址，从文件当前位移量f_offset值读取所要求的字节数count到块设备缓冲区中， 然后再送到bufp指向的用户数据区中</li>
</ul>
<h4 id="文件写"><a href="#文件写" class="headerlink" title="文件写"></a>文件写</h4><p>文件写指把用户数据区中的信息写入文件，由系统打开文件表项的f_offset决定把数据写入文件的哪个逻辑位置调用的形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nw = write (fd, buf, count);</span><br></pre></td></tr></table></figure>

<p>buf是信息传送的源地址， 即把buf所指向的用户数据区中的信息， 写入到文件中</p>
<h4 id="文件随机存取"><a href="#文件随机存取" class="headerlink" title="文件随机存取"></a>文件随机存取</h4><p>在文件初次“打开” 时， 文件的位移量f_offset清空为0，以后的文件读写操作总是<strong>根据offset的当前值， 顺序地读写文件</strong>。 为了支持文件的随机访问， 提供系统调用lseek， 它允许用户在读、 写文件前， 事先改变f_offset的指向</p>
<p>系统调用的形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lseek;</span><br><span class="line"><span class="keyword">long</span> offset;</span><br><span class="line"><span class="keyword">int</span> whence, fd;</span><br><span class="line">lseek (fd, offset, whence);</span><br></pre></td></tr></table></figure>

<p>文件描述字fd必须指向一个用读或写方式打开的文件</p>
<ul>
<li>当whence是“0”时， 则f_offset被置为offset</li>
<li>当whence是“1”时， 则f_offset被置为文件当前位置加上offset</li>
</ul>
<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>文件共享是指不同进程共同使用同一个文件，文件共享不仅为不同进程完成共同任务所必需，而且还节省大量外存空间，减少因文件复制而增加的I/O操作次数</p>
<h4 id="文件静态共享"><a href="#文件静态共享" class="headerlink" title="文件静态共享"></a>文件静态共享</h4><p>静态共享是通过文件所对应的inode节点来实现链接的，并且只允许链接到文件而非目录；文件链接系统调用形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chat * oldnamep, * newnamep;</span><br><span class="line">link (oldnamep, newnamep);</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<ul>
<li>检索目录找到oldnamep所指向文件的索引节点inode编号</li>
<li>再次检索目录找到newnamep所指文件的父目录文件，并<strong>把已存在文件的索引节点inode编号与别名构成一个目录项</strong>， 记入到该目录中去</li>
<li>把已存在文件索引节点inode的连接计数i_nlink加“1”</li>
</ul>
<p>所谓链接，实际上是共享已存在文件的inode；无论进程是否允许，这种链接关系都是存在的</p>
<p>文件解除链接调用形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink (namep);</span><br></pre></td></tr></table></figure>

<p>解除链接与文件删除执行的是同一系统调用代码。 删除文件是从文件主角度讲的， 解除文件连接是从共享文件的其他用户角度讲的，都要删去目录项，把i_nlink减“1”， 不过， 只有当i_nlink减为“0”时才释放文件的物理存储空间，从而真正删除文件</p>
<h4 id="文件动态共享"><a href="#文件动态共享" class="headerlink" title="文件动态共享"></a>文件动态共享</h4><p>指系统中不同的应用进程或同一用户的不同进程并发地访问同一文件，这种共享关系只有当进程存在时才可能出现，一旦进程消亡，其共享关系也就随之消失</p>
<p>问题：应让多个进程共用同一个读/写位移， 还是各个进程具有各自的读写位移呢？</p>
<ul>
<li><p>若是<strong>先执行fork()，再用“打开”来打开同一个文件名的文件</strong>，则系统分别为两个进程分配不同的系统打开文件表项并指向同一活动inode，于是两进程独立地使用各自的读写位移量指针</p>
<p>多用户共享文件， 每个希望独立地读、 写文件， 这时不能只设置一个读写位移指针， 须为每个用户进程分别设置一个读、写位移指针<br>位移指针应放在每个进程用户打开文件表的表目中。 这样，当一个进程读、 写文件， 并修改位移指针时， 另一个进程的位移指针不会随之改变， 从而使两个进程能独立地访问同一文件</p>
<p><img src="https://i.loli.net/2019/12/22/aWEPZ8sGt4VMfxU.png" alt></p>
</li>
<li><p>如果<strong>进程在打开一个文件之后，再用fork()系统调用创建子进程</strong>，由于子进程的用户打开文件表项是从父进程那里复制得到的，它自然会指向父进程所使用的系统打开文件表项，因此父子进程就公用同一个位移量指针来共享文件</p>
<p>同一用户父、 子进程协同完成任务， 使用同一读/写位移，同步地对文件进行操作<br>该位移指针宜放在相应文件的活动索引节点中。 当用系统调用fork建立子进程时， 父进程的PCB结构被复制到子进程的PCB结构中， 使两个进程的打开文件表指向同一活动的索引节点， 达到共享同一位移指针的目的</p>
<p><img src="https://i.loli.net/2019/12/22/JhzL8tV6rBlET3Q.png" alt></p>
</li>
</ul>
<p>系统打开表项的申请和释放过程：</p>
<ul>
<li>当进程要求打开文件时，首先系统为它申请一个系统打开文件表项，并建立此表项与相应文件活动inode之间的联系；然后把用户打开文件表项中的一个空闲项指向它</li>
<li>如果此后进程通过fork()创建一个子进程，系统自动把用户打开文件表项所指的系统打开文件表项中的f_count值加1（因为先打开文件后，再fork出的子进程和父进程共享相同的系统打开文件表项）</li>
<li>反之，当进程关闭一个文件时，系统不能简单地释放系统打开的文件表项，必须首先判断f_count的值是否大于1，如果其值大于1，说明还有进程共享相应的系统打开文件表项，此时只需把f_count值减1即可</li>
</ul>
<h4 id="文件符号链接共享"><a href="#文件符号链接共享" class="headerlink" title="文件符号链接共享"></a>文件符号链接共享</h4><p>操作系统可支持多个物理磁盘或多个逻辑磁盘(分区)， 那么，文件系统是建立一棵目录树还是多棵目录树呢?</p>
<ul>
<li><p>Windows采用将盘符或卷标分配给磁盘或分区， 并将其名字作为文件路径名的一部分</p>
</li>
<li><p>UNIX/Linux的每个分区有自己的文件目录树， 当有多个文件系统时， 可通过安装的办法整合成一棵更大的文件目录树</p>
</li>
</ul>
<p>问题： 系统中每个文件对应一个inode， 编号是惟一的，但两个不同的磁盘或分区都含有相同inode号对应的文件， 也就是说， 整合的目录树中， inode号并不惟一地标识一个文件？<br>办法： <strong>拒绝创建跨越文件系统的硬链接</strong></p>
<ul>
<li><p>硬链接指的是将文件名和自身的inode链接起来；</p>
<p>缺点：只能用于单个文件系统，不能跨越文件系统，可用于文件共享却不能用于目录共享</p>
<p>优点：实现简单，访问速度快</p>
</li>
<li><p>软链接：符号链接，只有文件名、不指向inode的链接，通过名称来引用文件；</p>
<p>符号链接共享文件的实现思想：<br>用户A目录中形式为afile→bfile， 实现A的目录与B的文件的链接。 其中只包含被链接文件bfile的路径名而不是它的inode号， 而<strong>文件的拥有者才具有指向inode的指针</strong>；当用户A要访问被符号链接的用户B的文件bfile， 且要读“符号链接” 类文件时， <strong>被操作系统截获， 它将依据符号链接中的路径名去读文件</strong>， 于是就能实现用户A使用文件名afile对用户B的文件bfile的共享</p>
<p>优点：能用于链接计算机系统中不同文件系统中的文件，可链接计算机网络中不同机器上的文件， 此时， 仅需提供文件所在机器地址和该机器中文件的路径名</p>
<p>缺点：搜索文件路径开销大， 需要额外的空间查找存储路径</p>
</li>
</ul>
<h3 id="文件空间管理"><a href="#文件空间管理" class="headerlink" title="文件空间管理"></a>文件空间管理</h3><p>磁盘文件空间分配采用两种办法</p>
<ul>
<li>连续分配： 文件存放在辅存空间连续存储区中， 在建立文件时， 用户必须给出文件大小， 然后， 查找到能满足的连续存储区供使用</li>
<li>非连续分配： 一种方法是<strong>以块(扇区)为单位</strong>， 扇区不一定要连续， <strong>同一文件的扇区按文件记录的逻辑次序用链指针连接或位示图指示</strong></li>
</ul>
<p>另一种方法是以簇为单位， 簇是由若干个连续扇区组成的分配单位； 实质上是连续分配和非连续分配的结合。 各个簇可以用链指针、 索引表， 位示图来管理</p>
<h4 id="磁盘空闲空间管理方法"><a href="#磁盘空闲空间管理方法" class="headerlink" title="磁盘空闲空间管理方法"></a>磁盘空闲空间管理方法</h4><ul>
<li><p>位示图</p>
<ul>
<li>磁盘空间通常使用固定大小的块， 可方便地用位示图管理， 用若干字节构成一张位示图， 其中每一字位对应一个物理块， 字位的次序与块的相对次序一致， 字位为‘ 1’表示相应块已占用，字位为‘ 0’表示该块空闲</li>
<li>微型机操作系统VM/SP、 Windows和Macintosh等操作系统均使用这种技术管理文件存储空间</li>
<li>主要优点是： <strong>每个盘块仅需1个附加位</strong>， 如盘块长1KB， 位示图开销仅占0.012%； <strong>可把位示图全部或大部分保存在主存</strong>， 再配合现代机器都具有的位操作指令， 实现高速物理块分配和去配</li>
</ul>
</li>
<li><p>空闲区表</p>
<ul>
<li>该方法常用于连续文件， 将<strong>空闲存储块的位置</strong>及<strong>其连续空闲的块数</strong>构成一张表</li>
<li>分配时， 系统依次扫描空闲区表， 寻找合适的空闲块并修改登记项</li>
<li>删除文件释放空闲区时， 把空闲区位置及连续的空闲区长度填入空闲区表， <strong>出现邻接的空闲区时， 还需执行合并操作并修改登记项</strong></li>
<li>空闲区表的搜索算法有首次适应、 邻近适应、 最佳适应和最坏适应算法等， 参见pp.239</li>
</ul>
</li>
<li><p>空闲块链</p>
<ul>
<li><p>把所有空闲块连接在一起， 系统保持指针指向第一个空闲块，每一空闲块中包含指向下一空闲块的指针</p>
</li>
<li><p>申请一块时， 从链头取一块并修改系统指针</p>
</li>
<li><p>删除时释放占用块， 使其成为空闲块并将它挂到空闲链上</p>
</li>
</ul>
<p>缺点：这种方法效率低， 每申请一块都要读出空闲块并取得指针， 申请多块时要多次读盘</p>
<p>优点：便于文件动态增长和收缩</p>
</li>
<li><p>空闲块列表</p>
<p>把所有空闲块物理地址放到一个空闲块列表文件中；由于空闲块列表较大，不可能全部放在内存中，因此可以小部分保存在内存中：</p>
<ul>
<li><p>列表用一个下推栈实现：栈中靠前数千个元素保存在内存专用区中；当分配一个新空闲块时，从栈顶弹出；当一个物理块被解除分配时，它被压入内存专用区的栈尾中</p>
<p>只有当下推栈中在内存的部分满或空时，才需要在内存和磁盘之间进行传送；因此该技术在大多数情况下都提供了零时间的访问</p>
</li>
<li><p>列表用一个FIFO队列实现：队列头和队列尾的几千项放在内存专用区中；分配空闲块时从队列头取出首项，取消分配时可以把它添加在内存专用区队列尾</p>
<p>只有当队列头部空或内存中的队列尾部满时，才需要在磁盘和内存直接进行传送</p>
</li>
</ul>
<p>在上面两种策略中，一个后台线程可以对内存中的列表慢慢地进行排序，从而使连续分配变得快速和容易</p>
</li>
<li><p>空闲块成组链接</p>
<p><img src="https://i.loli.net/2019/12/22/WwAPBOTlCEsYXrS.png" alt></p>
<p>存储空间分成512字节一块。 假定文件卷启用时共有可用文件338块， 编号从12至349。每100块划分一组， <strong>每组第一块（如图中的50、68和188）登记下一组空闲块的盘物理块号和空闲总数</strong>；在最后一组中，第1项是0，作为结束标志，表明系统空闲盘块链已经结束</p>
<p>操作系统启动时，将磁盘专用块复制到内存系统工作区中，访问内存专用块就可以完成申请或释放空闲盘块的操作</p>
<ul>
<li>分配空闲盘块时：先把专用块中的空闲块计数减1，以它为指针找到专用块的相应表项，其内容就是要分配的空闲磁盘块号；<strong>当空闲块计数减1后等于0时，专用块仅剩1个磁盘块号</strong>，此时要取出表项中的磁盘块号（设为i），再把此盘块中所保存的<strong>下一组空闲磁盘块链接</strong>信息经缓冲区复制到内存专用块中，然后把当前磁盘块i分配出去</li>
<li>释放存储块时，将磁盘块号记录在由专用块所指示的表项中，然后空闲块计数加1；若发现此表已满（达100项），则应把整个表的内容经缓冲区复制到下面要释放的磁盘块中，然后将释放块的块号写入专用块的第一个位置，置空闲块计数为1；搜索到磁盘块的第一项是0时，系统要发出警告，表明空闲块已经用完</li>
</ul>
</li>
</ul>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>解决文件读写效率低下的基本思路：把磁盘访问转变为内存访问，实现这种转变的手段是<strong>内存映射文件（Memory Mapped File，MMF）</strong></p>
<p>基本原理：把进程需要访问的文件映射到其虚地址空间中，于是便可通过读写这段虚地址进行文件访问，而磁盘访问变成内存访问</p>
<p>内存映射文件是按照文件名来访问的，多个进程可以把同一个文件映射到各自的虚地址空间中，且虚地址不必相同；随着进程的运行，被引用的映射文件由存储管理程序装入内存，多个进程读写虚存的映射文件区就可以共享文件信息</p>
<p>优点是： 方便易用、 节省空间、 便于共享、 灵活高</p>
<p>系统提供两个新的系统调用：</p>
<ul>
<li>映射文件mmap()， 有两个参数： 一个文件名和一个虚拟地址， 把一个文件映射到进程地址空间</li>
<li>移去映射文件unmmap()， 让文件与进程地址空间断开， 并把映射文件的数据写回磁盘文件</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/22/Ou71wjqHrQix8tk.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>只需要让进程映射的进程虚存空间的页表项的外存地址指向文件所在的磁盘块，就很容易实现映射文件和移去映射文件系统调用；当多进程共享文件时，实现技术是：<strong>把共享映射文件的进程的虚页面指向相同的页框，而页框则保存磁盘的页面副本</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/22/819AOQTwPXvrftm.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h3 id="文件系统的实现层次"><a href="#文件系统的实现层次" class="headerlink" title="文件系统的实现层次"></a>文件系统的实现层次</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/12/22/5OdNqk1m7hE4LzX.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>






        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2019-12-22T09:10:25.702Z" itemprop="dateUpdated">2019-12-22 17:10:25</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2019/12/21/操作系统-文件管理/" target="_blank" rel="external">http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/</a>
        
    </div>
    
    <footer>
        <a href="http://QQ876684433.github.io">
            <img src="/img/avatar.jpg" alt="steve_chph">
            steve_chph
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/操作系统/">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/文件管理/">文件管理</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/&title=《操作系统-文件管理》 — 至繁归于至简 - chph's blog&pic=http://QQ876684433.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/&title=《操作系统-文件管理》 — 至繁归于至简 - chph's blog&source=the blog website of steve_chph, steve_chph的个人博客网站" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《操作系统-文件管理》 — 至繁归于至简 - chph's blog&url=http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/&via=http://QQ876684433.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/12/22/数据库-完整性、视图、安全性和目录/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">数据库-完整性、视图、安全性和目录</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/12/21/操作系统-设备管理/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">操作系统-设备管理</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢你~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>steve_chph &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/&title=《操作系统-文件管理》 — 至繁归于至简 - chph's blog&pic=http://QQ876684433.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/&title=《操作系统-文件管理》 — 至繁归于至简 - chph's blog&source=the blog website of steve_chph, steve_chph的个人博客网站" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《操作系统-文件管理》 — 至繁归于至简 - chph's blog&url=http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/&via=http://QQ876684433.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACxklEQVR42u3aQXLjMAwEwPz/07sPcGTPAGTFh/bJlZIltg4kMsDPT/z59/B5veb1+qc7JHd+/8RjHzw8PLxDS0+W+/o94T395f2dk5fyyyvAw8PDu8Z72lHzTT+hJr/NX/f7NePh4eF9D6/dxNvSfPYS8fDw8L6ZlxwDm+95hIGHh4f3t7y28N2Uy++fnh8Sh7MWPDw8vJiXd5G+5/uV/h4eHh7euqueDAq0YWtytzYOflwDHh4e3gVevuHmBets7CC/c71OPDw8vKO8NkLNN/q2iTV77ocoGQ8PD+8Cr23qvy+dk6W0h8cs5C2CCTw8PLySt1lKPnyQLO5Uef3hfwU8PDy8Q7xNfLDpue0L5XomAg8PD+8QL29N5Y+cleCnXnSUteDh4eGNeLP9cxNPJN83I18f+nt4eHh4a96s1bSJGPKhrs3d6mQaDw8Pr+T9rD+zUKO9ZxTdtlNaeHh4eCNeXhbPgt32SNiU6b9kLXh4eHiXeW2raRZetDFHMlhQ9/fw8PDwRrz2Z+3m3o5V5bFvUbLj4eHhHeVFhekilm3vmQ8lRGA8PDy8C7y2VZ8fD/cmHWaBCB4eHt5ZXhtG3AtnZ6/7wzV4eHh413izsrU9eU6FtsP5CDw8PLw1r4XlG3c7grAJgj+MDuDh4eEd5Z2KA2bhbHtlO9SFh4eH91e8TVmcHx7vj5w8qhhmxnh4eHgLXr6UNvxtg9rNS3w8GPDw8PAu8NrwdJgcJ6Xw6ClRmIuHh4e34M0GTzdjrG0LbdZgw8PDw7vHazfffMSqLZc3r7UNL/Dw8PD2vNmt24flB0D+ig8U1nh4eHgL3r4xlmzTq1bWLP7Aw8PD+xpeOz41iyryNPrxgMHDw8P7Gt4spEiWmBwtRTmOh4eHd43XNp/yRlQ+mpAfEnVJjYeHh3eUt/nZrEGVjwIkRfM+wsDDw8OLef8BmdWxhlFHXNMAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'chph个人博客';
            clearTimeout(titleTime);
        } else {
            document.title = 'Welcome to chph's blog';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
