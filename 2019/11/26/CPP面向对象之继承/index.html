<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>C++面向对象之继承 | 至繁归于至简 - chph&#39;s blog | steve_chph personal website</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="C++,继承,面向对象">
    <meta name="description" content="C++面向对象之继承 参考书籍：《Primer C++, 5th》  定义基类和派生类下面可能会用到的源码： 12345678910111213141516171819202122#ifndef QUOTE_H_#define QUOTE_H_#include &amp;lt;iostream&amp;gt;class Quote&amp;#123;private:    std::string bookNo;prote">
<meta name="keywords" content="C++,继承,面向对象">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面向对象之继承">
<meta property="og:url" content="http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/index.html">
<meta property="og:site_name" content="至繁归于至简 - chph&#39;s blog">
<meta property="og:description" content="C++面向对象之继承 参考书籍：《Primer C++, 5th》  定义基类和派生类下面可能会用到的源码： 12345678910111213141516171819202122#ifndef QUOTE_H_#define QUOTE_H_#include &amp;lt;iostream&amp;gt;class Quote&amp;#123;private:    std::string bookNo;prote">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2019/11/27/Xczqr6LGanyIQVN.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/tUPW17aKvqQzmsh.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/hvtalZF6kLwuqX2.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/e9NKbaIrXP6SoRm.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/MvnOP58KS6wRXji.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/rJ1tRg8UufwXIzn.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/GgkZVWIScfHp3xd.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/hyInO1iSfWBeQxG.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/WQIKwVPa67NtE2v.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/vNV8IH3zrX4Jjla.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/gJ7axq3sVvUAQhj.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/SRzq3O6imcCPptu.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/MRUSntrFqzxQeLJ.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/gxDu6ZH7o28FTmY.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/gKDkOyYmW6idbsT.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/HWQES617izRGBba.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/LkzYxlKp8vyaVme.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/MWCjRQivtZoUBY6.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/cj6vYmDgnwN8fAr.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/uKTDBqH8k71PjLv.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/IXnykHGUbo2MhDq.png">
<meta property="og:updated_time" content="2019-11-27T12:45:51.559Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++面向对象之继承">
<meta name="twitter:description" content="C++面向对象之继承 参考书籍：《Primer C++, 5th》  定义基类和派生类下面可能会用到的源码： 12345678910111213141516171819202122#ifndef QUOTE_H_#define QUOTE_H_#include &amp;lt;iostream&amp;gt;class Quote&amp;#123;private:    std::string bookNo;prote">
<meta name="twitter:image" content="https://i.loli.net/2019/11/27/Xczqr6LGanyIQVN.png">
    
        <link rel="alternate" type="application/atom+xml" title="至繁归于至简 - chph&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">steve_chph</h5>
          <a href="mailto:chph13420146901@gmail.com" title="chph13420146901@gmail.com" class="mail">chph13420146901@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/QQ876684433" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">C++面向对象之继承</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">C++面向对象之继承</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-11-26T11:06:55.000Z" itemprop="datePublished" class="page-time">
  2019-11-26
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#C-面向对象之继承"><span class="post-toc-number">1.</span> <span class="post-toc-text">C++面向对象之继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#定义基类和派生类"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">定义基类和派生类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义基类"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">定义基类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#成员函数与继承"><span class="post-toc-number">1.1.1.1.</span> <span class="post-toc-text">成员函数与继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#访问控制与继承"><span class="post-toc-number">1.1.1.2.</span> <span class="post-toc-text">访问控制与继承</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义派生类"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">定义派生类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#派生类中的虚函数"><span class="post-toc-number">1.1.2.1.</span> <span class="post-toc-text">派生类中的虚函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#派生类对象及派生类向基类的类型转换"><span class="post-toc-number">1.1.2.2.</span> <span class="post-toc-text">派生类对象及派生类向基类的类型转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#派生类构造函数"><span class="post-toc-number">1.1.2.3.</span> <span class="post-toc-text">派生类构造函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#派生类使用基类的成员"><span class="post-toc-number">1.1.2.4.</span> <span class="post-toc-text">派生类使用基类的成员</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#继承与静态成员"><span class="post-toc-number">1.1.2.5.</span> <span class="post-toc-text">继承与静态成员</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#派生类的声明"><span class="post-toc-number">1.1.2.6.</span> <span class="post-toc-text">派生类的声明</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#被用作基类的类"><span class="post-toc-number">1.1.2.7.</span> <span class="post-toc-text">被用作基类的类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#防止继承发生"><span class="post-toc-number">1.1.2.8.</span> <span class="post-toc-text">防止继承发生</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类型转换与继承"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">类型转换与继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#静态类型与动态类型"><span class="post-toc-number">1.1.3.1.</span> <span class="post-toc-text">静态类型与动态类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#不存在从基类向派生类的隐式类型转换"><span class="post-toc-number">1.1.3.2.</span> <span class="post-toc-text">不存在从基类向派生类的隐式类型转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在对象之间不存在类型转换"><span class="post-toc-number">1.1.3.3.</span> <span class="post-toc-text">在对象之间不存在类型转换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#引入知识点：对象切片"><span class="post-toc-number">1.1.3.3.1.</span> <span class="post-toc-text">引入知识点：对象切片</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#多重继承与虚继承"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">多重继承与虚继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多重继承"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">多重继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多重继承的派生类从每个基类中继承状态"><span class="post-toc-number">1.2.1.1.</span> <span class="post-toc-text">多重继承的派生类从每个基类中继承状态</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#派生类构造函数初始化所有基类"><span class="post-toc-number">1.2.1.2.</span> <span class="post-toc-text">派生类构造函数初始化所有基类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#继承的构造函数与多重继承"><span class="post-toc-number">1.2.1.3.</span> <span class="post-toc-text">继承的构造函数与多重继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#析构函数与多重继承"><span class="post-toc-number">1.2.1.4.</span> <span class="post-toc-text">析构函数与多重继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多重继承的派生类的拷贝与移动操作"><span class="post-toc-number">1.2.1.5.</span> <span class="post-toc-text">多重继承的派生类的拷贝与移动操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类型转换与多个基类"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">类型转换与多个基类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#基于指针类型或引用类型的查找"><span class="post-toc-number">1.2.2.1.</span> <span class="post-toc-text">基于指针类型或引用类型的查找</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多重继承下的类作用域"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">多重继承下的类作用域</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#虚继承"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">虚继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用虚基类"><span class="post-toc-number">1.2.4.1.</span> <span class="post-toc-text">使用虚基类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#虚基类成员的可见性"><span class="post-toc-number">1.2.4.2.</span> <span class="post-toc-text">虚基类成员的可见性</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#构造函数与虚继承"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">构造函数与虚继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#虚继承的对象的构造方式"><span class="post-toc-number">1.2.5.1.</span> <span class="post-toc-text">虚继承的对象的构造方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#构造函数与虚构函数的次序"><span class="post-toc-number">1.2.5.2.</span> <span class="post-toc-text">构造函数与虚构函数的次序</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#其他知识点"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">其他知识点</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-CPP面向对象之继承"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">C++面向对象之继承</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-11-26 19:06:55" datetime="2019-11-26T11:06:55.000Z"  itemprop="datePublished">2019-11-26</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="C-面向对象之继承"><a href="#C-面向对象之继承" class="headerlink" title="C++面向对象之继承"></a>C++面向对象之继承</h1><blockquote>
<p>参考书籍：《Primer C++, 5th》</p>
</blockquote>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><p>下面可能会用到的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUOTE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUOTE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Quote() = <span class="keyword">default</span>;</span><br><span class="line">    Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price) : bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><p>继承关系中，<strong>根节点的类通常会定义一个虚析构函数</strong>，即使该函数不执行任何实际操作也是如此</p>
<h4 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h4><p>基类中通常有两种成员函数：</p>
<ul>
<li><p>虚函数：基类希望其派生类进行覆盖的函数</p>
<ul>
<li><p>当使用<strong>指针或者引用</strong>调用虚函数时，该调用将被动态绑定；根据引用或指针所绑定的对象类型的不同，该调用可能执行基类的版本，也可能执行某个派生类的版本</p>
</li>
<li><p><strong>任何构造函数之外的非静态函数都可以是虚函数</strong></p>
</li>
<li><p>并且virtual只能出现在类内部的声明语句之前，而不能用在类外部的函数定义</p>
</li>
<li><p>如果基类把一个函数声明为虚函数，则该函数<strong>在派生类中隐式地也是虚函数</strong>（即使没有virtual关键字）</p>
</li>
</ul>
</li>
<li><p>普通函数：基类希望派生类直接继承而不要改变的函数</p>
<p>非虚成员函数的<strong>解析过程发生在编译时而非运行时</strong></p>
</li>
</ul>
<h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权限访问从基类继承而来的成员</p>
<p>（private、protected、public，过于简单，就不再赘述）</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须通过使用类派生列表明确指出它从哪些基类继承而来，每个基类前面可以使用三种访问说明符中的一个：public、protected、private</p>
<p><strong>三种继承方式不影响子类对父类的访问权限，子类对父类只看父类的访问控制权；</strong>三种继承方式都能访问父类中的public和protected成员</p>
<p>简单来说：访问说明符的作用是控制派生类从基类继承而来的成员是否对<strong>派生类的用户</strong>可见</p>
<p>如果一个派生是共有的，则<strong>基类的共有成员也是派生类接口的组成部分</strong>，我们能将共有派生类型的对象绑定到基类的引用或指针上</p>
<h4 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h4><p>派生类经常（但不总是）覆盖它继承的虚函数；如果没有覆盖，则该虚函数的行为类似于其他普通成员，派生类<strong>会直接继承其在基类中的版本</strong></p>
<h4 id="派生类对象及派生类向基类的类型转换"><a href="#派生类对象及派生类向基类的类型转换" class="headerlink" title="派生类对象及派生类向基类的类型转换"></a>派生类对象及派生类向基类的类型转换</h4><p>派生类对象包含多个组成部分：</p>
<ul>
<li>派生类自己定义的（非静态）成员的子对象</li>
<li>与派生类继承的基类对应的子对象（如果基类有多个，那这样的子对象也有多个）</li>
</ul>
<p>正因为如此，我们能够</p>
<ul>
<li>把派生类的对象当成基类对象来使用</li>
<li>能将基类的指针或引用绑定到派生类对象的基类部分上</li>
<li>可以把派生类对象指针用在需要基类指针的地方</li>
<li>可以把派生类对象或者派生类对象的引用用到需要基类引用的地方</li>
</ul>
<p>继承的关键所在：派生类对象中含有与基类对应的组成部分</p>
<h4 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h4><p><strong>每个类控制它自己的成员的初始化过程</strong>：意味着派生类不能直接初始化继承的基类成员，需要通过基类的构造函数初始化它的基类部分</p>
<p>我们可以通过构造函数初始化列表将实参传递给基类构造函数，同时用这个方法指定我们要调用的基类的构造函数版本，否则派生类对象的基类对象会像数据成员一样执行默认初始化</p>
<p>首先初始化基类的部分，然后<strong>按照声明的顺序</strong>依次初始化派生类的成员</p>
<h4 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h4><p>派生类可以访问基类的共有成员和受保护成员；派生类对象的作用域嵌套在基类的作用域之内，因此派生类的一个成员使用派生类其他成员的方式与使用基类成员的方式没有什么不同（除了基类private成员）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/Xczqr6LGanyIQVN.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h4><p>如果基类定义了一个静态成员，那么整个继承体系中该静态成员只存在唯一的实例；静态成员遵循通用的访问控制规则， 如果某静态成员是可访问的，那么我们既能通过基类（及其对象）、也能通过派生类（及其对象）使用它</p>
<h4 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h4><p>派生类的声明<strong>包含类名但是不包含它的派生列表</strong>；派生类列表与定义的其他细节必须与类的主体一起出现</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/tUPW17aKvqQzmsh.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>一条声明语句的目的是<strong>令程序知晓某个名字的存在</strong>以及<strong>该名字表示一个什么样的实体</strong>（如一个类、函数或者变量）</p>
<h4 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h4><p>一个类必须已经定义而非仅仅声明才能被用作基类：</p>
<ul>
<li>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必然要知道基类中定义了哪些成员</li>
<li>言外之意：一个类不能派生它本身</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/hvtalZF6kLwuqX2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>每个类都会继承直接基类的所有成员；在整个继承体系中，<strong>最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象</strong></p>
<h4 id="防止继承发生"><a href="#防止继承发生" class="headerlink" title="防止继承发生"></a>防止继承发生</h4><p>C++11新标准：在<strong>类名后跟一个final</strong>，可以防止该类被继承</p>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><h4 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h4><ul>
<li>静态类型：编译时就确定的，它是变量声明时的类型或表达式生成的类型</li>
<li>动态类型：变量或表达式表示的内存中的对象的类型</li>
</ul>
<p><u>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致</u></p>
<h4 id="不存在从基类向派生类的隐式类型转换"><a href="#不存在从基类向派生类的隐式类型转换" class="headerlink" title="不存在从基类向派生类的隐式类型转换"></a>不存在从基类向派生类的隐式类型转换</h4><p>有一种特别的情况：<u>即使一个基类指针或者引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换</u></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/e9NKbaIrXP6SoRm.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或者引用的静态类型来腿短该转换是否合法</p>
<ul>
<li><p>如果基类中含有一个或多个虚函数，我们可以使用dynamic_case请求一个类型转换，该<strong>转换的安全检查将在运行时执行</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">Bulk_quote *bulkP = <span class="keyword">dynamic_cast</span>&lt;Bulk_quote *&gt;(itemP);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bulkP-&gt;isbn() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们已知某个基类向派生类的转换是安全的，则我们可以使用static_cast来<strong>强制覆盖掉编译器的检查工作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">Bulk_quote *bulkP = <span class="keyword">static_cast</span>&lt;Bulk_quote *&gt;(itemP);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bulkP-&gt;isbn() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="在对象之间不存在类型转换"><a href="#在对象之间不存在类型转换" class="headerlink" title="在对象之间不存在类型转换"></a>在对象之间不存在类型转换</h4><p>派生类向基类的自动类型转换只针对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换：</p>
<ul>
<li>初始化或赋值一个类类型对象时，实际上是在调用某个函数<ul>
<li>执行初始化时，调用的是构造函数</li>
<li>执行赋值操作时，调用的是赋值运算符</li>
</ul>
</li>
<li>这些成员函数通常都包含一个参数，该参数的类型是类类型的const版本的引用</li>
</ul>
<p>这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象，因为<strong>这些操作不是虚函数</strong>，因此：</p>
<ul>
<li>当我们给基类的构造函数传递一个派生类对象时，实际运行的<strong>构造函数是基类中定义的那个</strong>，显然该构造函数<strong>只能处理基类自己的成员</strong></li>
<li>当我们将一个派生类对象赋值给一个基类对象，则实际运行的<strong>赋值运算符也是基类中定义的那个</strong>，该运算符同样<strong>只能处理基类自己的成员</strong></li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/MvnOP58KS6wRXji.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="引入知识点：对象切片"><a href="#引入知识点：对象切片" class="headerlink" title="引入知识点：对象切片"></a>引入知识点：对象切片</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/rJ1tRg8UufwXIzn.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<blockquote>
<p>If you upcast to an object instead of a pointer or reference, something will happen that may surprise you: the object is “sliced” until all that remains is the subobject that corresponds to the destination type of your cast.<br>—— Thinking In C++</p>
</blockquote>
<h2 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h2><p>多重继承的派生类继承了<strong>所有父类的属性</strong></p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul>
<li>关键字class对应的默认访问说明符是private，关键字struct对应的是public</li>
<li>多重继承的派生列表只能包含已经被定义过的类，而且这些类不能是final的</li>
<li>派生列表中，同一个基类只能出现一次</li>
</ul>
<h4 id="多重继承的派生类从每个基类中继承状态"><a href="#多重继承的派生类从每个基类中继承状态" class="headerlink" title="多重继承的派生类从每个基类中继承状态"></a>多重继承的派生类从每个基类中继承状态</h4><p>多重继承关系中，派生类的对象包含有每个基类的子对象，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span>:</span> <span class="keyword">public</span> ZooAnimal &#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span>:</span> <span class="keyword">public</span> Bear, <span class="keyword">public</span> Endangered &#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/GgkZVWIScfHp3xd.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="派生类构造函数初始化所有基类"><a href="#派生类构造函数初始化所有基类" class="headerlink" title="派生类构造函数初始化所有基类"></a>派生类构造函数初始化所有基类</h4><p>构造一个派生类的对象将同时构造并初始化它的所有基类子对象，多重继承的派生类的构造函数初始值只能初始化<strong>它的直接基类</strong>（例如Panda的直接基类是Bear和Endangered）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/hyInO1iSfWBeQxG.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>基类的构造顺序与<strong>派生列表中基类的出现顺序</strong>保持一致，而与派生类构造函数初始值列表中的基类顺序无关</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/WQIKwVPa67NtE2v.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/vNV8IH3zrX4Jjla.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="继承的构造函数与多重继承"><a href="#继承的构造函数与多重继承" class="headerlink" title="继承的构造函数与多重继承"></a>继承的构造函数与多重继承</h4><p>C++11中允许派生类继承多个基类的构造函数，但是如果从多个基类中继承了相同的构造函数（形参列表完全相同），那么程序将报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base1() = <span class="keyword">default</span>;</span><br><span class="line">    Base1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);</span><br><span class="line">    Base1(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base2() = <span class="keyword">default</span>;</span><br><span class="line">    Base2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);</span><br><span class="line">    Base2(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tempCodeRunnerFile.cpp:20:18: error: ‘D1::D1(const string&amp;)’ inherited from ‘Base2’</span><br><span class="line">     using Base2::Base2;</span><br><span class="line">                  ^~~~~</span><br><span class="line">tempCodeRunnerFile.cpp:19:18: error: conflicts with version inherited from ‘Base1’</span><br><span class="line">     using Base1::Base1;</span><br></pre></td></tr></table></figure>

<p>此时必须在派生类中<strong>定义这个冲突构造函数的派生类自己的版本</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">    D1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)&#123;&#125;</span><br><span class="line">    D1() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：前面版本的D1之所以只对<code>D1::D1(const string&amp;)</code>报错，是因为D1中没有定义自己版本的构造函数，编译器为D1合成了默认的构造函数，<strong>覆盖了从Base1和Base2继承过来的冲突的默认版本的构造函数</strong>；但是现在这个版本定义了自己的<code>D1(const std::string &amp;){}</code>来解决冲突，导致编译器不会为D1合成默认构造函数，因此也需要为D1显式定义默认构造函数</p>
<h4 id="析构函数与多重继承"><a href="#析构函数与多重继承" class="headerlink" title="析构函数与多重继承"></a>析构函数与多重继承</h4><p>析构函数的调用顺序与构造函数相反：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure>

<h4 id="多重继承的派生类的拷贝与移动操作"><a href="#多重继承的派生类的拷贝与移动操作" class="headerlink" title="多重继承的派生类的拷贝与移动操作"></a>多重继承的派生类的拷贝与移动操作</h4><ul>
<li>多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或者赋值操作</li>
<li><strong>只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作</strong></li>
</ul>
<p>例如Panda调用合成版本的拷贝构造函数，首先调用Bear的拷贝构造函数拷贝Bear子对象部分，而Bear又会在执行之前调用呢ZooAnimal的拷贝构造函数拷贝ZooAnimal子对象部分，Bear子对象部分拷贝完成后，又会调用Endangered拷贝构造函数拷贝Endangered子对象部分，最后才调用Panda的合成构造函数拷贝Panda部分</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/gJ7axq3sVvUAQhj.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h3 id="类型转换与多个基类"><a href="#类型转换与多个基类" class="headerlink" title="类型转换与多个基类"></a>类型转换与多个基类</h3><p>派生类有多个基类时，如果存在多个以基类为参数的重载函数，那么编译器会报错，因为<strong>编译器不会在派生类向基类的几种转换中进行比较和选择</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Panda.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Bear.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Endangered.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ZooAnimal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Endangered &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Panda p;</span><br><span class="line">    func(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译报错，程序有二义性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Test01.cpp: In function ‘int main(int, const char**)’:</span><br><span class="line">Test01.cpp:<span class="number">15</span>:<span class="number">11</span>: error: call of overloaded ‘func(Panda&amp;)’ is ambiguous</span><br><span class="line">     func(p);</span><br><span class="line">           ^</span><br><span class="line">Test01.cpp:<span class="number">6</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br><span class="line">Test01.cpp:<span class="number">8</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Endangered &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br><span class="line">Test01.cpp:<span class="number">10</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br></pre></td></tr></table></figure>

<p>注意：这个只限于直接基类为参数的重载，比如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Panda.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Bear.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Endangered.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ZooAnimal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span> &lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void func(Endangered &amp;) &#123; cout &lt;&lt; "func(Endangered &amp;) &lt;&lt; endl;"; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Panda p;</span><br><span class="line">    func(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承关系是ZooAnimal -&gt; Bear -&gt; Panda，输出结果是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">func(Bear &amp;)</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure>

<p>即会调用继承链上最近的那个重载版本</p>
<h4 id="基于指针类型或引用类型的查找"><a href="#基于指针类型或引用类型的查找" class="headerlink" title="基于指针类型或引用类型的查找"></a>基于指针类型或引用类型的查找</h4><p>通过基类指针来引用派生类对象时，如果析构函数是非虚函数，那么delete时无法调用派生类对象的析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooAnimal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal(<span class="comment">/* args */</span>);</span><br><span class="line">    ~ZooAnimal();</span><br><span class="line">&#125;;</span><br><span class="line">... ...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Panda p;</span></span><br><span class="line">    ZooAnimal *z_ptr = <span class="keyword">new</span> Panda();</span><br><span class="line">    <span class="comment">// func(p);</span></span><br><span class="line">    <span class="keyword">delete</span> z_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~ZooAnimal()</span><br><span class="line">    </span><br><span class="line">====================================================================</span><br><span class="line">====================================================================</span><br><span class="line">    </span><br><span class="line">class ZooAnimal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal(<span class="comment">/* args */</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~ZooAnimal();</span><br><span class="line">&#125;;</span><br><span class="line">... ...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Panda p;</span></span><br><span class="line">    ZooAnimal *z_ptr = <span class="keyword">new</span> Panda();</span><br><span class="line">    <span class="comment">// func(p);</span></span><br><span class="line">    <span class="keyword">delete</span> z_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure>

<p>在基类和派生类的析构函数都是虚函数时，无论使用哪个基类的指针来引用派生类对象，调用析构函数时，<strong>都是按照调用派生类对象析构函数的顺序执行</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~MI() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~MI()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 *pb1 = <span class="keyword">new</span> MI;</span><br><span class="line">    Base2 *pb2 = <span class="keyword">new</span> MI;</span><br><span class="line">    D1 *pd1 = <span class="keyword">new</span> MI;</span><br><span class="line">    D2 *pd2 = <span class="keyword">new</span> MI;</span><br><span class="line">    <span class="keyword">delete</span> pb2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pd2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line"></span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line"></span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br></pre></td></tr></table></figure>

<h3 id="多重继承下的类作用域"><a href="#多重继承下的类作用域" class="headerlink" title="多重继承下的类作用域"></a>多重继承下的类作用域</h3><p>单继承与多继承时的不同：</p>
<ul>
<li>单继承时，派生类的作用域嵌套在直接基类和间接基类的作用域中，查找过程<strong>沿着继承体系自底向上</strong>进行，直到找到所需的<strong>名字</strong>；派生类的名字将隐藏基类的<strong>同名成员</strong></li>
<li>多继承时，相同的查找过程将<strong>在所有直接基类中同时进行</strong>，如果<strong>名字</strong>在多个基类中都被找到，则对该名字的使用将具有二义性</li>
</ul>
<p>注意一点是，上面强调的是<strong>名字</strong>，即使派生类继承的两个函数形参列表不同也可能产生错误，因为它是<strong>按名字查找</strong>，<strong>先查找名字后进行类型检查</strong>，当编译器在两个作用域中同时发现了同名成员将直接报告一个调用二义性的错误</p>
<p>对一个派生类来说，从多个基类中分别继承同名的成员是完全合法的，只不过<strong>在使用这个名字时必须明确指出它的版本（这个如下面代码所示）</strong>；也就是说，派生仅是产生了潜在的二义性，只要没有调用就不会产生二义性（可以通过编译）；要想避免潜在的二义性，最好的办法是<strong>在派生类中为该函数定义一个新版本</strong>，或者<strong>通过using来显式使用确定的基类版本</strong>（例如using ZooAnimal::max_weight，或者using Endangered::max_weight）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~MI() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~MI()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="comment">// using D1::func1;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 *pb1 = <span class="keyword">new</span> MI;</span><br><span class="line">    Base2 *pb2 = <span class="keyword">new</span> MI;</span><br><span class="line">    D1 *pd1 = <span class="keyword">new</span> MI;</span><br><span class="line">    D2 *pd2 = <span class="keyword">new</span> MI;</span><br><span class="line">    <span class="keyword">delete</span> pb2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pd2;</span><br><span class="line">    MI mi;</span><br><span class="line">    mi.D1::func1();	<span class="comment">// 显式指定使用的名字的版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虽然派生列表中同一个基类只能出现一次，但是派生类可以多次继承同一个类；派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类</p>
<p>默认情况下，派生类中含有继承链上每个类对应的字部分，如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/SRzq3O6imcCPptu.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>从图中可以看到，B1(base)和B2(base)中包含的A(base)是两个不同子部分（从x值不同可以看出，并且A的构造函数也调用了两次）</p>
<p>有时候要实现多次出现的同一个基类的共享，可以使用<strong>虚继承</strong>：虚继承的目的是令某个类作出声明，承诺愿意共享它的基类（共享的基类子对象称为<strong>虚基类</strong>），这样不论虚基类在继承体系中出现了多少次，<strong>在派生类中都只包含唯一一个共享的虚基类子对象</strong>：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/MRUSntrFqzxQeLJ.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>从上图可以看出此时A基类子对象只有一个，A只调用了一次构造函数</p>
<p>虚基类的缺点：必须在虚派生的真实需求出现之前就已经完成了虚派生的操作；在实际编程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题，它不会影响派生类本身，只会影响从制定了虚基类的派生类章进一步派生出来的类：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/gxDu6ZH7o28FTmY.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>例如Bear声明ZooAnimal为虚继承不会对Bear自身造成影响，但会对Panda造成影响</p>
<h4 id="使用虚基类"><a href="#使用虚基类" class="headerlink" title="使用虚基类"></a>使用虚基类</h4><p>指定虚基类的方式是在派生列表中添加关键字virtual，其中virtual和访问修饰符如public的顺序随意</p>
<p>virtual说明符表明了一种愿望：<strong>在后续的派生类中共享虚基类的同一份实例</strong></p>
<h4 id="虚基类成员的可见性"><a href="#虚基类成员的可见性" class="headerlink" title="虚基类成员的可见性"></a>虚基类成员的可见性</h4><ul>
<li>在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并且不会产生二义性</li>
<li>如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员</li>
<li>如果成员被多于一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本</li>
</ul>
<p>例如有如下继承关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2&#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>如果在D的对象中使用x，则有三种可能性：</p>
<ul>
<li><p>D1、D2都没有x的定义，此时x被解析为<strong>B的成员</strong>，此时不存在二义性</p>
</li>
<li><p>D1和D2只有其中一个有x的定义，此时依然没有二义性，派生类（D1或者D2）的x比共享虚基类B的x优先级更高（如下代码所示）</p>
<p><img src="https://i.loli.net/2019/11/27/gKDkOyYmW6idbsT.png" alt></p>
</li>
<li><p>D1、D2中均有x的定义，直接访问x将产生二义性</p>
</li>
</ul>
<p>解决这种二义性的最好方法是<strong>在派生类中为成员自定义新的实例</strong></p>
<h3 id="构造函数与虚继承"><a href="#构造函数与虚继承" class="headerlink" title="构造函数与虚继承"></a>构造函数与虚继承</h3><p>在虚派生中，虚基类是由最底层的派生类初始化的</p>
<h4 id="虚继承的对象的构造方式"><a href="#虚继承的对象的构造方式" class="headerlink" title="虚继承的对象的构造方式"></a>虚继承的对象的构造方式</h4><p>含有虚基类的对象的构造顺序与一般的顺序稍有区别：</p>
<ul>
<li>首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分</li>
<li>接下来按照直接基类在派生列表中出现的次序依次对其进行初始化</li>
</ul>
<p>也就是说：<strong>虚基类总是先于非虚基类构造，与他们在继承体系中的次序和位置无关</strong>；如下代码所示，B处于派生列表的第一个，但是虚基类A先于B进行初始化：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/HWQES617izRGBba.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>但是如果有多个虚基类的时候，虚基类的构造顺序则与派生列表的顺序有关，如下面代码所示，派生列表中B1是第一个直接基类，B1虚继承了A2，因此A2先于A1执行初始化：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/LkzYxlKp8vyaVme.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="构造函数与虚构函数的次序"><a href="#构造函数与虚构函数的次序" class="headerlink" title="构造函数与虚构函数的次序"></a>构造函数与虚构函数的次序</h4><p>一个类可以有多个虚基类，这些虚的子对象按照它们在派生列表中出现的顺序依次从左向右构造：<strong>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类；如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类</strong></p>
<p>对于如下的继承体系：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/MWCjRQivtZoUBY6.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>它们的构造顺序如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/cj6vYmDgnwN8fAr.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>合成的拷贝和移动构造函数按照上面完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值；和往常一样，<strong>对象的销毁顺序与构造顺序正好相反</strong>：首先销毁TeddyBear，最后销毁ZooAnimal部分</p>
<p>最后来一个例子：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/uKTDBqH8k71PjLv.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>因为Class不是虚基类，因此<code>new Final</code>对象中含有多份Class的子对象部分，当使用Class类型指针绑定到<code>new Final</code>对象时，会造成Class基类的二义性，即控制台报错的：<code>ex18_29.cpp:15:21: error: ‘Class’ is an ambiguous base of ‘Final’</code></p>
<p>接下来我们修改一下，将其中一个Class申明为虚继承，另一个依然为普通继承：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/IXnykHGUbo2MhDq.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>可以看到，Class还是存在二义性：<code>ex18_29.cpp:15:21: error: ‘Class’ is an ambiguous base of ‘Final’</code></p>
<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2019-11-27T12:45:51.559Z" itemprop="dateUpdated">2019-11-27 20:45:51</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2019/11/26/CPP面向对象之继承/" target="_blank" rel="external">http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/</a>
        
    </div>
    
    <footer>
        <a href="http://QQ876684433.github.io">
            <img src="/img/avatar.jpg" alt="steve_chph">
            steve_chph
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/继承/">继承</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面向对象/">面向对象</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/&title=《C++面向对象之继承》 — 至繁归于至简 - chph's blog&pic=http://QQ876684433.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/&title=《C++面向对象之继承》 — 至繁归于至简 - chph's blog&source=the blog website of steve_chph, steve_chph的个人博客网站" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《C++面向对象之继承》 — 至繁归于至简 - chph's blog&url=http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/&via=http://QQ876684433.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/11/17/操作系统-进程管理/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">操作系统-进程管理</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢你~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>steve_chph &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/&title=《C++面向对象之继承》 — 至繁归于至简 - chph's blog&pic=http://QQ876684433.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/&title=《C++面向对象之继承》 — 至繁归于至简 - chph's blog&source=the blog website of steve_chph, steve_chph的个人博客网站" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《C++面向对象之继承》 — 至繁归于至简 - chph's blog&url=http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/&via=http://QQ876684433.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvklEQVR42u3aQW7DMAwEwP7/0ynQaxt7SYpN0I5PQWLYHhmQlCU/PuLj8XX0Pj+7Wn5+fk7zwMPDw2s9+rMjeaD84b6feX3H6yG+fmY8PDy8bV6yGESXG0ziyRDnz4yHh4f3DrzJo1x/kw8oHh4e3t/g5Rv0hJQPEB4eHt5reb3tbO+WvUFZz1rw8PDwaunBYgFs4/Mb1ffw8PD+Ge9RPE4NU/Waj9aBh4eHt8GrFu+vw4jrLW9+ryTwzVsT8PDw8H6fN2kCSK5zaiCehh14eHh4R3m9uLYaWCQNBD3ezVDi4eHhLfB6xapqA0H+fTLd9xod8PDw8E7xei1QSRiRLyHz99N8V3h4eHgDXtICNa/FJ2FHHkBECxgeHh7eAi8JBaoRbf5rc9cfb/fx8PDwtnnVKThfGJJfq8FHoWiHh4eHd5RX3RD3gt1JpDsqs+Hh4eEt8PLItdo4lQ9Wb0mothfg4eHhneJVJ9Z8U9ssWRWn+BsqHh4e3jKvWgbLw4sqo9rQEC0MeHh4eAu8U6FDL4CoNldF98XDw8Nb4E0m7vlCkg9otVULDw8Pb5uXP9akVFYNMnrHD1fAw8PDW+Alk3JexErw+erUG4Kn7xAPDw9vzJv8jc8n+iSSyJeQfIOOh4eHt8HL2wXysKBw4+KZyR+AmzACDw8Pb8zLp/LekjAvVlUXHjw8PLzX8qphazWM6BXY8jIYHh4e3gYv39pOQttqW1Wvx+HmfDw8PLxDvEfxyFsNqlP5PIYo7/3x8PDwWrxeM1NhI3uozNZbqPDw8PD2eL0mgGqxvxfy9t4PHh4e3u/wepNyL6jNt9TJEnKzvcbDw8N7KS/fTPfi3eqjR7EvHh4e3tvw8oA1b1DohSBRGQwPDw9vgVctelVT4ckg5i1fB7IWPDw8vNo5xwpgyRIyiWsPNxDg4eHhpdf5BLPKK/Dq8nGVAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'chph个人博客';
            clearTimeout(titleTime);
        } else {
            document.title = 'Welcome to chph's blog';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
