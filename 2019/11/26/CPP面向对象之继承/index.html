<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>C++面向对象之继承 | 至繁归于至简 - chph&#39;s blog | steve_chph personal website</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="C++,继承,面向对象">
    <meta name="description" content="C++面向对象之继承 参考书籍：《Primer C++, 5th》  定义基类和派生类下面可能会用到的源码： 12345678910111213141516171819202122#ifndef QUOTE_H_#define QUOTE_H_#include &amp;lt;iostream&amp;gt;class Quote&amp;#123;private:    std::string bookNo;prote">
<meta name="keywords" content="C++,继承,面向对象">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面向对象之继承">
<meta property="og:url" content="http://chphong.github.io/2019/11/26/CPP面向对象之继承/index.html">
<meta property="og:site_name" content="至繁归于至简 - chph&#39;s blog">
<meta property="og:description" content="C++面向对象之继承 参考书籍：《Primer C++, 5th》  定义基类和派生类下面可能会用到的源码： 12345678910111213141516171819202122#ifndef QUOTE_H_#define QUOTE_H_#include &amp;lt;iostream&amp;gt;class Quote&amp;#123;private:    std::string bookNo;prote">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2019/11/27/Xczqr6LGanyIQVN.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/tUPW17aKvqQzmsh.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/hvtalZF6kLwuqX2.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/e9NKbaIrXP6SoRm.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/MvnOP58KS6wRXji.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/rJ1tRg8UufwXIzn.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/lkCJV72QrxT9ApB.jpg">
<meta property="og:image" content="https://i.loli.net/2019/11/27/GjEd7WuLAslzhyk.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/HZ3sVWNPURl8dwp.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/aZWzN4d25eVxcgt.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/MrZi38CY4RzgAB6.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/im3hwSZuBGONYLq.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/sxpgqBD3GS8CtFW.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/tR9NWrv3Lg7e1zZ.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/pEBSe6ZRH4cGvfW.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/irgp9ow8BfPvX7u.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/SvA6Kz81Oaq4UHd.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/1ep5UxZjVhXbETn.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/nls2PwDjX9YAKzg.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/IM8KaB95T4n27Fw.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/ktsLipHr4XJuM9q.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/gZbcrlsvqL9QioM.png">
<meta property="og:image" content="https://i.loli.net/2019/11/28/CoLEN8mxFh1KW5n.png">
<meta property="og:image" content="https://i.loli.net/2019/11/29/2ZzSd4GhLKgOMqB.png">
<meta property="og:image" content="https://i.loli.net/2019/11/29/2et6QdkF8JnuZI4.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/GgkZVWIScfHp3xd.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/hyInO1iSfWBeQxG.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/WQIKwVPa67NtE2v.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/vNV8IH3zrX4Jjla.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/gJ7axq3sVvUAQhj.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/SRzq3O6imcCPptu.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/MRUSntrFqzxQeLJ.png">
<meta property="og:image" content="https://i.loli.net/2019/11/26/gxDu6ZH7o28FTmY.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/gKDkOyYmW6idbsT.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/HWQES617izRGBba.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/LkzYxlKp8vyaVme.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/MWCjRQivtZoUBY6.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/cj6vYmDgnwN8fAr.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/uKTDBqH8k71PjLv.png">
<meta property="og:image" content="https://i.loli.net/2019/11/27/IXnykHGUbo2MhDq.png">
<meta property="og:updated_time" content="2020-01-07T04:04:48.950Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++面向对象之继承">
<meta name="twitter:description" content="C++面向对象之继承 参考书籍：《Primer C++, 5th》  定义基类和派生类下面可能会用到的源码： 12345678910111213141516171819202122#ifndef QUOTE_H_#define QUOTE_H_#include &amp;lt;iostream&amp;gt;class Quote&amp;#123;private:    std::string bookNo;prote">
<meta name="twitter:image" content="https://i.loli.net/2019/11/27/Xczqr6LGanyIQVN.png">
    
        <link rel="alternate" type="application/atom+xml" title="至繁归于至简 - chph&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">steve_chph</h5>
          <a href="mailto:chph13420146901@gmail.com" title="chph13420146901@gmail.com" class="mail">chph13420146901@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/chphong" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://107.182.188.221:23333/"  >
                <i class="icon icon-lg icon-link"></i>
                Project(HTTP)
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://107.182.188.221:23334/"  >
                <i class="icon icon-lg icon-demo"></i>
                Project(HTTPS)
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">C++面向对象之继承</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">C++面向对象之继承</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-11-26T11:06:55.000Z" itemprop="datePublished" class="page-time">
  2019-11-26
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#C-面向对象之继承"><span class="post-toc-number">1.</span> <span class="post-toc-text">C++面向对象之继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#定义基类和派生类"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">定义基类和派生类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义基类"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">定义基类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#成员函数与继承"><span class="post-toc-number">1.1.1.1.</span> <span class="post-toc-text">成员函数与继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#访问控制与继承"><span class="post-toc-number">1.1.1.2.</span> <span class="post-toc-text">访问控制与继承</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#定义派生类"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">定义派生类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#派生类中的虚函数"><span class="post-toc-number">1.1.2.1.</span> <span class="post-toc-text">派生类中的虚函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#派生类对象及派生类向基类的类型转换"><span class="post-toc-number">1.1.2.2.</span> <span class="post-toc-text">派生类对象及派生类向基类的类型转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#派生类构造函数"><span class="post-toc-number">1.1.2.3.</span> <span class="post-toc-text">派生类构造函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#派生类使用基类的成员"><span class="post-toc-number">1.1.2.4.</span> <span class="post-toc-text">派生类使用基类的成员</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#继承与静态成员"><span class="post-toc-number">1.1.2.5.</span> <span class="post-toc-text">继承与静态成员</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#派生类的声明"><span class="post-toc-number">1.1.2.6.</span> <span class="post-toc-text">派生类的声明</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#被用作基类的类"><span class="post-toc-number">1.1.2.7.</span> <span class="post-toc-text">被用作基类的类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#防止继承发生"><span class="post-toc-number">1.1.2.8.</span> <span class="post-toc-text">防止继承发生</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类型转换与继承"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">类型转换与继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#静态类型与动态类型"><span class="post-toc-number">1.1.3.1.</span> <span class="post-toc-text">静态类型与动态类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#不存在从基类向派生类的隐式类型转换"><span class="post-toc-number">1.1.3.2.</span> <span class="post-toc-text">不存在从基类向派生类的隐式类型转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在对象之间不存在类型转换"><span class="post-toc-number">1.1.3.3.</span> <span class="post-toc-text">在对象之间不存在类型转换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#引入知识点：对象切片"><span class="post-toc-number">1.1.3.3.1.</span> <span class="post-toc-text">引入知识点：对象切片</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#虚函数"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">虚函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#派生类中的虚函数-1"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">派生类中的虚函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#final和override说明符"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">final和override说明符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#虚函数与默认实参"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">虚函数与默认实参</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#回避虚函数的机制"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">回避虚函数的机制</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#抽象基类"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">抽象基类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#纯虚函数"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">纯虚函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#含有纯虚函数的类是抽象基类"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">含有纯虚函数的类是抽象基类</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#访问控制与继承-1"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">访问控制与继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#受保护成员"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">受保护成员</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#公有、私有和受保护继承"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">公有、私有和受保护继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#派生类向基类转换的可访问性"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">派生类向基类转换的可访问性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#关键概念：类的设计与受保护的成员"><span class="post-toc-number">1.4.3.1.</span> <span class="post-toc-text">关键概念：类的设计与受保护的成员</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#友元与继承"><span class="post-toc-number">1.4.4.</span> <span class="post-toc-text">友元与继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#改变个别成员的可访问性"><span class="post-toc-number">1.4.5.</span> <span class="post-toc-text">改变个别成员的可访问性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#默认的继承保护级别"><span class="post-toc-number">1.4.6.</span> <span class="post-toc-text">默认的继承保护级别</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#继承中的类作用域"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">继承中的类作用域</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在编译时进行名字查找"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">在编译时进行名字查找</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#名字冲突与继承"><span class="post-toc-number">1.5.2.</span> <span class="post-toc-text">名字冲突与继承</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#通过作用域运算符来使用隐藏的成员"><span class="post-toc-number">1.5.3.</span> <span class="post-toc-text">通过作用域运算符来使用隐藏的成员</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#名字查找先于类型检查"><span class="post-toc-number">1.5.4.</span> <span class="post-toc-text">名字查找先于类型检查</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#虚函数与作用域-amp-amp-通过基类调用隐藏的虚函数"><span class="post-toc-number">1.5.5.</span> <span class="post-toc-text">虚函数与作用域&amp;&amp;通过基类调用隐藏的虚函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#覆盖重载的函数"><span class="post-toc-number">1.5.6.</span> <span class="post-toc-text">覆盖重载的函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#构造函数与拷贝控制"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">构造函数与拷贝控制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#虚析构函数"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">虚析构函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#虚析构函数将阻止合成移动操作"><span class="post-toc-number">1.6.1.1.</span> <span class="post-toc-text">虚析构函数将阻止合成移动操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#合成拷贝控制与继承"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">合成拷贝控制与继承</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#多重继承与虚继承"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">多重继承与虚继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多重继承"><span class="post-toc-number">1.7.1.</span> <span class="post-toc-text">多重继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多重继承的派生类从每个基类中继承状态"><span class="post-toc-number">1.7.1.1.</span> <span class="post-toc-text">多重继承的派生类从每个基类中继承状态</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#派生类构造函数初始化所有基类"><span class="post-toc-number">1.7.1.2.</span> <span class="post-toc-text">派生类构造函数初始化所有基类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#继承的构造函数与多重继承"><span class="post-toc-number">1.7.1.3.</span> <span class="post-toc-text">继承的构造函数与多重继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#析构函数与多重继承"><span class="post-toc-number">1.7.1.4.</span> <span class="post-toc-text">析构函数与多重继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#多重继承的派生类的拷贝与移动操作"><span class="post-toc-number">1.7.1.5.</span> <span class="post-toc-text">多重继承的派生类的拷贝与移动操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#类型转换与多个基类"><span class="post-toc-number">1.7.2.</span> <span class="post-toc-text">类型转换与多个基类</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#基于指针类型或引用类型的查找"><span class="post-toc-number">1.7.2.1.</span> <span class="post-toc-text">基于指针类型或引用类型的查找</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#多重继承下的类作用域"><span class="post-toc-number">1.7.3.</span> <span class="post-toc-text">多重继承下的类作用域</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#虚继承"><span class="post-toc-number">1.7.4.</span> <span class="post-toc-text">虚继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用虚基类"><span class="post-toc-number">1.7.4.1.</span> <span class="post-toc-text">使用虚基类</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#虚基类成员的可见性"><span class="post-toc-number">1.7.4.2.</span> <span class="post-toc-text">虚基类成员的可见性</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#构造函数与虚继承"><span class="post-toc-number">1.7.5.</span> <span class="post-toc-text">构造函数与虚继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#虚继承的对象的构造方式"><span class="post-toc-number">1.7.5.1.</span> <span class="post-toc-text">虚继承的对象的构造方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#构造函数与虚构函数的次序"><span class="post-toc-number">1.7.5.2.</span> <span class="post-toc-text">构造函数与虚构函数的次序</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#其他知识点"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">其他知识点</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-CPP面向对象之继承"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">C++面向对象之继承</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-11-26 19:06:55" datetime="2019-11-26T11:06:55.000Z"  itemprop="datePublished">2019-11-26</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/C/">C++</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="C-面向对象之继承"><a href="#C-面向对象之继承" class="headerlink" title="C++面向对象之继承"></a>C++面向对象之继承</h1><blockquote>
<p>参考书籍：《Primer C++, 5th》</p>
</blockquote>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><p>下面可能会用到的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUOTE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUOTE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Quote() = <span class="keyword">default</span>;</span><br><span class="line">    Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price) : bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><p>继承关系中，<strong>根节点的类通常会定义一个虚析构函数</strong>，即使该函数不执行任何实际操作也是如此</p>
<h4 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h4><p>基类中通常有两种成员函数：</p>
<ul>
<li><p>虚函数：基类希望其派生类进行覆盖的函数</p>
<ul>
<li><p>当使用<strong>指针或者引用</strong>调用虚函数时，该调用将被动态绑定；根据引用或指针所绑定的对象类型的不同，该调用可能执行基类的版本，也可能执行某个派生类的版本</p>
</li>
<li><p><strong>任何构造函数之外的非静态函数都可以是虚函数</strong></p>
</li>
<li><p>并且virtual只能出现在类内部的声明语句之前，而不能用在类外部的函数定义</p>
</li>
<li><p>如果基类把一个函数声明为虚函数，则该函数<strong>在派生类中隐式地也是虚函数</strong>（即使没有virtual关键字）</p>
</li>
</ul>
</li>
<li><p>普通函数：基类希望派生类直接继承而不要改变的函数</p>
<p>非虚成员函数的<strong>解析过程发生在编译时而非运行时</strong></p>
</li>
</ul>
<h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权限访问从基类继承而来的成员</p>
<p>（private、protected、public，过于简单，就不再赘述）</p>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须通过使用类派生列表明确指出它从哪些基类继承而来，每个基类前面可以使用三种访问说明符中的一个：public、protected、private</p>
<p><strong>三种继承方式不影响子类对父类的访问权限，子类对父类只看父类的访问控制权；</strong>三种继承方式都能访问父类中的public和protected成员</p>
<p>简单来说：访问说明符的作用是控制派生类从基类继承而来的成员是否对<strong>派生类的用户</strong>可见</p>
<p>如果一个派生是共有的，则<strong>基类的共有成员也是派生类接口的组成部分</strong>，我们能将共有派生类型的对象绑定到基类的引用或指针上</p>
<h4 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h4><p>派生类经常（但不总是）覆盖它继承的虚函数；如果没有覆盖，则该虚函数的行为类似于其他普通成员，派生类<strong>会直接继承其在基类中的版本</strong></p>
<h4 id="派生类对象及派生类向基类的类型转换"><a href="#派生类对象及派生类向基类的类型转换" class="headerlink" title="派生类对象及派生类向基类的类型转换"></a>派生类对象及派生类向基类的类型转换</h4><p>派生类对象包含多个组成部分：</p>
<ul>
<li>派生类自己定义的（非静态）成员的子对象</li>
<li>与派生类继承的基类对应的子对象（如果基类有多个，那这样的子对象也有多个）</li>
</ul>
<p>正因为如此，我们能够</p>
<ul>
<li>把派生类的对象当成基类对象来使用</li>
<li>能将基类的指针或引用绑定到派生类对象的基类部分上</li>
<li>可以把派生类对象指针用在需要基类指针的地方</li>
<li>可以把派生类对象或者派生类对象的引用用到需要基类引用的地方</li>
</ul>
<p>继承的关键所在：派生类对象中含有与基类对应的组成部分</p>
<h4 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h4><p><strong>每个类控制它自己的成员的初始化过程</strong>：意味着派生类不能直接初始化继承的基类成员，需要通过基类的构造函数初始化它的基类部分</p>
<p>我们可以通过构造函数初始化列表将实参传递给基类构造函数，同时用这个方法指定我们要调用的基类的构造函数版本，否则派生类对象的基类对象会像数据成员一样执行默认初始化</p>
<p>首先初始化基类的部分，然后<strong>按照声明的顺序</strong>依次初始化派生类的成员</p>
<h4 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h4><p>派生类可以访问基类的共有成员和受保护成员；派生类对象的作用域嵌套在基类的作用域之内，因此派生类的一个成员使用派生类其他成员的方式与使用基类成员的方式没有什么不同（除了基类private成员）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/Xczqr6LGanyIQVN.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h4><p>如果基类定义了一个静态成员，那么整个继承体系中该静态成员只存在唯一的实例；静态成员遵循通用的访问控制规则， 如果某静态成员是可访问的，那么我们既能通过基类（及其对象）、也能通过派生类（及其对象）使用它</p>
<h4 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h4><p>派生类的声明<strong>包含类名但是不包含它的派生列表</strong>；派生类列表与定义的其他细节必须与类的主体一起出现</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/tUPW17aKvqQzmsh.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>一条声明语句的目的是<strong>令程序知晓某个名字的存在</strong>以及<strong>该名字表示一个什么样的实体</strong>（如一个类、函数或者变量）</p>
<h4 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h4><p>一个类必须已经定义而非仅仅声明才能被用作基类：</p>
<ul>
<li>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必然要知道基类中定义了哪些成员</li>
<li>言外之意：一个类不能派生它本身</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/hvtalZF6kLwuqX2.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>每个类都会继承直接基类的所有成员；在整个继承体系中，<strong>最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象</strong></p>
<h4 id="防止继承发生"><a href="#防止继承发生" class="headerlink" title="防止继承发生"></a>防止继承发生</h4><p>C++11新标准：在<strong>类名后跟一个final</strong>，可以防止该类被继承</p>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><h4 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h4><ul>
<li>静态类型：编译时就确定的，它是变量声明时的类型或表达式生成的类型</li>
<li>动态类型：变量或表达式表示的内存中的对象的类型</li>
</ul>
<p><u>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致</u></p>
<h4 id="不存在从基类向派生类的隐式类型转换"><a href="#不存在从基类向派生类的隐式类型转换" class="headerlink" title="不存在从基类向派生类的隐式类型转换"></a>不存在从基类向派生类的隐式类型转换</h4><p>有一种特别的情况：<u>即使一个基类指针或者引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换</u></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/e9NKbaIrXP6SoRm.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或者引用的静态类型来腿短该转换是否合法</p>
<ul>
<li><p>如果基类中含有一个或多个虚函数，我们可以使用dynamic_case请求一个类型转换，该<strong>转换的安全检查将在运行时执行</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">Bulk_quote *bulkP = <span class="keyword">dynamic_cast</span>&lt;Bulk_quote *&gt;(itemP);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bulkP-&gt;isbn() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们已知某个基类向派生类的转换是安全的，则我们可以使用static_cast来<strong>强制覆盖掉编译器的检查工作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">Bulk_quote *bulkP = <span class="keyword">static_cast</span>&lt;Bulk_quote *&gt;(itemP);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bulkP-&gt;isbn() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="在对象之间不存在类型转换"><a href="#在对象之间不存在类型转换" class="headerlink" title="在对象之间不存在类型转换"></a>在对象之间不存在类型转换</h4><p>派生类向基类的自动类型转换只针对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换：</p>
<ul>
<li>初始化或赋值一个类类型对象时，实际上是在调用某个函数<ul>
<li>执行初始化时，调用的是构造函数</li>
<li>执行赋值操作时，调用的是赋值运算符</li>
</ul>
</li>
<li>这些成员函数通常都包含一个参数，该参数的类型是类类型的const版本的引用</li>
</ul>
<p>这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象，因为<strong>这些操作不是虚函数</strong>，因此：</p>
<ul>
<li>当我们给基类的构造函数传递一个派生类对象时，实际运行的<strong>构造函数是基类中定义的那个</strong>，显然该构造函数<strong>只能处理基类自己的成员</strong></li>
<li>当我们将一个派生类对象赋值给一个基类对象，则实际运行的<strong>赋值运算符也是基类中定义的那个</strong>，该运算符同样<strong>只能处理基类自己的成员</strong></li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/MvnOP58KS6wRXji.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h5 id="引入知识点：对象切片"><a href="#引入知识点：对象切片" class="headerlink" title="引入知识点：对象切片"></a>引入知识点：对象切片</h5><blockquote>
<p>原文链接：<a href="https://blog.csdn.net/beckle_ye/article/details/4700612" target="_blank" rel="noopener">https://blog.csdn.net/beckle_ye/article/details/4700612</a></p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/rJ1tRg8UufwXIzn.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<blockquote>
<p>If you upcast to an object instead of a pointer or reference, something will happen that may surprise you: the object is “sliced” until all that remains is the subobject that corresponds to the destination type of your cast.<br>—— Thinking In C++</p>
</blockquote>
<p>这句话的意思也就是说：在函数传参处理多态性时，如果一个派生类对象在UpCasting时，<strong>用的是传值的方式</strong>，而不是指针和引用，那么，这个派生类对象在UpCasting以后，将会被slice（切分）成基类对象，也就是说，派生类中独有的成员变量和方法都被slice掉了，只剩下和基类相同的成员变量和属性。这个派生类对象被切成了一个基类对象<br>如下例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> pname;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pet(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name) : pname(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pname; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">description</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is "</span> + pname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Pet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> favoriteActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;activity)</span><br><span class="line">        : Pet(name), favoriteActivity(activity) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">description</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Pet::name() + <span class="string">" likes to "</span> +</span><br><span class="line">               favoriteActivity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe</span><span class="params">(Pet p)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// Slices the object</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.description() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Pet <span class="title">p</span><span class="params">(<span class="string">"Alfred"</span>)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">d</span><span class="params">(<span class="string">"Fluffy"</span>, <span class="string">"sleep"</span>)</span></span>;</span><br><span class="line">    describe(p); <span class="comment">//正常调用基类函数</span></span><br><span class="line">    describe(d); <span class="comment">//对象切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is Alfred</span><br><span class="line">This is Fluffy</span><br></pre></td></tr></table></figure>

<p>发生对象切片前后的情况是这样的：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/lkCJV72QrxT9ApB.jpg" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>发生Object Slicing后，原先的虚函数Dog vptr表变成了Pet vptr，Dog的成员favoriteActivity也不存在了，其实这时候执行了一些步骤：</p>
<ul>
<li>在正常情况下，main函数中执行describe函数，在传递Dog对象d的时候，调用了Pet类的拷贝构造函数，相当于此时，在describe函数中的那个Pet类对象p是拷贝构造的结果，所以，跟Dog对象d已经没有了关系。所以，此时，p.description()执行的会是调用的基类也就是Pet类的description函数</li>
</ul>
<p>但是如果将description函数声明为纯虚函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> pname;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pet(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name) : pname(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pname; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">description</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>；</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Pet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> favoriteActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;activity)</span><br><span class="line">        : Pet(name), favoriteActivity(activity) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">description</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Pet::name() + <span class="string">" likes to "</span> +</span><br><span class="line">               favoriteActivity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe</span><span class="params">(Pet p)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// Slices the object</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.description() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Pet <span class="title">p</span><span class="params">(<span class="string">"Alfred"</span>)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">d</span><span class="params">(<span class="string">"Fluffy"</span>, <span class="string">"sleep"</span>)</span></span>;</span><br><span class="line">    describe(p); <span class="comment">//正常调用基类函数</span></span><br><span class="line">    describe(d); <span class="comment">//对象切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这时候Pet类型就不能被实例化，所以在全局的describe函数中不可能有者拷贝构造函数来实例化一个Pet类对象，此时编译器就会报错</p>
<p>这里就体现出了纯虚函数的一个重要意义：可以在编译期间<strong>避免对象切片</strong>，从而避免很多可能会出现的问题</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>使用基类的<strong>引用或指针调用</strong>一个虚成员函数时会执行动态绑定；如果我们通过一个<strong>具有普通类型的表达式</strong>调用虚函数时，在<strong>编译时</strong>就会将调用的版本确定下来</p>
<p>通常如果我们不使用某个函数，则无须为该函数提供定义；但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，否则会编译出错</p>
<h3 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h3><p>基类中的虚函数在派生类中隐含地也是一个虚函数</p>
<ul>
<li><p>当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配；</p>
</li>
<li><p>派生类中虚函数的返回类型也必须与基类函数匹配</p>
<ul>
<li><p>例外情况是，当类的虚函数返回类型是类本身的指针或引用时，该条规则失效</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A&amp; <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="function">B&amp; <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>即这样也是有效的</p>
</li>
</ul>
</li>
</ul>
<h3 id="final和override说明符"><a href="#final和override说明符" class="headerlink" title="final和override说明符"></a>final和override说明符</h3><ul>
<li><p>我们可以使用override显式指定派生类中的某个函数是覆盖基类对应的虚函数，如果override标记的派生类的函数是<strong>在基类中不存在</strong>，那么编译器将报错</p>
</li>
<li><p>如果我们把某个函数指定为final，则之后派生类中任何尝试覆盖该函数的操作将引发错误</p>
</li>
</ul>
<p>注意：final和override都<strong>只能用在虚函数上，</strong>而且也只能出现在形参列表（包括从const或引用修饰符）以及尾置返回类型之后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A &amp;<span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">B &amp;<span class="title">func</span><span class="params">()</span> override </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> final</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译器报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test01.cpp:<span class="number">18</span>:<span class="number">10</span>: error: ‘<span class="keyword">void</span> B::func2()’ marked ‘override’, but does <span class="keyword">not</span> override</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> override</span>;</span><br><span class="line">          ^~~~~</span><br><span class="line">Test01.cpp:<span class="number">19</span>:<span class="number">10</span>: error: ‘<span class="keyword">void</span> B::func3()’ marked ‘final’, but is <span class="keyword">not</span> <span class="keyword">virtual</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> final</span>;</span><br><span class="line">          ^~~~~</span><br></pre></td></tr></table></figure>

<h3 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h3><p>虚函数可以拥有默认实参，如果某次函数调用使用了默认实参，则该<strong>实参值由本次调用的静态类型决定</strong></p>
<p>如果通过基类的引用或者指针调用函数，则<strong>使用基类中定义的默认实参</strong>，即使实际运行的是派生类中的函数版本也是如此，因此传入派生类函数的将是基类函数定义的默认实参；如果派生类函数依赖不同的是实参，则程序结果将与我们的预期不同</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/GjEd7WuLAslzhyk.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h3 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h3><p>可以使用作用域运算符来使得虚函数的调用不要进行动态绑定，而是强迫执行虚函数的某个特定版本，这种调用将在编译时完成解析</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/HZ3sVWNPURl8dwp.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>一个纯虚函数无须给出定义，通过在函数体的位置（即声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数（=0只能出现在类内部的虚函数声明语句处）</p>
<p>当然我们也可以给纯虚函数提供定义，不过<strong>函数体必须定义在类的外部</strong>，也就是说，我们不能在类的内部为一个=0的函数提供函数体</p>
<h3 id="含有纯虚函数的类是抽象基类"><a href="#含有纯虚函数的类是抽象基类" class="headerlink" title="含有纯虚函数的类是抽象基类"></a>含有纯虚函数的类是抽象基类</h3><p>含有纯虚函数的类是抽象基类，抽象基类负责定义接口，后续的其他类可以覆盖该接口</p>
<p>我们不能创建一个抽象基类的对象</p>
<h2 id="访问控制与继承-1"><a href="#访问控制与继承-1" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><h3 id="受保护成员"><a href="#受保护成员" class="headerlink" title="受保护成员"></a>受保护成员</h3><p>受保护成员对于<strong>类的用户</strong>来说是不可访问的，派生类的成员或友元只能<strong>通过派生类对象</strong>来访问基类的受保护成员，派生类对于一个<u><strong>基类对象</strong>的受保护成员</u>没有任何访问特权</p>
<p>例子如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/28/aZWzN4d25eVxcgt.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p><strong>派生类B的成员函数无法通过基类对象来访问受保护成员</strong>，也就是说此时B是基类A的用户，用户代码B无法访问A的受保护成员，它只能通过this指针来访问</p>
<p>至于友元函数，则是书上的例子：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/28/MrZi38CY4RzgAB6.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h3 id="公有、私有和受保护继承"><a href="#公有、私有和受保护继承" class="headerlink" title="公有、私有和受保护继承"></a>公有、私有和受保护继承</h3><ul>
<li><p>派生访问说明符对于派生类的成员及友元能否访问其直接基类的成员没什么影响，对基类成员的访问权限只与基类中的访问说明符有关</p>
</li>
<li><p>派生访问说明符的目的是控制<strong>派生类用户</strong>（<strong>包括派生类的派生类在内</strong>）对于基类成员的访问权限</p>
<ul>
<li><p>这是私有继承的例子：</p>
<p><img src="https://i.loli.net/2019/11/28/im3hwSZuBGONYLq.png" alt></p>
</li>
<li><p>受保护继承的例子：</p>
<p><img src="https://i.loli.net/2019/11/28/sxpgqBD3GS8CtFW.png" alt></p>
</li>
</ul>
</li>
</ul>
<p>（<em>按照我个人的理解是这样的：私有派生将基类的成员继承过来之后，这部分基类的成员*</em>对外<strong>的访问说明符变成了私有private，即基类的成员不会成为</strong>派生类对外的接口*<em>，而对于派生类内部没有任何影响</em>）</p>
<h3 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h3><p>有三种情况：</p>
<ul>
<li><p>D<strong>公有地继承</strong>B，<strong>用户代码</strong>才能使用派生类向基类的转换；受保护或私有继承不行</p>
<p><img src="https://i.loli.net/2019/11/28/tR9NWrv3Lg7e1zZ.png" alt></p>
</li>
<li><p>不论D如果继承B，D的<strong>成员函数和友元</strong>都能使用派生类向基类的转换</p>
<p><img src="https://i.loli.net/2019/11/28/pEBSe6ZRH4cGvfW.png" alt></p>
</li>
<li><p>如果D<strong>公有地或受保护地</strong>继承B，则<strong>D的派生类</strong>的成员和友元可以使用D向B的类型转换；如果D私有继承B，则不能使用</p>
<p><img src="https://i.loli.net/2019/11/28/irgp9ow8BfPvX7u.png" alt></p>
</li>
</ul>
<p>书中给出了一个助记的方法：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/28/SvA6Kz81Oaq4UHd.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="关键概念：类的设计与受保护的成员"><a href="#关键概念：类的设计与受保护的成员" class="headerlink" title="关键概念：类的设计与受保护的成员"></a>关键概念：类的设计与受保护的成员</h4><p>（讲的太好了，没必要自己整理，故全文截图如下）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/28/1ep5UxZjVhXbETn.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/28/nls2PwDjX9YAKzg.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h3 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h3><p>友元关系<strong>既不能传递，也不能继承</strong></p>
<p>每个类负责控制自己的成员的访问权限，即使<strong>对于派生类的基类部分也是如此</strong>：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/28/IM8KaB95T4n27Fw.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>可以看到例子中，可以通过派生类B在基类A的友元类Test中访问基类A的私有成员，而直接使用B访问x则会报错，这是因为<strong>派生类B的基类子对象部分的访问控制依然是由基类来控制的</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/28/ktsLipHr4XJuM9q.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h3 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h3><p>可以通过using声明来改变派生类<strong>继承的某个名字</strong>的访问级别</p>
<p>通过在类内部使用using声明语句，我们可以将该类的直接或间接基类中的任何<strong>可访问成员</strong>（例如，非私有成员）标记出来：</p>
<ul>
<li>using语句出现在类的private部分：该名字只能被<strong>类的成员和友元</strong>访问</li>
<li>using语句出现在类的public部分：<strong>类的所有用户</strong>都能访问它</li>
<li>using语句出现在类的protected部分：该名字对于<strong>成员、友元和类的派生类</strong>是可访问的</li>
</ul>
<h3 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h3><p>默认情况下：</p>
<ul>
<li>class关键字定义的派生类是私有继承的</li>
<li>struct关键字定义的派生类是公有继承的</li>
</ul>
<p><em>ps：struct和class的唯一差别就是<strong>默认访问说明符和默认派生说明符</strong>；除此之外，再无其他不同之处</em></p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>每个类定义自己的作用域，当存在继承关系时，派生类的作用域嵌套在基类的作用域之内</p>
<p>如果一个名字在派生类的作用域内无法正确解析，则编译器将<strong>继续在外层的基类作用域</strong>中寻找该名字的定义</p>
<h3 id="在编译时进行名字查找"><a href="#在编译时进行名字查找" class="headerlink" title="在编译时进行名字查找"></a>在编译时进行名字查找</h3><p>一个对象、引用或指针的<strong>静态类型</strong>决定了该对象的哪些成员是可见的；即使静态类型和动态类型不一致，但是我们<strong>能够使用哪些成员依然是由静态类型决定</strong>的</p>
<p>（按我的个人理解，对象、引用或者指针的静态类型决定了当前作用域，其派生类的作用域对与当前的对象、引用或者指针是不可见的，如果存在继承链A -&gt; B -&gt; C，通过B调用时，查找将从B开始，然后再到A，而C的作用域对B是不可见的）</p>
<h3 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h3><p>定义在内层作用域（即派生类）中的名字将隐藏外层作用域（即基类）的名字</p>
<h3 id="通过作用域运算符来使用隐藏的成员"><a href="#通过作用域运算符来使用隐藏的成员" class="headerlink" title="通过作用域运算符来使用隐藏的成员"></a>通过作用域运算符来使用隐藏的成员</h3><p>作用域运算符<code>::</code>能<strong>覆盖掉原有的查找规则</strong>，并指示编译器从基类的作用域中开始查找名字</p>
<p><strong>名字查找的过程</strong>（以p-&gt;mem()或p.mem()为例）：</p>
<ul>
<li>首先确定p的静态类型</li>
<li>在p的静态类型对应的类中查找名字mem<ul>
<li>如果找不到，则依次在直接基类中不断查找直至到达继承链顶端；如果仍然找不到，编译器将报错</li>
<li>一旦找到名字mem，就进行常规的类型检查，以确认对于当前找到的名字mem，本次调用是否合法<ul>
<li>如果调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码<ul>
<li>如果mem是虚函数，且我们通过引用或指针进行调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型（即运行时的实际类型）</li>
<li>反之（mem不是虚函数或者我们是通过对象本身（而非引用或指针）进行调用），编译器将产生一个常规函数调用，并且这个调用是在编译期间就已经确定的</li>
</ul>
</li>
<li>如果调用非法，则编译器报错，并且<strong>不会再向上继续往基类中查找</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="名字查找先于类型检查"><a href="#名字查找先于类型检查" class="headerlink" title="名字查找先于类型检查"></a>名字查找先于类型检查</h3><ul>
<li>声明在内层作用域的函数并不会重载声明在外层作用域的函数</li>
<li>因此，定义派生类中的函数也不会重载其基类的成员</li>
</ul>
<p>如果派生类（内层作用域）的成员与基类（外层作用域）的某个成员<strong>同名</strong>，则派生类的成员将隐藏其作用域内该基类成员，<strong>即使派生类成员与基类成员的形参列表不一样</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/28/gZbcrlsvqL9QioM.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h3 id="虚函数与作用域-amp-amp-通过基类调用隐藏的虚函数"><a href="#虚函数与作用域-amp-amp-通过基类调用隐藏的虚函数" class="headerlink" title="虚函数与作用域&amp;&amp;通过基类调用隐藏的虚函数"></a>虚函数与作用域&amp;&amp;通过基类调用隐藏的虚函数</h3><p>如果派生类定义的函数名和基类的虚函数一样，但是形参列表不同，那么派生类的函数只是隐藏了基类中的同名虚函数，并没有覆盖，因此运行时发生动态绑定时，依然运行的是基类的虚函数版本</p>
<p>如下例的<code>bp2-&gt;fcn();</code>调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fcn()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D1::fcn(int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D1::f2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::fcn(int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::fcn()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::f2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base bobj;</span><br><span class="line">    D1 d1obj;</span><br><span class="line">    D2 d2obj;</span><br><span class="line">    Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;</span><br><span class="line">    bp1-&gt;fcn();</span><br><span class="line">    bp2-&gt;fcn();	<span class="comment">// 注意看这个调用，这是个虚调用，但是执行的是Base::fcn版本</span></span><br><span class="line">    bp3-&gt;fcn();</span><br><span class="line">    D1 *d1p = &amp;d1obj;</span><br><span class="line">    D2 *d2p = &amp;d2obj;</span><br><span class="line">    <span class="comment">// bp2-&gt;f2();</span></span><br><span class="line">    d1p-&gt;f2();</span><br><span class="line">    d2p-&gt;f2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="覆盖重载的函数"><a href="#覆盖重载的函数" class="headerlink" title="覆盖重载的函数"></a>覆盖重载的函数</h3><p>成员函数无论是否是虚函数都能被重载</p>
<p>如果派生类希望所有的重载版本对于它来说都是可见的，那么它就<strong>需要覆盖所有的版本，或者一个也不覆盖</strong>（因为如果只覆盖其中一个或几个，那么剩余的基类版本将被隐藏起来，不可访问）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/28/CoLEN8mxFh1KW5n.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>解决方案是：</p>
<ul>
<li><strong>为重载的成员提供一条using声明语句</strong>，它只需要指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以<strong>把该函数的所有重载版本实例添加到派生类作用域中</strong></li>
</ul>
<p>这样我们就无需覆盖基类中的每一个重载版本了，派生类只需要定义其特有的函数就可以了，而不用为继承而来的其他函数重新定义</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/29/2ZzSd4GhLKgOMqB.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>基类函数的每个实例在派生类中必须都是可访问的，如果有任意一个同名实例是private，则using声明语句将出错（protected是允许的，因为基类protected实例在派生类中可访问）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/29/2et6QdkF8JnuZI4.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个<strong>虚析构函数</strong>；如果指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除的对象的动态类型不符的情况，因此我们可以通过在基类中将析构函数定义为虚函数以确保执行正确的析构函数版本</p>
<p><strong>析构函数的析构属性能够被继承</strong>，无论派生类的析构函数是自己定义的还是编译器合成的</p>
<blockquote>
<p>C++三法则：如果需要析构函数，则一定需要拷贝构造函数和赋值操作符</p>
<p>如何理解这句话，首先，从“如果需要析构函数”这里我们知道，类中必然<strong>出现了指针类型的成员</strong>（<strong>否则不需要我们写析构函数，默认的析构函数就可以用了</strong>），所以，我们需要自己写析构函数来释放给指针所分配的内存来防止内存泄露，那么为什么说“一定需要拷贝构造函数和赋值操作符”呢，原因还是这样：类中出现了指针类型的成员。有指针类型的成员，我们必须防止浅拷贝问题，所以，一定需要拷贝构造函数和赋值操作符，这两个函数是防止浅拷贝问题所必须的</p>
<p>来源：<a href="https://blog.csdn.net/u010025211/article/details/48028571" target="_blank" rel="noopener">https://blog.csdn.net/u010025211/article/details/48028571</a></p>
</blockquote>
<p>但是对于基类来说，它总是需要一个析构函数，并且<strong>定义为虚函数，函数体为空</strong>，因此我们无法确定基类是否还需要赋值运算符或者拷贝构造函数</p>
<h4 id="虚析构函数将阻止合成移动操作"><a href="#虚析构函数将阻止合成移动操作" class="headerlink" title="虚析构函数将阻止合成移动操作"></a>虚析构函数将阻止合成移动操作</h4><p>基类需要一个虚析构函数导致：</p>
<ul>
<li>如果一个类定义了析构函数，即使是=default合成的版本，编译器也不会为这个类合成移动操作</li>
</ul>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><h2 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h2><p>多重继承的派生类继承了<strong>所有父类的属性</strong></p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul>
<li>关键字class对应的默认访问说明符是private，关键字struct对应的是public</li>
<li>多重继承的派生列表只能包含已经被定义过的类，而且这些类不能是final的</li>
<li>派生列表中，同一个基类只能出现一次</li>
</ul>
<h4 id="多重继承的派生类从每个基类中继承状态"><a href="#多重继承的派生类从每个基类中继承状态" class="headerlink" title="多重继承的派生类从每个基类中继承状态"></a>多重继承的派生类从每个基类中继承状态</h4><p>多重继承关系中，派生类的对象包含有每个基类的子对象，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span>:</span> <span class="keyword">public</span> ZooAnimal &#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span>:</span> <span class="keyword">public</span> Bear, <span class="keyword">public</span> Endangered &#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/GgkZVWIScfHp3xd.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="派生类构造函数初始化所有基类"><a href="#派生类构造函数初始化所有基类" class="headerlink" title="派生类构造函数初始化所有基类"></a>派生类构造函数初始化所有基类</h4><p>构造一个派生类的对象将同时构造并初始化它的所有基类子对象，多重继承的派生类的构造函数初始值只能初始化<strong>它的直接基类</strong>（例如Panda的直接基类是Bear和Endangered）</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/hyInO1iSfWBeQxG.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>基类的构造顺序与<strong>派生列表中基类的出现顺序</strong>保持一致，而与派生类构造函数初始值列表中的基类顺序无关</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/WQIKwVPa67NtE2v.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/vNV8IH3zrX4Jjla.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="继承的构造函数与多重继承"><a href="#继承的构造函数与多重继承" class="headerlink" title="继承的构造函数与多重继承"></a>继承的构造函数与多重继承</h4><p>C++11中允许派生类继承多个基类的构造函数，但是如果从多个基类中继承了相同的构造函数（形参列表完全相同），那么程序将报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base1() = <span class="keyword">default</span>;</span><br><span class="line">    Base1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);</span><br><span class="line">    Base1(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base2() = <span class="keyword">default</span>;</span><br><span class="line">    Base2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);</span><br><span class="line">    Base2(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tempCodeRunnerFile.cpp:20:18: error: ‘D1::D1(const string&amp;)’ inherited from ‘Base2’</span><br><span class="line">     using Base2::Base2;</span><br><span class="line">                  ^~~~~</span><br><span class="line">tempCodeRunnerFile.cpp:19:18: error: conflicts with version inherited from ‘Base1’</span><br><span class="line">     using Base1::Base1;</span><br></pre></td></tr></table></figure>

<p>此时必须在派生类中<strong>定义这个冲突构造函数的派生类自己的版本</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">    D1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)&#123;&#125;</span><br><span class="line">    D1() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：前面版本的D1之所以只对<code>D1::D1(const string&amp;)</code>报错，是因为D1中没有定义自己版本的构造函数，编译器为D1合成了默认的构造函数，<strong>覆盖了从Base1和Base2继承过来的冲突的默认版本的构造函数</strong>；但是现在这个版本定义了自己的<code>D1(const std::string &amp;){}</code>来解决冲突，导致编译器不会为D1合成默认构造函数，因此也需要为D1显式定义默认构造函数</p>
<h4 id="析构函数与多重继承"><a href="#析构函数与多重继承" class="headerlink" title="析构函数与多重继承"></a>析构函数与多重继承</h4><p>析构函数的调用顺序与构造函数相反：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure>

<h4 id="多重继承的派生类的拷贝与移动操作"><a href="#多重继承的派生类的拷贝与移动操作" class="headerlink" title="多重继承的派生类的拷贝与移动操作"></a>多重继承的派生类的拷贝与移动操作</h4><ul>
<li>多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或者赋值操作</li>
<li><strong>只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作</strong></li>
</ul>
<p>例如Panda调用合成版本的拷贝构造函数，首先调用Bear的拷贝构造函数拷贝Bear子对象部分，而Bear又会在执行之前调用呢ZooAnimal的拷贝构造函数拷贝ZooAnimal子对象部分，Bear子对象部分拷贝完成后，又会调用Endangered拷贝构造函数拷贝Endangered子对象部分，最后才调用Panda的合成构造函数拷贝Panda部分</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/gJ7axq3sVvUAQhj.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>



<h3 id="类型转换与多个基类"><a href="#类型转换与多个基类" class="headerlink" title="类型转换与多个基类"></a>类型转换与多个基类</h3><p>派生类有多个基类时，如果存在多个以基类为参数的重载函数，那么编译器会报错，因为<strong>编译器不会在派生类向基类的几种转换中进行比较和选择</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Panda.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Bear.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Endangered.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ZooAnimal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Endangered &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Panda p;</span><br><span class="line">    func(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译报错，程序有二义性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Test01.cpp: In function ‘int main(int, const char**)’:</span><br><span class="line">Test01.cpp:<span class="number">15</span>:<span class="number">11</span>: error: call of overloaded ‘func(Panda&amp;)’ is ambiguous</span><br><span class="line">     func(p);</span><br><span class="line">           ^</span><br><span class="line">Test01.cpp:<span class="number">6</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br><span class="line">Test01.cpp:<span class="number">8</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Endangered &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br><span class="line">Test01.cpp:<span class="number">10</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br></pre></td></tr></table></figure>

<p>注意：这个只限于直接基类为参数的重载，比如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Panda.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Bear.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Endangered.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ZooAnimal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span> &lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void func(Endangered &amp;) &#123; cout &lt;&lt; "func(Endangered &amp;) &lt;&lt; endl;"; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Panda p;</span><br><span class="line">    func(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承关系是ZooAnimal -&gt; Bear -&gt; Panda，输出结果是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">func(Bear &amp;)</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure>

<p>即会调用继承链上最近的那个重载版本</p>
<h4 id="基于指针类型或引用类型的查找"><a href="#基于指针类型或引用类型的查找" class="headerlink" title="基于指针类型或引用类型的查找"></a>基于指针类型或引用类型的查找</h4><p>通过基类指针来引用派生类对象时，如果析构函数是非虚函数，那么delete时无法调用派生类对象的析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooAnimal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal(<span class="comment">/* args */</span>);</span><br><span class="line">    ~ZooAnimal();</span><br><span class="line">&#125;;</span><br><span class="line">... ...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Panda p;</span></span><br><span class="line">    ZooAnimal *z_ptr = <span class="keyword">new</span> Panda();</span><br><span class="line">    <span class="comment">// func(p);</span></span><br><span class="line">    <span class="keyword">delete</span> z_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~ZooAnimal()</span><br><span class="line">    </span><br><span class="line">====================================================================</span><br><span class="line">====================================================================</span><br><span class="line">    </span><br><span class="line">class ZooAnimal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal(<span class="comment">/* args */</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~ZooAnimal();</span><br><span class="line">&#125;;</span><br><span class="line">... ...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Panda p;</span></span><br><span class="line">    ZooAnimal *z_ptr = <span class="keyword">new</span> Panda();</span><br><span class="line">    <span class="comment">// func(p);</span></span><br><span class="line">    <span class="keyword">delete</span> z_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure>

<p>在基类和派生类的析构函数都是虚函数时，无论使用哪个基类的指针来引用派生类对象，调用析构函数时，<strong>都是按照调用派生类对象析构函数的顺序执行</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~MI() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~MI()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 *pb1 = <span class="keyword">new</span> MI;</span><br><span class="line">    Base2 *pb2 = <span class="keyword">new</span> MI;</span><br><span class="line">    D1 *pd1 = <span class="keyword">new</span> MI;</span><br><span class="line">    D2 *pd2 = <span class="keyword">new</span> MI;</span><br><span class="line">    <span class="keyword">delete</span> pb2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pd2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line"></span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line"></span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br></pre></td></tr></table></figure>

<h3 id="多重继承下的类作用域"><a href="#多重继承下的类作用域" class="headerlink" title="多重继承下的类作用域"></a>多重继承下的类作用域</h3><p>单继承与多继承时的不同：</p>
<ul>
<li>单继承时，派生类的作用域嵌套在直接基类和间接基类的作用域中，查找过程<strong>沿着继承体系自底向上</strong>进行，直到找到所需的<strong>名字</strong>；派生类的名字将隐藏基类的<strong>同名成员</strong></li>
<li>多继承时，相同的查找过程将<strong>在所有直接基类中同时进行</strong>，如果<strong>名字</strong>在多个基类中都被找到，则对该名字的使用将具有二义性</li>
</ul>
<p>注意一点是，上面强调的是<strong>名字</strong>，即使派生类继承的两个函数形参列表不同也可能产生错误，因为它是<strong>按名字查找</strong>，<strong>先查找名字后进行类型检查</strong>，当编译器在两个作用域中同时发现了同名成员将直接报告一个调用二义性的错误</p>
<p>对一个派生类来说，从多个基类中分别继承同名的成员是完全合法的，只不过<strong>在使用这个名字时必须明确指出它的版本（这个如下面代码所示）</strong>；也就是说，派生仅是产生了潜在的二义性，只要没有调用就不会产生二义性（可以通过编译）；要想避免潜在的二义性，最好的办法是<strong>在派生类中为该函数定义一个新版本</strong>，或者<strong>通过using来显式使用确定的基类版本</strong>（例如using ZooAnimal::max_weight，或者using Endangered::max_weight）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~MI() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~MI()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="comment">// using D1::func1;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 *pb1 = <span class="keyword">new</span> MI;</span><br><span class="line">    Base2 *pb2 = <span class="keyword">new</span> MI;</span><br><span class="line">    D1 *pd1 = <span class="keyword">new</span> MI;</span><br><span class="line">    D2 *pd2 = <span class="keyword">new</span> MI;</span><br><span class="line">    <span class="keyword">delete</span> pb2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pd2;</span><br><span class="line">    MI mi;</span><br><span class="line">    mi.D1::func1();	<span class="comment">// 显式指定使用的名字的版本</span></span><br><span class="line">    				<span class="comment">// 如果直接使用mi.func1(),编译器会报错，因为func1出现二义性，即使参数列表不同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line"></span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line"></span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br></pre></td></tr></table></figure>

<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虽然派生列表中同一个基类只能出现一次，但是派生类可以多次继承同一个类；派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类</p>
<p>默认情况下，派生类中含有继承链上每个类对应的字部分，如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/SRzq3O6imcCPptu.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>从图中可以看到，B1(base)和B2(base)中包含的A(base)是两个不同子部分（从x值不同可以看出，并且A的<strong>构造函数也调用了两次</strong>）</p>
<p>有时候要实现多次出现的同一个基类的共享，可以使用<strong>虚继承</strong>：虚继承的目的是令某个类作出声明，承诺愿意共享它的基类（共享的基类子对象称为<strong>虚基类</strong>），这样不论虚基类在继承体系中出现了多少次，<strong>在派生类中都只包含唯一一个共享的虚基类子对象</strong>：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/MRUSntrFqzxQeLJ.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>从上图可以看出此时A基类子对象只有一个，<strong>A只调用了一次构造函数</strong></p>
<p>虚基类的缺点：必须在虚派生的真实需求出现之前就已经完成了虚派生的操作；在实际编程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题，它不会影响派生类本身，<strong>只会影响从制定了虚基类的派生类中进一步派生出来的类</strong>：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/26/gxDu6ZH7o28FTmY.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>例如Bear声明ZooAnimal为虚继承不会对Bear自身造成影响，但会对Panda造成影响</p>
<h4 id="使用虚基类"><a href="#使用虚基类" class="headerlink" title="使用虚基类"></a>使用虚基类</h4><p>指定虚基类的方式是在派生列表中添加关键字virtual，其中virtual和访问修饰符如public的顺序随意</p>
<p>virtual说明符表明了一种愿望：<strong>在后续的派生类中共享虚基类的同一份实例</strong></p>
<h4 id="虚基类成员的可见性"><a href="#虚基类成员的可见性" class="headerlink" title="虚基类成员的可见性"></a>虚基类成员的可见性</h4><ul>
<li>在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并且不会产生二义性</li>
<li>如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员</li>
<li>如果成员被多于一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本</li>
</ul>
<p>例如有如下继承关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2&#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>如果在D的对象中使用x，则有三种可能性：</p>
<ul>
<li><p>D1、D2都没有x的定义，此时x被解析为<strong>B的成员</strong>，此时不存在二义性</p>
</li>
<li><p>D1和D2只有其中一个有x的定义，此时依然没有二义性，<strong>派生类（D1或者D2）的x比共享虚基类B的x优先级更高</strong>（如下代码所示）</p>
<p><img src="https://i.loli.net/2019/11/27/gKDkOyYmW6idbsT.png" alt></p>
</li>
<li><p>D1、D2中均有x的定义，<strong>直接访问x将产生二义性</strong></p>
</li>
</ul>
<p>解决这种二义性的最好方法是<strong>在派生类中为成员自定义新的实例</strong></p>
<h3 id="构造函数与虚继承"><a href="#构造函数与虚继承" class="headerlink" title="构造函数与虚继承"></a>构造函数与虚继承</h3><p>在虚派生中，<u><em>虚基类是由最底层的派生类初始化的</em></u></p>
<h4 id="虚继承的对象的构造方式"><a href="#虚继承的对象的构造方式" class="headerlink" title="虚继承的对象的构造方式"></a>虚继承的对象的构造方式</h4><p>含有虚基类的对象的构造顺序与一般的顺序稍有区别：</p>
<ul>
<li>首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分</li>
<li>接下来按照直接基类在派生列表中出现的次序依次对其进行初始化</li>
</ul>
<p>也就是说：<strong>虚基类总是先于非虚基类构造，与他们在继承体系中的次序和位置无关</strong>；如下代码所示，B处于派生列表的第一个，但是虚基类A先于B进行初始化：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/HWQES617izRGBba.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>但是如果有多个虚基类的时候，虚基类的构造顺序则与派生列表的顺序有关，如下面代码所示，派生列表中B1是第一个直接基类，B1虚继承了A2，因此A2先于A1执行初始化：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/LkzYxlKp8vyaVme.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<h4 id="构造函数与虚构函数的次序"><a href="#构造函数与虚构函数的次序" class="headerlink" title="构造函数与虚构函数的次序"></a>构造函数与虚构函数的次序</h4><p>一个类可以有多个虚基类，这些虚的子对象按照它们在派生列表中出现的顺序依次从左向右构造：<strong>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类；如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类</strong></p>
<p>对于如下的继承体系：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/MWCjRQivtZoUBY6.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>它们的构造顺序如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/cj6vYmDgnwN8fAr.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>合成的拷贝和移动构造函数按照上面完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值；和往常一样，<strong>对象的销毁顺序与构造顺序正好相反</strong>：首先销毁TeddyBear，最后销毁ZooAnimal部分</p>
<p>最后来一个例子：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/uKTDBqH8k71PjLv.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>因为Class不是虚基类，因此<code>new Final</code>对象中含有多份Class的子对象部分，当使用Class类型指针绑定到<code>new Final</code>对象时，会造成Class基类的二义性，即控制台报错的：<code>ex18_29.cpp:15:21: error: ‘Class’ is an ambiguous base of ‘Final’</code></p>
<p>接下来我们修改一下，将其中一个Class申明为虚继承，另一个依然为普通继承：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2019/11/27/IXnykHGUbo2MhDq.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<p>可以看到，Class还是存在二义性：<code>ex18_29.cpp:15:21: error: ‘Class’ is an ambiguous base of ‘Final’</code></p>
<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2>
        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2020-01-07T04:04:48.950Z" itemprop="dateUpdated">2020-01-07 12:04:48</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2019/11/26/CPP面向对象之继承/" target="_blank" rel="external">http://chphong.github.io/2019/11/26/CPP面向对象之继承/</a>
        
    </div>
    
    <footer>
        <a href="http://chphong.github.io">
            <img src="/img/avatar.jpg" alt="steve_chph">
            steve_chph
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/继承/">继承</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面向对象/">面向对象</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://chphong.github.io/2019/11/26/CPP面向对象之继承/&title=《C++面向对象之继承》 — 至繁归于至简 - chph's blog&pic=http://chphong.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://chphong.github.io/2019/11/26/CPP面向对象之继承/&title=《C++面向对象之继承》 — 至繁归于至简 - chph's blog&source=the blog website of steve_chph, steve_chph的个人博客网站" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://chphong.github.io/2019/11/26/CPP面向对象之继承/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《C++面向对象之继承》 — 至繁归于至简 - chph's blog&url=http://chphong.github.io/2019/11/26/CPP面向对象之继承/&via=http://chphong.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://chphong.github.io/2019/11/26/CPP面向对象之继承/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/11/29/编译原理课堂笔记/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">编译原理课堂笔记</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/11/17/操作系统-进程管理/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">操作系统-进程管理</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢你~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>steve_chph &copy; 2015 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://chphong.github.io/2019/11/26/CPP面向对象之继承/&title=《C++面向对象之继承》 — 至繁归于至简 - chph's blog&pic=http://chphong.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://chphong.github.io/2019/11/26/CPP面向对象之继承/&title=《C++面向对象之继承》 — 至繁归于至简 - chph's blog&source=the blog website of steve_chph, steve_chph的个人博客网站" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://chphong.github.io/2019/11/26/CPP面向对象之继承/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《C++面向对象之继承》 — 至繁归于至简 - chph's blog&url=http://chphong.github.io/2019/11/26/CPP面向对象之继承/&via=http://chphong.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://chphong.github.io/2019/11/26/CPP面向对象之继承/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACNUlEQVR42u3azW6DQAxFYd7/palUdVGJhJxrQ1U8Z1ZRQoBvFpZ/Ztvw2r/X78/H9e5Xcrfjf7c7lgwZMh7L2E/X8WHvXuj8Vc7B5JsPGyRDhowFGDzIpgGaYEg4/nB/GTJkyAgDKAnc/J4yZMiQkQZclKiBgpanhjJkyJDBA+V5akiuJyH49lpchgwZD2TUBgN/8/n2+YYMGTL+PWMPVxpMybM67/NzBxkyZIxmkNY8KUqvHXzWyloZMmTMZqRHtXhBS5K8/rNkyJAxm0GSuVorv9MyizdIhgwZoxlpsz593f4BMj5ykCFDxgqM9FhYJ1DyordVi8uQIWMQgydhnZfgw8v0ehkyZMxmcGVtb/jYkm/ii19lyJAxmnHV43kArZW+aGAgQ4aMBRikBOXFKh9Spv+VIUPGaozaSDLl1QYGBNaarMqQIeMhjE7LPg2+/P5p0ilDhozZjLuHjukAsnUgTIYMGUMZafrVaZzxtloxcZQhQ8YyjM7ja8MDnkqiilyGDBnjGJ0EjuxQ7cq4MSdDhowFGPx107Svdj15erHdJkOGjAcy0kEmL3GvDfFBu02GDBnjGHu4eEsuDay8bH7xXxkyZIxm1FrwPLDW7pAmizJkyFiBkR6q4CG1tpfpwQ4ZMmSsw7hqoFhLNGtBH40HZMiQsRijn+TxUUHrzIgMGTKWZ9RgtY0ItkOGDBkLMEgRy4NmMb3Dg9V4kClDhoyHMzqDgU67LT3+dUExLEOGjOcxvgDlN9E/yFSRGgAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'chph个人博客';
            clearTimeout(titleTime);
        } else {
            document.title = 'Welcome to chph's blog';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
