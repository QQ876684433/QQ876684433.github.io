<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>至繁归于至简 - chph&#39;s blog</title>
  
  <subtitle>steve_chph personal website</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://QQ876684433.github.io/"/>
  <updated>2019-10-24T01:51:45.876Z</updated>
  <id>http://QQ876684433.github.io/</id>
  
  <author>
    <name>steve_chph</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统-存储管理</title>
    <link href="http://QQ876684433.github.io/2019/10/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://QQ876684433.github.io/2019/10/23/操作系统-存储管理/</id>
    <published>2019-10-23T13:23:37.000Z</published>
    <updated>2019-10-24T01:51:45.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li></ul></blockquote><p>内存空间一般分为两部分：</p><ul><li>系统区：存放操作系统内核程序和数据结构等</li><li>用户区：存放应用程序和数据</li></ul><p>有效的存储管理也是多道程序设计技术的关键支撑，存储管理包含以下功能：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/4QPXOMmnc6V8RBg.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="存储器工作原理"><a href="#存储器工作原理" class="headerlink" title="存储器工作原理"></a>存储器工作原理</h2><h3 id="存储器层次"><a href="#存储器层次" class="headerlink" title="存储器层次"></a>存储器层次</h3><p>目前计算机均采用层次结构的存储子系统，自上至下依次为：寄存器、缓存、内存、磁盘、磁带5层。其中<strong>寄存器、缓存和内存是操作系统存储管理的管辖范畴</strong>；磁盘和磁带属于文件管理和设备管理的管辖对象。</p><h3 id="地址转换与存储保护"><a href="#地址转换与存储保护" class="headerlink" title="地址转换与存储保护"></a>地址转换与存储保护</h3><p>源程序在计算机上运行涉及的过程：</p><ul><li>编译程序或汇编程序处理源程序并生成目标代码（程序）</li><li>链接程序将目标代码链接为一个<strong>可重定位代码（程序）</strong>，此时程序处在<strong>逻辑地址空间</strong>中</li><li>装载程序将可执行代码装入物理地址空间，直到此时程序才能运行</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/jqZwMSNIoas5r3x.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h4><p>程序编译指的是编译程序（compiler）或汇编程序（assembly）的处理生成目标模块（目标代码）。一个程序可以由独立编写的且具有不同功能的多个源程序模块组成，由于模块包含外部引用，即指向<strong>其他模块中的数据或指令地址</strong>，或包含<strong>对库函数的引用</strong>，<strong>编译程序或汇编程序负责记录引用发生的位置</strong>，其处理结果将产生相应的多个目标模块，每个目标模块都附有<strong>供引用使用的内部符号表和外部符号表</strong>。符号表中依次给出<strong>各个符号名及在本目标模块中的名字地址</strong>，在模块<strong>被链接时</strong>进行转换</p><h4 id="程序链接"><a href="#程序链接" class="headerlink" title="程序链接"></a>程序链接</h4><p>链接程序（linker）的作用是<strong>根据目标模块之间的调用和依赖关系，将主模块、被调模块以及所用到的库函数装配和链接成一个完整的可装载执行模块</strong>。</p><p>根据程序链接发生的时刻和链接的方式，程序链接可以分成以下三种方式：</p><ul><li><p>静态链接</p><p>在程序装载到内存和运行之前，就已经将它的所有目标模块及所需要的库函数进行链接和装配成一个<strong>完整的可执行程序</strong>且此后不再拆分</p><blockquote><p>简单来说就是在链接阶段，将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件，该可执行文件可能会比较大</p><ul><li><p>这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行</p></li><li><p>缺点是：文件太大，一个全静态方式生成的简单print文件都有857K。而动态链接生成的一样的可执行文件却只要8.４Ｋ</p></li></ul><p>reference：<a href="https://blog.csdn.net/freestyle4568world/article/details/49817799" target="_blank" rel="noopener">https://blog.csdn.net/freestyle4568world/article/details/49817799</a></p></blockquote><p>可重定位目标程序：</p><p><img src="https://i.loli.net/2019/10/23/sSd2pJmYozEWDj5.png" alt></p></li><li><p>动态链接</p><p>程序在装入内存前并未事先进行程序各目标模块的链接，而是在程序装载时一边装载一遍链接，生成一个可执行程序。</p><ul><li>在装载目标模块时，若发生外部模块调用，将引发外部目标模块的搜索、装载和链接</li><li>同时若发现所需某部目标模块已在内存，可<strong>直接进行链接且无需再次装载，支持目标模块的共享</strong></li></ul></li><li><p>运行时链接</p><p>将某些目标模块或库函数的链接推迟到执行时才进行。在程序执行过程中，若发现被调用模块或库函数尚未链接，先在内存中进行搜索以查看其是否装入内存</p><ul><li>若已装入，则直接将其链接到调用者程序中</li><li>否则进行该模块在外存上的搜索，以及装入内存和进行链接，生成一个可执行程序</li></ul><p>运行时链接的好处：</p><ul><li>避免事先无法知道本次要运行哪些目标模块</li><li>避免程序执行过程中不被调用的某些目标模块在执行前进行链接和装载而引起的开销，提高系统资源利用率和系统效率</li></ul><p>采用运行时链接时，程序执行所需要的库函数所在的部分目标模块是伴随着其被调用才动态进行装载和链接。具体的做法是：<u>不必将程序所需的外部函数代码从系统库中提取出并链入目标模块中，而仅仅是在程序调用处登记调用信息，记录函数名及入口号，形成调用链接；一旦函数库调入内存后，就可以确定所调函数在内存的物理地址</u>。</p></li></ul><h4 id="程序装载"><a href="#程序装载" class="headerlink" title="程序装载"></a>程序装载</h4><p>装载程序（loader）把可执行程序装入内存的方式有三种：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/UlP8L6R12y3XbVC.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>磁盘中的装载模块使用的是逻辑地址，逻辑地址的集合称为进程的<strong>逻辑地址空间</strong>：</p><ul><li>逻辑地址空间可以是一维的，这时逻辑地址限制在从0开始顺序排序的地址空间内</li><li>逻辑地址空间也可以是二维的，这时整个程序被分为若干段，每段都有不同段号，<strong>段内地址从0开始顺序编址</strong></li></ul><p>物理内存从统一的基地址开始顺序编址的存储单元称为物理地址或绝对地址，物理地址的总体构成物理地址空间</p><p><strong>可执行程序逻辑地址转换（绑定）为物理地址的过程称为地址重定位、地址映射或地址转换</strong>，基于程序装入方式的不同，可以区分三种地址重定位：</p><ul><li><p>静态地址重定位</p><p><img src="https://i.loli.net/2019/10/23/yAb246iZNMTedSD.png" alt></p></li><li><p>动态地址重定位</p><p><img src="https://i.loli.net/2019/10/23/fL1H2gUhyRE9CMT.png" alt></p><p><img src="https://i.loli.net/2019/10/23/KgY5IQmcdjeyVsH.png" alt></p></li><li><p>运行时链接地址重定位</p><p><img src="https://i.loli.net/2019/10/23/eQkOVLR5i8HtPh9.png" alt></p></li></ul><p>为了允许程序因对换或空闲区收集而被移动（会导致正在执行的程序在不同时刻处于内存的不同位置），必须使用动态地址重定位。动态地址重定位要借助于<strong>硬件地址转换机制</strong>来实现，<strong>重定位寄存器的内容通常保护在进程控制块中</strong>，每当执行进程上下文切换时，当前运行进程的重定位寄存器中的内容与其他信息被一起保护起来，新进程的重定位寄存器的内容会被恢复，这样进程就在上次中断的位置恢复运行，所使用的是与上次在此位置的同样的内存基地址。</p><p>存储保护涉及防止地址越界和控制正确存取：</p><ul><li>地址越界保护：无论采用何种地址重定位方式，通常进程运行时产生的所有内存访问地址都应进行检查，确保进程仅访问自己的内存区，以免破坏其他进程的内存区</li><li>信息存取保护：进程在访问分配给自己的内存区时，要对访问权限进行检查，如允许读、写、执行等，从而确保数据的安全性和完整性，防止有意或无意的误操作而破坏内存信息</li></ul><h2 id="连续存储管理"><a href="#连续存储管理" class="headerlink" title="连续存储管理"></a>连续存储管理</h2><h3 id="固定分区存储管理"><a href="#固定分区存储管理" class="headerlink" title="固定分区存储管理"></a>固定分区存储管理</h3><p>固定分区又称为静态分区模式，基本思想是：内存空间被划分为<strong>数目固定不变的分区，各分区大小不等，每个分区只装入一个作业</strong>，若多个分区中都装有作业，则它们可以并发执行。</p><p>为了说明各分区分配和使用情况，需要设置一张内存分配表，记录内存中划分的分区及其使用情况。<strong>内存分配表指出各分区起始地址和长度</strong>，占用标志用来指示此分区是否被使用，当其值为0时，表明此分区尚未被占用。</p><p>固定分区管理的一项任务是何时及如何把内存空间划分成分区。这项工作通常由系统管理员和操作系统初始化模块协同完成。系统初次启动时，管理员根据当天作业情况把内存划分成大小不等但数目固定的分区。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/vj71eTxgNHQmV4u.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="排队策略"><a href="#排队策略" class="headerlink" title="排队策略"></a>排队策略</h4><p>作业进入固定分区的两种排队策略：</p><ul><li>一是每个分区有单独的作业等待队列，调度程序选中作业后，创建用户进程并将其排入一个<strong>能够装入它的最小分区的进程等待队列尾部</strong>，当此分区空闲时，就装入队首进程执行<ul><li>好处是可以使装入分区浪费的空间最小</li><li>但是如果等待处理的作业大小很不均匀，将导致分区有的空闲而有的忙碌</li></ul></li><li>二是<strong>所有等待处理的作业排成一个等待队列</strong>，每当有分区空闲时，就从队首依次搜索分区长度能够容纳的作业以便装入执行；为了防止小作业占用大分区，也可以搜索<strong>分区长度能够容纳的最大作业</strong>装入执行</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>实现简单，对于程序大小和出现频率已知的情形还是比较合适的</li><li>解决单道程序运行在并发环境下不能与CPU速度匹配的问题</li><li>解决了单道程序运行时内存空间利用率低的问题</li></ul><p>缺点：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/7ctDUWL4kFdGoBe.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;存储管理&quot;&gt;&lt;a href=&quot;#存储管理&quot; class=&quot;headerlink&quot; title=&quot;存储管理&quot;&gt;&lt;/a&gt;存储管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="存储管理" scheme="http://QQ876684433.github.io/tags/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-10-22）</title>
    <link href="http://QQ876684433.github.io/2019/10/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-10-22%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/22/数据库课堂笔记（2019-10-22）/</id>
    <published>2019-10-22T05:52:13.000Z</published>
    <updated>2019-10-23T07:12:45.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-10-22）"><a href="#数据库课堂笔记（2019-10-22）" class="headerlink" title="数据库课堂笔记（2019-10-22）"></a>数据库课堂笔记（2019-10-22）</h2><h3 id="Ch4-Object-Relational-SQL-Oracle"><a href="#Ch4-Object-Relational-SQL-Oracle" class="headerlink" title="Ch4. Object-Relational SQL (Oracle)"></a>Ch4. Object-Relational SQL (Oracle)</h3><h4 id="Object-Types（对象类型）"><a href="#Object-Types（对象类型）" class="headerlink" title="Object Types（对象类型）"></a>Object Types（对象类型）</h4><h5 id="类型的循环嵌套定义"><a href="#类型的循环嵌套定义" class="headerlink" title="类型的循环嵌套定义"></a>类型的循环嵌套定义</h5><p>对象类型(object type)不能嵌套定义， 但 REF 关系可以实现嵌套引用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">type</span> police_officer_t <span class="keyword">as</span> <span class="keyword">object</span></span><br><span class="line">(</span><br><span class="line">    pol_person person_t,</span><br><span class="line">    badge_number <span class="built_in">integer</span>,</span><br><span class="line">    partner <span class="keyword">ref</span> police_officer_t</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="REF-的其它约束"><a href="#REF-的其它约束" class="headerlink" title="REF 的其它约束"></a>REF 的其它约束</h5><ul><li><p>两张表之间的相互REF关系的定义</p><p><img src="https://i.loli.net/2019/10/22/3cR6MzrC4h9Fj2t.png" alt></p></li><li><p>两个具有相互REF关系的表/类型的删除</p><p><img src="https://i.loli.net/2019/10/22/f8vQaitUkF5hMVH.png" alt></p></li><li><p>REF属性数据的加载</p><p><img src="https://i.loli.net/2019/10/22/ojbT5m3XgcLidSN.png" alt></p><p><img src="https://i.loli.net/2019/10/22/5QTBnZmsLpKNqdV.png" alt></p></li></ul><h4 id="Collection-Types（集合类型）"><a href="#Collection-Types（集合类型）" class="headerlink" title="Collection Types（集合类型）"></a>Collection Types（集合类型）</h4><p>集合类型允许我们将多个值（即值的集合）存放到一行记录的某一列中，在Oracle中，集合类型有以下两种：</p><ul><li><p>表类型（Table Types，嵌套表）</p></li><li><p>数组类型（Array Types）</p><p>其中数组类型中存放的元素是具有相同的类型（the element type）的</p></li></ul><h5 id="表类型和嵌套表（Table-Types-and-Nested-Tables）"><a href="#表类型和嵌套表（Table-Types-and-Nested-Tables）" class="headerlink" title="表类型和嵌套表（Table Types and Nested Tables）"></a>表类型和嵌套表（Table Types and Nested Tables）</h5><p>创建一个<strong>表类型（table type）</strong>的方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> dependents_t <span class="keyword">AS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> person_t;</span><br></pre></td></tr></table></figure><p>这样就可以通过表类型（dependents_t）来定义新的表，而dependents_t则形成一个嵌套表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employees (</span><br><span class="line">    eid <span class="built_in">int</span>,</span><br><span class="line">    eperson person_t,</span><br><span class="line">    dependents dependents_t,</span><br><span class="line">    primary <span class="keyword">key</span> (eid)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如上，dependents属性的类型就是一个表类型（dependents_t），它是employees的嵌套表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/22/rXlRbBpLfgZJNEu.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="嵌套表的访问"><a href="#嵌套表的访问" class="headerlink" title="嵌套表的访问"></a>嵌套表的访问</h5><ul><li><p>对嵌套表进行访问时，如果需要对表类型属性进行子查询，那么需要使用<strong>转换函数：table(…)</strong>：</p><p><img src="https://i.loli.net/2019/10/22/ywjF8oRn42peHrc.png" alt></p></li><li><p>嵌套表属性不能直接使用统计函数，比如count(…)等，同样需要使用转换函数table(…)</p><p><img src="https://i.loli.net/2019/10/22/MUkJDqIZuyFw9Ng.png" alt></p></li><li><p>Oracle 数据库没有提供 nested table 的相等比较运算，但是提供了单个对象的相等比较功能</p><p><img src="https://i.loli.net/2019/10/22/VXsY1jQ8m4TPZdf.png" alt></p></li><li><p>Oracle是支持嵌套表与表自身的联接查询的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid, d.ssno</span><br><span class="line"><span class="keyword">from</span> employees e, <span class="keyword">table</span>(e.dependents) d</span><br></pre></td></tr></table></figure></li></ul><h5 id="Oracle的外联接（outer-join）"><a href="#Oracle的外联接（outer-join）" class="headerlink" title="Oracle的外联接（outer join）"></a>Oracle的外联接（outer join）</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/hehaiyang/p/4745897.html" target="_blank" rel="noopener">https://www.cnblogs.com/hehaiyang/p/4745897.html</a></p></blockquote><p>对于外连接， 也可以使用“(+) ”来表示。 关于使用（+）的一些注意事项：</p><ol><li><strong>（+）操作符只能出现在WHERE子句中</strong>，并且不能与OUTER JOIN语法同时使用。</li><li>当使用（+）操作符执行外连接时，如果在WHERE子句中包含有多个条件，则必须在所有条件中都包含（+）操作符。</li><li>（+）操作符只适用于列，而不能用在表达式上。</li><li>（+）操作符不能与OR和IN操作符一起使用。</li><li>（+）操作符只能用于实现左外连接和右外连接，而<strong>不能用于实现完全外连接</strong>。</li></ol><p>用（+）来实现， 这个+号可以这样来理解： <strong>+ 表示补充，即哪个表有加号，这个表就是匹配表</strong>。如果加号写在右表，左表就是全部显示，所以是<strong>左连接</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> t_A a,t_B b <span class="keyword">where</span> a.id=b.id(+);</span><br></pre></td></tr></table></figure><p>如果加号写在左表，右表就是全部显示，所以是<strong>右连接</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> t_A a,t_B b <span class="keyword">where</span> a.id(+)=b.id;</span><br></pre></td></tr></table></figure><p>而对于全外联接，左表和右表都不做限制，所有的记录都显示，两表不足的地方均为NULL。 <strong>全外连接不支持（+）写法</strong>。</p><h5 id="嵌套游标（Nested-Cursors）"><a href="#嵌套游标（Nested-Cursors）" class="headerlink" title="嵌套游标（Nested Cursors）"></a>嵌套游标（Nested Cursors）</h5><p>可以使用嵌套游标来实现对嵌套表的查询，例如对于普通的查询操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid, d.ssno <span class="keyword">as</span> dep_sso</span><br><span class="line"><span class="keyword">from</span> employees e, <span class="keyword">table</span>(e.dependents) d</span><br><span class="line"><span class="keyword">where</span> d.age &lt; <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>可以使用嵌套游标来实现相同的功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid,</span><br><span class="line">    <span class="keyword">cursor</span> ( <span class="keyword">select</span> d.ssno <span class="keyword">as</span> dep_ssno</span><br><span class="line">        <span class="keyword">from</span> <span class="keyword">table</span>(e.dependents) d</span><br><span class="line">        <span class="keyword">where</span> d.age &lt; <span class="number">16</span>) dep_tab</span><br><span class="line"><span class="keyword">from</span> employees e;</span><br></pre></td></tr></table></figure><p>另外，嵌套游标也可以用来实现对嵌套表属性的统计功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> eid,</span><br><span class="line">    <span class="keyword">cursor</span> ( <span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">table</span>(e.dependents) )</span><br><span class="line"><span class="keyword">from</span> employees e;</span><br></pre></td></tr></table></figure><p>但是似乎cursor是多余的，因为以下两种方式也可以对嵌套表属性进行统计：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/3COt2zYwkmI5XRL.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="Array-Types（数组类型）"><a href="#Array-Types（数组类型）" class="headerlink" title="Array Types（数组类型）"></a>Array Types（数组类型）</h4><p>嵌套表类型（Nested Table）和数组类型（VARRAY）的对比：</p><table><thead><tr><th align="center"></th><th align="center">Nested table</th><th align="center">VARRAY</th></tr></thead><tbody><tr><td align="center">成员的排列次序</td><td align="center">无序</td><td align="center">有序</td></tr><tr><td align="center">成员的最大数目</td><td align="center">没有限制</td><td align="center">确定的值</td></tr><tr><td align="center">成员的存储组织</td><td align="center">单独的存储表</td><td align="center">直接存储在原表中</td></tr></tbody></table><p>两者在访问模式上的区别：</p><ul><li>可以对嵌套表属性执行insert操作， 或通过update操作修改其成员的取值</li><li>但对于 VARRAY 属性则不能执行上述的插入或修改操作， 只能通过<strong>update语句修改整个 VARRAY 属性</strong>的取值</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Makefile学习笔记</title>
    <link href="http://QQ876684433.github.io/2019/10/21/Makefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://QQ876684433.github.io/2019/10/21/Makefile学习笔记/</id>
    <published>2019-10-21T02:08:59.000Z</published>
    <updated>2019-10-21T02:08:59.036Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统-中断技术</title>
    <link href="http://QQ876684433.github.io/2019/10/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E6%8A%80%E6%9C%AF/"/>
    <id>http://QQ876684433.github.io/2019/10/17/操作系统-中断技术/</id>
    <published>2019-10-17T12:57:02.000Z</published>
    <updated>2019-10-18T07:44:33.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中断技术"><a href="#中断技术" class="headerlink" title="中断技术"></a>中断技术</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li><li>Linux Kernel Teaching - <a href="https://linux-kernel-labs.github.io/master/lectures/interrupts.html" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/lectures/interrupts.html</a></li></ul></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​        每当应用程序执行系统调用要求获得操作系统服务、I/O设备报告传输情况，或者产生各种内部和外部事件时，都需要通过中断机制产生中断信号并启动操作系统内核工作，可以说，操作系统是由“<strong>中断驱动</strong>”的。最初中断技术仅作为设备向CPU报告I/O操作情况的一种手段，以免CPU因不断地轮训设备而耗费CPU时间，<strong>中断的出现解决了主机和设备的并行性问题</strong>。</p><p>​        <strong>中断（interrupt）</strong>指的是在程序执行过程中遇到急需处理的事件时，暂时终止现行程序在CPU上的运行，转而执行相应的事件处理程序，待处理完成后再<u>返回断点</u>或<u>调度其他程序执行</u>的过程。</p><p>​        不同的计算机系统中通常有不同的中断源和中断装置，但是它们都有一个共性：中断事件发生后，中断装置能改变处理器内操作的执行顺序。</p><h2 id="中断源分类"><a href="#中断源分类" class="headerlink" title="中断源分类"></a>中断源分类</h2><h3 id="硬中断"><a href="#硬中断" class="headerlink" title="硬中断"></a>硬中断</h3><p>由硬件发出或产生的中断称为硬中断，按照硬中断事件的来源和实现手段，可以将硬中断划分为外中断和内中断</p><h4 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h4><p>又称为<strong>中断</strong>或<strong>异步中断</strong>，是指<strong>来自处理器之外的中断信号</strong>，包括：时钟中断、键盘中断、它机中断、外部设备中断等。外中断又分为</p><ul><li><strong>可屏蔽中断</strong></li><li><strong>不可屏蔽中断</strong></li></ul><p>各个中断具有不同的中断优先级，表示事件的紧急程度，在处理高一级中断时，往往会部分或者全部屏蔽低级中断。</p><h4 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h4><p>又称为<strong>异常（exception）</strong>或<strong>同步中断</strong>，是指<strong>来自处理器内部的中断信号</strong>，通常是由于在程序执行过程中，发现与<strong>当前指令</strong>关联的、不正常的或错误的事件。内中断可被细分为：</p><ul><li>访管中断，由执行系统调用引起</li><li>硬件故障中断，如电源失效、奇偶校验错误、总线超时等</li><li>程序性异常，如非法操作、地址越界、页面故障、调试指令、除数为0和浮点数溢出等</li></ul><p>这些事件都由<strong>异常处理程序</strong>处理，并且通常依赖于执行程序的当前现场。<strong>内中断不能被屏蔽，一旦出现应立即予以响应并进行处理</strong>，而异常处理程序运行时是否屏蔽外部中断或屏蔽哪些中断，可根据异常处理的需要来设定</p><h4 id="中断和异常的区别"><a href="#中断和异常的区别" class="headerlink" title="中断和异常的区别"></a>中断和异常的区别</h4><ul><li><p>中断由与当前运行程序无关的中断信号触发的，系统不能确定中断事件的发生时间，故<strong>中断与CPU是异步的</strong>，CPU对中断的响应完全是被动的。<strong>中断的发生与CPU当前状态无关</strong>，既可以发生在用户态也可以发生在内核态，因为无论是用户态还是内核态，都需要处理外部设备发来的中断请求。一般来说，<strong>中断处理程序所提供的服务不是当前进程所需要的</strong>，如时钟中断、磁盘中断等</p><p>异常是由<strong>CPU控制单元</strong>产生的，源于<strong>现行程序执行指令过程中检测到的例外</strong>（exception）。<strong>异常与CPU是同步的</strong>，允许指令在执行过程期间响应异常，而且允许多次响应异常，大部分异常发生在用户态，而<strong>内核态唯一发生的异常是“缺页异常”</strong></p></li><li><p>“中断”应该被快速处理以便及时响应其他中断信号，所以<strong>中断处理程序处理过程中是不能阻塞的</strong></p><p>“异常”处于被打断的当前进程上下文中，所提供的服务是当前进程所需要的，所以<strong>异常处理程序处理过程中是可以阻塞的</strong></p></li><li><p>中断允许发生嵌套，但异常大多为一重；异常处理过程中可能会发生中断，但是中断处理过程中绝不会被异常打断</p></li></ul><blockquote><p>reference：<a href="https://stackoverflow.com/questions/7295936/what-is-the-difference-between-interrupt-and-exception-context" target="_blank" rel="noopener">https://stackoverflow.com/questions/7295936/what-is-the-difference-between-interrupt-and-exception-context</a></p><p>Interrupts and exceptions both alter the program flow. The difference between the two is that <strong>interrupts are used to handle external events (serial ports, keyboard)</strong> and <strong>exceptions are used to handle instruction faults, (division by zero, undefined opcode).</strong></p><p>Interrupts are handled by the processor after finishing the current instruction. If it finds a signal on its interrupt pin, it will look up the address of the interrupt handler in the interrupt table and pass that routine control. After returning from the interrupt handler routine, it will resume program execution at the instruction after the interrupted instruction.</p><p>Exceptions on the other hand are divided into three kinds. These are <strong>Faults, Traps and Aborts</strong>. Faults are detected and serviced by the processor before the faulting instructions. Traps are serviced after the instruction causing the trap. User defined interrupts go into this category and can be said to be traps; this includes the MS- DOS INT 21h software interrupt, for example. Aborts are used only to signal severe system problems, when operation is no longer possible.</p></blockquote><h3 id="中断和异常的响应及服务"><a href="#中断和异常的响应及服务" class="headerlink" title="中断和异常的响应及服务"></a>中断和异常的响应及服务</h3><p>产生处理器外部中断或者内部异常的时候，CPU都会在<strong>执行完当前指令后</strong>，根据中断源所提供的“中断向量”，在内核中找到响应中断服务例程并调度执行。</p><p>中断向量<strong>由硬件或操作系统预先分配和设置</strong>，系统调用所对应的向量则在访管指令中给出；各种异常向量<strong>在CPU的硬件结构中预先规定</strong>。这样不同情况就因中断向量的不同而区分开来。</p><p>操作系统如何转到中断处理程序和异常处理程序执行呢？</p><ul><li>对于中断，它主要由外部设备、时钟部件或其他计算机发出的（发现中断源并产生中断的硬件称为中断控制器，这些硬件包括中断逻辑线路和中断寄存器）<u>当前指令执行结束后，CPU会检查中断寄存器是否有中断事件发生</u>：<ul><li>若无中断信号或中断信号被屏蔽，则继续执行程序的后续指令</li><li>否则将暂停执行当前程序，转向内核的中断处理程序执行</li></ul></li><li>对于异常，它是在执行指令时，由于指令本身的原因发生的，指令的控制逻辑和实现线路一旦发现异常情况便转向内核的异常处理程序</li></ul><p>这个<u>由硬件对中断和异常事件做出反应的过程</u>称为<strong>中断响应</strong>。目前的计算机都采用软硬件结合（<strong>硬件中断控制器</strong>和<strong>软件中断/异常处理程序</strong>相结合）的方法实现中断/异常处理。中断/异常响应需要执行以下四个步骤：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/18/I7Eo5uDZ6jtdcCV.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="中断优先级和多重中断"><a href="#中断优先级和多重中断" class="headerlink" title="中断优先级和多重中断"></a>中断优先级和多重中断</h3><h4 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h4><p>中断装置所预设的中断响应顺序称为中断优先级。例如，同样是设备，可以设定高速设备优先级高，慢速设备优先级低，以提高高速设备的利用率。那么中断系统如何按照预先设定的优先顺序予以响应？可以使用硬件和软件方法</p><ul><li>硬件方法根据排定的优先级顺序做一个硬件链式排队器，当产生高一级中断事件时，应该<strong>屏蔽比它优先级低的所有中断源</strong></li><li>软件方法编写一个查询程序，依据优先级顺序<strong>从高到低进行查询</strong>，一旦发现有中断请求，便转入相应中断事件处理程序入口</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;中断技术&quot;&gt;&lt;a href=&quot;#中断技术&quot; class=&quot;headerlink&quot; title=&quot;中断技术&quot;&gt;&lt;/a&gt;中断技术&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="中断" scheme="http://QQ876684433.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>Linux写时拷贝技术（copy-on-write）</title>
    <link href="http://QQ876684433.github.io/2019/10/17/Linux%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%EF%BC%88copy-on-write%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/17/Linux写时拷贝技术（copy-on-write）/</id>
    <published>2019-10-17T10:36:13.000Z</published>
    <updated>2019-10-17T12:55:08.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux写时拷贝技术（copy-on-write）"><a href="#Linux写时拷贝技术（copy-on-write）" class="headerlink" title="Linux写时拷贝技术（copy on write）"></a>Linux写时拷贝技术（copy on write）</h1><h2 id="fork-和-exec"><a href="#fork-和-exec" class="headerlink" title="fork() 和 exec()"></a>fork() 和 exec()</h2><blockquote><p>参考资料：</p><ul><li><a href="https://www.geeksforgeeks.org/difference-fork-exec/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/difference-fork-exec/</a></li><li><a href="https://stackoverflow.com/questions/1653340/differences-between-fork-and-exec" target="_blank" rel="noopener">https://stackoverflow.com/questions/1653340/differences-between-fork-and-exec</a></li></ul></blockquote><p>每一个应用程序都是通过进程来运行的，进程是一个程序运行的实例，fork()和exec()都可以创建新的进程</p><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br></pre></td></tr></table></figure><p><code>fork()</code>创建的新进程是原调用进程的的一个拷贝，新进程称为子进程，原进程是它的父进程，父子进程之间的差别在于：</p><ul><li><p>子进程有自己独立的进程ID（pid），而且pid与任意已经存在的<strong>进程组</strong>的ID都不同</p><p>（链接原文说的是“进程组”，目前没搞懂和直接说“进程”有什么不同，待考证）</p><blockquote><p>在兼容于<a href="https://zh.wikipedia.org/wiki/POSIX" target="_blank" rel="noopener">POSIX</a>标准的<a href="https://zh.wikipedia.org/wiki/作業系統" target="_blank" rel="noopener">操作系统</a>中，<strong>进程组</strong>（英语：Process group，又译<strong>过程组群</strong>）是指一个或多个<a href="https://zh.wikipedia.org/wiki/行程" target="_blank" rel="noopener">进程</a>的集合。进程组被使用于控制<a href="https://zh.wikipedia.org/wiki/信号_(计算机科学)" target="_blank" rel="noopener">信号</a>的分配。对于一个进程组发出的的信号，会被个别递送到这个组群下的每个进程成员中。</p><p>进程组本身，也可以被集合成一个组群来管理，称为<strong>会话组</strong>（sessions）。归属于某个特定会话组下的进程组，不能移动到别的会话组下；在某个进程组下的特定进程，在创造出新的进程时，这个进程也只能属于这个父进程所归属的相同会话组。</p><p>—— 来源 <a href="https://zh.wikipedia.org/wiki/行程群組" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E7%BE%A4%E7%B5%84</a></p></blockquote></li><li><p>The child’s parent process ID is the same as the parent’s process ID.（这个没必要翻译orz）</p></li><li><p>The child does not inherit its parent’s <strong>memory locks</strong> and <strong>semaphore adjustments</strong></p><p>子进程不会继承父进程的内存锁和信号量调整</p></li><li><p>The child does not inherit outstanding asynchronous I/O operations from its parent nor does it inherit any asynchronous I/O contexts from its parent</p><p>子进程不会从其父级继承未完成的异步I / O操作，也不会从其父级继承任何异步I / O上下文</p></li></ul><h4 id="fork-的返回值"><a href="#fork-的返回值" class="headerlink" title="fork()的返回值"></a>fork()的返回值</h4><ul><li>如果创建子进程成功，那么子进程的PID就会被返回到父进程中，即<code>pid_t pid = fork();</code>中的pid就是创建的子进程的PID，而对子进程而言<code>pid_t pid = fork();</code>中的pid的值是0；可以根据父进程和子进程返回值的不同来使得父进程和子进程接下来执行不同的任务</li><li>如果创建子进程失败，那么父进程中<code>pid_t pid = fork();</code>返回值是-1，然后不会有子进程被创建出来，并且错误码会被设置</li></ul><p><code>fork()</code>之后子进程是父进程的拷贝，父进程和子进程会从相同的指令处接着往下面继续执行，即父进程和子进程都会从<code>pid_t pid = fork();</code>下面一行开始执行</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><blockquote><p>there is a whole family of <code>exec</code> calls (<code>execl</code>, <code>execle</code>, <code>execve</code> and so on) but <code>exec</code> in context here means any of them</p></blockquote><p><code>exec()</code>是一系列函数的统称</p><p><code>exec()</code>使用新的进程映像替换当前的进程映像，即它将要运行的程序加载到当前的进程空间中，然后从新程序的入口点开始运行。一般可以结合<code>fork()</code>和<code>exec()</code>来使得当前进程能够启动一个新进程来运行新程序。下面是一个在bash中运行ls程序来获取目录文件列表的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+--------+</span><br><span class="line">| pid=7  |</span><br><span class="line">| ppid=4 |</span><br><span class="line">| bash   |</span><br><span class="line">+--------+</span><br><span class="line">    |</span><br><span class="line">    | calls fork</span><br><span class="line">    V</span><br><span class="line">+--------+             +--------+</span><br><span class="line">| pid=7  |    forks    | pid=22 |</span><br><span class="line">| ppid=4 | ----------&gt; | ppid=7 |</span><br><span class="line">| bash   |             | bash   |</span><br><span class="line">+--------+             +--------+</span><br><span class="line">    |                      |</span><br><span class="line">    | waits for pid 22     | calls exec to run ls</span><br><span class="line">    |                      V</span><br><span class="line">    |                  +--------+</span><br><span class="line">    |                  | pid=22 |</span><br><span class="line">    |                  | ppid=7 |</span><br><span class="line">    |                  | ls     |</span><br><span class="line">    V                  +--------+</span><br><span class="line">+--------+                 |</span><br><span class="line">| pid=7  |                 | exits</span><br><span class="line">| ppid=4 | &lt;---------------+</span><br><span class="line">| bash   |</span><br><span class="line">+--------+</span><br><span class="line">    |</span><br><span class="line">    | continues</span><br><span class="line">    V</span><br></pre></td></tr></table></figure><h3 id="fork-和exec-的区别"><a href="#fork-和exec-的区别" class="headerlink" title="fork()和exec()的区别"></a>fork()和exec()的区别</h3><ul><li>fork starts a new process which is a copy of the one that calls it, while exec replaces the current process image with another (different) one.</li><li>Both parent and child processes are executed simultaneously in case of fork() while Control never returns to the original program unless there is an exec() error.</li></ul><h2 id="Copy-On-Write"><a href="#Copy-On-Write" class="headerlink" title="Copy On Write"></a>Copy On Write</h2><blockquote><p>参考资料：<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="noopener">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html</a></p></blockquote><p>​        从上面的介绍中可以知道，<code>fork()</code>会创建一个和父进程完全相同的子进程，但是子进程接下来可能会执行<code>exec()</code>来加载新的程序，如果子进程一创建就调用<code>exec()</code>，那么系统开销是很大的，因为刚刚拷贝了一份父进程，就接着被新的进程替换掉，显然前面的备份是有点多余的。因此，为了提高效率，Linux中引入了copy on write（写时复制）技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p><ul><li>在fork之后、exec之前，父子进程用的是相同的物理空间（内存区），<strong>子进程的代码段、数据段、堆栈都是指向父进程的物理空间</strong>，即两者的虚拟空间不同，但其对应的物理空间是同一个</li><li>当父子进程中有<strong>更改相应段的行为发生</strong>时，再为子进程相应的段分配物理空间<ul><li>如果不是因为exec，内核会<strong>给子进程的数据段、堆栈段分配相应的物理空间</strong>（至此两者有各自的进程空间，互不影响），而<strong>代码段继续共享父进程的物理空间</strong>（两者的代码完全相同）</li><li>如果是因为exec，由于两者执行的代码不同，子进程的<strong>代码段也会分配单独的物理空间</strong></li></ul></li><li>fork之后内核会通过将子进程放在队列的前面，以让子进程先执行，以免父进程<strong>先运行导致写时复制，而后子进程才执行exec系统调用</strong>，这样可以避免无意义的复制而造成效率的下降</li></ul><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>​        对于一个父进程P1，它的虚拟地址空间上有：正文段，数据段，堆，栈这四个部分，相应地，内核要为这四个部分分配各自的物理块，即正文段块，数据段块，堆块，栈块</p><ol><li><p>现在P1用fork()函数为进程创建一个子进程P2</p><p>对于内核来说，它会执行如下的任务：</p><ul><li><p>复制P1的正文段，数据段，堆，栈这四个部分，并且它们内容相同</p></li><li><p>为这四个部分分配物理块，对于新的进程P2：</p><ul><li>正文段－＞P1的正文段的物理块，其实就是<strong>不为P2分配正文段块</strong>，让P2的正文段指向P1的正文段块</li><li>数据段－＞P2自己的数据段块（为其分配对应的块）</li><li>堆－＞P2自己的堆块</li><li>栈－＞P2自己的栈块</li></ul><p>如图所示：其中大箭头表示内容复制方向</p><p><img src="https://i.loli.net/2019/10/17/Vct5I6YNm7jHJSX.jpg" alt></p></li></ul></li><li><p>写时复制技术</p><p>内核<strong>只为新生成的子进程创建虚拟空间结构</strong>，它们来复制于父进程的虚拟空间结构，但是<strong>不为这些段分配物理内存</strong>，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间</p><p><img src="https://i.loli.net/2019/10/17/QKVqc6bECtrJn2X.jpg" alt></p></li><li><p>vfork()</p><p>内核连子进程的虚拟地址空间结构也不创建了，<strong>直接共享了父进程的虚拟空间</strong>，自然地子进程也共享了父进程的物理空间</p><p><img src="https://i.loli.net/2019/10/17/9SGa4vYgzFTHhIk.jpg" alt></p></li></ol><blockquote><p>传统的fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。Linux的fork()使用写时拷贝（copy-on-write）页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，<strong>资源的复制只有在需要写入的时候才进行</strong>，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候。<strong>在页根本不会被写入的情况下（<em>举例来说，fork()后立即调用exec()</em>）它们就无需复制了。fork()的实际开销就是复制父进程的页表以及给子进程创建惟一的进程描述符</strong>。在一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以<strong>避免拷贝大量根本就不会被使用的数据</strong>（地址空间里常常包含数十兆的数据）。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。这里补充一点：<strong>Linux COW与exec没有必然联系</strong></p></blockquote><p>（<em>原文中还提到C++中string的copy-on-write技术，因为这个与本主题无关，想要了解的话可以通过上面的参考链接查看</em>）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux写时拷贝技术（copy-on-write）&quot;&gt;&lt;a href=&quot;#Linux写时拷贝技术（copy-on-write）&quot; class=&quot;headerlink&quot; title=&quot;Linux写时拷贝技术（copy on write）&quot;&gt;&lt;/a&gt;Linux写时拷
      
    
    </summary>
    
      <category term="Linux" scheme="http://QQ876684433.github.io/categories/Linux/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://QQ876684433.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-程序接口与系统调用</title>
    <link href="http://QQ876684433.github.io/2019/10/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://QQ876684433.github.io/2019/10/16/操作系统-程序接口与系统调用/</id>
    <published>2019-10-16T00:03:25.000Z</published>
    <updated>2019-10-17T10:33:35.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序接口与系统调用"><a href="#程序接口与系统调用" class="headerlink" title="程序接口与系统调用"></a>程序接口与系统调用</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li><li>Linux Kernel Teaching - <a href="https://linux-kernel-labs.github.io/master/index.html" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/index.html</a></li></ul></blockquote><h2 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h2><p>操作系统通过“程序接口”和“操作接口”将其服务和功能提供给用户：</p><ul><li>程序接口是操作系统对外提供服务和功能的手段，它由一组系统调用组成，在应用程序中使用“系统调用”可<strong>获得操作系统的低层服务</strong>，访问或使用系统管理的<strong>各种软硬件资源</strong></li><li>操作接口由一组控制命令和（或）作业控制语言组成，是操作系统为用户提供的<strong>组织和控制其作业（应用程序）执行</strong>的手段</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/uS6gCQYp4I3mBRW.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="程序接口与系统调用-1"><a href="#程序接口与系统调用-1" class="headerlink" title="程序接口与系统调用"></a>程序接口与系统调用</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/UBGqYT2x7A3KvE8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>因此可以这样认为，<strong>内核的主体是系统调用的集合</strong></p><blockquote><p>At a high level system calls are “services” offered by the kernel to user applications and they resemble library APIs in that they are described as a function call with a name, parameters and return value.</p><p>在高层次上来看，系统调用是内核为用户应用程序提供的“服务”，它们类似于库API，因为它们被描述为<strong>具有名称，参数和返回值的函数调用</strong></p></blockquote><h4 id="为什么使用系统调用"><a href="#为什么使用系统调用" class="headerlink" title="为什么使用系统调用"></a>为什么使用系统调用</h4><ul><li>根本原因是<strong>为了对系统进行“保护”</strong></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/MkKoNrVWsL6afz2.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>系统调用是一种中介角色，<strong>把用户和硬件资源隔离开来</strong>，应用程序只有通过系统调用才能请求系统服务并使用系统资源</li></ul><h4 id="系统调用的作用"><a href="#系统调用的作用" class="headerlink" title="系统调用的作用"></a>系统调用的作用</h4><ul><li>内核可以基于权限和规则<strong>对资源访问进行裁决</strong>，保证系统的安全性</li><li>系统调用<strong>对资源进行抽象</strong>，提供一致性接口，避免用户在使用资源时发生错误，且使编程效率大大提高</li></ul><p><strong>系统调用是应用程序获得操作系统服务的唯一途径</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/m28cC6uSbAKaOlJ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="API、库函数和系统调用"><a href="#API、库函数和系统调用" class="headerlink" title="API、库函数和系统调用"></a>API、库函数和系统调用</h3><p>不同操作系统提供的系统调用功能虽然大同小异，但是实现细节不尽相同，因此如果应用程序直接使用系统调用，那么会存在问题：</p><ul><li>接口复杂，使用困难</li><li>应用程序跨平台可移植性受到很大限制</li></ul><h4 id="不同操作系统之间的可移植性"><a href="#不同操作系统之间的可移植性" class="headerlink" title="不同操作系统之间的可移植性"></a>不同操作系统之间的可移植性</h4><p>POSIX（Portable Operating System Interface）为不同平台下的应用程序提供相同的<strong>应用程序接口（API）</strong>，但是它并没有保证相同的API的内部实现是一致的。其中系统调用只是其中一种API</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/AuwnP7WCJk6LHfs.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/lPKFso3z5XwkBd6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="库函数和系统调用"><a href="#库函数和系统调用" class="headerlink" title="库函数和系统调用"></a>库函数和系统调用</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/ZRPfL1eghsjGz6S.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>库函数属于应用程序，在<strong>用户态运行</strong>（用户可以替换库函数）</li><li>系统调用对应的服务例程属于系统程序，在<strong>内核态运行</strong>（用户通常不能替换系统调用）</li></ul><h3 id="系统调用分类"><a href="#系统调用分类" class="headerlink" title="系统调用分类"></a>系统调用分类</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/tjFvOqmTol53EsP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="系统调用实现"><a href="#系统调用实现" class="headerlink" title="系统调用实现"></a>系统调用实现</h3><ul><li>操作系统实现系统调用功能的机制称为<strong>陷阱或异常处理机制</strong></li><li>由于系统调用引起处理器中断的机器指令称为<strong>访管指令、自陷指令或中断指令</strong></li></ul><p>其中访管指令为非特权指令，在目态下执行时会将CPU转换到内核态</p><p>每个系统调用都事先规定编号，称为功能号，发出访管指令、自陷指令或中断指令时，必须通过某种方式指明对应系统调用的功能号（另外还要附带传递给相应服务例程的参数）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/uXIv26L59FMnryR.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/WDl4MKQNdikSoHj.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/BYsGkhpDeNqu3RX.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>应用程序和系统调用之间传递参数所采用的方法：</p><ul><li>访管指令或自陷指令自带参数</li><li>通过CPU通用寄存器传递参数</li><li>在内存区中开辟专用堆栈区传递参数</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/blihXo7WxKufDLZ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="系统调用与函数调用的区别"><a href="#系统调用与函数调用的区别" class="headerlink" title="系统调用与函数调用的区别"></a>系统调用与函数调用的区别</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/iHQXv2lD6sajo1u.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="System-Calls-in-Linux-Kernel"><a href="#System-Calls-in-Linux-Kernel" class="headerlink" title="System Calls in Linux Kernel"></a>System Calls in Linux Kernel</h2><blockquote><p>reference：<a href="https://linux-kernel-labs.github.io/master/lectures/syscalls.html" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/lectures/syscalls.html</a></p><p>Linux System Call Table for x86-64（Linux x86-64系统调用表）：<a href="http://shell-storm.org/shellcode/files/syscalls.html" target="_blank" rel="noopener">http://shell-storm.org/shellcode/files/syscalls.html</a></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/NIOgQMqSlaHjkye.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在进行系统调用的时候，特定的汇编指令会做如下的工作：</p><ul><li>setup information to identify the system call and its parameters</li><li>trigger a kernel mode switch</li><li>retrieve the result of the system call</li></ul><p>在Linux中，系统调用是通过数字编号来标识的，系统调用的参数的大小是机器的字长（word，32或者64位）。系统调用的参数最多有6个，系统调用编号和参数都是保存在特定的寄存器中，例如在32bit的x86架构中：</p><ul><li>系统调用数字编号保存在EAX寄存器中</li><li>系统调用的参数保存在EBX、ECX、EDX、ESI、EDI、EBP寄存器中</li></ul><p>为了使得开发应用程序时进行系统调用更简便，一些系统函数库（例如libc）会提供函数来完成系统调用内部的实际实现</p><p>当发生用户态到内核态的转移的时候，当前程序的执行流被中断，然后跳转到内核的入口点，这类似于中断和异常处理的方式（事实上，在一些架构中用户态到内核态的转换是异常处理的结果）</p><blockquote><p>During the user - kernel mode transition the stack is also switched from ther user stack to the kernel stack.</p><p>在发生用户态向内核态转移的时候，当前的系统堆栈也会由用户栈切换到内核态</p></blockquote><p>在系统调用的入口点会将当前寄存器的值（这些寄存器包含的是用户空间的值，并且包括<strong>系统调用数字编号和系统调用参数</strong>）保存起来</p><h3 id="系统调用例子"><a href="#系统调用例子" class="headerlink" title="系统调用例子"></a>系统调用例子</h3><blockquote><p>更详细的系统调用过程（结合Linux源码解析），参考：<a href="http://zhongmingmao.me/2019/04/20/linux-system-call-process/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/04/20/linux-system-call-process/</a></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/17/8CD37Y9OcLZaHut.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>系统调用调度器（system call dispatcher）</strong>的功能是验证系统调用的数字编号，然后运行和系统调用相关的内核函数，如下代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handles int $0x80 */</span></span><br><span class="line"><span class="comment">/* 在进入内核之前，通过push和SAVE_ALL将当前用户态的寄存器，保存在pt_regs结构里面，然后调用do_int80_syscall_32 */</span></span><br><span class="line">__<span class="function">visible <span class="keyword">void</span> <span class="title">do_int80_syscall_32</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    enter_from_user_mode();</span><br><span class="line">    local_irq_enable();</span><br><span class="line">    do_syscall_32_irqs_on(regs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* simplified version of the Linux x86 32bit System Call Dispatcher */</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">do_syscall_32_irqs_on</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr = regs-&gt;orig_ax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 系统调用的数量由 NR_syscalls 宏给定，这个判断似乎是检查系统调用号是不是合法的，如果合法则进行接下来的实际内核函数的执行，并且把返回结果保存到ax中 */</span></span><br><span class="line">    <span class="comment">/* 似乎这里的 regs-&gt;ax 指的是eax（32bit）或者rax（64bit）的统称，而不是x86中16bit的ax寄存器 */</span></span><br><span class="line">    <span class="keyword">if</span> (nr &lt; IA32_NR_syscalls)</span><br><span class="line">        regs-&gt;ax = ia32_sys_call_table[nr](regs-&gt;bx, regs-&gt;cx,</span><br><span class="line">                                           regs-&gt;dx, regs-&gt;si,</span><br><span class="line">                                           regs-&gt;di, regs-&gt;bp);</span><br><span class="line">    syscall_return_slowpath(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面参考自：<a href="https://blog.csdn.net/hq815601489/article/details/80009791" target="_blank" rel="noopener">https://blog.csdn.net/hq815601489/article/details/80009791</a></p></blockquote><p>Linux提供了200多个系统调用，通过汇编指令 <code>int 0x80</code> 实现，用系统调用号来区分入口函数。</p><p><strong>Linux实现系统调用的基本过程</strong>是：</p><ul><li><p>应用程序准备参数，发出调用请求；</p></li><li><p>C库封装函数引导。该函数在Linux提供的标准C库，即 glibc 中。对应的封装函数由下列汇编指令实现（以读函数调用为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; NASM</span><br><span class="line">; read(int fd, void *buffer, size_t nbytes)</span><br><span class="line">mov eax, 3          ; read系统调用号为3</span><br><span class="line">mov ebx, fd</span><br><span class="line">mov ecx, buffer</span><br><span class="line">mov edx, nbytes</span><br><span class="line">int 0x80            ; 触发系统调用</span><br></pre></td></tr></table></figure></li><li><p>执行系统调用。前两步在用户态工作，陷入后在内核态工作。系统调用处理程序根据系统调用号，<strong>按系统调用表中的偏移地址跳转，调用对应的内核函数</strong>；</p></li><li><p>系统调用完成相应功能，将<strong>返回值存入 eax</strong> ，返回到中断处理函数；</p></li><li><p>系统调用返回。内核函数处理完毕后，库函数读寄存器（ eax ）返回值，并返回给应用程序。恢复现场。</p></li></ul><p><strong>应用程序调用系统调用的过程</strong>是：</p><ul><li><p>把系统调用号存入 eax ；</p></li><li><p>把函数参数存入其它通用寄存器（约定顺序为 ebx 、 ecx 、 edx 、 esi 、 edi ，<u>更多的参数（通常不会出现这种情况）使用堆栈传递</u>，也可以<u>通过寄存器存放指向参数在用户空间的地址指针来传递</u>）；</p></li><li><p>触发 0x80 号中断（ int 0x80 ）。</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; NASM</span><br><span class="line">; 向显示器输出hello, world</span><br><span class="line">; write(int fd, const void *buffer, size_t nbytes)</span><br><span class="line">; exit(int status)</span><br><span class="line">        global  _start</span><br><span class="line">        section .text</span><br><span class="line">_start:</span><br><span class="line">        mov     eax, 4              ; write系统调用号为4</span><br><span class="line">        mov     ebx, 1              ; 文件描述符1：标准输出stdout</span><br><span class="line">        mov     ecx, message        ; 要输出的信息</span><br><span class="line">        mov     edx, message.len    ; 要输出的长度</span><br><span class="line">        int     0x80</span><br><span class="line"></span><br><span class="line">        mov     eax, 1              ; exit系统调用号为1</span><br><span class="line">        mov     ebx, 0              ; 状态码0：正常退出</span><br><span class="line">        int     0x80</span><br><span class="line"></span><br><span class="line">        section .data</span><br><span class="line">message:</span><br><span class="line">        db      &quot;hello, world&quot;, 10</span><br><span class="line">.len    equ     $ - message</span><br></pre></td></tr></table></figure></li></ul><p><strong>Linux系统调用实现机制</strong>：</p><ul><li><p>系统调用初始化</p><p>系统调用处理程序 <code>system_call()</code> 的入口地址放在系统的<strong>中断表述符表IDT（Interrupt Descriptor Table）</strong>中，Linux系统初始化时，由 <code>trap_init()</code> 将其填写完整，其设置系统调用处理程序的语句为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_system_gate(<span class="number">0x80</span>, &amp;system_call)</span><br></pre></td></tr></table></figure><p>经过初始化以后，每当执行 <code>int 0x80</code> 指令时，产生一个异常<strong>使系统陷入内核空间并执行128号异常处理程序</strong>，即系统调用处理程序 <code>system_call()</code> </p></li><li><p>系统调用公共入口</p><p><code>system_call()</code> 是所有系统调用的公共入口，其功能是保护现场，<strong>进行正确性检查，根据系统调用号跳转到具体的内核函数</strong>。内核函数执行完毕时需调用<code>ret_from_sys_call()</code>，这时完成返回用户空间前的最后检查，用<code>RESTORE_ALL</code>宏恢复现场并执行<code>iret</code>指令返回用户断点</p></li><li><p>保护现场</p><ul><li>硬件（CPU）保护：<code>ss</code> 、 <code>esp</code> 、 <code>eflags</code> 、 <code>cs</code> 、 <code>eip</code> ，压入核心栈</li><li>软件（操作系统）保护<ul><li>使用 <code>SAVE_ALL</code> 宏将寄存器压入堆栈，加载内核的 <code>ds</code> 和 <code>es</code> ，往 <code>edx</code> 中放入 <code>$(_KERNEL_DS)</code> 以指明使用内核数据段，把内核数据段选择符装入 <code>ds</code> 和 <code>es</code> 。注意：该宏压入寄存器的顺序<strong>不是随意的</strong>，而是和系统调用的参数传递密切相关</li><li><code>es</code> 、 <code>ds</code> 、 <code>eax</code> 、 <code>ebp</code> 、 <code>edi</code> 、 <code>esi</code> 、 <code>edx</code> 、 <code>ecx</code> 、 <code>ebx</code> ，压入核心栈</li></ul></li></ul><p>系统调用处理时的核心栈内容：</p><table><thead><tr><th align="center"></th><th align="center">寄存器</th></tr></thead><tbody><tr><td align="center">硬件完成</td><td align="center">ss</td></tr><tr><td align="center">硬件完成</td><td align="center">esp</td></tr><tr><td align="center">硬件完成</td><td align="center">eflags</td></tr><tr><td align="center">硬件完成</td><td align="center">cs</td></tr><tr><td align="center">硬件完成</td><td align="center">eip</td></tr><tr><td align="center">软件完成</td><td align="center">es</td></tr><tr><td align="center">软件完成</td><td align="center">ds</td></tr><tr><td align="center">软件完成</td><td align="center">eax</td></tr><tr><td align="center">软件完成</td><td align="center">ebp</td></tr><tr><td align="center">软件完成</td><td align="center">edi</td></tr><tr><td align="center">软件完成</td><td align="center">esi</td></tr><tr><td align="center">软件完成</td><td align="center">edx</td></tr><tr><td align="center">软件完成</td><td align="center">ecx</td></tr><tr><td align="center">软件完成</td><td align="center">ebx</td></tr></tbody></table></li><li><p>返回值传递</p><p>当内核函数返回到 <code>system_call()</code> 时， <code>eax</code> 中存放着内核函数的返回值。要将这个返回值传递给应用程序，内核先将 <code>eax</code> 放入原先 <code>SAVE_ALL</code> 宏保存 <code>eax</code> 的位置，这样当 <code>system_call()</code> 调用 <code>RESTORE_ALL</code> 恢复寄存器时， <code>eax</code> 便被恢复成系统调用的返回值，完成了返回值从内核空间到用户空间的传递</p></li></ul><p><strong>系统调用号和系统调用表</strong></p><p>系统调用的数量由 <code>NR_syscalls</code> 宏给定，每个系统调用所对应的编号已预先在系统文件中定义，且都用一个宏表示，其定义有如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_exit 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_fork 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_read 3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Linux的系统调用号和内核函数映射关系的系统调用表也被预先定义在系统文件中，具有如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">ENTRY(sys_call_table)</span><br><span class="line">    .long SYMBOL_NAME(sys_ni_syscall)    /* 空项 */</span><br><span class="line">    .long SYMBOL_NAME(sys_exit)</span><br><span class="line">    .long SYMBOL_NAME(sys_fork)</span><br><span class="line">    .long SYMBOL_NAME(sys_read)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>内核函数入口地址为： <code>eax * 4 + sys_call_table</code></p><blockquote><p>上面参考自：<a href="https://blog.csdn.net/hq815601489/article/details/80009791" target="_blank" rel="noopener">https://blog.csdn.net/hq815601489/article/details/80009791</a></p></blockquote><p>概括来说，系统调用过程中会发生如下的事情：</p><ul><li>The application is setting up the system call number and parameters and it issues a trap instruction</li><li>The execution mode switches from user to kernel; the CPU switches to a kernel stack; the user stack and the return address to user space is saved on the kernel stack</li><li>The kernel entry point saves registers on the kernel stack</li><li><strong>The system call dispatcher</strong> identifies the system call function and runs it</li><li>The user space registers are restored and execution is switched back to user (e.g. calling IRET)</li><li>The user space application resumes</li></ul><h3 id="系统调用表"><a href="#系统调用表" class="headerlink" title="系统调用表"></a>系统调用表</h3><p>系统调用调度器通过系统调用表来将系统调用号映射到内核函数（系统调用服务例程）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_I386(nr, sym, qual) [nr] = sym,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">sys_call_ptr_t</span> ia32_sys_call_table[] = &#123;</span><br><span class="line">  [<span class="number">0</span> ... __NR_syscall_compat_max] = &amp;sys_ni_syscall,</span><br><span class="line">  #include &lt;<span class="keyword">asm</span>/syscalls_32.h&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__SYSCALL_I386(<span class="number">0</span>, sys_restart_syscall, )</span><br><span class="line">__SYSCALL_I386(<span class="number">1</span>, sys_exit, )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">__SYSCALL_I386(<span class="number">2</span>, sys_fork, )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">__SYSCALL_I386(<span class="number">2</span>, sys_fork, )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__SYSCALL_I386(<span class="number">3</span>, sys_read, )</span><br><span class="line">__SYSCALL_I386(<span class="number">4</span>, sys_write, )</span><br></pre></td></tr></table></figure><h3 id="系统调用参数处理"><a href="#系统调用参数处理" class="headerlink" title="系统调用参数处理"></a>系统调用参数处理</h3><p>因为系统调用的参数是由用户空间设置的，内核不能保证参数的正确性，因此必须每次都对参数进行验证。指针参数有以下特殊情况是必须要检验的：</p><ul><li>不允许指针指向内核空间</li><li>检测指针是否有效</li></ul><p>因为<strong>系统调用是在内核态执行的，它们有访问内核空间的权限</strong>，因此如果没有对指针进行合适的检测，那么就会使得用户应用程序拥有读或者写内核空间的权限（甚至不正确的写内核空间会破坏内核内存）。</p><p>类似的，如果用户程序传递的指针是无效的（例如一个写指针指向一个只读的内存区域），它也会导致内核崩溃。</p><p>有以下两种方法来解决以上问题：</p><ul><li>在使用指针之前，先对照用户地址空间检查指针</li><li>避免检查指针，依靠MMU来检测指针何时无效，并使用页错误处理程序确定指针无效</li></ul><p><em>（原文中还有些比较高级的内容，这里不再列出，毕竟涉及的知识比较高深，参见：<a href="https://linux-kernel-labs.github.io/master/lectures/syscalls.html）" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/lectures/syscalls.html）</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序接口与系统调用&quot;&gt;&lt;a href=&quot;#程序接口与系统调用&quot; class=&quot;headerlink&quot; title=&quot;程序接口与系统调用&quot;&gt;&lt;/a&gt;程序接口与系统调用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统调用" scheme="http://QQ876684433.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-10-15）</title>
    <link href="http://QQ876684433.github.io/2019/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-10-15%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/15/数据库课堂笔记（2019-10-15）/</id>
    <published>2019-10-15T03:25:09.000Z</published>
    <updated>2019-10-22T06:15:38.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-10-15）"><a href="#数据库课堂笔记（2019-10-15）" class="headerlink" title="数据库课堂笔记（2019-10-15）"></a>数据库课堂笔记（2019-10-15）</h2><h3 id="Ch4-Object-Relational-SQL-Oracle"><a href="#Ch4-Object-Relational-SQL-Oracle" class="headerlink" title="Ch4. Object-Relational SQL (Oracle)"></a>Ch4. Object-Relational SQL (Oracle)</h3><p>对象关系型数据表相关例子如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/15/cVmO6Xky84isWf5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/15/ZhLsu87Y6iJI4Bn.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="Object-Types（对象类型）"><a href="#Object-Types（对象类型）" class="headerlink" title="Object Types（对象类型）"></a>Object Types（对象类型）</h4><h5 id="定义新的数据类型"><a href="#定义新的数据类型" class="headerlink" title="定义新的数据类型"></a>定义新的数据类型</h5><p>对象类型的创建和删除语法（CREATE TYPE … AS OBJECT）如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> typename <span class="keyword">AS</span> <span class="keyword">OBJECT</span></span><br><span class="line">(attrname datatype, ......);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TYPE</span> typename;</span><br></pre></td></tr></table></figure><blockquote><p>这些数据类型一经定义， 便以持久形式保存在数据库系统中， 用户可以<strong>像使用系统内置的数据类型</strong>一样使用这些复杂的数据类型， 以此来扩充系统的数据类型</p></blockquote><p>创建对象类型的语法跟创建表的语法差不多，只不过对象类型的定义中没有约束条件的定义（constraint define），创建一个person_t的类型如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> person_t <span class="keyword">AS</span> <span class="keyword">OBJECT</span></span><br><span class="line">(</span><br><span class="line">    ssno <span class="built_in">int</span>,</span><br><span class="line">    pname name_t,</span><br><span class="line">    age <span class="built_in">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="对象类型的使用"><a href="#对象类型的使用" class="headerlink" title="对象类型的使用"></a>对象类型的使用</h5><p>自定义的对象类型可以有以下用法：</p><ul><li><p>使用所创建的对象类型来创建新类型</p><p>用于定义<strong>新类型中的属性</strong> (类型的嵌套定义)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> person_t <span class="keyword">AS</span> <span class="keyword">OBJECT</span></span><br><span class="line">(</span><br><span class="line">    ssno <span class="built_in">int</span>,</span><br><span class="line">    pname name_t,</span><br><span class="line">    age <span class="built_in">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中name_t就是一个对象类型</p></li><li><p>使用所创建的对象类型来创建新的表<br>用于定义<strong>表中的属性</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> teachers (</span><br><span class="line">    tid <span class="built_in">int</span>,</span><br><span class="line">    tname name_t,</span><br><span class="line">    room <span class="built_in">int</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中name_t就是一个对象类型</p></li><li><p>使用对象数据类型来直接创建一张表</p><ul><li><p>新创建的‘表’ 的结构与对象类型的结构相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename <span class="keyword">OF</span> typename</span><br><span class="line">&#123; ( <span class="keyword">constraint</span>-<span class="keyword">define</span> ) &#125; ;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>可以在创建的‘表’ 中<strong>增加完整性约束定义</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> people <span class="keyword">OF</span> person_t</span><br><span class="line">(</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>( ssno )</span><br><span class="line">) ;</span><br></pre></td></tr></table></figure></li></ul><h5 id="对象值的创建、-查询与更新"><a href="#对象值的创建、-查询与更新" class="headerlink" title="对象值的创建、 查询与更新"></a>对象值的创建、 查询与更新</h5><p>两个重要的函数：</p><ul><li><p>对象构造函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typename ( argument, …… )</span><br></pre></td></tr></table></figure><p>例如：<code>name_t ( ‘Einstein’, ‘Albert’, ‘E’ )</code>，就跟普通关系型数据表的行的创建一样</p></li><li><p><strong>返回对象取值</strong>的函数</p><blockquote><p>Ø <strong>Even though the primary table is object table, still it displays the rows in general format.</strong></p><p>Ø <strong>To display the entire structure of the object, this will be used.</strong></p><p>reference：<a href="http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html" target="_blank" rel="noopener">http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html</a></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value ( … )</span><br></pre></td></tr></table></figure><p>尽管oracle是对象关系型数据库，但是在直接查询一个对象关系表的时候，<strong>表中数据的类型是不会被返回的</strong>，因此需要使用value(…)函数来将表中属性类型返回回来</p><blockquote><p>Even though the vendors table is object table it will not show the adt along with data, to see the data along with the adt</p><p><strong>SQL&gt;Select * from vendors;</strong></p><p>This will give the data without adt.</p><p><strong>SQL&gt;Select value(v) from vendors v;</strong></p><p>This will give the columns data along wih the type.</p><p>reference：<a href="http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html" target="_blank" rel="noopener">http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html</a></p></blockquote></li></ul><p>对象值的创建（使用对象构造函数）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/15/EPDKns1egr9OCTY.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>对象值的查询（使用连续的点运算符）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/15/fUepAr6OEWgXkFL.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>对象值的更新：</p><ul><li><p>修改整个对象值</p><p>可以用对象值直接给对象属性进行赋值（即直接使用对象构造函数构造的新对象值替换表中的对象属性值），例如：</p><p><img src="https://i.loli.net/2019/10/15/8JBQ6jSWw1ehUpH.png" alt></p><p>如果某张表是基于“对象类型”创建的，那么可以<strong>用“对象”值直接修改整个元组</strong></p><p><img src="https://i.loli.net/2019/10/15/zAnDOIjicFoG1wK.png" alt></p></li><li><p>修改对象中成员属性的值</p><p>使用点运算符修改对象类型的某个属性值，例如：</p><p><img src="https://i.loli.net/2019/10/15/JN4XUpO1E6GwadZ.png" alt></p></li></ul><h5 id="对象的引用类型"><a href="#对象的引用类型" class="headerlink" title="对象的引用类型"></a>对象的引用类型</h5><p>可以通过以下语句创建对象的引用类型：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REF &lt;object type&gt;</span><br></pre></td></tr></table></figure><ul><li>创建的是指向某个元组对象的指针类型</li><li>引用类型可以用来实现对象类型之间的嵌套引用</li></ul><p>在使用含有REF类型的对象类型(Object Type)来创建关系表时， <strong>必须使用Scope for子句来限制REF属性的取值范</strong>围。</p><p>定义<strong>类型之间的引用关系</strong>的基本方法：</p><p>​    假设当前已经定义了三个对象类型customer_t, agents_t, products_t，那么可以通过如下方式来定义<strong>类型之间的引用关系</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create type order_t as object (</span><br><span class="line">    ordno int,</span><br><span class="line">    month char(3),</span><br><span class="line">    cid char(4),</span><br><span class="line">    aid char(3),</span><br><span class="line">    pid char(3),</span><br><span class="line">    qty int,</span><br><span class="line">    dollars double precision,</span><br><span class="line">    ordcust ref customer_t,</span><br><span class="line">    ordagent ref agent_t,</span><br><span class="line">    ordprod ref product_t</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>最后三行新增三个REF属性， 分别引用（指向） 三个不同的元组对象（Row Object）</p><p>创建<strong>含有引用类型的关系表</strong>的基本方法：</p><ul><li><p>先使用基本对象类型创建相应的基本关系表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customers <span class="keyword">of</span> customer_t</span><br><span class="line">(primary <span class="keyword">key</span> (cid));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> products <span class="keyword">of</span> product_t</span><br><span class="line">(primary <span class="keyword">key</span> (pid));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> agents <span class="keyword">of</span> agent_t</span><br><span class="line">(primary <span class="keyword">key</span> (aid));</span><br></pre></td></tr></table></figure></li><li><p>再使用含有REF属性的引用类型创建对应的关系表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> orders <span class="keyword">of</span> order_t (</span><br><span class="line">    primary <span class="keyword">key</span> (ordno),</span><br><span class="line">    <span class="keyword">scope</span> <span class="keyword">for</span> (ordcust) <span class="keyword">is</span> customers,</span><br><span class="line">    <span class="keyword">scope</span> <span class="keyword">for</span> (ordagent) <span class="keyword">is</span> agents,</span><br><span class="line">    <span class="keyword">scope</span> <span class="keyword">for</span> (ordprod) <span class="keyword">is</span> products</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中<code>scope for</code>是用来限制REF属性的取值范围的，在创建关系表时如果表中含有引用类型，那么必须使用<code>scope for</code>来指定属性要引用的对象</p></li></ul><p>根据元组之间的REF引用关系进行查询和普通的查询是一样的，都可以使用点运算符，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> o.ordcust.cname,</span><br><span class="line">o.ordagent.aname</span><br><span class="line"><span class="keyword">from</span> orders o</span><br></pre></td></tr></table></figure><p>其中ordcust和ordagent都是引用类型</p><p>引用类型两个函数和两个谓词：</p><p>两个函数</p><ul><li><p>获取对象(元组)的引用指针: REF(……)</p><blockquote><p>Ø <strong>The ref function allows referencing of existing row objects.</strong></p><p>Ø <strong>Each of the row objects has an object id value assigned to it.</strong></p><p>Ø <strong>The object id assigned can be seen by using ref function.</strong></p><p>reference：<a href="http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html" target="_blank" rel="noopener">http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html</a></p></blockquote><p>从上面可以看出，ref实际返回的是引用对象的id，因此如果需要查询并查看引用对象的内容，需要使用下面要介绍的deref。可以用来判断一个引用类型的引用对象是不是给定的对象，例如：</p><p><img src="https://i.loli.net/2019/10/15/OPnxQpyh635CqWk.png" alt></p></li><li><p>返回引用指针所指向对象的值: DEREF(……)</p><blockquote><p>Ø <strong>The deref function performs opposite action.</strong></p><p>Ø <strong>It takes a reference value of object id and returns the value of the row objects.</strong></p><p>reference：<a href="http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html" target="_blank" rel="noopener">http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html</a></p></blockquote><p>它用来检索整个被引用对象， 而不是仅仅获得该对象的引用指针，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">value</span> ( p ), deref ( p.partner )</span><br><span class="line"><span class="keyword">from</span> police_officers p</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">type</span> police_officer_t <span class="keyword">as</span> <span class="keyword">object</span> (</span><br><span class="line">    pol_person person_t,</span><br><span class="line">    badge_number <span class="built_in">integer</span>,</span><br><span class="line">    partner <span class="keyword">ref</span> police_officer_t </span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>两个判定谓词：</p><ul><li><p>IS DANGLING</p><ul><li>用于判断所引用的元组对象是否存在</li><li>如果<strong>所引用的元组对象不存在， 那么该谓词返回逻辑真(TRUE)</strong>， 否则返回逻辑假(FALSE)</li><li>该谓词主要用于检查那些错误的对象引用指针</li></ul><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> o.cid <span class="keyword">from</span> orders o</span><br><span class="line"><span class="keyword">where</span> o.ordcust <span class="keyword">IS</span> DANGLING;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> o.cid <span class="keyword">from</span> orders o</span><br><span class="line"><span class="keyword">where</span> o.ordcust &lt;&gt;</span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">ref</span>(c) <span class="keyword">from</span> customers c</span><br><span class="line">    <span class="keyword">where</span> c.cid = o.cid)</span><br></pre></td></tr></table></figure><p>即可以用来检索cid和引用的对象是否一致</p></li><li><p>IS NULL</p><ul><li>可以使用 IS NULL 谓词来查找取值为空(NULL) 的 <strong>REF 属性</strong>，但是‘is dangling’不等于‘is null’</li><li>对象引用指针的使用规则<ul><li>A dangling REF is non-null but useless</li><li>If o.ordcust is null or dangling, then o.ordcust.cname is null</li></ul></li></ul></li></ul><blockquote><p>A null pointer just means the pointer isn’t pointing to anything, or in some languages means it is unknown what it is pointing at. But because it is a null pointer, you know this, the code knows this, so no problem. A dangling pointer is one that you think is pointing at something but in reality is no longer there, hence the pointer is actually inaccurate but doesn’t know it.</p><p>reference：<a href="https://stackoverflow.com/questions/12714199/null-pointer-vs-dangling-pointer" target="_blank" rel="noopener">https://stackoverflow.com/questions/12714199/null-pointer-vs-dangling-pointer</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>从头到尾彻底理解KMP/BM/Sunday算法</title>
    <link href="http://QQ876684433.github.io/2019/10/07/%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3KMP-BM-Sunday%E7%AE%97%E6%B3%95/"/>
    <id>http://QQ876684433.github.io/2019/10/07/从头到尾彻底理解KMP-BM-Sunday算法/</id>
    <published>2019-10-07T15:54:05.000Z</published>
    <updated>2019-10-08T03:43:51.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【转载】从头到尾彻底理解KMP-BM-Sunday算法"><a href="#【转载】从头到尾彻底理解KMP-BM-Sunday算法" class="headerlink" title="【转载】从头到尾彻底理解KMP/BM/Sunday算法"></a>【转载】从头到尾彻底理解KMP/BM/Sunday算法</h1><h2 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h2><pre><code>假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</code></pre><p>如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；<br>如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。<br>    理清楚了暴力匹配算法的流程及内在的逻辑，咱们可以写出暴力匹配的代码，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ViolentMatch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == p[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++    </span></span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0    </span></span><br><span class="line">i = i - j + <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匹配成功，返回模式串p在文本串s中的位置，否则返回-1</span></span><br><span class="line"><span class="keyword">if</span> (j == pLen)</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>举个例子，如果给定文本串S“BBC ABCDAB ABCDABCDABDE”，和模式串P“ABCDABD”，现在要拿模式串P去跟文本串S匹配，整个过程如下所示：1. S[0]为B，P[0]为A，不匹配，执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[1]跟P[0]匹配，相当于模式串要往右移动一位（i=1，j=0）   ![](https://img-blog.csdn.net/20140723224710203)    2. S[1]跟P[0]还是不匹配，继续执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[2]跟P[0]匹配（i=2，j=0），从而模式串不断的向右移动一位（不断的执行“令i = i - (j - 1)，j = 0”，i从2变到4，j一直为0）</code></pre><p> <img src="https://img-blog.csdn.net/20140726213551553" alt></p><pre><code>3. 直到S[4]跟P[0]匹配成功（i=4，j=0），此时按照上面的暴力匹配算法的思路，转而执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，可得S[i]为S[5]，P[j]为P[1]，即接下来S[5]跟P[1]匹配（i=5，j=1）</code></pre><p> <img src="https://img-blog.csdn.net/20140726213602848" alt></p><pre><code>4. S[5]跟P[1]匹配成功，继续执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，得到S[6]跟P[2]匹配（i=6，j=2），如此进行下去</code></pre><p> <img src="https://img-blog.csdn.net/20140726213343578" alt></p><pre><code>5. 直到S[10]为空格字符，P[6]为字符D（i=10，j=6），因为不匹配，重新执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，相当于S[5]跟P[0]匹配（i=5，j=0）</code></pre><p> <img src="https://img-blog.csdn.net/20140726213353687" alt></p><pre><code>6. 至此，我们可以看到，如果按照暴力匹配算法的思路，尽管之前文本串和模式串已经分别匹配到了S[9]、P[5]，但因为S[10]跟P[6]不匹配，所以文本串回溯到S[5]，模式串回溯到P[0]，从而让S[5]跟P[0]匹配。</code></pre><p> <img src="https://img-blog.csdn.net/20140726213631208" alt></p><pre><code>而S[5]肯定跟P[0]失配。为什么呢？因为在之前第4步匹配中，我们已经得知S[5] = P[1] = B，而P[0] = A，即P[1] != P[0]，故S[5]必定不等于P[0]，所以回溯过去必然会导致失配。那有没有一种算法，让i 不往回退，只需要移动j 即可呢？答案是肯定的。这种算法就是本文的主旨KMP算法，它利用之前已经部分匹配这个有效信息，保持i 不回溯，通过修改j 的位置，让模式串尽量地移动到有效的位置。</code></pre><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre><code>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。下面先直接给出KMP的算法流程（如果感到一点点不适，没关系，坚持下，稍后会有具体步骤及解释，越往后看越会柳暗花明☺）：</code></pre><ul><li><p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p><ul><li><p>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</p></li><li><p>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。</p><ul><li>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文的3.3.3节中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。</li></ul><p>很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀后缀。</p><p>此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。</p><p>转换成代码表示，则是：</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    </span></span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span></span><br><span class="line"><span class="comment">//next[j]即为j所对应的next值      </span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == pLen)</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>继续拿之前的例子来说，当S[10]跟P[6]匹配失败时，KMP不是跟暴力匹配那样简单的把模式串右移一位，而是执行第②条指令：“如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]”，即j 从6变到2（后面我们将求得P[6]，即字符D对应的next 值为2），所以相当于模式串向右移动的位数为j - next[j]（j - next[j] = 6-2 = 4）。</code></pre>{% image https://img-blog.csdn.net/20140726213353687 '' '' %} <pre><code>向右移动4位后，S[10]跟P[2]继续匹配。为什么要向右移动4位呢，因为移动4位后，模式串中又有个“AB”可以继续跟S[8]S[9]对应着，从而不用让i 回溯。相当于在除去字符D的模式串子串中寻找相同的前缀和后缀，然后根据前缀后缀求出next 数组，最后基于next 数组进行匹配（不关心next 数组是怎么求来的，只想看匹配过程是咋样的，可直接跳到下文3.3.4节）。</code></pre><p> <img src="https://img-blog.csdn.net/20140721223539765" alt></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li><p>①寻找前缀后缀最长公共元素长度</p><ul><li>对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示：</li></ul><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140819173639786" alt title>                </div>                <div class="image-caption"></div>            </figure><p>比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k + 1 = 2）。</p></blockquote></li><li><p>②求next数组</p><ul><li>next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示：</li></ul><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140819173649739" alt title>                </div>                <div class="image-caption"></div>            </figure><p>比如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1）。</p></blockquote></li><li><p>③根据next数组进行匹配</p><ul><li><p>匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀pj-k pj-k+1, …, pj-1 跟文本串si-k si-k+1, …, si-1匹配成功，但pj 跟si匹配失败时，因为next[j] = k，相当于在不包含pj的模式串中有最大长度为k 的相同前缀后缀，即p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令j = next[j]，从而让模式串右移j - next[j] 位，使得模式串的前缀p0 p1, …, pk-1对应着文本串 si-k si-k+1, …, si-1，而后让pk 跟si 继续匹配。如下图所示：</p><p><img src="https://img-blog.csdn.net/20140812223633281" alt></p><p>综上，KMP的next 数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。如模式串中在j 处的字符跟文本串在i 处的字符匹配失配时，下一步用next [j] 处的字符继续跟文本串i 处的字符匹配，相当于模式串向右移动 j - next[j] 位。</p><p>接下来，分别具体解释上述3个步骤。</p></li></ul></li></ul><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><h4 id="寻找最长前缀后缀"><a href="#寻找最长前缀后缀" class="headerlink" title="寻找最长前缀后缀"></a>寻找最长前缀后缀</h4><pre><code>如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：</code></pre>{% image https://img-blog.csdn.net/20140725231726921 '' '' %}<pre><code>也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（下简称《最大长度表》）：</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140721222801918" alt title>                </div>                <div class="image-caption"></div>            </figure> <h4 id="基于《最大长度表》匹配"><a href="#基于《最大长度表》匹配" class="headerlink" title="基于《最大长度表》匹配"></a>基于《最大长度表》匹配</h4><pre><code>因为模式串中首尾可能会有重复的字符，故可得出下述结论：</code></pre><blockquote><p>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</p></blockquote><p> 下面，咱们就结合之前的《最大长度表》和上述结论，进行字符串的匹配。如果给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示：</p><p> <img src="https://img-blog.csdn.net/20140723224710203" alt></p><ol><li><p>因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第5个字符A匹配成功：</p><p><img src="https://img-blog.csdn.net/20140721223809617" alt></p></li></ol><ol start="2"><li><p>继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为6个（ABCDAB），然后根据《最大长度表》可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论，可知需要向右移动6 - 2 = 4 位。</p><p><img src="https://img-blog.csdn.net/20140721223809617" alt></p></li></ol><ol start="3"><li><p>模式串向右移动4位后，发现C处再度失配，因为此时已经匹配了2个字符（AB），且上一位字符B对应的最大长度值为0，所以向右移动：2 - 0 =2 位。</p><p><img src="https://img-blog.csdn.net/20140721223539765" alt></p></li></ol><ol start="4"><li><p>A与空格失配，向右移动1 位。</p><p><img src="https://img-blog.csdn.net/20140721223823548" alt></p></li></ol><ol start="5"><li><p>继续比较，发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B对应的最大长度2，即向右移动6 - 2 = 4 位。</p><p><img src="https://img-blog.csdn.net/20140721223558140" alt></p></li></ol><ol start="6"><li><p>经历第5步后，发现匹配成功，过程结束。</p><p><img src="https://img-blog.csdn.net/20140721223611515" alt></p></li></ol><pre><code>通过上述匹配过程可以看出，问题的关键就是寻找模式串中最大长度的相同前缀和后缀，找到了模式串中每个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。而这个最大长度便正是next 数组要表达的含义。</code></pre><h4 id="根据《最大长度表》求next-数组"><a href="#根据《最大长度表》求next-数组" class="headerlink" title="根据《最大长度表》求next 数组"></a>根据《最大长度表》求next 数组</h4><pre><code>由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为：</code></pre><p> <img src="https://img-blog.csdn.net/20140721230517324" alt></p><pre><code>而且，根据这个表可以得出下述结论</code></pre><ul><li><p>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</p><p>  上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。</p><p>  给定字符串“ABCDABD”，可求得它的next 数组如下：</p><p><img src="https://img-blog.csdn.net/20140721230250468" alt></p><p>  把next 数组跟之前求得的最大长度表对比后，不难发现，next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。</p><p>  换言之，对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140728110939595" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>  根据最大长度表求出了next 数组后，从而有</p></li></ul><blockquote><p>失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</p></blockquote><p>​    而后，你会发现，无论是基于《最大长度表》的匹配，还是基于next 数组的匹配，两者得出来的向右移动的位数是一样的。为什么呢？因为：</p><ul><li><p>根据《最大长度表》，失配时，模式串向右移动的位数 = 已经匹配的字符数 - 失配字符的上一位字符的最大长度值</p></li><li><p>而根据《next 数组》，失配时，模式串向右移动的位数 = 失配字符的位置 - 失配字符对应的next 值</p><ul><li><p>其中，从0开始计数时，失配字符的位置 = 已经匹配的字符数（失配字符不计数），而失配字符对应的next 值 = 失配字符的上一位字符的最大长度值，两相比较，结果必然完全一致。</p><p>所以，你可以把《最大长度表》看做是next 数组的雏形，甚至就把它当做next 数组也是可以的，区别不过是怎么用的问题。</p></li></ul></li></ul><h4 id="通过代码递推计算next-数组"><a href="#通过代码递推计算next-数组" class="headerlink" title="通过代码递推计算next 数组"></a>通过代码递推计算next 数组</h4><pre><code>接下来，咱们来写代码求下next 数组。基于之前的理解，可知计算next 数组的方法可以采用递推：</code></pre><ol><li><p>如果对于值k，已有p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k。</p><ul><li>此意味着什么呢？究其本质，next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀。有了这个next 数组，在KMP匹配中，当模式串中j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动j - next[j] 位。</li></ul><blockquote><p>举个例子，如下图，根据模式串“ABCDABD”的next 数组可知失配位置的字符D对应的next 值为2，代表字符D前有长度为2的相同前缀和后缀（这个相同的前缀后缀即为“AB”），失配后，模式串需要向右移动j - next [j] = 6 - 2 =4位。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140721223809617" alt title>                </div>                <div class="image-caption"></div>            </figure><p>向右移动4位后，模式串中的字符C继续跟文本串匹配。</p></blockquote></li></ol><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140721223539765" alt title>                </div>                <div class="image-caption"></div>            </figure></blockquote><ol start="2"><li>下面的问题是：已知next [0, …, j]，如何求出next [j + 1]呢？<pre><code>对于P的前j+1个序列字符：</code></pre></li></ol><ul><li><p>若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1；</p></li><li><p>若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。 相当于在字符p[j+1]之前不存在长度为k+1的前缀”p0 p1, …, pk-1 pk”跟后缀“pj-k pj-k+1, …, pj-1 pj”相等，那么是否可能存在另一个值t+1 &lt; k+1，使得长度更小的前缀 “p0 p1, …, pt-1 pt” 等于长度更小的后缀 “pj-t pj-t+1, …, pj-1 pj” 呢？如果存在，那么这个t+1 便是next[ j+1]的值，此相当于利用已经求得的next 数组（next [0, …, k, …, j]）进行P串前缀跟P串后缀的匹配。</p><p> 一般的文章或教材可能就此一笔带过，但大部分的初学者可能还是不能很好的理解上述求解next 数组的原理，故接下来，我再来着重说明下。</p><p>  如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。</p></li></ul>{% image https://img-blog.csdn.net/20140729182154066 '' '' %}<pre><code>但如果pk != pj 呢？说明“p0 pk-1 pk”  ≠ “pj-k pj-1 pj”。换言之，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140729181940812" alt title>                </div>                <div class="image-caption"></div>            </figure><pre><code>结合上图来讲，若能在前缀“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk&apos;-1 pk&apos; = pj-k&apos; pj-1 pj，则最大相同的前缀后缀长度为k&apos; + 1，从而next [j + 1] = k’ + 1 = next [k&apos; ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] = 0。那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？这又归根到next数组的含义。我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。此过程相当于模式串的自我匹配，所以不断的递归k = next[k]，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。如下图所示：</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20150812214857858" alt title>                </div>                <div class="image-caption"></div>            </figure>    <blockquote><p>引用下一读者wudehua55555于本文评论下留言，以辅助大家从另一个角度理解：“ 一直以为博主在用递归求next数组时没讲清楚，为何要用k = next[k],仔细看了这个红黄蓝分区图才突然恍然大悟，就是找到p[k]对应的next[k]，根据对称性，只需再判断p[next[k]]与p[j]是否相等即可，于是令k = next[k],这里恰好就使用了递归的思路。其实我觉得不要一开始就陷入递归的方法中，换一种思路，直接从考虑对称性入手，可直接得出k = next[k]，而这正好是递归罢了。以上是一些个人看法，非常感谢博主提供的解析，非计算机的学生也能看懂，虽然从昨晚9点看到了现在。高兴。”</p></blockquote><pre><code>所以，因最终在前缀ABC中没有找到D，故E的next 值为0：</code></pre><blockquote><p>模式串的后缀：ABDE</p></blockquote><blockquote><p>模式串的前缀：ABC</p></blockquote><blockquote><p>前缀右移两位：     ABC</p></blockquote><pre><code>读到此，有的读者可能又有疑问了，那能否举一个能在前缀中找到字符D的例子呢？OK，咱们便来看一个能在前缀中找到字符D的例子，如下图所示：</code></pre><p> <img src="https://img-blog.csdn.net/20140809163257703" alt></p><pre><code>给定模式串DABCDABDE，我们很顺利的求得字符D之前的“DABCDAB”的各个子串的最长相同前缀后缀的长度分别为0 0 0 0 1 2 3，但当遍历到字符D，要求包括D在内的“DABCDABD”最长相同前缀后缀时，我们发现pj处的字符D跟pk处的字符C不一样，换言之，前缀DABC的最后一个字符C 跟后缀DABD的最后一个字符D不相同，所以不存在长度为4的相同前缀后缀。怎么办呢？既然没有长度为4的相同前缀后缀，咱们可以寻找长度短点的相同前缀后缀，最终，因在p0处发现也有个字符D，p0 = pj，所以p[j]对应的长度值为1，相当于E对应的next 值为1（即字符E之前的字符串“DABCDABD”中有长度为1的相同前缀和后缀）。综上，可以通过递推求得next 数组，代码如下所示：</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span>* p,<span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) </span><br><span class="line">&#123;</span><br><span class="line">++k;</span><br><span class="line">++j;</span><br><span class="line">next[j] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>用代码重新计算下“ABCDABD”的next 数组，以验证之前通过“最长相同前缀后缀长度值右移一位，然后初值赋为-1”得到的next 数组是否正确，计算结果如下表格所示：</code></pre>{% image https://img-blog.csdn.net/20140812004705968 '' '' %} <pre><code>从上述表格可以看出，无论是之前通过“最长相同前缀后缀长度值右移一位，然后初值赋为-1”得到的next 数组，还是之后通过代码递推计算求得的next 数组，结果是完全一致的。</code></pre><h4 id="基于《next-数组》匹配"><a href="#基于《next-数组》匹配" class="headerlink" title="基于《next 数组》匹配"></a>基于《next 数组》匹配</h4><pre><code>下面，我们来基于next 数组进行匹配。</code></pre>{% image https://img-blog.csdn.net/20140721231622000 '' '' %}<pre><code>还是给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示：</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140723224710203" alt title>                </div>                <div class="image-caption"></div>            </figure><pre><code>在正式匹配之前，让我们来再次回顾下上文2.1节所述的KMP算法的匹配流程：</code></pre><ul><li><p>“假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p><ul><li>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</li><li>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。<ul><li>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。”</li></ul></li></ul></li><li><p>最开始匹配时</p><ul><li><p>P[0]跟S[0]匹配失败</p><ul><li>所以执行“如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]”，所以j = -1，故转而执行“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++”，得到i = 1，j = 0，即P[0]继续跟S[1]匹配。</li></ul></li><li><p>P[0]跟S[1]又失配，j再次等于-1，i、j继续自增，从而P[0]跟S[2]匹配。</p></li><li><p>P[0]跟S[2]失配后，P[0]又跟S[3]匹配。</p></li><li><p>P[0]跟S[3]再失配，直到P[0]跟S[4]匹配成功，开始执行此条指令的后半段：“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++”。</p><p><img src="https://img-blog.csdn.net/20140726213602848" alt></p></li></ul></li><li><p>P[1]跟S[5]匹配成功，P[2]跟S[6]也匹配成功, …，直到当匹配到P[6]处的字符D时失配（即S[10] != P[6]），由于P[6]处的D对应的next 值为2，所以下一步用P[2]处的字符C继续跟S[10]匹配，相当于向右移动：j - next[j] = 6 - 2 =4 位。</p><p><img src="https://img-blog.csdn.net/20140721223809617" alt></p></li><li><p>向右移动4位后，P[2]处的C再次失配，由于C对应的next值为0，所以下一步用P[0]处的字符继续跟S[10]匹配，相当于向右移动：j - next[j] = 2 - 0 = 2 位。</p><p><img src="https://img-blog.csdn.net/20140721223539765" alt></p></li><li><p>移动两位之后，A 跟空格不匹配，模式串后移1 位。</p><p><img src="https://img-blog.csdn.net/20140721223823548" alt></p></li><li><p>P[6]处的D再次失配，因为P[6]对应的next值为2，故下一步用P[2]继续跟文本串匹配，相当于模式串向右移动 j - next[j] = 6 - 2 = 4 位。</p><p><img src="https://img-blog.csdn.net/20140721223558140" alt></p></li><li><p>匹配成功，过程结束。</p><p><img src="https://img-blog.csdn.net/20140721223611515" alt></p></li></ul><pre><code>匹配过程一模一样。也从侧面佐证了，next 数组确实是只要将各个最大前缀后缀的公共元素的长度值右移一位，且把初值赋为-1 即可。</code></pre><h4 id="基于《最大长度表》与基于《next-数组》等价"><a href="#基于《最大长度表》与基于《next-数组》等价" class="headerlink" title="基于《最大长度表》与基于《next 数组》等价"></a>基于《最大长度表》与基于《next 数组》等价</h4><pre><code>我们已经知道，利用next 数组进行匹配失配时，模式串向右移动 j - next [ j ] 位，等价于已匹配字符数 - 失配字符的上一位字符所对应的最大长度值。原因是：</code></pre><ol><li><p>j 从0开始计数，那么当数到失配字符时，j 的数值就是已匹配的字符数；</p></li><li><p>由于next 数组是由最大长度值表整体向右移动一位（且初值赋为-1）得到的，那么失配字符的上一位字符所对应的最大长度值，即为当前失配字符的next 值。</p><p> 但为何本文不直接利用next 数组进行匹配呢？因为next 数组不好求，而一个字符串的前缀后缀的公共元素的最大长度值很容易求。例如若给定模式串“ababa”，要你快速口算出其next 数组，乍一看，每次求对应字符的next值时，还得把该字符排除之外，然后看该字符之前的字符串中有最大长度为多大的相同前缀后缀，此过程不够直接。而如果让你求其前缀后缀公共元素的最大长度，则很容易直接得出结果：0 0 1 2 3，如下表格所示：</p><p><img src="https://img-blog.csdn.net/20140725232020608" alt></p><p> 然后这5个数字 全部整体右移一位，且初值赋为-1，即得到其next 数组：-1 0 0 1 2。</p></li></ol><h4 id="Next-数组与有限状态自动机"><a href="#Next-数组与有限状态自动机" class="headerlink" title="Next 数组与有限状态自动机"></a>Next 数组与有限状态自动机</h4><pre><code>next 负责把模式串向前移动，且当第j位不匹配的时候，用第next[j]位和主串匹配，就像打了张“表”。此外，next 也可以看作有限状态自动机的状态，在已经读了多少字符的情况下，失配后，前面读的若干个字符是有用的。</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140805003320486" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="Next-数组的优化"><a href="#Next-数组的优化" class="headerlink" title="Next 数组的优化"></a>Next 数组的优化</h4><p>   行文至此，咱们全面了解了暴力匹配的思路、KMP算法的原理、流程、流程之间的内在逻辑联系，以及next 数组的简单求解（《最大长度表》整体右移一位，然后初值赋为-1）和代码求解，最后基于《next 数组》的匹配，看似洋洋洒洒，清晰透彻，但以上忽略了一个小问题。</p><pre><code>比如，如果用之前的next 数组方法求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1（0 0 1 2整体右移一位，初值赋为-1），当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 =2位。</code></pre>{% image http://hi.csdn.net/attachment/201106/14/8394323_1308075859Zfue.jpg '' '' %}<pre><code>右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hi.csdn.net/attachment/201106/14/8394323_13080758591kyV.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><pre><code>问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。所以，咱们得修改下求next 数组的代码。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//优化过后的next 数组求法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextval</span><span class="params">(<span class="keyword">char</span>* p, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])</span><br><span class="line">&#123;</span><br><span class="line">++j;</span><br><span class="line">++k;</span><br><span class="line"><span class="comment">//较之前next数组求法，改动在下面4行</span></span><br><span class="line"><span class="keyword">if</span> (p[j] != p[k])</span><br><span class="line">next[j] = k;   <span class="comment">//之前只有这一行</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]</span></span><br><span class="line">next[j] = next[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>利用优化过后的next 数组求法，可知模式串“abab”的新next数组为：-1 0 -1 0。可能有些读者会问：原始next 数组是前缀后缀最长公共元素长度值右移一位， 然后初值赋为-1而得，那么优化后的next 数组如何快速心算出呢？实际上，只要求出了原始next 数组，便可以根据原始next 数组快速求出优化后的next 数组。还是以abab为例，如下表格所示：</code></pre>{% image https://img-blog.csdn.net/20140801160510832 '' '' %}<pre><code>只要出现了p[next[j]] = p[j]的情况，则把next[j]的值再次递归。例如在求模式串“abab”的第2个a的next值时，如果是未优化的next值的话，第2个a对应的next值为0，相当于第2个a失配时，下一步匹配模式串会用p[0]处的a再次跟文本串匹配，必然失配。所以求第2个a的next值时，需要再次递归：next[2] = next[ next[2] ] = next[0] = -1（此后，根据优化后的新next值可知，第2个a失配时，执行“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符”），同理，第2个b对应的next值为0。</code></pre><p>对于优化后的next数组可以发现一点：如果模式串的后缀跟前缀相同，那么它们的next值也是相同的，例如模式串abcabc，它的前缀后缀都是abc，其优化后的next数组为：-1 0 0 -1 0 0，前缀后缀abc的next值都为-1 0 0。</p><pre><code>然后引用下之前3.1节的KMP代码：</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    </span></span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span></span><br><span class="line"><span class="comment">//next[j]即为j所对应的next值      </span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == pLen)</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>接下来，咱们继续拿之前的例子说明，整个匹配过程如下：</code></pre><ol><li>S[3]与P[3]匹配失败。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hi.csdn.net/attachment/201106/14/8394323_130807585714lW.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure> <ol start="2"><li><p>S[3]保持不变，P的下一个匹配位置是P[next[3]]，而next[3]=0，所以P[next[3]]=P[0]与S[3]匹配。</p><p><img src="http://hi.csdn.net/attachment/201106/14/8394323_13080758571390.jpg" alt></p></li><li><p>由于上一步骤中P[0]与S[3]还是不匹配。此时i=3，j=next [0]=-1，由于满足条件j==-1，所以执行“++i, ++j”，即主串指针下移一个位置，P[0]与S[4]开始匹配。最后j==pLen，跳出循环，输出结果i - j = 4（即模式串第一次在文本串中出现的位置），匹配成功，算法结束。</p><p><img src="http://hi.csdn.net/attachment/201106/14/8394323_1308075857e40u.jpg" alt>   </p></li></ol><h2 id="KMP的时间复杂度分析"><a href="#KMP的时间复杂度分析" class="headerlink" title="KMP的时间复杂度分析"></a>KMP的时间复杂度分析</h2><pre><code>相信大部分读者读完上文之后，已经发觉其实理解KMP非常容易，无非是循序渐进把握好下面几点：</code></pre><ol><li><p>如果模式串中存在相同前缀和后缀，即pj-k pj-k+1, …, pj-1 = p0 p1, …, pk-1，那么在pj跟si失配后，让模式串的前缀p0 p1…pk-1对应着文本串si-k si-k+1…si-1，而后让pk跟si继续匹配。</p></li><li><p>之前本应是pj跟si匹配，结果失配了，失配后，令pk跟si匹配，相当于j 变成了k，模式串向右移动j - k位。</p></li><li><p>因为k 的值是可变的，所以我们用next[j]表示j处字符失配后，下一次匹配模式串应该跳到的位置。换言之，失配前是j，pj跟si失配时，用p[ next[j] ]继续跟si匹配，相当于j变成了next[j]，所以，j = next[j]，等价于把模式串向右移动j - next [j] 位。</p></li><li><p>而next[j]应该等于多少呢？next[j]的值由j 之前的模式串子串中有多大长度的相同前缀后缀所决定，如果j 之前的模式串子串中（不含j）有最大长度为k的相同前缀后缀，那么next [j] = k。</p><p> 如之前的图所示：</p></li></ol>{% image https://img-blog.csdn.net/20140812223633281 '' '' %}<pre><code>接下来，咱们来分析下KMP的时间复杂度。分析之前，先来回顾下KMP匹配算法的流程：</code></pre><p>“KMP的算法流程：</p><ul><li><p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p><ul><li><p>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</p></li><li><p>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。”</p><p>我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是i++、j++；如果匹配失配，i 不变（即 i 不回溯），模式串会跳过匹配过的next [j]个字符。整个算法最坏的情况是，当模式串首字符位于i - j的位置时才匹配成功，算法结束。</p><p>所以，如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。</p></li></ul></li></ul><h2 id="扩展1：BM算法"><a href="#扩展1：BM算法" class="headerlink" title="扩展1：BM算法"></a>扩展1：BM算法</h2><pre><code>KMP的匹配是从模式串的开头开始匹配的，而1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了一种新的字符串匹配算法：Boyer-Moore算法，简称BM算法。该算法从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的时间复杂度。在实践中，比KMP算法的实际效能高。BM算法定义了两个规则：</code></pre><ul><li><p>坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果”坏字符”不包含在模式串之中，则最右出现位置为-1。</p></li><li><p>好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。</p><p>  下面举例说明BM算法。例如，给定文本串“HERE IS A SIMPLE EXAMPLE”，和模式串“EXAMPLE”，现要查找模式串是否在文本串中，如果存在，返回模式串在文本串中的位置。</p></li></ul><ol><li>首先，”文本串”与”模式串”头部对齐，从尾部开始比较。”S”与”E”不匹配。这时，”S”就被称为”坏字符”（bad character），即不匹配的字符，它对应着模式串的第6位。且”S”不包含在模式串”EXAMPLE”之中（相当于最右出现位置是-1），这意味着可以把模式串后移6-(-1)=7位，从而直接移到”S”的后一位。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140728192101322" alt title>                </div>                <div class="image-caption"></div>            </figure><ol start="2"><li><p>依然从尾部开始比较，发现”P”与”E”不匹配，所以”P”是”坏字符”。但是，”P”包含在模式串”EXAMPLE”之中。因为“P”这个“坏字符”对应着模式串的第6位（从0开始编号），且在模式串中的最右出现位置为4，所以，将模式串后移6-4=2位，两个”P”对齐。</p><p><img src="https://img-blog.csdn.net/20140728192109185" alt></p><p><img src="https://img-blog.csdn.net/20140728192118623" alt></p></li><li><p>依次比较，得到 “MPLE”匹配，称为”好后缀”（good suffix），即所有尾部匹配的字符串。注意，”MPLE”、”PLE”、”LE”、”E”都是好后缀。</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140728193254930" alt title>                </div>                <div class="image-caption"></div>            </figure><ol start="4"><li><p>发现“I”与“A”不匹配：“I”是坏字符。如果是根据坏字符规则，此时模式串应该后移2-(-1)=3位。问题是，有没有更优的移法？</p><p><img src="https://img-blog.csdn.net/20140728193420403" alt></p><p><img src="https://img-blog.csdn.net/20140728193428671" alt> </p></li><li><p>更优的移法是利用好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串中上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。</p><p>所有的“好后缀”（MPLE、PLE、LE、E）之中，只有“E”在“EXAMPLE”的头部出现，所以后移6-0=6位。</p><p>可以看出，“坏字符规则”只能移3位，“好后缀规则”可以移6位。每次后移这两个规则之中的较大值。这两个规则的移动位数，只与模式串有关，与原文本串无关。</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140728194226031" alt title>                </div>                <div class="image-caption"></div>            </figure>       <ol start="6"><li>继续从尾部开始比较，“P”与“E”不匹配，因此“P”是“坏字符”，根据“坏字符规则”，后移 6 - 4 = 2位。因为是最后一位就失配，尚未获得好后缀。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140728194006343" alt title>                </div>                <div class="image-caption"></div>            </figure><pre><code>由上可知，BM算法不仅效率高，而且构思巧妙，容易理解。</code></pre><h2 id="扩展2：Sunday算法"><a href="#扩展2：Sunday算法" class="headerlink" title="扩展2：Sunday算法"></a>扩展2：Sunday算法</h2><pre><code>上文中，我们已经介绍了KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，本文最后再介绍一种比BM算法更快的查找算法即Sunday算法。Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似：</code></pre><ul><li><p>只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。</p><ul><li><p>如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1；</p></li><li><p>否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。</p><p>下面举个例子说明下Sunday算法。假定现在要在文本串”substring searching algorithm”中查找模式串”search”。</p></li></ul></li></ul><ol><li>刚开始时，把模式串与文本串左边对齐：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">substring searching algorithm</span><br><span class="line">search</span><br><span class="line">^</span><br></pre></td></tr></table></figure><ol start="2"><li>结果发现在第2个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">substring searching algorithm</span><br><span class="line">　　　 search</span><br><span class="line">　　　　^</span><br></pre></td></tr></table></figure><ol start="3"><li>结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">substring searching algorithm</span><br><span class="line">          search</span><br><span class="line">               ^</span><br></pre></td></tr></table></figure><ol start="4"><li><p>匹配成功。</p><p> 回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于Sunday算法每一步的移动量都比较大，效率很高。完。</p></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p>《算法导论》的第十二章：字符串匹配；</p></li><li><p>本文中模式串“ABCDABD”的部分图来自于此文：<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html；" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html；</a></p></li><li><p>本文3.3.7节中有限状态自动机的图由微博网友@龚陆安 绘制：<a href="http://d.pr/i/NEiz；" target="_blank" rel="noopener">http://d.pr/i/NEiz；</a></p></li><li><p>北京7月暑假班邹博半小时KMP视频：<a href="http://www.julyedu.com/video/play/id/5；" target="_blank" rel="noopener">http://www.julyedu.com/video/play/id/5；</a></p></li><li><p>北京7月暑假班邹博第二次课的PPT：<a href="http://yun.baidu.com/s/1mgFmw7u；" target="_blank" rel="noopener">http://yun.baidu.com/s/1mgFmw7u；</a></p></li><li><p>理解KMP 的9张PPT：<a href="http://weibo.com/1580904460/BeCCYrKz3#_rnd1405957424876；" target="_blank" rel="noopener">http://weibo.com/1580904460/BeCCYrKz3#_rnd1405957424876；</a></p></li><li><p>详解KMP算法（多图）：<a href="http://www.cnblogs.com/yjiyjige/p/3263858.html；" target="_blank" rel="noopener">http://www.cnblogs.com/yjiyjige/p/3263858.html；</a></p></li><li><p>本文第4部分的BM算法参考自此文：<a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html；" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html；</a></p></li><li><p><a href="http://youlvconglin.blog.163.com/blog/static/5232042010530101020857；" target="_blank" rel="noopener">http://youlvconglin.blog.163.com/blog/static/5232042010530101020857；</a></p></li><li><p>《数据结构 第二版》，严蔚敏 &amp; 吴伟民编著；</p></li><li><p><a href="http://blog.csdn.net/v_JULY_v/article/details/6545192；" target="_blank" rel="noopener">http://blog.csdn.net/v_JULY_v/article/details/6545192；</a></p></li><li><p><a href="http://blog.csdn.net/v_JULY_v/article/details/6111565；" target="_blank" rel="noopener">http://blog.csdn.net/v_JULY_v/article/details/6111565；</a></p></li><li><p>Sunday算法的原理与实现：<a href="http://blog.chinaunix.net/uid-22237530-id-1781825.html；" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-22237530-id-1781825.html；</a></p></li><li><p>模式匹配之Sunday算法：<a href="http://blog.csdn.net/sunnianzhong/article/details/8820123；" target="_blank" rel="noopener">http://blog.csdn.net/sunnianzhong/article/details/8820123；</a></p></li><li><p>一篇KMP的英文介绍：<a href="http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/kmpen.htm；" target="_blank" rel="noopener">http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/kmpen.htm；</a></p></li><li><p>我2014年9月3日在西安电子科大的面试&amp;算法讲座视频（第36分钟~第94分钟讲KMP）：<a href="http://www.julyedu.com/video/play/21；" target="_blank" rel="noopener">http://www.julyedu.com/video/play/21；</a></p></li><li><p>一幅图理解KMP next数组的求法：<a href="http://v.atob.site/kmp-next.html" target="_blank" rel="noopener">http://v.atob.site/kmp-next.html</a></p></li></ol><blockquote><p>版权声明：本文为CSDN博主「v_JULY_v」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【转载】从头到尾彻底理解KMP-BM-Sunday算法&quot;&gt;&lt;a href=&quot;#【转载】从头到尾彻底理解KMP-BM-Sunday算法&quot; class=&quot;headerlink&quot; title=&quot;【转载】从头到尾彻底理解KMP/BM/Sunday算法&quot;&gt;&lt;/a&gt;【转载】从
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="转载" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>股票问题通解-有限状态机</title>
    <link href="http://QQ876684433.github.io/2019/10/02/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E9%80%9A%E8%A7%A3-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://QQ876684433.github.io/2019/10/02/股票问题通解-有限状态机/</id>
    <published>2019-10-02T03:21:30.000Z</published>
    <updated>2019-10-07T11:36:52.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【转载】股票问题通解-有限状态机"><a href="#【转载】股票问题通解-有限状态机" class="headerlink" title="【转载】股票问题通解 - 有限状态机"></a>【转载】股票问题通解 - 有限状态机</h1><p>很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。</p><p>这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。</p><p>先随便抽出一道题，看看别人的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s1=-prices[<span class="number">0</span>],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();++i) &#123;            </span><br><span class="line">        s1 = max(s1, -prices[i]);</span><br><span class="line">        s2 = max(s2, s1+prices[i]);</span><br><span class="line">        s3 = max(s3, s2-prices[i]);</span><br><span class="line">        s4 = max(s4, s3+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">0</span>,s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。</p><p>本文就来告诉你这个框架，然后带着你一道一道秒杀。</p><p>这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。</p><p>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。</p><h2 id="一、穷举框架"><a href="#一、穷举框架" class="headerlink" title="一、穷举框架"></a>一、穷举框架</h2><p>首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。</p><p>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。</p><p>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp状态<span class="number">1</span>[...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><p>比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。</p><p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dpi[<span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n<span class="number">-1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line">n 为天数，大 K 为最多交易数</span><br><span class="line">此问题共 n × K × <span class="number">2</span> 种状态，全部穷举就能搞定。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">        <span class="keyword">for</span> s in &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">            dpi[s] = max(buy, sell, rest)</span><br></pre></td></tr></table></figure><p>而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p><p>我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p><p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p><h2 id="二、状态转移框架"><a href="#二、状态转移框架" class="headerlink" title="二、状态转移框架"></a>二、状态转移框架</h2><p>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.leetcode-cn.com/c4eb5f0aa4daf7bef4b3b8af95129bb7394ec58e1ba7b191d9104bbd8ff1ccb3-40198bf2f6894018328b250b772b4a17724a983f99ba359b798a289733bffcbc-file_1559885188422-1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">              max(   选择 rest  ,           选择 sell      )</span><br><span class="line"></span><br><span class="line">解释：今天我没有持有股票，有两种可能：</span><br><span class="line">要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span><br><span class="line">要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span><br><span class="line"></span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">              max(   选择 rest  ,           选择 buy         )</span><br><span class="line"></span><br><span class="line">解释：今天我持有着股票，有两种可能：</span><br><span class="line">要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span><br><span class="line">要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span><br></pre></td></tr></table></figure><p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。</p><p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">-1</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 i 是从 <span class="number">0</span> 开始的，所以 i = <span class="number">-1</span> 意味着还没有开始，这时候的利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 k 是从 <span class="number">1</span> 开始的，所以 k = <span class="number">0</span> 意味着根本不允许交易，这时候利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span><br></pre></td></tr></table></figure><p>把上面的状态转移方程总结一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">base <span class="keyword">case</span>：</span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">0</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。</p><h2 id="三、秒杀题目"><a href="#三、秒杀题目" class="headerlink" title="三、秒杀题目"></a>三、秒杀题目</h2><h3 id="第一题，k-1"><a href="#第一题，k-1" class="headerlink" title="第一题，k = 1"></a>第一题，k = 1</h3><p>直接套状态转移方程，根据 base case，可以做一些化简：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i]) </span><br><span class="line">            = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">解释：k = <span class="number">0</span> 的 base <span class="keyword">case</span>，所以 dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">现在发现 k 都是 <span class="number">1</span>，不会改变，即 k 对状态转移已经没有影响了。</span><br><span class="line">可以进行进一步化简去掉所有 k：</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i])</span><br></pre></td></tr></table></figure><p>直接写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = prices.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>显然<code>i = 0</code> 时 <code>dp[i-1]</code> 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 解释：</span></span><br><span class="line">        <span class="comment">//   dp[i][0] </span></span><br><span class="line">        <span class="comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span></span><br><span class="line">        <span class="comment">// = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">        <span class="comment">//解释：</span></span><br><span class="line">        <span class="comment">//   dp[i][1] </span></span><br><span class="line">        <span class="comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span></span><br><span class="line">        <span class="comment">// = max(-infinity, 0 - prices[i]) </span></span><br><span class="line">        <span class="comment">// = -prices[i]</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k == 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="comment">// base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span></span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        <span class="comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span></span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p><h3 id="第二题，k-infinity"><a href="#第二题，k-infinity" class="headerlink" title="第二题，k = +infinity"></a>第二题，k = +infinity</h3><p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">            = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k][<span class="number">0</span>] - prices[i])</span><br><span class="line"></span><br><span class="line">我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>直接翻译成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_inf</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三题，k-infinity-with-cooldown"><a href="#第三题，k-infinity-with-cooldown" class="headerlink" title="第三题，k = +infinity with cooldown"></a>第三题，k = +infinity with cooldown</h3><p>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-2</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">解释：第 i 天选择 buy 的时候，要从 i<span class="number">-2</span> 的状态转移，而不是 i<span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><p>翻译成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_cool</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp_pre_0 = <span class="number">0</span>; <span class="comment">// 代表 dp[i-2][0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);</span><br><span class="line">        dp_pre_0 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四题，k-infinity-with-fee"><a href="#第四题，k-infinity-with-fee" class="headerlink" title="第四题，k = +infinity with fee"></a>第四题，k = +infinity with fee</h3><p>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i] - fee)</span><br><span class="line">解释：相当于买入股票的价格升高了。</span><br><span class="line">在第一个式子里减也是一样的，相当于卖出股票的价格减小了。</span><br></pre></td></tr></table></figure><p>在第一个式子里减也是一样的，相当于卖出股票的价格减小了。<br>直接翻译成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_fee</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第五题，k-2"><a href="#第五题，k-2" class="headerlink" title="第五题，k = 2"></a>第五题，k = 2</h3><p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。</p><p>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始的动态转移方程，没有可化简的地方</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123; <span class="comment">/* 处理一下 base case*/</span> &#125;</span><br><span class="line">    dp[i][k][<span class="number">0</span>] = Math.max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][k][<span class="number">1</span>] = Math.max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][k][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>为什么错误？我这不是照着状态转移方程写的吗？</p><p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max_k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123; </span><br><span class="line">            <span class="comment">/* 处理 base case */</span></span><br><span class="line">            dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][k][<span class="number">1</span>] = -prices[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 穷举了 n × max_k × 2 个状态，正确。</span></span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。</p><p>这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">2</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">2</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxProfit_k_2(<span class="keyword">int</span>[] prices) &#123;</span><br><span class="line">    <span class="keyword">int</span> dp_i10 = <span class="number">0</span>, dp_i11 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp_i20 = <span class="number">0</span>, dp_i21 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">        dp_i20 = Math.max(dp_i20, dp_i21 + price);</span><br><span class="line">        dp_i21 = Math.max(dp_i21, dp_i10 - price);</span><br><span class="line">        dp_i10 = Math.max(dp_i10, dp_i11 + price);</span><br><span class="line">        dp_i11 = Math.max(dp_i11, -price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。</p><h3 id="第六题，k-any-integer"><a href="#第六题，k-any-integer" class="headerlink" title="第六题，k = any integer"></a>第六题，k = any integer</h3><p>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？</p><p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。</p><p>直接把之前的代码重用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_any</span><span class="params">(<span class="keyword">int</span> max_k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (max_k &gt; n / <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> maxProfit_k_inf(prices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123; <span class="comment">/* 处理 base case */</span> &#125;</span><br><span class="line">            dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);     </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，6 道题目通过一个状态转移方程全部解决。</p><h2 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h2><p>本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。</p><p>关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？</p><p>具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。</p><p>所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。</p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/" target="_blank" rel="noopener">买卖股票的最佳时机</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">买卖股票的最佳时机 III</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">买卖股票的最佳时机 IV</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">买卖股票的最佳时机含手续费</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a><strong>推荐阅读</strong></h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia" target="_blank" rel="noopener">动态规划设计方法：归纳思想</a></p><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/" target="_blank" rel="noopener">滑动窗口算法解决一类子串问题</a></p><p><a href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/" target="_blank" rel="noopener">腾讯面试题详解：编辑距离</a></p><blockquote><p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/</a><br>来源：力扣（LeetCode）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【转载】股票问题通解-有限状态机&quot;&gt;&lt;a href=&quot;#【转载】股票问题通解-有限状态机&quot; class=&quot;headerlink&quot; title=&quot;【转载】股票问题通解 - 有限状态机&quot;&gt;&lt;/a&gt;【转载】股票问题通解 - 有限状态机&lt;/h1&gt;&lt;p&gt;很多读者抱怨股票系列
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="转载" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-26）</title>
    <link href="http://QQ876684433.github.io/2019/09/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-26%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/26/数据库课堂笔记（2019-09-26）/</id>
    <published>2019-09-26T13:24:12.000Z</published>
    <updated>2019-10-20T15:02:04.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-26）"><a href="#数据库课堂笔记（2019-09-26）" class="headerlink" title="数据库课堂笔记（2019-09-26）"></a>数据库课堂笔记（2019-09-26）</h2><h3 id="Ch3-Basic-SQL-Query-Language"><a href="#Ch3-Basic-SQL-Query-Language" class="headerlink" title="Ch3. Basic SQL Query Language"></a>Ch3. Basic SQL Query Language</h3><h4 id="UNION和FOR-ALL条件"><a href="#UNION和FOR-ALL条件" class="headerlink" title="UNION和FOR ALL条件"></a>UNION和FOR ALL条件</h4><ul><li>Union：结果中没有重复行（会将重复行给剔除）</li><li>Union All：结果中可能会有重复行（即不会将重复行给剔除）</li></ul><p>例子：</p><ul><li>R1 := S1 <strong>UNION</strong> S2</li><li>R2 := S1 <strong>UNION ALL</strong> S2</li><li>R3 := ( S1 <strong>UNION ALL</strong> S2 ) <strong>UNION</strong> S3</li><li>R4 := S1 <strong>UNION ALL</strong> ( S2 <strong>UNION</strong> S3 )</li></ul><p>只要<strong>最后一个操作是UNION</strong>，那么结果就没有重复行；所以R1&amp;R3的结果中没有重复行</p><h4 id="INTERSECT和EXCEPT操作"><a href="#INTERSECT和EXCEPT操作" class="headerlink" title="INTERSECT和EXCEPT操作"></a>INTERSECT和EXCEPT操作</h4><ul><li><p>INTERSECT</p><p>The INTERSECT clause in SQL is used to combine two <a href="https://www.geeksforgeeks.org/sql-select-clause/" target="_blank" rel="noopener">SELECT</a> statements but the dataset returned by the INTERSECT statement will be the intersection of the data-sets of the two SELECT statements. In simple words, the INTERSECT statement will return only those rows which will be common to both of the SELECT statements.</p><p><img src="https://i.loli.net/2019/10/20/9wkabC6zJxj7UBD.png" alt></p><p>The INTERSECT statement will return only those rows present in the deep green shaded region. i.e. common to both of the data-sets.</p></li><li><p>EXCEPT</p><p>The SQL <strong>EXCEPT</strong> clause/operator is used to combine two SELECT statements and returns rows from the first SELECT statement that are not returned by the second SELECT statement. This means EXCEPT returns only rows, which are not available in the second SELECT statement.</p><p>Just as with the UNION operator, the same rules apply when using the EXCEPT operator. <strong>MySQL does not support the EXCEPT operator</strong>.</p></li></ul><h4 id="SQL中的DIVISION操作"><a href="#SQL中的DIVISION操作" class="headerlink" title="SQL中的DIVISION操作"></a>SQL中的DIVISION操作</h4><p>SQL中没有类似于关系代数中的÷（division）操作，但可以通过<strong>两个NOT EXIST</strong>来实现除法操作，例子如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q: Find cids of customers who place orders <span class="keyword">with</span> <span class="keyword">ALL</span> agents based <span class="keyword">in</span> <span class="keyword">New</span> York.</span><br><span class="line"></span><br><span class="line">A: o[cid, aid] ÷ (a <span class="keyword">where</span> city=‘<span class="keyword">New</span> York’)[aid]</span><br></pre></td></tr></table></figure><ul><li><p>以上是关系代数运算，它的意思等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if row c in customers table is a customer of result <span class="keyword">set</span>, <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> a <span class="keyword">in</span> agents <span class="keyword">table</span> which <span class="keyword">is</span> based <span class="keyword">in</span> <span class="keyword">New</span> York</span><br><span class="line">        we can find a <span class="keyword">row</span> o <span class="keyword">in</span> orders <span class="keyword">table</span> which: o.cid = c.cid <span class="keyword">and</span> o.aid = a.aid</span><br></pre></td></tr></table></figure></li><li><p>-&gt;等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if row c in customers table is a customer of result <span class="keyword">set</span>, <span class="keyword">then</span></span><br><span class="line"><span class="keyword">no</span> <span class="keyword">row</span>(a) <span class="keyword">in</span> agents <span class="keyword">table</span> which</span><br><span class="line">        <span class="keyword">is</span> based <span class="keyword">in</span> <span class="keyword">New</span> York, <span class="keyword">and</span></span><br><span class="line">        <span class="string">"no row(o) in orders table which o.cid = c.cid and o.aid = a.aid"</span></span><br></pre></td></tr></table></figure><p>这样我们可以根据最后一句构造出第一个条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond1: NOT EXISTS ( <span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid=c.cid <span class="keyword">and</span> o.aid=a.aid )</span><br></pre></td></tr></table></figure></li><li><p>-&gt;等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if row c in customers table is a customer of result <span class="keyword">set</span>, <span class="keyword">then</span></span><br><span class="line"><span class="keyword">no</span> <span class="keyword">row</span>(a) <span class="keyword">in</span> agents <span class="keyword">table</span> which</span><br><span class="line"><span class="keyword">is</span> based <span class="keyword">in</span> <span class="keyword">New</span> York, <span class="keyword">and</span></span><br><span class="line">cond1</span><br></pre></td></tr></table></figure><p>然后使用cond1可以构造出第二个条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond2: NOT EXISTS ( <span class="keyword">select</span> * <span class="keyword">from</span> agents a <span class="keyword">where</span> city = ‘<span class="keyword">New</span> York’ <span class="keyword">and</span> cond1 )</span><br></pre></td></tr></table></figure></li><li><p>-&gt;等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if row c in customers table is a</span><br><span class="line">    customer of result <span class="keyword">set</span>, <span class="keyword">then</span></span><br><span class="line">    cond2</span><br></pre></td></tr></table></figure><p>最后我们可以使用cond2写出SQL查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.cid <span class="keyword">FROM</span> customers c <span class="keyword">WHERE</span> cond2 )</span><br></pre></td></tr></table></figure></li><li><p>完整的SQL查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.cid <span class="keyword">FROM</span> customers c</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> agents a</span><br><span class="line">    <span class="keyword">WHERE</span> a.city = ‘<span class="keyword">New</span> York’ <span class="keyword">and</span> <span class="keyword">NOT</span></span><br><span class="line">    <span class="keyword">EXISTS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orders o</span><br><span class="line">        <span class="keyword">WHERE</span> o.cid=c.cid <span class="keyword">and</span> o.aid=a.aid ) )</span><br></pre></td></tr></table></figure></li></ul><p>按照我自己的理解的话，这个类似于”双重否定表肯定”的感觉，或者逆否命题</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/20/LGkiJveumwUMCYP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>搬一张图片：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/20/zfYtal5LXSxHVpA.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-24）</title>
    <link href="http://QQ876684433.github.io/2019/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-24%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/24/数据库课堂笔记（2019-09-24）/</id>
    <published>2019-09-24T03:25:09.000Z</published>
    <updated>2019-10-15T03:30:19.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-24）"><a href="#数据库课堂笔记（2019-09-24）" class="headerlink" title="数据库课堂笔记（2019-09-24）"></a>数据库课堂笔记（2019-09-24）</h2><h3 id="Ch3-Basic-SQL-Query-Language"><a href="#Ch3-Basic-SQL-Query-Language" class="headerlink" title="Ch3. Basic SQL Query Language"></a>Ch3. Basic SQL Query Language</h3><h4 id="建立数据库"><a href="#建立数据库" class="headerlink" title="建立数据库"></a>建立数据库</h4><h5 id="ANSI-SQL数据类型"><a href="#ANSI-SQL数据类型" class="headerlink" title="ANSI SQL数据类型"></a>ANSI SQL数据类型</h5><ul><li><p>字符数据类型（Character）</p><ul><li>固定长度字符串类型：CHARACTER(n)，CHAR(n)</li><li>可变长度字符串类型：CHARACTER VARYING(n)，CHAR VARYING(n)</li></ul></li><li><p>数字数据类型（Numeric）</p><p>(此处推荐阅读：<a href="https://academy.vertabelo.com/blog/understanding-numerical-data-types-sql/" target="_blank" rel="noopener">https://academy.vertabelo.com/blog/understanding-numerical-data-types-sql/</a>)</p><blockquote><p>precision(p)：数字的总位数</p><p>scale(s)：小数点右边的数字个数</p></blockquote><blockquote><p>Precision is an integer that represents the total number of digits allowed in this column. These digits are in a particular radix, or number base – i.e. binary (base-2) or decimal (base-10). They are usually defined with a <em>decimal</em> <em>point</em>.</p><p>The scale, also an integer value, represents the number of <em>decimal</em> <em>places</em> to the right (if positive) or left (if negative; this is rarely used) of the <em>decimal</em> <em>point</em>.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE account (</span><br><span class="line">&gt;     accountNo integer,</span><br><span class="line">&gt;     balance numeric(8,2)</span><br><span class="line">&gt; );</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://academy.vertabelo.com/blog/understanding-numerical-data-types-sql/numeric-data-types-1.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></blockquote><p><strong>Exact numeric data types</strong>(means the values are stored as a literal representation of the number’s value):</p><ul><li>NUMERIC(p, s), DECIMAL(p, s), DEC(p, s)</li><li>INTEGER, INT, SMALLINT</li></ul><p><strong>Approximate numeric data types</strong>(means they are not represented as exact numbers in the database):</p><ul><li>FLOAT(p)</li><li>REAL</li><li>DOUBLE PRECISION</li></ul></li></ul><p>Oracle数据库中NUMBER数据类型的例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/mv4Di5buqhlRPOf.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="创建数据表的语句"><a href="#创建数据表的语句" class="headerlink" title="创建数据表的语句"></a>创建数据表的语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename&#123;</span><br><span class="line">    colname datatype [<span class="keyword">NOT</span> <span class="literal">NULL</span>]</span><br><span class="line">    &#123; , colname datatype [<span class="keyword">NOT</span> <span class="literal">NULL</span>] ...&#125;</span><br><span class="line">    [ , PRIMARY <span class="keyword">KEY</span> (colname &#123; , colname ...&#125;)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(1) <strong>[ … ] -&gt; 表示可选，即出现0次或者1次    { … } -&gt; 表示出现0次或者多次</strong></p><p>(2) CREATE TABLE</p><p>(3) NOT NULL</p><p>(4) PRIMARY KEY</p><p>说明创建一个数据表时，必须<strong>至少包含一个属性</strong>，另外<strong>主键可以有0个、1个或者多个</strong></p><h4 id="简单的选择语句"><a href="#简单的选择语句" class="headerlink" title="简单的选择语句"></a>简单的选择语句</h4><h5 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ......</span><br><span class="line"><span class="keyword">FROM</span> …...</span><br><span class="line">[ <span class="keyword">WHERE</span> …… ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> …... [ <span class="keyword">HAVING</span> …… ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> …… ];</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * | colname &#123; , colname ... &#125;</span><br><span class="line"><span class="keyword">FROM</span> tablename &#123; , tablename ... &#125;</span><br><span class="line">[ <span class="keyword">WHERE</span> search_condition ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> colname &#123; , colname ... &#125;</span><br><span class="line">[ <span class="keyword">HAVING</span> search_condition ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> colname [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ]</span><br><span class="line">&#123; , colname [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ] ... &#125; ];</span><br></pre></td></tr></table></figure><p>可以看出HAVING语句是跟GROUP BY一起使用的，不能单独存在；另外可以根据多个属性对查询结果进行排序，并且可以分别为每一个属性指定按照升序或者降序排列</p><h5 id="关系代数和SQL查询"><a href="#关系代数和SQL查询" class="headerlink" title="关系代数和SQL查询"></a>关系代数和SQL查询</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/IWFsYj8klAbUeHn.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/T7dJ18FvyzZqspt.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/D6eKmEURinphOVo.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/gFRvoE57ndSHpBN.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="ALL-DISTINCT"><a href="#ALL-DISTINCT" class="headerlink" title="ALL|DISTINCT"></a>ALL|DISTINCT</h5><p>select语句中可以添加all或者distinct来指示查询结果是否剔除重复行，下面的查询结果中每一行都是唯一的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span> pid <span class="keyword">FROM</span> orders ;</span><br></pre></td></tr></table></figure><h5 id="表和列的别名"><a href="#表和列的别名" class="headerlink" title="表和列的别名"></a>表和列的别名</h5><ul><li><p>表别名</p><p><code>table_name as alias_name</code>或者<code>table_name alias_name</code>，即<code>as</code>是可以省略的。给表取别名可以用在表与表自身联接查询的情况：</p><p><img src="https://i.loli.net/2019/10/10/DKgy69otJiwqIba.png" alt></p><p>（这里有一个技巧是通过<code>c1.cid &lt; c2.cid</code>来将查询结果重复行和<strong>逆序行</strong>去掉）</p></li><li><p>列别名</p><p><code>expression as alias_name</code>，这个可以向表别名一样直接给列取别名（<code>as</code>同样是可选的），也可以给列表达式取别名，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ordno, dollars,</span><br><span class="line">o.qty*p.price*(<span class="number">1</span>-c.discnt*<span class="number">0.01</span>) <span class="keyword">as</span> mydollars</span><br><span class="line"><span class="keyword">FROM</span> ...</span><br></pre></td></tr></table></figure><p>表达式取别名的作用是在查询结果作为子查询的时候，能够方便的通过别名来访问使用了表达式的列</p></li></ul><p><strong>*贴一道诡异的题目</strong>（注释是我的个人理解，这样sql语句才能解释的通）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/eMYauO3iG1FAXk9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><h5 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr [NOT] IN ( subquery )</span><br></pre></td></tr></table></figure><blockquote><p><strong>相关子查询和独立子查询（非相关子查询）</strong></p><ul><li>非相关子查询的执行不依赖与外部的查询。<br> 执行过程：<br>（1）执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。<br>（2）执行外部查询，并显示整个结果。　</li><li>相关子查询的执行依赖于外部查询。多数情况下是<strong>子查询的WHERE子句中引用了外部查询的表</strong>。<br>执行过程：<br>（1）从外层查询中取出一个元组，将元组相关列的值传给内层查询。<br>（2）执行内层查询，得到子查询操作的值。<br>（3）外查询根据子查询返回的结果或结果集得到满足条件的行。<br>（4）然后<strong>外层查询取出下一个元组重复做步骤1-3</strong>，直到外层的元组全部处理完毕。 　</li></ul><p>参考资料：<a href="https://blog.csdn.net/shiyong1949/article/details/80923083" target="_blank" rel="noopener">https://blog.csdn.net/shiyong1949/article/details/80923083</a></p></blockquote><p>例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/kObM9JydzA6E2T7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/Im9Ks38rzeqa57d.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>另外要注意<strong>表名</strong>和<strong>列名</strong>作用域问题，IN语句中的表名和列名不能被语句外部使用：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/6a58ipwJFATRHqu.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="定量比较谓词"><a href="#定量比较谓词" class="headerlink" title="定量比较谓词"></a>定量比较谓词</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr  SOME|ANY|ALL ( subquery )</span><br></pre></td></tr></table></figure><p>定量谓词 vs <code>[NOT] IN</code></p><ul><li><code>IN</code>相当于<code>SOME</code></li><li><code>NOT IN</code>相当于<code>&lt;&gt; ALL</code></li></ul><p>ps：<strong>SOME 和 ANY是一样的</strong>（参考：<a href="https://stackoverflow.com/questions/1383988/tsql-some-any-why-are-they-same-with-different-names）" target="_blank" rel="noopener">https://stackoverflow.com/questions/1383988/tsql-some-any-why-are-they-same-with-different-names）</a></p><p>例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/home/steve/.config/Typora/typora-user-images/1571108972229.png" alt="1571108972229" title>                </div>                <div class="image-caption">1571108972229</div>            </figure><p>划线部分到底是ALL还是ANY/SOME？</p><p>翻译的意思是：比任何客户都小。因此使用ALL</p><h5 id="存在谓词"><a href="#存在谓词" class="headerlink" title="存在谓词"></a>存在谓词</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NOT] EXISTS ( subquery )</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/15/PRrpIBYuiv3maEG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><code>NOT EXISTS</code>可以用来实现差运算</p><h5 id="BETWEEN运算符"><a href="#BETWEEN运算符" class="headerlink" title="BETWEEN运算符"></a>BETWEEN运算符</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr [NOT] BETWEEN expr1 AND expr2</span><br></pre></td></tr></table></figure><ul><li><p>The BETWEEN operator selects values within a given range. The values can be <strong>numbers, text, or dates</strong>.</p></li><li><p>The BETWEEN operator is inclusive: <strong>begin and end values are included</strong>. </p></li></ul><p>expr1和expr2是计算两个边界值的表达式</p><h5 id="IS-NULL运算符"><a href="#IS-NULL运算符" class="headerlink" title="IS NULL运算符"></a>IS NULL运算符</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column IS [NOT] NULL</span><br></pre></td></tr></table></figure><p>null值字段不能和其他非null字段直接比较（&gt;、&lt;、=等），可以使用<code>IS NULL</code>来判断一个字段的值是不是NULL</p><h5 id="LIKE运算符"><a href="#LIKE运算符" class="headerlink" title="LIKE运算符"></a>LIKE运算符</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column [NOT] LIKE val1 [ ESCAPE val2 ]</span><br></pre></td></tr></table></figure><p>val1是模板值（pattern），val2是转义指示字符</p><ul><li>Underscore ( _ ) : Wildcard for any single character，任何单个字符的通配符</li><li>Percent ( % ) : Wildcard for any sequence of zero or more characters，任何<strong>零个或多个</strong>字符的通配符，即%可以不匹配任何字符</li><li>Escape character : Precedes quoted literal character，转义字符</li><li>All other characters : Represent themselves，代表字符本身</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-17）</title>
    <link href="http://QQ876684433.github.io/2019/09/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-17%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/17/数据库课堂笔记（2019-09-17）/</id>
    <published>2019-09-17T03:25:09.000Z</published>
    <updated>2019-10-03T04:12:11.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-17）"><a href="#数据库课堂笔记（2019-09-17）" class="headerlink" title="数据库课堂笔记（2019-09-17）"></a>数据库课堂笔记（2019-09-17）</h2><h3 id="Ch2-The-Relational-Model"><a href="#Ch2-The-Relational-Model" class="headerlink" title="Ch2. The Relational Model"></a>Ch2. The Relational Model</h3><h4 id="操作的相互依赖性（The-Interdependence-of-Operations）"><a href="#操作的相互依赖性（The-Interdependence-of-Operations）" class="headerlink" title="操作的相互依赖性（The Interdependence of Operations）"></a>操作的相互依赖性（The Interdependence of Operations）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/21/l2A49OG67wMe5jD.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>基本关系集合</strong>：并、差、乘积、选择、投影[、别名]，这可以称为<strong>关系完备（Relationally Complete）</strong>的</p><ul><li><p>交运算</p><p><img src="https://i.loli.net/2019/09/21/CldHe1aWLI5zFDJ.png" alt></p><p><img src="https://i.loli.net/2019/09/21/auDksXGlxCFdyIY.png" alt></p></li><li><p>连接运算</p><p><img src="https://i.loli.net/2019/09/21/24XWvu5Q1tk8jzF.png" alt></p></li><li><p>除法运算</p><p><img src="https://i.loli.net/2019/09/21/ACurzjOJkS7mcix.png" alt></p></li></ul><h4 id="其他的关系运算"><a href="#其他的关系运算" class="headerlink" title="其他的关系运算"></a>其他的关系运算</h4><h5 id="外联接（OUTER-JOIN）"><a href="#外联接（OUTER-JOIN）" class="headerlink" title="外联接（OUTER JOIN）"></a>外联接（OUTER JOIN）</h5><ul><li><p>外联接是左外联接和右外联接的并集</p><p><img src="https://i.loli.net/2019/10/03/peVol82cHMZ4ysa.png" alt></p></li><li><p>联接运算符（JOIN）无法反向重构出原来参与运算的关系表，例如如果通过<code>（R JOIN S）</code>和R反向重构出S：</p><p><img src="https://i.loli.net/2019/10/03/1P5EZy6SbH4pRu2.png" alt></p></li><li><p>外联接与比普通联接运算符的不同在于：针对未参与自然联接的元组u，生成对应的外联接结果元组时<strong>使用null来填充空缺值</strong>。例子如下</p><p><img src="https://i.loli.net/2019/10/03/ZPrlzuNmevRHYQn.png" alt></p></li><li><p>外联接可以通过结果和其中一个关系来反向重构另一个关系：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反向重构关系S： ((R outer join S) where C&lt;&gt;null )[B, C]</span><br></pre></td></tr></table></figure></li></ul><h5 id="θ-联接"><a href="#θ-联接" class="headerlink" title="θ - 联接"></a>θ - 联接</h5><ul><li><p>定义：</p><p><img src="https://i.loli.net/2019/10/03/tCG8UdM74FfW6Bl.png" alt></p><p><img src="https://i.loli.net/2019/10/03/TCv7BsIpiq3w9bf.png" alt></p><p>一个更加通俗理解是这样：</p><p><img src="https://i.loli.net/2019/10/03/YHUPtEWlkiOKDeG.png" alt></p><p>可以把θ联接看成是<strong>带条件查询的笛卡尔乘积</strong></p></li><li><p>自然联接是θ联接中的的θ为”=”的特殊情况，即：</p><p><img src="https://img-blog.csdn.net/20180424203614498" alt></p><p>文字描述：</p><ul><li>要求关系R和关系S必须有相同的属性<strong>组</strong>B(B1, B2, …)</li><li>R和S的属性组B的值完全相同的元组才能够连接</li><li>要在结果中<strong>去掉重复的属性列</strong>（<strong>这些重复列的值完全一样</strong>）</li></ul></li><li><p>例子：</p><p><img src="https://i.loli.net/2019/10/03/XjeydJptFUVkO3E.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://QQ876684433.github.io/2019/09/15/hello-world/"/>
    <id>http://QQ876684433.github.io/2019/09/15/hello-world/</id>
    <published>2019-09-15T05:02:14.666Z</published>
    <updated>2019-09-15T05:02:14.666Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-12）</title>
    <link href="http://QQ876684433.github.io/2019/09/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-12%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/12/数据库课堂笔记（2019-09-12）/</id>
    <published>2019-09-12T03:25:09.000Z</published>
    <updated>2019-09-21T02:50:12.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-12）"><a href="#数据库课堂笔记（2019-09-12）" class="headerlink" title="数据库课堂笔记（2019-09-12）"></a>数据库课堂笔记（2019-09-12）</h2><h3 id="Ch2-The-Relational-Model"><a href="#Ch2-The-Relational-Model" class="headerlink" title="Ch2. The Relational Model"></a>Ch2. The Relational Model</h3><h4 id="关系代数（Relational-Algebra）"><a href="#关系代数（Relational-Algebra）" class="headerlink" title="关系代数（Relational Algebra）"></a>关系代数（Relational Algebra）</h4><h5 id="自然关系运算"><a href="#自然关系运算" class="headerlink" title="自然关系运算"></a>自然关系运算</h5><ul><li><p><strong>连接（等值连接，自然连接，JOIN）</strong></p><blockquote><p>其作用是： 根据两个关系中的<strong>同名属性的相等比较</strong>， 来实现两个关系的合并；可以表示为 <code>R join S</code> 或者 <code>R ∞ S</code></p></blockquote><p><img src="https://i.loli.net/2019/09/18/uBaTPweGtvfmRqx.png" alt></p><p>如果R和S的同名属性为B1和B2，那么这里的<code>R ∞ S</code>相当于：<code>((R × S) where R.B1 = S.B1 and R.B2 = S.B2 ) [R.A, R.B1, R.B2, S.C]</code>。注意与<code>R × S</code>的区别：<code>R × S</code>没有进行任何同名属性的比较，只是单纯进行笛卡尔积，并且新的表的表头是原来两个表的表头的拼接。</p><p><img src="https://i.loli.net/2019/09/18/12rtzW58wGhNulb.png" alt></p><blockquote><p>If Head(R) ∩ Head(S) = ∅ , then R ∞ S = R x S<br>If Head(R) = Head(S) , then R ∞ S = R ∩ S<br>If Head(R) is subset of Head(S) , then R ∞ S is subset of S</p></blockquote><p>乘积和连接运算满足交换律和结合律：</p><blockquote><p>1) R x S = S x R<br>2) R ∞ S = S ∞ R</p><p>3) (R x S) x T = R x (S x T)<br>4) (R ∞ S) ∞ T = R ∞ (S ∞ T)</p></blockquote></li><li><p><strong>除法（Division）</strong></p><p><img src="https://i.loli.net/2019/09/21/OEMaNngviY7hzc3.png" alt></p><p>注意T：<strong>the largest possible set</strong></p><p>除法有如下性质：</p><p><img src="https://i.loli.net/2019/09/21/J2BwGknFYygq6HP.png" alt></p><p>使用除法操作的场景：可以使用除法<code>division</code>运算来回答使用<strong>关键词”All、所有”</strong>的问题</p><p><img src="https://i.loli.net/2019/09/21/BP3o17HCT4hvKDr.png" alt></p><p>（1）对PRODUCTS进行投影操作PRODUCTS[pid]的原因：除数的列集合必须是被除数的列集合的子集</p><p>（2）为什么要对ORDERS在cid、pid上进行投影：因为我们最终想要的结果只需要cid的集合，因此其他属性不需要投影，而pid在进行除法运算后就没了</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>152.乘积最大子序列</title>
    <link href="http://QQ876684433.github.io/2019/09/10/152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://QQ876684433.github.io/2019/09/10/152-乘积最大子序列/</id>
    <published>2019-09-10T03:38:00.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-10）</title>
    <link href="http://QQ876684433.github.io/2019/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-10%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/10/数据库课堂笔记（2019-09-10）/</id>
    <published>2019-09-10T03:25:09.000Z</published>
    <updated>2019-09-17T14:22:52.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-10）"><a href="#数据库课堂笔记（2019-09-10）" class="headerlink" title="数据库课堂笔记（2019-09-10）"></a>数据库课堂笔记（2019-09-10）</h2><h3 id="Ch2-The-Relational-Model"><a href="#Ch2-The-Relational-Model" class="headerlink" title="Ch2. The Relational Model"></a>Ch2. The Relational Model</h3><h4 id="键、超键和空值（Keys，Superkeys，and-Null-Values）"><a href="#键、超键和空值（Keys，Superkeys，and-Null-Values）" class="headerlink" title="键、超键和空值（Keys，Superkeys，and Null Values）"></a>键、超键和空值（Keys，Superkeys，and Null Values）</h4><h5 id="键（Keys）"><a href="#键（Keys）" class="headerlink" title="键（Keys）"></a>键（Keys）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/oAfCMukbUgwaRxv.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>条件1说明了任意一行u在属性集K上的值是唯一的；<strong>表可能具有不止一个键</strong>；关系规则3保证了所有列的集合可以唯一区分任意两行，因此<strong>关系中至少存在一个键</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/meGc57MyshgdLJ9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/RzwquBxEKGfOMIn.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="超键（Superkeys）"><a href="#超键（Superkeys）" class="headerlink" title="超键（Superkeys）"></a>超键（Superkeys）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/S3cbnm4Kv1Q9qaG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>属性集是不是键或者超键，取决于“设计者的意图”，有时候某些属性集在特定时刻它满足条件1，但是可能随着时间的改变，很有可能不再满足该条件，这样的属性集不是键或者超键</p><p><strong>空集既不是超键也不是键</strong>，因为属性集为空集时无法唯一确定某一行，因为所有行在空集上的取值都是空集</p><h5 id="候选键和主键（Candidate-Key-amp-Primary-Key）"><a href="#候选键和主键（Candidate-Key-amp-Primary-Key）" class="headerlink" title="候选键和主键（Candidate Key &amp; Primary Key）"></a>候选键和主键（Candidate Key &amp; Primary Key）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/46FHld1hWT7RkrV.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>主键是数据库设计者从候选键中选择出来，用来唯一确定数据表某一行的键</p><p><img src="https://i.loli.net/2019/09/15/igh9kcW6peAYPBF.png" alt></p></li><li><p>它有可能被其他表用来作为<strong>对当前表特定行的引用</strong>来使用</p><p><img src="https://i.loli.net/2019/09/15/KgdHEksYv37O1fA.png" alt></p></li></ul><h5 id="空值（Null-Values）"><a href="#空值（Null-Values）" class="headerlink" title="空值（Null Values）"></a>空值（Null Values）</h5><ul><li><p>空值应该被解释为<strong>未知的或者尚未定义的</strong>，意思是当我们<strong>以后知道更多情况的时候会重新填写该值。</strong></p><blockquote><p>A null value is placed in a field of a table when a specific value is either <strong>unknown or inappropriate</strong>.</p></blockquote></li><li><p>要注意的是：<u>空值和数字0（对于数值属性）或者是空串（对于字符串属性）是不同的</u></p></li><li><p><strong>主键不能包含空值</strong>，因为表的主键是唯一区分表的单独行的，在还没确定主键的值之前，该行是不允许被存储到数据表中的</p><p><img src="https://i.loli.net/2019/09/15/jYNURDvFofVLiq6.png" alt></p><p>实体完整性规则与3NF等价</p></li><li><p><strong>空值无法与任何非空值进行比较</strong>，用属性的非空值作为条件进行查询，永远也无法查询到该属性为空值的所在行</p></li></ul><h4 id="关系代数（Relational-Algebra）"><a href="#关系代数（Relational-Algebra）" class="headerlink" title="关系代数（Relational Algebra）"></a>关系代数（Relational Algebra）</h4><p>关系代数可以看作根据查询结果来生成新表的方法的集合，这些方法称为<strong>关系代数运算</strong>。</p><p>关系代数的运算分为两种类型：</p><ul><li><p><strong>集合论运算</strong>：以行为元素单位进行的集合运算</p><p><img src="https://i.loli.net/2019/09/17/13qwasP9bMj8XuW.png" alt></p></li><li><p><strong>自然关系运算</strong>：基于行的结构的运算</p><p><img src="https://i.loli.net/2019/09/17/orM4PlgVREWiFK9.png" alt></p></li></ul><h5 id="相容表（兼容表）"><a href="#相容表（兼容表）" class="headerlink" title="相容表（兼容表）"></a><strong>相容表（兼容表）</strong></h5><p>当表R和S有相同的表头（表标题），那么表R和表S是相容表，即：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/JmI3rojPadZEAs6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>相同的表头的含义：相同数量的属性、属性对的域相同、属性对有相同的名字</p><p>ps：关系型数据库中，两列有相同的含义意思是<strong>他们有相同的列名（属性名）</strong>；同时<strong>属性集是无序</strong>的，因此两个数据表的表头中属性顺序不一致，并不影响它们是相容表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/KlgNfBErdzQ1oSk.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="交、并、差"><a href="#交、并、差" class="headerlink" title="交、并、差"></a><strong>交、并、差</strong></h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/3nQBH1dKpTbiy8f.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>并（UNION）和交（INTERACTION）是满足<strong>交换律</strong>和<strong>结合律</strong>的；差（DIFFERENCE）不满足<strong>交换律</strong></p><h5 id="赋值、别名"><a href="#赋值、别名" class="headerlink" title="赋值、别名"></a><strong>赋值、别名</strong></h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/i8kaOMNA1heVzu2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>S为表R的别名，简写为<code>S:=R</code>，通常用于：“关系自身的连接运算”、用来保存计算的“中间结果”。</p><h5 id="乘积运算（R×S）"><a href="#乘积运算（R×S）" class="headerlink" title="乘积运算（R×S）"></a><strong>乘积运算（R×S）</strong></h5><p>乘积运算是基于集合运算中的笛卡尔积的，它可以允许我们建立一个包含两个表中行之间所有可能的相互联系的新表。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/UbSqeLfFAyH1wxO.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/eLwW2dxrtYy5sKk.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我们可以使用相对较小的表来构造大表，例如1000行的表的积可以有100万行</p><p>当要计算表与自身的乘积时，会存在限定符名重复的问题，例如乘积R×R是不允许的，我们<strong>可以通过使用表的别名来避免</strong>，例如S:=R，那么R与自身的乘积可以表示为：R×S</p><h5 id="自然关系运算"><a href="#自然关系运算" class="headerlink" title="自然关系运算"></a>自然关系运算</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/E3XRvUaQdhzOAmi.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>用关系代数表达式回答用自然语言表达的对数据的查询要求，我们称这样的表达式为<strong>关系代数查询</strong>，简称为查询</p><ul><li><p><strong>投影运算（project）</strong></p><p><img src="https://i.loli.net/2019/09/17/u9waNYiOZhQ4ARj.png" alt></p><p><img src="https://i.loli.net/2019/09/17/COaoQDtgiY9Sb8e.png" alt></p><p>投影运算实际上是在表中选择列的运算，运算结果其实是新的表，因此它会<strong>将重复的行删除</strong>，以保证任意两行是不一样的</p></li><li><p><strong>选择运算（selection）</strong></p><p>从给定的表中选择出满足特定准则的行来构成新的表</p><p><img src="https://i.loli.net/2019/09/17/oyprhnLcR7Y2JtQ.png" alt></p><ul><li><p>C是比较表达式，比较符号有：<code>&lt;, &gt;, =, &lt;=, &gt;=, 和&lt;&gt;</code>，其中<code>&lt;&gt;</code>为不等符号，类似于<code>!=</code></p></li><li><p>如果比较的条件中有字符常量，那么要使用引号，例如<code>city=&#39;Dallas&#39;</code>，其中字符常量是按照字典顺序来比较的</p></li><li><p>比较条件可以是复合表达式，例如<code>C AND C&#39;</code>等</p><p><img src="https://i.loli.net/2019/09/17/k7g5TqnPr6dHlFs.png" alt></p></li></ul><p>进行选择运算时要避免<strong>内容依赖</strong>的问题：即对于某个特定时刻表的内容，两个查询结果相同还不足以保证这两个查询表达式是等价的，他们必须要求对于所有可能的表的内容都给出相同的结果</p></li><li><p>关系代数的优先级</p><p><img src="https://i.loli.net/2019/09/17/K2vSMUuGefiLXb6.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>软件系统设计02-质量属性策略</title>
    <link href="http://QQ876684433.github.io/2019/09/09/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A102-%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E7%AD%96%E7%95%A5/"/>
    <id>http://QQ876684433.github.io/2019/09/09/软件系统设计02-质量属性策略/</id>
    <published>2019-09-09T12:37:15.000Z</published>
    <updated>2019-09-21T02:02:20.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件系统设计02-质量属性策略"><a href="#软件系统设计02-质量属性策略" class="headerlink" title="软件系统设计02-质量属性策略"></a>软件系统设计02-质量属性策略</h1><h2 id="第四章-理解质量属性"><a href="#第四章-理解质量属性" class="headerlink" title="第四章 理解质量属性"></a>第四章 理解质量属性</h2><h3 id="质量属性定义"><a href="#质量属性定义" class="headerlink" title="质量属性定义"></a>质量属性定义</h3><p><strong>质量属性（Quality Attribute，QA）</strong>：它是一个系统可度量或者可测试的属性，用来指示系统在多大程度上满足了它的利益相关者的需求</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/Dmh8IoW5f4c2MF3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="架构和需求"><a href="#架构和需求" class="headerlink" title="架构和需求"></a>架构和需求</h3><h4 id="需求的分类"><a href="#需求的分类" class="headerlink" title="需求的分类"></a>需求的分类</h4><ul><li><strong>功能性需求（Functional Requirements）</strong>：描述了系统必须做的事情（必须实现的功能），以及在运行时接受外部刺激时系统应该表现出的行为或者反应</li><li><strong>质量属性需求（Quality Attribute Requirements）</strong>：它是功能性需求或者整个产品的质量或者限定条件——对于功能性需求来说，它描述了系统响应有多快或者在接受错误输入时必须具备多大的弹性等；对于整个系统来说，它描述了产品的部署需要的时间或者对运营成本的限制</li><li><strong>约束（Constraints）</strong>：约束条件是<strong>具有零自由度的设计决策</strong>，即是说它是一个已经做出的设计决策，不能再修改。例如系统使用的编程语言或者要依赖的指定模块等</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/jdH9W4NpQTciDoX.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="不同种类的需求在架构中的体现"><a href="#不同种类的需求在架构中的体现" class="headerlink" title="不同种类的需求在架构中的体现"></a>不同种类的需求在架构中的体现</h4><ul><li>功能性需求：通过整个设计中合适的职责分配来满足</li><li>质量属性需求：通过设计到架构中的各种结构以及填充这些结构的元素的行为和交互来满足</li><li>约束：通过接受设计决策并将其与其他受影响的设计决策进行协调来满足约束条件</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/sAGFdjfNtq1pyU5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h3><p>功能性需求<strong>不能决定架构</strong>。原因是对于一个给定的功能性需求集合，我们可以有很多不同的方法来将功能性需求划分到不同的架构模块中；事实上，即使我们不划分模块，甚至内部毫无架构结构可言，也依旧有可能将功能性需求实现。</p><p>我们进行架构设计是为了使得系统更加易于理解，以便支持各种各样的<strong>其他目的——即质量属性需求</strong>。</p><p>尽管功能性需求<strong>独立于特定的系统结构</strong>，但是它是通过将系统的职责分配到不同的架构元素中来实现的；虽然职责可以被任意分配到某一个模块中，但是当质量属性占很重要地位的时候，软件架构会约束系统职责的分配。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/1k7jC4bmetfMHdS.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="质量属性考量"><a href="#质量属性考量" class="headerlink" title="质量属性考量"></a>质量属性考量</h3><p>功能性需求和质量属性都不是自身独立的。</p><p>从架构师的角度，系统质量属性会有以下三个问题：</p><ul><li>某个质量属性的定义是不可测试的</li><li>对质量属性的讨论通常侧重于特定问题所属的质量，而且这个问题往往在不同的质量属性范围中有重叠</li><li>每个质量社区都发展出了自己的属性词汇</li></ul><p>前两个问题可以通过才用“质量属性场景”这个工具来区分不同的质量属性；第三个问题可以通过对每一个属性的多个社区词汇进行讨论，寻找出某个质量属性的不通社区词汇之间最本质最基础的概念</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/ARi5bKTxBnFCMLz.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/VNMErefpAtXSTcy.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="质量属性分类"><a href="#质量属性分类" class="headerlink" title="质量属性分类"></a>质量属性分类</h4><ul><li>系统运行时的属性：可用性（Availability）、性能（Performance）、易用性（Usability）等</li><li>系统开发时的属性：可修改性（Modifiability）、可测试性（Testability）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/zIuGqswZ8JO3tvi.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在复杂的系统中，质量属性相互之间不可能是独立开的，一个质量属性的实现对其他质量属性产生或积极或负面的影响，因此在架构设计时需要在这些设计决策之间作出合适的权衡。</p><h3 id="制定质量属性需求"><a href="#制定质量属性需求" class="headerlink" title="制定质量属性需求"></a>制定质量属性需求</h3><p>质量属性需求应当是<strong>明确的和可测试的</strong>。质量属性表达的常用形式包含这些部分：</p><ul><li><strong>刺激（Stimulus）</strong>：到达系统的事件，例如易用性中的用户操作，安全性中的外部攻击，可修改性中的修改需求，可测试性中的某个开发阶段的完成等</li><li><strong>刺激源（Stimulus source）</strong>：不同的刺激源，系统对待和处理的方式会不一样，例如受信任用户和不受信任用户经历的审查是不一样的</li><li><strong>响应（Response）</strong>：对于刺激，系统应当采取的措施，例如在可修改性的场景中，一个修改需求的到达要求开发者将这个修改需求实现、测试并部署所作出的修改</li><li><strong>响应度量（Response measure）</strong>：判断系统的响应是否满足需求，例如性能的度量可以是延迟或者吞吐量，可修改性的度量可以是工作量或者修改、测试和部署修改所需的时间等</li><li><strong>环境（Environment）</strong>：需求的环境是一系列场景发生情况的集合，它充当了刺激的限定词，例如对待代码冻结以发布前后发生的错误，处理的方式是不一样的</li><li><strong>工件（Artifact）</strong>：它是系统中需求适用的部分，不同的问题，它可能影响整个系统，也有可能只影响系统的某一个部分，例如数据库出错和元数据库出错的处理方式是不一样的，用户接口的修改需求和中间件的修改需求所需要的时间也是不一样的，等等</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/PYTGwBznM42QHN8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/NZ4BG2OqXTiDuzw.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>质量属性需求可以划分为六个场景，它们可能单独发生，也有可能伴随发生，特别是系统架构设计初期</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/Q8yB2pgMoIGvmDt.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="质量属性场景示例图"><a href="#质量属性场景示例图" class="headerlink" title="质量属性场景示例图"></a>质量属性场景示例图</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/xOyBMiYCUJd1jXz.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/YLOvhojfMnNRxpB.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="通过策略来实现质量属性需求"><a href="#通过策略来实现质量属性需求" class="headerlink" title="通过策略来实现质量属性需求"></a>通过策略来实现质量属性需求</h3><h4 id="架构策略（Architectural-Tactics）"><a href="#架构策略（Architectural-Tactics）" class="headerlink" title="架构策略（Architectural Tactics）"></a>架构策略（Architectural Tactics）</h4><p>架构策略是用来实现需要的质量属性的技术，它是一种设计决策，会影响质量属性响应的实现以及会直接影响系统对某些刺激的响应。<strong>策略赋予一种设计可移植性，将性能传递给另一种设计，并将可集成性传递给第三种设计</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/D9BrKmp7Fjqgwfb.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="指导设计决策"><a href="#指导设计决策" class="headerlink" title="指导设计决策"></a>指导设计决策</h3><p><strong>架构是应用设计决策集合的结果</strong>。设计决策可以分为七个类别，在设计架构的时候可以分别从某个设计决策的维度进行设计考量，降低架构设计的复杂度：</p><ul><li><p><strong>职责分配（Allocation of Responsibilities）</strong></p><p>涉及职责分配的决策包括：</p><ul><li>识别重要的职责（基础系统功能、架构基础设施、质量属性的满足）</li><li>决定如何将这些职责分配到运行时和非运行时元素</li></ul><p>制定如上决策的策略有：功能分解、对真实世界对象建模、基于操作的主要模式分组、基于相似的质量属性分组</p><p><img src="https://i.loli.net/2019/09/16/X47xSvL1yr589FV.png" alt></p></li><li><p><strong>协作模型（Coordination Model）</strong></p><p>软件架构中各个元素之间相互交互的设计机制就是协作模型，它包括如下方面：</p><ul><li>识别系统中必须协作或者禁止协作的元素</li><li>确定协作的属性，例如时间线、完成度、正确性和一致性等</li><li>选择实现上面协作属性的通信机制，例如有状态的和无状态的、同步的和异步的、保证交付和不保证交付的，以及与性能相关的属性（吞吐量，延迟等）</li></ul></li><li><p><strong>数据模型（Data Model）</strong></p><p>每个系统必须以某种内部方式表示系统范围内的数据，这就是数据模型。有关数据模型的决策如下：</p><ul><li>选择主要的数据抽象（属性与相应的操作）。它包括数据的创建、初始化、访问、持久化、操作、解释和销毁</li><li>编译一致解释数据所需的元数据</li><li>组织数据，包括数据是否要存储在关系型数据库、对象集合中，或者两者兼有。如果两者兼有，则还得确定两个不同位置之间的映射</li></ul></li><li><p><strong>资源管理（Management of Resource）</strong></p><p>软件架构必须仲裁系统中共享资源的使用，包括硬件资源（CPU、存储、电源、硬件缓冲、系统时钟和I/O端口等）和软件资源（系统锁、软件缓冲、线程池，以及非线程安全的代码），资源管理决策包括如下方面：</p><ul><li>识别必须被管理的资源，确定每种资源的限度</li><li>确定每种资源是由哪个系统元素管理的</li><li>当资源存在竞争时，要确定资源的共享方式以及采取的仲裁策略</li><li>确定各种资源饱和时会造成的影响，例如随着CPU负载的增加，系统的性能会相应地下降；当内存逐渐耗尽，会在某个点开始密集地分页/交换，随之而来的是性能突然下降甚至崩溃</li></ul></li><li><p><strong>架构元素之间的映射（Mapping among Architectural Elements）</strong></p><ul><li><p>不同类型架构之间的映射</p><p>例如开发单元（模块）到执行单元（线程或者进程）的映射</p></li><li><p>软件元素和环境元素之间的映射</p><p>例如进程到特定CPUs的映射</p></li></ul><p>一般有如下比较实用的映射：</p><ul><li><strong>开发模块</strong>与<strong>运行时元素</strong>之间的相互映射，即运行时元素是由每个模块创建出来的，开发模块包含了对应每个运行时元素的代码</li><li><strong>运行时元素</strong>到<strong>处理器</strong>的分配</li><li><strong>数据模型</strong>到<strong>数据存储</strong>的分配</li><li><strong>开发模块和运行时元素</strong>到<strong>交付单元</strong>之间的映射</li></ul></li><li><p><strong>绑定时间决策（结合时间决策，Binding Time Decision）</strong></p><blockquote><p><strong>Binding time</strong> is an important, yet underestimated viewpoint in software architecture and design. It defines the latest time during the software life cycle when something flexible becomes decided and fixed. This heavily impacts the flexibility of a software design and the resulting application. A terminology for describe binding time is established and an analysis is carried out in form of side-by-side comparisons for patterns and mechanisms from the creational, structural, and behavioral domains. These terminology and synoptic comparisons with the binding time considerations can aid software architects and developers in selecting patterns and taking correct architectural decisions for their binding time requirements.</p><p>——Abstract from Paper “<u>Describing binding time in software design patterns</u>”</p></blockquote><p>绑定时间是软件架构和设计中一个重要但却被低估的观点，它定义了软件生命周期中具备灵活性的元素变成确定的和固定的状态时的最迟时间。它会深刻影响软件设计以及最终应用程序的灵活性。</p><p>其他六种决策也都和结合时间决策有关联：</p><ul><li>对于职责分配，可以在构建编译时通过参数化的makefile来选择模块</li><li>对于协作模型的选择，可以设计一个运行时通信协议进行协作</li><li>对于资源管理，可以设计一个机制，使得系统能够允许在运行时接受新的外围设备插入，紧接着识别设备并自动下载安装相应的驱动程序</li><li>对于技术选型，可以构建app store方式来为已经购买app的用户自动下载适合版本的app等</li></ul><p>在制定结合时间决策时，要考虑<strong>实现这种决策的开销</strong>，以及<strong>后续修改这种决策实现的开销</strong>。例如考虑到代码开发完成后有迁移系统平台的可能性，那么就应该在设计时通过一些额外的开销来将自己的开发工作变得平台独立，以便后续的平台移植。</p></li><li><p><strong>技术选择（Choice of Technology）</strong></p><p>技术选择是这七种决策的约束，因此我们必须选择合适的技术来实现这七种决策。技术选型决策包含以下方面：</p><ul><li>确定哪些技术能够实现其他六种决策</li><li>确定是否有合适的开发工具（IDEs，模拟器，测试工具，等等）来支持开发活动</li><li>确定内部人员对技术的熟悉程度，以及外部资源对技术的支持程度（例如课程、手册、示例，以及能够提供紧急情况专业知识的承包商的可用性）</li><li>确定所选技术的副作用，例如技术限制的协作迷行、资源管理等</li><li>确定一个新的技术是否和现有的技术栈兼容</li></ul></li></ul><h2 id="第五章-可用性"><a href="#第五章-可用性" class="headerlink" title="第五章 可用性"></a>第五章 可用性</h2><p><strong>Availability=detect+correct+restart</strong></p><p>当系统提供的服务与相应的服务规格不一致的时候，我们认为该系统失效（Failure）了，这种失效是可以被系统的用户直接观测到的 </p><p><strong>可用性损失期</strong>（从发生故障到发现故障，修复故障，最后到系统重启恢复到故障发生前的状态）由以下方面决定：</p><ul><li>Time to <strong>detect</strong> failure</li><li>Time to <strong>correct</strong> failure </li><li>Time to <strong>restart</strong> application</li></ul><p><strong>单点故障</strong></p><p>单点故障（英语：single point of failure，缩写SPOF）是指系统中一旦失效，就会让整个系统无法运作的部件，换句话说，单点故障即会整体故障。</p><p>高可用性的一些策略：</p><ul><li>消除单点失效（单点故障）</li><li>复制（备份机制，例如checkpoint等）、故障转移（快速恢复）</li><li>自动检测和重启机制</li></ul><p><strong>可恢复性</strong></p><p>在应用程序或系统发生故障后重新建立性能级别并恢复受影响数据的能力</p><p><strong>可用性的计算方式</strong></p><p>可用性可以计算为在<strong>指定时间间隔内</strong>在<strong>指定范围内</strong>提供<strong>指定服务</strong>的<strong>概率</strong>，一般表示为%形式，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/20/4B6Ae2q9hjCuKHE.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>要注意的是，由于系统维护的原因，在计算可用性时不会考虑定期的关机时间。</p><p>根据上面的公式，可以想到的提高可用性的措施：</p><ul><li>缩短系统修复时间</li><li>延长系统两次失败之间的时间间隔</li></ul><p><strong>Outage, Failure, Fault, and Error</strong></p><ul><li>Fault：系统出错或者故障，他是系统失效（failure）的原因，但是此时系统还是可用的</li><li>Failure：系统失效，它是系统状态可以被观测到的特征，往往当系统Failure时，这个系统已经不能为用户提供系统预期的服务了，甚至有可能系统已经宕机了</li><li>Error：是由Fault变成可观测的系统Failure的中间状态</li><li>Outage：指的是系统停机或者停止服务时间，它包括系统失效/出故障这种非正常的情况，也包括定期维护而停止服务的时间；提高可用性就是通过减少系统出错（Fault），从而缩短系统停止服务（Outage）的时间</li></ul><p>为了使系统更加安全和高可用，首先需要对这两方面进行分析：<strong>自己定系统最容易发生错误</strong>，以及<strong>每种错误发生后最有能造成的后果</strong>。为了进行这种分析，可以才用如下方法：</p><ul><li><p><strong>危害分析（Hazard Analysis）</strong></p><p>可以根据严重性来对每种危害进行分类，例如：</p><ul><li><strong>灾难性的（Catastrophic）</strong>：这种失效会导致整个系统直接崩溃，后果最严重</li><li><strong>赌运气的（冒险的，Hazardous）</strong>：这种失效对系统的安全或者性能有很大概率的负面影响</li><li><strong>重大的（Major）</strong>：危害也很重大，但是程度比上面两种稍微轻一些</li><li><strong>轻微的（Minor）</strong>：这种失效是显而易见的，但是危害程度小很多</li><li><strong>没有影响（No Effect）</strong>：这种失效没有任何影响</li></ul></li><li><p><strong>故障树分析（Fault Tree Analysis）</strong></p></li><li><p>失效模式，效果和临界性/危害性分析（Failure Mode, Effects, and Criticality Analysis）</p></li></ul><h3 id="可用性通用场景"><a href="#可用性通用场景" class="headerlink" title="可用性通用场景"></a>可用性通用场景</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/20/aY7wED59RkPS3FO.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><img src="https://i.loli.net/2019/09/20/Li73lgVMjRrfcmG.png" alt></p><h3 id="可用性策略（Tactis-for-Availability）"><a href="#可用性策略（Tactis-for-Availability）" class="headerlink" title="可用性策略（Tactis for Availability）"></a>可用性策略（Tactis for Availability）</h3><p>由于系统出错（Fault）有可能导致系统失效（Failure），因此我们应该采取一些策略来<strong>防止出错（Fault）演变成失效（Failure</strong>），或者至少<strong>限制出错的影响范围然后尽可能修复</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/20/6gajKyc8shDd5Ye.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（题外话：<u>这些策略有可能以软件基础设施的形式提供（例如中间件工具包），所以架构师的职责之一是选择和使用（而不是实现它）适合的可用性策略以及正确的策略组合</u>）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/20/vRDBag8P3GhYspi.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="错误检测（Detect-Faults）"><a href="#错误检测（Detect-Faults）" class="headerlink" title="错误检测（Detect Faults）"></a>错误检测（Detect Faults）</h4><ul><li><p><strong>Ping/Echo</strong></p><ul><li>它是节点间异步的请求/响应消息对，通常用来确定<strong>可达性</strong>和<strong>往返延迟</strong>，同时echo节点也能够通过ping来确定发出ping的组件是存活的、能够正确响应的 </li><li>通常来说<strong>ping是由监控节点主动发出的</strong>，用来确认某个或者某些节点是可达的以及往返延迟是多少</li><li>Ping/Echo需要预设一个时间阈值，这个阈值用来告诉监控节点：在接收到echo之前，监控节点会等待多长时间，超时之后才会认为被监控的节点已经失效</li></ul></li><li><p><strong>Monitor（监视器）</strong></p><p>监视器是用来监视系统中多个部分健康状况的组件，例如监控：处理器、进程、IO、存储等待</p></li><li><p><strong>HeartBeat（心跳机制）</strong></p><ul><li><p>HeartBeat在系统监视器以及被监视的进程之间周期性地交互消息以检测是否有错误发生</p></li><li><p>例子：</p><p><img src="https://i.loli.net/2019/09/20/PHsiaK7hrEX2jDB.png" alt></p><p>被监控的进程周期性地主动发送心跳消息到监视器以重置watch dog中的计时器，防止计时器超时而使得监视器错误地发出一个错误信号标识被监控的进程失效</p></li><li><p>HeartBeat vs Ping/Echo：区别主要在于负责初始化健康监测机制的组件是谁，监视器还是被监控的组件自身，HeartBeat中是被监控的进程主动发出心跳信号，而Ping/Echo中是监视器主动发出ping信号来监测被监控组件的健康状态</p></li></ul></li><li><p><strong>Timestamp（时间戳）</strong></p><p>主要用于监测<strong>不正确的时间序列</strong>，一般用在分布式消息传递系统中。可以通过<strong>在事件发生时立即将本地时间附加到事件消息中</strong>来实现时间戳机制；如果具体的时间信息不重要的话，可以直接使用序列数字作为时间戳（<u>但这样的话似乎需要一个集中发放序列号的组件？</u>）</p></li><li><p><strong>Sanity Checking（健全检测）</strong></p><p>它通常是用来监测某个特定操作或者某个组件的输出的<strong>有效性或者合理性</strong>，这种策略通常基于系统内部设计、系统的状态或者正在审议中的信息等；它经常在接口中采用，用来检验特定的信息流</p></li><li><p><strong>Condition Monitoring（条件监控）</strong></p><p>它通常是用来监测一个进程或者设备的条件状态、或者验证设计时做出的假设的有效性。例如常见的方法是校验和checksum。但是监控组件自身必须足够简单以避免引入新的软件错误</p></li><li><p><strong>Voting（投票）</strong></p><p>这种策略最常见的实现方式是<strong>三重模块化冗余（triple modular redundancy，TMR）</strong>，使用是三个组件来做同样的事情，每个组件都接受相同的输入，然后将它们的输出转发到<strong>投票逻辑单元（voting logic）</strong>中检验三个输出状态的一致性</p><p>当遇到输出状态不一致的时候，投票器会报告出错状态，但同时它也还需要决定输出结果是什么，一般可以采用<strong>多数人规则（majority rule）</strong>或者<strong>对离散结果取平均</strong>，这些策略都取决于具体的投票逻辑。并且，投票逻辑应该被实现为一个简单、经过严格审查和测试的单例，以降低引入新的错误的概率</p><ul><li>Replication：各个组件是相互之间的克隆，通过相同组件的拷贝可以防止硬件的随机错误，但是不能避免软件或者硬件在设计或者实现上的错误，因为这种策略的各个组件没有差异化的设计</li><li>Functional Redundancy（功能冗余）：这些组件是差异化设计和实现的，但是它们对相同的输入，总是应该给出相同的输出</li><li>Analytic Redundancy（分析冗余）：这种策略中，不仅组件内部的实现是差异化的，他们的输入输出也是差异化的。这种策略的目的是通过使用单独的需求规范来容忍设计规范的错误。在嵌入式系统中，有些输入源可能失效，这时候分析冗余就可以生效了。</li></ul></li><li><p><strong>Exception Detection（异常检测）</strong></p><p>它通常是监测改变了正常执行流的系统条件，可以分为以下几种：</p><ul><li>系统异常（system exception）：不同的处理器硬件架构会有不同的系统异常，例如除零、总线和地址出错、非法程序指令等等</li><li>参数围栏（the parameter fence）：它包括一个先验的数据模式（例如0xDEADBEEF），它被放在一个对象的变长参数的后面，这允许在运行时监测到分配给一个对象的变长参数的内存是否被overwrite</li><li>参数类型（the parameter typing）：使用一个基类来定义函数，例如add、find等，然后派生类使用基类的函数接口，根据自身不同的参数结构来实现不同的功能。使用强类型来构建和解析消息，比简单的把消息看作一串字节，更能够减少出错、提高可用性，当然也会因此使得系统演化变得复杂</li><li>超时（timeout）：当组件没有在时间限制内完成的话，该策略会抛出一个超时异常</li></ul><p><strong>一般来说异常检测策略是在一个进程内部操作的，而ping/echo以及heartbeat时在不同进程键进程操作的</strong></p></li><li><p><strong>Self-test（自检）</strong></p><p>组件可以运行一个进程来监测自身操作的正确性，这个自检进程可以由组件自身初始化，也可以由系统监视器初始化。自检技术包括校验和checksum等</p></li></ul><h4 id="错误恢复（Recover-from-Faults）"><a href="#错误恢复（Recover-from-Faults）" class="headerlink" title="错误恢复（Recover from Faults）"></a>错误恢复（Recover from Faults）</h4><h5 id="预备和恢复策略（Preparation-and-Repair）"><a href="#预备和恢复策略（Preparation-and-Repair）" class="headerlink" title="预备和恢复策略（Preparation and Repair）"></a>预备和恢复策略（Preparation and Repair）</h5><ul><li><p><strong>Active Redundancy（hot spare，主动冗余，热备份）</strong></p><p>它将所有的节点（主动节点和冗余备份节点）配置在一个保护组中，它们并行地接收和处理相同的输入（只会才用主动节点的输出，其他的输出会被舍弃），这样可以使得冗余备份节点和主动节点保持同步的状态，因此它们可以在主动节点失效的时候立刻切换和接管工作。最简单的实现方式是1+1冗余（一个主动节点+一个冗余备份节点）。主动冗余可以用来作为基础设施北湖，例如活跃的网络链路和支援的网络链路一起使用可以提高网络连接的高可用性</p></li><li><p><strong>Passive Redundancy（warm spare，被动冗余，热备用）</strong></p><p>在保护组中只有主动成员才处理输入流量，同时给保护组中的冗余备份节点提供<strong>周期性的状态更新</strong>。当主动节点出错的时候，系统必须确定冗余备份节点的备份状态足够新（即足够接近主动节点出故障时的状态）才能够被作为替补恢复到正常的系统服务体系中，因此恢复的时间可能比主动冗余要慢</p></li><li><p><strong>Spare（cold spare，候补，冷备用）</strong></p><p>这个策略下冗余备份节点在主动节点发生故障前都是不提供服务的，因此当备份节点需要替换到正常系统体系中前，它需要启动一个power-on-reset进程来将自身的状态更新到主动节点出故障前的状态。由于它糟糕的恢复性能，它一般更适用于只有高可靠性需求（而对高可用性需求不高）的系统中</p></li><li><p><strong>Exception Handling（异常处理）</strong></p><p>一旦检测到系统异常，系统必须以某种方式进行处理。异常处理的方式很大程度上取决于所使用的开发环境，从简单的函数返回状态码/错误码，到使用包含了对错误纠正有用的信息的异常类，例如异常的名字、异常源头以及异常的原因，软件可以利用这些信息来掩盖出错，一般来说是<strong>纠正出错的原因</strong>然后<strong>重新尝试操作</strong></p></li><li><p><strong>Rollback（回退）</strong></p></li></ul><ul><li><h5 id="重新引入策略（Reintroduction）"><a href="#重新引入策略（Reintroduction）" class="headerlink" title="重新引入策略（Reintroduction）"></a>重新引入策略（Reintroduction）</h5></li></ul><p>这个部分关注将一个失效（但是已经恢复）的组件引入到正常的系统体系中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件系统设计02-质量属性策略&quot;&gt;&lt;a href=&quot;#软件系统设计02-质量属性策略&quot; class=&quot;headerlink&quot; title=&quot;软件系统设计02-质量属性策略&quot;&gt;&lt;/a&gt;软件系统设计02-质量属性策略&lt;/h1&gt;&lt;h2 id=&quot;第四章-理解质量属性&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件系统设计" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="架构" scheme="http://QQ876684433.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>91.解码方法</title>
    <link href="http://QQ876684433.github.io/2019/09/06/91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>http://QQ876684433.github.io/2019/09/06/91-解码方法/</id>
    <published>2019-09-06T11:29:49.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a>91.解码方法</h1><p>原题目如下：</p><blockquote><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26</p><p>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p><p>示例 1:</p><p>输入: “12”</p><p>输出: 2</p><p>解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。</p><p>示例 2:</p><p>输入: “226”</p><p>输出: 3</p><p>解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/decode-ways著作权归领扣网络所有。" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-ways著作权归领扣网络所有。</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题刚开始做的时候思路是挺清晰的，就是动态规划，从左往右遍历一遍即可。对于一个长度为n的串s，由于编码只有一位数和两位数这两种可能，因此很容易得出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numDecodings(s[<span class="number">1</span>:n]) = numDecodings(s[<span class="number">1</span>:n<span class="number">-1</span>]) + numDecodings(s[<span class="number">1</span>:n<span class="number">-2</span>])</span><br></pre></td></tr></table></figure><p>当然不是直接相加那么简单，这要分情况讨论一下：</p><p>（1）如果s[i]非0（由题可知，0不是合法的编码），s[1:n]一定可以按照在s[1:n-1]的所有解码方式后面加上s[i]来解码</p><p>（2）如果s[i-1]s[i]是合法的编码（<strong>即10&lt;=int(s[i-1]s[i])&lt;=26，大于等于10的是因为01、02等待这种以0开头的两位数不是合法的编码</strong>），那么s[1:n]也一定可以按照在s[1:n-2]的所有解码方式后面加上s[i-1]s[i]来得到</p><p>（3）否则上面两种情况都不符合，那么s[1:n]无论如何也无法进行解码，比如出现连续两个0的情况</p><p>我当时做的时候，因为没有考虑编码串中出现0的情况，所以出现了偏差。另外，由于前面做题的惯性思维，动态规划问题老是想构造数组，后来细细想这道题才发现根本不需要那么大的空间开销，只需要记录dp[i-1]和dp[i-2]即可计算出dp[i]。最终的解决方案如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> s[<span class="number">0</span>]!=<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> prev = <span class="number">1</span>, target = s[<span class="number">0</span>]==<span class="string">'0'</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">'0'</span>) temp = target;</span><br><span class="line">            <span class="comment">// int val = (s[i-1]-'0')*10+(s[i]-'0');</span></span><br><span class="line">            <span class="comment">// if(val&gt;=10&amp;&amp;val&lt;=26) temp+=prev;</span></span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span>||s[i<span class="number">-1</span>]==<span class="string">'2'</span>&amp;&amp;(s[i]&lt;=<span class="string">'6'</span>))temp+=prev;</span><br><span class="line">            </span><br><span class="line">            prev = target;</span><br><span class="line">            target = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测评的结果如下，然后我看了一下最高分的解答，思路跟我的差不多，就没必要去优化了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/06/YuE7XgBWSrZz51w.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题解没什么比较新的角度，跟我的想法差不多，就不再赘述</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;91-解码方法&quot;&gt;&lt;a href=&quot;#91-解码方法&quot; class=&quot;headerlink&quot; title=&quot;91.解码方法&quot;&gt;&lt;/a&gt;91.解码方法&lt;/h1&gt;&lt;p&gt;原题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一条包含字母 A-Z 的消息通过以下方式进行了
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>63.不同路径II</title>
    <link href="http://QQ876684433.github.io/2019/09/04/63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>http://QQ876684433.github.io/2019/09/04/63-不同路径II/</id>
    <published>2019-09-04T13:20:26.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="63-不同路径II"><a href="#63-不同路径II" class="headerlink" title="63.不同路径II"></a>63.不同路径II</h1><p>原题目如下：</p><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:</p><p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]</p><p>输出: 2</p><p>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">&gt; 2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-ii</a><br>著作权归领扣网络所有。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题与<a href="https://chph.xyz/2019/09/04/62-不同路径/" target="_blank" rel="noopener">前一道题</a>的区别只在于输入的二维数组增加了障碍物这一限制条件，只要在之前的思路（详见前面的链接）上稍作修改即可，用m和n分别表示输入的数组的行和列，我自己当时的解题思路如下：</p><ul><li>采用自底向上的递推方式，还是采用一位数组来降低空间开销，将dp数组初始化为包含m个元素的数组，然后将最后一个元素设置为1，原因是从最底层走，不考虑障碍物的情况下，只有一条路径能够到达目的地（<em>后来发现出现的问题就是，如果目的地就是障碍物的话，这样是无法AC的，所以在开始推导的最开始直接排除了这种情况<code>if(obstacleGrid[m-1][n-1]==1) return 0;</code>，省事</em>）</li><li>推导的核心公式是<code>dp[j] = dp[j]+dp[j+1];</code>，所以存在边界的问题，因此限定<code>0 ≤ j ≤ m-2</code>，而<code>j = m-1</code>的情况（即最底层）单独判断：如果在点<code>obstacleGrid[m-1][i]</code>遇到障碍物，则将dp数组的最后一个元素设置为0，表示从最底层小于等于点i的开始走，必然无法走到目的地</li><li>如果不是在最底层遇到障碍物（设为点<code>obstacleGrid[j][i]</code>），则只需要将<code>dp[j]</code>设置为0，表示从该点开始走，无法走到目的地，对其他路径的贡献为0</li></ul><p>所以最终的解决方案如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.size(), n = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; dp(m<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        dp.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[m<span class="number">-1</span>][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[m<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[j][i]==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = dp[j]+dp[j+<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提交之后，虽然AC了，但是感觉有点不够优雅：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/04/3RYpKZCPfHU4bDE.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><u><em>ps：这里有个坑是大数组的输入，如果使用<code>vector&lt;int&gt;</code>会溢出，改用<code>vector&lt;long&gt;</code>就可以了，这个也是没办法的</em></u></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>学习了leetcode官方的题解后发现自己的思路局限在了自底向上的角度，实际上自顶向下和自底向上最终的 结果是一样的，但使用自顶向下似乎更有助于思考问题。</p><p>最关键的问题还是集中在遇到障碍物时采取的措施上，因为题目没有要求输入数据不能修改，可以直接使用obstacleGrid作为dp数组，达到最优化空间复杂度，这样dp递推方程就变成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>而当<code>obstacleGrid[i][j]</code>是障碍物时，可直接将其置0：</p><blockquote><p>如果这个点有障碍物，设值为 <code>0</code> ，这可以保证不会对后面的路径产生贡献。</p></blockquote><p>这个可以体现在上面的递推方程上。即使是这样，还是避免不了边界条件的处理，这里就不展开了。</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>归根结底，解法不优雅的根源是边界问题的处理，所以也可以通过在原有的数组行列上各添加一维全0的数据，这样就比较优雅了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;63-不同路径II&quot;&gt;&lt;a href=&quot;#63-不同路径II&quot; class=&quot;headerlink&quot; title=&quot;63.不同路径II&quot;&gt;&lt;/a&gt;63.不同路径II&lt;/h1&gt;&lt;p&gt;原题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>62.不同路径</title>
    <link href="http://QQ876684433.github.io/2019/09/04/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://QQ876684433.github.io/2019/09/04/62-不同路径/</id>
    <published>2019-09-04T11:37:53.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h1><p>原题目如下：</p><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:</p><p>输入: m = 3, n = 2</p><p>输出: 3</p><p>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 2:</p><p>输入: m = 7, n = 3</p><p>输出: 28</p><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题一看就是很典型的动态规划问题，一般来说都可以从填表入手，动态规划方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>所以可以从初始状态开始（即finish处开始）推导填表，最后得到的就是问题的解。举个简单的例子，m=7，n=3（其实m和n是可以互换的对结果没有影响）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/04/VC6Ub3IFT95xPNg.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这样就可以通过一个二维数组来解决问题。一般来说二维数组开销太大，而且往往都能够通过压缩成一维数组来解决，因为<code>dp[i][j]</code>计算出来之后，<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>的值就不再需要了，所以最终的解答如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">                dp[j] = dp[j]+dp[j<span class="number">-1</span>];</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一次AC，惊喜满满：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/04/BDZc7A9of1GuiNS.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题解给出的方案和我的差不多，这里就没必要展开了，但是里面提供了一个数学角度的解决方案：</p><blockquote><p>思路：排列组合</p><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p><p>比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。</p><p>所以有 C_{m+n-2}^{m-1}C<br>m+n−2<br>m−1</p><p>作者：powcai</p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/</a></p><p>来源：力扣（LeetCode）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;62-不同路径&quot;&gt;&lt;a href=&quot;#62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62.不同路径&quot;&gt;&lt;/a&gt;62.不同路径&lt;/h1&gt;&lt;p&gt;原题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
