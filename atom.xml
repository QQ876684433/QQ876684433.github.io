<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>至繁归于至简 - chph&#39;s blog</title>
  
  <subtitle>steve_chph personal website</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://QQ876684433.github.io/"/>
  <updated>2019-09-15T04:29:52.255Z</updated>
  <id>http://QQ876684433.github.io/</id>
  
  <author>
    <name>steve_chph</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>由String的构造方法引申出来的java字符编码</title>
    <link href="http://QQ876684433.github.io/2019/07/17/%E7%94%B1String%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%B3%E5%87%BA%E6%9D%A5%E7%9A%84java%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <id>http://QQ876684433.github.io/2019/07/17/由String的构造方法引申出来的java字符编码/</id>
    <published>2019-07-17T01:39:40.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="由String的构造方法引申出来的java字符编码"><a href="#由String的构造方法引申出来的java字符编码" class="headerlink" title="由String的构造方法引申出来的java字符编码"></a>由String的构造方法引申出来的java字符编码</h1><blockquote><p>作者：<a href="http://www.cnblogs.com/gdayq/" target="_blank" rel="noopener">挟天子以令诸侯</a> </p><p>出处：<a href="http://www.cnblogs.com/gdayq/" target="_blank" rel="noopener">http://www.cnblogs.com/gdayq/</a><br>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p></blockquote><p>在String类的constructors中，有一个constructor是将int数组类型转化为字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] num = &#123;<span class="number">48</span>,<span class="number">49</span>,<span class="number">50</span>,<span class="number">51</span>,<span class="number">52</span>&#125;;</span><br><span class="line">String numStr = <span class="keyword">new</span> String(num,<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">System.out.println(numStr);</span><br></pre></td></tr></table></figure><p>输出结果是：</p><p>0123</p><p>这个constructor的作用是将int数组中每一位上的数字转化为在Unicode编码中对应的字符。现在来看看它是怎么转化的。</p><p>源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span>[] codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">   <span class="keyword">if</span> (offset &gt; codePoints.length - count) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> end = offset + count;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Pass 1: Compute precise size of char[]</span></span><br><span class="line">   <span class="keyword">int</span> n = count;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">      <span class="keyword">if</span> (Character.isBmpCodePoint(c))</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (Character.isValidCodePoint(c))</span><br><span class="line">         n++;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Integer.toString(c));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Pass 2: Allocate and fill in char[]</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">char</span>[] v = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = offset, j = <span class="number">0</span>; i &lt; end; i++, j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">      <span class="keyword">if</span> (Character.isBmpCodePoint(c))</span><br><span class="line">         v[j] = (<span class="keyword">char</span>) c;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         Character.toSurrogates(c, v, j++);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.value  = v;</span><br><span class="line">      <span class="keyword">this</span>.count  = n;</span><br><span class="line">      <span class="keyword">this</span>.offset = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，但是用到了Character类的三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Character.isBmpCodePoint(c)</span><br><span class="line">Character.isValidCodePoint(c)</span><br><span class="line">Character.toSurrogates(c, v, j++)</span><br></pre></td></tr></table></figure><p>先来看看第一个方法isBmpCodePoint()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBmpCodePoint</span><span class="params">(<span class="keyword">int</span> codePoint)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> codePoint &gt;&gt;&gt; <span class="number">16</span> == <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Optimized form of:</span></span><br><span class="line">    <span class="comment">//     codePoint &gt;= MIN_VALUE &amp;&amp; codePoint &lt;= MAX_VALUE</span></span><br><span class="line">    <span class="comment">// We consistently use logical shift (&gt;&gt;&gt;) to facilitate</span></span><br><span class="line">    <span class="comment">// additional runtime optimizations.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&gt;&gt;&gt;是移位运算符，codePoint &gt;&gt;&gt; 16 的意思是将codePoint变量无符号右移16位，然后判断是否等于0，这个是在判断什么呢？根据字面意思理解is bmp code point,是否是bmp代码点，也是不明白，然后就去search了一下，于是就引申出了两个概念—-代码点与代码单元。</p><p>说到代码点与代码单元，就得先说说Unicode编码的基本概念了。</p><h2 id="1、Unicode的基本概念"><a href="#1、Unicode的基本概念" class="headerlink" title="1、Unicode的基本概念"></a>1、Unicode的基本概念</h2><h3 id="1）编码字符集"><a href="#1）编码字符集" class="headerlink" title="1）编码字符集"></a>1）编码字符集</h3><p>　　编码字符集是一个字符集，它为每一个字符分配一个唯一数字。Unicode 标准的核心是一个编码字符集，字母“A”的编码为0041和字符“€”的编码为20AC。Unicode标准始终使用十六进制数字，而且在书写时在前面加上前缀“U+”，所以“A”的编码书写为“U+0041”。说白了，就是在编码字符集中，每一个字符都有一个自己的一个唯一的ID。</p><h3 id="2）代码点与代码单元"><a href="#2）代码点与代码单元" class="headerlink" title="2）代码点与代码单元"></a>2）代码点与代码单元</h3><table><thead><tr><th>Unicode 代码点</th><th>U+0041</th><th>U+00DF</th><th>U+6771</th><th>U+10400</th></tr></thead><tbody><tr><td>表示字形</td><td></td><td></td><td></td><td></td></tr><tr><td>UTF-32 代码单元</td><td>00000041</td><td>000000DF</td><td>00006771</td><td>00010400</td></tr><tr><td>UTF-16 代码单元</td><td>0041</td><td>00DF</td><td>6771</td><td>D801DC00</td></tr><tr><td>UTF-8 代码单元</td><td>41</td><td>C39F</td><td>E69DB1</td><td>F0909080</td></tr></tbody></table><p>　　网摘：“代码点（Code Point）就是指Unicode中为字符分配的编号，一个字符只占一个代码点，例如我们说到字符“汉”，它的代码点是U+6C49.代码单元（Code Unit）则是针对编码方法而言，它指的是编码方法中对一个字符编码以后所占的最小存储单元。例如UTF-8中，代码单元是一个字节，因为一个字符可以被编码为1个，2个或者3个4个字节；在UTF-16中，代码单元变成了两个字节（就是一个char），因为一个字符可以被编码为1个或2个char（你找不到比一个char还小的UTF-16编码的字符，嘿嘿）。说得再罗嗦一点，一个字符，仅仅对应一个代码点，但却可能有多个代码单元（即可能被编码为2个char）。”</p><p>　　说白了，代码点：就是字符所对应的那个“ID”。代码单元：指的是在各种不同的编码方式中（UTF-8,UTF-16），对一个字符编码以后所占的最小存储单元。</p><h6 id="3）增补字符"><a href="#3）增补字符" class="headerlink" title="3）增补字符"></a>3）增补字符</h6><p>　　16 位编码的所有 65536 个字符并不能完全表示全世界所有正在使用或曾经使用的字符。于是，Unicode 标准已扩展到包含多达 1112064 个字符。那些超出原来的16 位限制的字符被称作<strong>增补字符。</strong></p><p>　　Java的char类型是固定16bits(两个字节)的。代码点在U+0000 — U+FFFF之内到是可以用一个char完整的表示出一个字符。但代码点在U+FFFF之外的，一个char无论如何无法表示一个完整字符。这样用char类型来获取字符串中的那些代码点在U+FFFF之外的字符就会出现问题。</p><p>　　于是，有了增补字符。增补字符是代码点在 U+10000 至 U+10FFFF 范围之间的字符，也就是那些使用原始的 Unicode 的 16 位设计无法表示的字符。从 U+0000 至 U+FFFF 之间的字符集有时候被称为基本多语言面（BMP UBasic Multilingual Plane ）。Unicode的代码点可以分成17个代码级别。第一个代码级别称为基本的多语言级别，代码点从U+0000到U+FFFF，其中包括了经典的Unicode代码，其余的16个附加级别，代码点从U+10000到U+10FFFF，其中包括了一些增补字符。因此，每一个 Unicode 字符要么属于 BMP，要么属于增补字符<strong>。</strong></p><h2 id="2、基于Unicode的具体编码格式"><a href="#2、基于Unicode的具体编码格式" class="headerlink" title="2、基于Unicode的具体编码格式"></a>2、基于Unicode的具体编码格式</h2><p> 网摘：</p><p>　　<strong>UTF-32</strong> 即将每一个 Unicode 代码点表示为相同值的32位整数。很明显，它是内部处理最方便的表达方式，但是，如果作为一般字符串表达方式，则要消耗更多的内存。</p><p>　　<strong>UTF-16</strong> 使用一个或两个未分配的16位代码单元的序列对 Unicode 代码点进行编码。假设U是一个代码点，也就是Unicode编码表中一个字符所对应的Unicode值:<br>　　　　(1) 如果在BMP级别中，那么16bits(一个代码单元)就足够表示出字符的Unicode值。<br>　　　　(2)如果U+10FFFF&gt;U&gt;=U+10000，也就是处于增补字符级别中。UTF-16用2个16位来表示出了，并且正好将每个16位都控制在替代区域U+D800-U+DFFF（其中\uD800-\uDBFF为高代理项 范围，\uDC00- \uDFFF为低代理项 范围） 中。</p><p>　　也就是说，在UTF-16中，增补字符的表示方式是由两个代码单元来表示的，原因就是一个代码单元放不下它。那么在java中是如何处理这些增补字符的呢？</p><p>　　java的处理方式是这样的：对于增补字符U（U+10FFFF&gt;U&gt;=U+10000）。首先，分别初始化2个16位无符号的整数 —— W1和W2。其中W1=110110xxxxxxxxxx（0xD800-0xDBFF）,W2 = 110111xxxxxxxxxx(0xDC00-OxDFFF)。然后，将Unicode的高10位分配给W1的低10位，将Unicode 的低10位分配给W2的低10位。这样就可以将20bits的代码点U拆成两个16bits的代码单元。而且这两个代码点正好落在替代区域U+D800-U+DFFF中。　</p><p>　　UTF-16表示的增补字符怎样才能被正确的识别为增补字符，而不是两个普通的字符呢？答案是通过看它的第一个char是不是在高代理范围内，第二个char是不是在低代理范围内来决定，这也意味着，高代理和低代理所占的共2048个码位（从0xD800到0xDFFF）是不能分配给其他字符的。</p><p>Unicode的编号中，U+D800到U+DFFF是否有字符分配？答案是也没有！这么做的目的是希望基本多语言面中的字符和一个char型的UTF-16编码的字符能够一一对应。（这里就不写代码验证了）</p><p>　　java具体的是怎么来拆分增补字符的呢？看一个例子：通过两个代码点U+11001,U+1D56B（使用4个字节表示的代码点）以U+1D56B来说</p><p>　　0x1D56B= 0001 1101 01-01 0110 1011</p><p>　　将0x1D56B的高10位0001 1101 01分配给W1的低10位组合成110110 0001 1101 01=0xD875<br>　　将0x1D56B的低10位01 0110 1011分配给W2的低10位组合成110111 01 0110 1011=0xDD6B<br>　　这样代码点U+1D56B采用UTF-16编码方式，用2个连续的代码单元U+D875和U+DD6B表示出了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] codePoints = &#123;<span class="number">0x11001</span>,<span class="number">0x1d56b</span>&#125;; <span class="comment">//增补字符  </span></span><br><span class="line">String s = <span class="keyword">new</span> String(codePoints,<span class="number">0</span>,<span class="number">2</span>);  </span><br><span class="line">        </span><br><span class="line">System.out.println(<span class="string">"s: "</span> + s); </span><br><span class="line">System.out.println(<span class="string">"s.length: "</span> + s.length()); <span class="comment">//4,说明length()是按代码单元计算的  </span></span><br><span class="line">System.out.println(<span class="string">"s.charAt(0): "</span> + Integer.toHexString((<span class="keyword">int</span>)s.charAt(<span class="number">0</span>)));<span class="comment">//输出结果表明增补字符并非简单地把两个代码单元拆开  </span></span><br><span class="line">System.out.println(<span class="string">"s.charAt(1): "</span> + Integer.toHexString((<span class="keyword">int</span>)s.charAt(<span class="number">1</span>)));</span><br><span class="line">System.out.println(<span class="string">"s.charAt(2): "</span> + Integer.toHexString((<span class="keyword">int</span>)s.charAt(<span class="number">2</span>)));</span><br><span class="line">System.out.println(<span class="string">"s.charAt(3): "</span> + Integer.toHexString((<span class="keyword">int</span>)s.charAt(<span class="number">3</span>)));</span><br><span class="line">System.out.println(<span class="string">"s.codePointAt(0):"</span> + Integer.toHexString(s.codePointAt(<span class="number">0</span>)));</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s: ??</span><br><span class="line">s.length: <span class="number">4</span></span><br><span class="line">s.charAt(<span class="number">0</span>): d804</span><br><span class="line">s.charAt(<span class="number">1</span>): dc01</span><br><span class="line">s.charAt(<span class="number">2</span>): d835</span><br><span class="line">s.charAt(<span class="number">3</span>): dd6b</span><br><span class="line">s.codePointAt(<span class="number">0</span>):<span class="number">11001</span></span><br></pre></td></tr></table></figure><p>可以看到</p><p>字符串的长度为4，说明length()是按代码单元计算的，然后我们看看U+1D56B的拆分结果：</p><p>s.charAt(2): d835<br>s.charAt(3): dd6b</p><p>与我们计算的 U+D875 U+DD6B 有出入，该代理代码点不一样，带着这个疑问，我们去看看java代码是如何转化的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[java.lang.String]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = offset, j = <span class="number">0</span>; i &lt; end; i++, j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">    <span class="keyword">if</span> (Character.isBmpCodePoint(c))    <span class="comment">//判断是不是BMP级别</span></span><br><span class="line">    v[j] = (<span class="keyword">char</span>) c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    Character.toSurrogates(c, v, j++);<span class="comment">//给出高低代理项</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[java.lang.Character]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toSurrogates</span><span class="params">(<span class="keyword">int</span> codePoint, <span class="keyword">char</span>[] dst, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We write elements "backwards" to guarantee all-or-nothing</span></span><br><span class="line">    dst[index+<span class="number">1</span>] = lowSurrogate(codePoint);<span class="comment">//给出低代理项</span></span><br><span class="line">    dst[index] = highSurrogate(codePoint);<span class="comment">//给出高代理项</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">[java.lang.Character]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> MIN_LOW_SURROGATE  = <span class="string">'\uDC00'</span>;<span class="comment">//低代理项最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">lowSurrogate</span><span class="params">(<span class="keyword">int</span> codePoint)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span>) ((codePoint &amp; <span class="number">0x3ff</span>) + MIN_LOW_SURROGATE);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">[java.lang.Character]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> MIN_HIGH_SURROGATE = <span class="string">'\uD800'</span>;<span class="comment">//高代理项最小值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SUPPLEMENTARY_CODE_POINT = <span class="number">0x010000</span>;<span class="comment">//增补字符最小代码点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">highSurrogate</span><span class="params">(<span class="keyword">int</span> codePoint)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span>) ((codePoint &gt;&gt;&gt; <span class="number">10</span>)</span><br><span class="line">+ (MIN_HIGH_SURROGATE - (MIN_SUPPLEMENTARY_CODE_POINT &gt;&gt;&gt; <span class="number">10</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出低代理项与计算方式一样，所以计算出的结果一致，但是高代理项在移位10bit，加上最小高代理项后，又减去了增值字符最小代码点的移位10bit后的值，其实这就相当于，对于增补字符U+1D56B，其操作是对 U+0D56B进行的操作。这里还没有确定为什么会减去这个位，有待考证！</p><h3 id="UTF-8："><a href="#UTF-8：" class="headerlink" title="UTF-8："></a>UTF-8：</h3><p>网摘：</p><p>　　使用一至四个字节的序列对编码 Unicode 代码点进行编码。U+0000 至 U+007F 使用一个字节编码，U+0080 至 U+07FF 使用两个字节，U+0800 至 U+FFFF 使用三个字节，而 U+10000 至 U+10FFFF 使用四个字节。UTF-8 设计原理为：字节值 0x00 至 0x7F 始终表示代码点 U+0000 至 U+007F（Basic Latin 字符子集，它对应 ASCII 字符集）。这些字节值永远不会表示其他代码点，这一特性使 UTF-8 可以很方便地在软件中将特殊的含义赋予某些 ASCII 字符。</p><p>以下是Unicode和UTF-8之间的转换关系表：</p><table><thead><tr><th>U-00000000 - U-0000007F：</th><th>0xxxxxxx</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>U-00000080 - U-000007FF：</td><td>110xxxxx</td><td>10xxxxxx</td><td></td><td></td><td></td><td></td></tr><tr><td>U-00000800 - U-0000FFFF：</td><td>1110xxxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td></td><td></td><td></td></tr><tr><td>U-00010000 - U-001FFFFF：</td><td>11110xxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td></td><td></td></tr><tr><td>U-00200000 - U-03FFFFFF：</td><td>111110xx</td><td>10xxxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td></td></tr><tr><td>U-04000000 - U-7FFFFFFF：</td><td>1111110x</td><td>10xxxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td></tr></tbody></table><p>可以看到：</p><p>（1）如果一个字节以10开头，一定不是首字节，需要向前查找。</p><p>（2）在一个首字节中，如果以0开头，表示是一个ASCII字符，而开头的连续的1的个数也表示了这个字符的字节数。如1110xxxx表示这个字符由三个字节组成。</p><p>下面来看一个使用各种编码对字符进行编码的例子，如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2015.cnblogs.com/blog/750327/201608/750327-20160829090326011-1949208095.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p><strong>分析到这里，结合源码，可以看出： Java 以 UTF-16 作为内存的字符存储格式。</strong></p><p>参考：</p><p><a href="http://blog.csdn.net/u010411264/article/details/45258629" target="_blank" rel="noopener">http://blog.csdn.net/u010411264/article/details/45258629</a><br><a href="http://blog.csdn.net/cumtwyc/article/details/45080679" target="_blank" rel="noopener">http://blog.csdn.net/cumtwyc/article/details/45080679</a><br><a href="http://blog.csdn.net/mazhimazh/article/details/17708001" target="_blank" rel="noopener">http://blog.csdn.net/mazhimazh/article/details/17708001</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;由String的构造方法引申出来的java字符编码&quot;&gt;&lt;a href=&quot;#由String的构造方法引申出来的java字符编码&quot; class=&quot;headerlink&quot; title=&quot;由String的构造方法引申出来的java字符编码&quot;&gt;&lt;/a&gt;由String的构造方
      
    
    </summary>
    
      <category term="转载" scheme="http://QQ876684433.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析Java序列化与反序列化机制</title>
    <link href="http://QQ876684433.github.io/2019/07/16/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>http://QQ876684433.github.io/2019/07/16/深入剖析Java序列化与反序列化机制/</id>
    <published>2019-07-16T15:10:08.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>精读Java源码-String类</title>
    <link href="http://QQ876684433.github.io/2019/07/16/%E7%B2%BE%E8%AF%BBJava%E6%BA%90%E7%A0%81-String%E7%B1%BB/"/>
    <id>http://QQ876684433.github.io/2019/07/16/精读Java源码-String类/</id>
    <published>2019-07-16T12:59:00.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精读Java源码-String类"><a href="#精读Java源码-String类" class="headerlink" title="精读Java源码 - String类"></a>精读Java源码 - String类</h1><blockquote><p>基于jdk1.8</p><p>推荐资料：</p><ul><li><a href="https://www.kaelli.com/33.html" target="_blank" rel="noopener">https://www.kaelli.com/33.html</a></li><li><a href="http://cmsblogs.com/?p=5256" target="_blank" rel="noopener">http://cmsblogs.com/?p=5256</a></li><li><a href="http://cmsblogs.com/?p=5258" target="_blank" rel="noopener">http://cmsblogs.com/?p=5258</a></li></ul></blockquote><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>public没什么好说的，final修饰符则决定了String类是不可继承的且对象是不可变的，你无法自己写一个继承自String的类，而String对象的不可变性也是大家耳熟能详的。</p><p>实现了java.io.Serializable、Comparable和CharSequence共3个接口：</p><ul><li>Serializable是用来保证String可以序列化和反序列化的。</li><li>Comparable的compareTo(String str)方法则是实现String的对比排序的。</li><li>CharSequence的length()方法用来返回字符串长度，charAt(int index)则可以获取到给定位置的单个字符，subSequence(int start, int end)则提供了截取子字符串的功能，toString()方法对于String来说就是返回它自己了</li></ul><h2 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class String is special cased within the Serialization Stream Protocol.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A Comparator that orders &#123;<span class="doctag">@code</span> String&#125; objects as by</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> compareToIgnoreCase&#125;. This comparator is serializable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class="line">        = <span class="keyword">new</span> CaseInsensitiveComparator();</span><br></pre></td></tr></table></figure><ul><li><p>value </p><p>用于存储字符串对象的值，在jdk1.8里面是char数组，在后面的版本中改成了byte数组；被final修饰说明它是不可变的</p></li><li><p>hash </p><p>为字符串对象的哈希值，默认值为0</p></li><li><p>serialPersistentFields </p><p><em>看定义，它是一个私有的、静态的、不可改变的</em>ObjectStreamField数组，实际上在JDK源码里有很多类都有这样一个属性，这些类的共同点是都实现了java.io.Serializable接口。在默认情况下一个实现了Serializable接口的类，所有的非 transient 非 static 修饰的字段都会被序列化，但<strong>如果还定义了serialPersistentFields字段，则只有serialPersistentFields里添加的字段才会被序列化</strong>。当一个字段用transient修饰，但又位于serialPersistentFields数组里时，它依然会被序列化——说明<strong>serialPersistentFields的作用优先级是比transient高的</strong>。</p><p>在String类里，<em>serialPersistentFields是一个容量为0的空数组，显然String的字段都不会被序列化</em></p></li><li><p>CASE_INSENSITIVE_ORDER </p><p>表示用于排序的比较器</p></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>排除@Deprecated的构造函数，String类提供的构造函数主要有以下几类：</p><ul><li><p>无参构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从原有字符串构造新的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = original.value;</span><br><span class="line"><span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接对参数里的原字符串进行浅拷贝构造新的字符串，由于String类是final的，而且内部的value也是final的，所以字符序列在不同的String实例中共享不会带来任何副作用</p></li><li><p>通过字符数组构造字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也没什么好讲的，它直接对参数里的字节数组进行了拷贝，这样的目的是使得外部的字节数组更改之后不会对字符串的字符序列造成影响。<code>offset &gt; value.length - count</code>的处理是为了防止<code>offset+count</code>的int类型溢出</p></li><li><p>通过整型数组构造字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span>[] codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= codePoints.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt; codePoints.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=============================分割线============================</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> end = offset + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass 1: Compute precise size of char[]</span></span><br><span class="line">    <span class="keyword">int</span> n = count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">        <span class="keyword">if</span> (Character.isBmpCodePoint(c))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Character.isValidCodePoint(c))</span><br><span class="line">            n++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Integer.toString(c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass 2: Allocate and fill in char[]</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] v = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset, j = <span class="number">0</span>; i &lt; end; i++, j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">        <span class="keyword">if</span> (Character.isBmpCodePoint(c))</span><br><span class="line">            v[j] = (<span class="keyword">char</span>)c;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Character.toSurrogates(c, v, j++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.value = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分割线上部分没什么好讲的，就是常规的参数边界检查，下半部分有点意思，它涉及到了代码点和代码单元的知识以及Java对Unicode字符集的处理方法，具体的可以参考：<a href="https://chph.xyz/2019/07/17/由String的构造方法引申出来的java字符编码/#由String的构造方法引申出来的java字符编码" target="_blank" rel="noopener">https://chph.xyz/2019/07/17/%E7%94%B1String%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%B3%E5%87%BA%E6%9D%A5%E7%9A%84java%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/#%E7%94%B1String%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%B3%E5%87%BA%E6%9D%A5%E7%9A%84java%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81</a></p><p>通俗来讲，它的处理分为两个阶段：</p><p>（1）计算int数组转成char数组后的精确长度，之所以两者不同，是因为Java采用了UTF-16字符编码，而Unicode代码点在不同的编码中的代码单元是不同的，UTF-16的字符编码由<strong>基本多语言面（BMP UBasic Multilingual Plane ）</strong>和<strong>增补字符（Supplementary Character）</strong>两部分组成，前者占用一个char，后者占用两个char，因此在遍历int数组时，<code>Character.isBmpCodePoint(c)</code>用来判断<code>c</code>是否是BMP，如果是，则长度不变，如果不是，而且它是有效的代码点<code>Character.isValidCodePoint(c)</code>，那么就要在原来int数组的长度是加一<code>n++</code></p><p>（2）计算出char数组的长度后，就可以分配空间并填充该空间了，道理类似，如果是BMP，则直接将int转为char，否则的话就要使用<code>Character.toSurrogates(c, v, j++)</code>来转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toSurrogates</span><span class="params">(<span class="keyword">int</span> codePoint, <span class="keyword">char</span>[] dst, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We write elements "backwards" to guarantee all-or-nothing</span></span><br><span class="line">    dst[index+<span class="number">1</span>] = lowSurrogate(codePoint);</span><br><span class="line">    dst[index] = highSurrogate(codePoint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个涉及到增补字符的高代理项和低代理项的转换，具体的原理在上面的链接里有提到了，这里不再深究，留待精读<code>Character</code>源码时再研究</p><p>最后将填充完成的char数组赋值给新的String实例的value即可</p></li><li><p>通过字节数组构造字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(charsetName, bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (charset == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset"</span>);</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value =  StringCoding.decode(charset, bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], String charsetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length, charsetName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length, charset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个构造函数的功能类似，根据给定的字符编码，调用<code>StringCoding.decode</code>来对字节数组进行解码来构造字符串，如果不提供字符编码的话，<code>StringCoding.decode</code>内部会调用<code>String csn = Charset.defaultCharset().name();</code>来使用Java默认的字符串编码来解码。</p></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="CaseInsensitiveComparator"><a href="#CaseInsensitiveComparator" class="headerlink" title="CaseInsensitiveComparator"></a>CaseInsensitiveComparator</h3><p><code>CaseInsensitiveComparator</code>是String类内部一个大小写不敏感的字符串比较器，被String类内部的方法<code>compareToIgnoreCase</code>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveComparator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// use serialVersionUID from JDK 1.2.2 for interoperability</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8575799808933029326L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> n2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(n1, n2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = s1.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> c2 = s2.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                c1 = Character.toUpperCase(c1);</span><br><span class="line">                c2 = Character.toUpperCase(c2);</span><br><span class="line">                <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                    c1 = Character.toLowerCase(c1);</span><br><span class="line">                    c2 = Character.toLowerCase(c2);</span><br><span class="line">                    <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                        <span class="comment">// No overflow because of numeric promotion</span></span><br><span class="line">                        <span class="keyword">return</span> c1 - c2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1 - n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Replaces the de-serialized object. */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> CASE_INSENSITIVE_ORDER; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compareTo</code>方法的主要思路是，循环遍历比较两个字符串长度匹配的部分，如果该部分忽略大小写后相等，那么比较的结果就是两者长度的比较，按照字典序，结果就是长度小的靠前。</p><p>长度匹配部分的比较比较有意思，它有三次判断：直接比较、转成大写字母比较、转成小写字母比较。这么做的原因和<code>regionMatches</code>方法的处理方式大致相同，因为对有些语言比如格鲁吉亚字母（Georgian alphabet），它的大小写转换规则有点特殊：<strong>大写不等还不一定不等，还需要转小写   比如 ქართული დამწერლობა</strong>。因此在退出比较之前还要再次转换成小写字母进行最后一次检查。</p><p>关于<code>readResolve</code>，我在stackoverflow找到的解释如下：</p><blockquote><p><code>readResolve</code> is used for <em>replacing</em> the object read from the stream. The only use I’ve ever seen for this is enforcing singletons; when an object is read, replace it with the singleton instance. This ensures that nobody can create another instance by serializing and deserializing the singleton.</p><p>The <code>readResolve</code> method is called when <code>ObjectInputStream</code> has read an object from the stream and is preparing to return it to the caller. <code>ObjectInputStream</code> checks whether the class of the object defines the <code>readResolve</code> method. If the method is defined, the <code>readResolve</code> method is called to allow the object in the stream to designate the object to be returned. The object returned should be of a type that is compatible with all uses. If it is not compatible, a <code>ClassCastException</code> will be thrown when the type mismatch is discovered.</p><p>Item 90, Effective Java, 3rd Ed covers <code>readResolve</code> and <code>writeReplace</code> for serial proxies - their main use. The examples do not write out <code>readObject</code> and <code>writeObject</code> methods because they are using default serialisation to read and write fields.</p><p><code>readResolve</code> is called after <code>readObject</code> has returned (conversely <code>writeReplace</code> is called before <code>writeObject</code> and probably on a different object). The object the method returns replaces <code>this</code>object returned to the user of <code>ObjectInputStream.readObject</code> and any further back references to the object in the stream. Both <code>readResolve</code> and <code>writeReplace</code> may return objects of the same or different types. Returning the same type is useful in some cases where fields must be <code>final</code> and either backward compatibility is required or values must copied and/or validated.</p><p>Use of <code>readResolve</code> does not enforce the singleton property.</p><p>……</p><p>源于：<a href="https://stackoverflow.com/questions/1168348/java-serialization-readobject-vs-readresolve/24459741" target="_blank" rel="noopener">https://stackoverflow.com/questions/1168348/java-serialization-readobject-vs-readresolve/24459741</a></p></blockquote><p>按照我的理解来讲就是当<code>ObjectInputStream</code>读到一个对象时，会检查这个对象的类是否定义了<code>readResolve</code>方法，如果定义了该方法，那么会将该方法的返回值作为对象返回，而不是返回<code>ObjectInputStream</code>在流中读到的对象，这样就可以强制实现单例模式。但是如果流中读到的对象和<code>readResolve</code>方法返回的对象类型不兼容，那么就会抛出<code>ClassCastException</code>。</p><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><h3 id="regionMatches"><a href="#regionMatches" class="headerlink" title="regionMatches"></a>regionMatches</h3><p><code>regionMatches</code>功能是判断两个字符串指定区间、且具有相同长度的子串是否相等，它有两个重载的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure><p>它们的唯一区别是前者大小写敏感，后者可以指定是否忽略大小写。只有当一下某一个条件满足（即返回值为true）时，该方法的结果是false，即两个子串不相等：</p><ul><li>下标越界：toffset&lt;0、ooffset&lt;0、toffset+len&gt;this.length()、ooffset+len&gt;other.length()</li><li>下标不越界情况下，两个子串的某一个位置对应的字符不相等</li></ul><p>由于两个重载的方法中后者的功能涵盖了前者，因此我们只看后者的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                             String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = other.value;</span><br><span class="line">    <span class="keyword">int</span> po = ooffset;</span><br><span class="line">    <span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">            || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">            || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = ta[to++];</span><br><span class="line">        <span class="keyword">char</span> c2 = pa[po++];</span><br><span class="line">        <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ignoreCase) &#123;</span><br><span class="line">            <span class="comment">// If characters don't match but case may be ignored,</span></span><br><span class="line">            <span class="comment">// try converting both characters to uppercase.</span></span><br><span class="line">            <span class="comment">// If the results match, then the comparison scan should</span></span><br><span class="line">            <span class="comment">// continue.</span></span><br><span class="line">            <span class="keyword">char</span> u1 = Character.toUpperCase(c1);</span><br><span class="line">            <span class="keyword">char</span> u2 = Character.toUpperCase(c2);</span><br><span class="line">            <span class="keyword">if</span> (u1 == u2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Unfortunately, conversion to uppercase does not work properly</span></span><br><span class="line">            <span class="comment">// for the Georgian alphabet, which has strange rules about case</span></span><br><span class="line">            <span class="comment">// conversion.  So we need to make one last check before</span></span><br><span class="line">            <span class="comment">// exiting.</span></span><br><span class="line">            <span class="keyword">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转成大写再转小写这个做法在前面的部分<code>CaseInsensitiveComparator</code>中已经提到了，道理是类似的，我们来看看这个地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line"><span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">         || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">         || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方的处理比较精妙，<code>-1&gt;&gt;&gt;1</code>等于2147483647，即int类型的上界，它考虑到了toffset和ooffset的值有可能是很靠近甚至等于这个上界的，如果使用<code>toffset + len &gt; (long)value.length</code>来判断的话，有可能出现<code>toffset + len</code>溢出的情况，而源码中的写法就能很好地解决了这个问题。</p><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>直接返回内部字符数组的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h3><p>返回String类内部字符数组value在参数索引处的字符，如果该位置的字符是高低代理项，那么它返回的字符也是高低代理项的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt"></a>codePointAt</h3><p>这个方法和<code>charAt</code>不同的地方在于，它返回的是int型的Unicode代码点，因此他会有两种情况：</p><ul><li>index位置的字符是BMP的话，则直接返回index位置的字符对应的int值</li><li>index位置的字符是在高代理项的范围内，如果index+1&lt;value.length，而且index+1位置的字符在低代理项范围内，那么将会返回(index, index+1)这对字符对应的Unicode增补代码点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.codePointAtImpl(value, index, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="codePointBefore"><a href="#codePointBefore" class="headerlink" title="codePointBefore"></a>codePointBefore</h3><p>返回参数index位置之前的Unicode代码点，因此它会有如下情况：</p><ul><li>index-1位置的字符在低代理项范围内，且index-2是非负数，那么返回(index-2, index-1)对应的Unicode代码点</li><li>index-1位置的字符是没有配对的高代理项（可能的情况是index-1和index位置的字符是配对的）或者低代理项（<em>这个不是很理解</em>）的话，则直接返回index-1位置字符的int值，不作转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointBefore</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span>) || (i &gt;= value.length)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.codePointBeforeImpl(value, index, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="codePointCount"><a href="#codePointCount" class="headerlink" title="codePointCount"></a>codePointCount</h3><p>计算<code>[beginIndex, endIndex)</code>范围内的子串的代码点个数，怎么计算的很容易，只需要注意的是，对于该范围内的子串，如果有字符是没有配对的代理项，那么它也当成一个代码点来计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span> || endIndex &gt; value.length || beginIndex &gt; endIndex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="offsetByCodePoints"><a href="#offsetByCodePoints" class="headerlink" title="offsetByCodePoints"></a>offsetByCodePoints</h3><p>计算从index位置开始，偏移codePointOffset个代码点后的索引位置，注意，这个codePointOffset可以是负数，这种情况下是往左偏移；同理，如果遇到不匹配的代理项，也是当成一个代码点来计数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">offsetByCodePoints</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> codePointOffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Character.offsetByCodePointsImpl(value, <span class="number">0</span>, value.length,</span><br><span class="line">            index, codePointOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getChars"><a href="#getChars" class="headerlink" title="getChars"></a>getChars</h3><p>该方法的主要功能是将字符串读取成字符数组，默认修饰符的<code>getChars</code>是没有任何边界参数检测的，原因很简单，因为它只在类库内部才能使用（concat方法），按照契约式编程原则是不会有意外情况发生的；public修饰的方法，它会对参数进行边界条件检测，用于将指定范围（srcBegin、srcEnd）的子串复制到字符数组参数dst中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(value, <span class="number">0</span>, dst, dstBegin, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getBytes"><a href="#getBytes" class="headerlink" title="getBytes"></a>getBytes</h3><p>获取字符串指定编码的字节数组，比如 charsetName 为 utf8，则将字符串转为 utf8 编码后对应的字节数组。如果不传参数则使用 JVM 默认编码，即<code>Charset.defaultCharset()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName)</span><br><span class="line">        <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> StringCoding.encode(charsetName, value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(Charset charset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (charset == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> StringCoding.encode(charset, value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes() &#123;</span><br><span class="line">    <span class="keyword">return</span> StringCoding.encode(value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>用来判断两个字符串的内容是否相同，但是仔细看可以发现，<code>equals</code>方法的参数其实是<code>Object</code>类型的，其实道理很简单，<code>String</code>类的<code>equals</code>方法是直接继承自<code>Object</code>类的，属于方法重写，参数个数和类型要相同，<code>Object</code>中的<code>equals</code>方法参数就是<code>Object</code>类型，该方法的实现思路如下：</p><ul><li>首先判断是不是同一个对象，如果是则返回<code>true</code></li><li>判断参数<code>anObject</code>是否是<code>String</code>类型（防御式编程），如果不是，则直接返回<code>false</code></li><li>最后再逐个字符进行比较，因为这是在<code>String</code>类内部，可以直接访问<code>value</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="contentEquals"><a href="#contentEquals" class="headerlink" title="contentEquals"></a>contentEquals</h3><p><code>contentEquals</code>的功能和<code>equals</code>差不多，都是比较字符串的内容是否相同，区别在于它的参数是<code>StringBuffer</code>或者<code>CharSequence</code>，适用范围更广。</p><p><code>AbstractStringBuilder</code>是<code>StringBuffer</code>和<code>StringBuilder</code>的公共父类，前者是线程安全的，后者是非线程安全的，因此需要分别对他们进行处理，<code>StringBuffer</code>需要加上<code>synchronized</code>同步块；注意到，无论是<code>StringBuffer</code>还是<code>StringBuilder</code>，cs都被强制转换为<code>StringBuilder</code>，最后调用<code>nonSyncContentEquals</code>方法来进行内容比较。</p><p>不同类型的字符串内容的比较算法都差不多，基本上都是先比较长度是否相同，这样可以避免不必要的循环遍历比较，如果相同再逐个字符比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contentEquals((CharSequence)sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">nonSyncContentEquals</span><span class="params">(AbstractStringBuilder sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = sb.getValue();</span><br><span class="line">    <span class="keyword">int</span> n = v1.length;</span><br><span class="line">    <span class="keyword">if</span> (n != sb.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != v2[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Argument is a StringBuffer, StringBuilder</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> AbstractStringBuilder) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> StringBuffer) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(cs) &#123;</span><br><span class="line">                <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Argument is a String</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> equals(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Argument is a generic CharSequence</span></span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">int</span> n = v1.length;</span><br><span class="line">    <span class="keyword">if</span> (n != cs.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != cs.charAt(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="equalsIgnoreCase"><a href="#equalsIgnoreCase" class="headerlink" title="equalsIgnoreCase"></a>equalsIgnoreCase</h3><p>判断两个字符串在忽略大小写情况下内容是否相同，遇到大小写就应该想到个别字母的大小写转换规则比较特殊，参见<code>CaseInsensitiveComparator</code>部分具体说明，因此对应位置两个字符是否相同条件是以下其中一个：</p><ul><li>直接<code>==</code>比较返回true</li><li><code>Character.toUpperCase</code>转换成大写字母后<code>==</code>比较相同</li><li><code>Character.toLowerCase</code>转换成小写字母后<code>==</code>比较相同</li></ul><p>当然，这部分的判断直接调用了内部的方法<code>regionMatches</code>进行比较了。</p><p>这个方法首先判断两个字符串是否是同一个对象，是则返回true，否则再判断参数字符串是否是null（防御式编程），然后再判断两个字符串长度是否相同，最后再比较字符串内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == anotherString) ? <span class="keyword">true</span></span><br><span class="line">            : (anotherString != <span class="keyword">null</span>)</span><br><span class="line">            &amp;&amp; (anotherString.value.length == value.length)</span><br><span class="line">            &amp;&amp; regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, anotherString, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;精读Java源码-String类&quot;&gt;&lt;a href=&quot;#精读Java源码-String类&quot; class=&quot;headerlink&quot; title=&quot;精读Java源码 - String类&quot;&gt;&lt;/a&gt;精读Java源码 - String类&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="源码" scheme="http://QQ876684433.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>软件学院大三上教材推荐</title>
    <link href="http://QQ876684433.github.io/2019/07/16/%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%95%99%E6%9D%90%E6%8E%A8%E8%8D%90/"/>
    <id>http://QQ876684433.github.io/2019/07/16/软件学院大三上教材推荐/</id>
    <published>2019-07-16T03:23:11.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件学院大三上教材推荐"><a href="#软件学院大三上教材推荐" class="headerlink" title="软件学院大三上教材推荐"></a>软件学院大三上教材推荐</h1><blockquote><p>来源：根据某朱姓学长的聊天记录整理</p></blockquote><h2 id="教材推荐建议"><a href="#教材推荐建议" class="headerlink" title="教材推荐建议"></a>教材推荐建议</h2><table><thead><tr><th>课程</th><th>教材</th><th>备注</th></tr></thead><tbody><tr><td>计算机与操作系统</td><td>操作系统教材，骆斌</td><td>原来是第五版，今年可能有第六版</td></tr><tr><td>数据库管理基础</td><td>数据库原理，编程与性能</td><td>数据库换了老师，今年的教材可能不确定</td></tr><tr><td>C++高级程序设计</td><td>C++程序设计，钱能</td><td>有推荐教材，但是老师不会按教材讲</td></tr><tr><td>软件系统设计</td><td>没有教材</td><td></td></tr><tr><td>大数据分析</td><td>没有教材，可以参考cs246的《大数据互联网大规模数据挖掘与分布式处理》</td><td>虽然推荐了cs246，但是老师不会按那个讲</td></tr><tr><td>云计算</td><td>没有教材</td><td></td></tr><tr><td>自动化测试</td><td>没有教材，可以参考陈振宇的《开发者测试》</td><td>除了开发者测试，还要学安卓测试，web测试，ai测试</td></tr><tr><td>web前端开发</td><td>有教材，但是经常变，去年是《Web开发权威指南》</td><td></td></tr><tr><td>编译原理</td><td>龙书，非常厚，可以买虎书看看，薄一点</td><td>龙书叫编译原理，看准翻译老师，是赵建华(计算机系编译原理、算法老师，今年给软院上离散)，郑滔(我们c++老师)，戴新宇(计算机系自然语言处理组老师)翻译的<br>虎书叫现代编译原理</td></tr><tr><td>嵌入式系统概论</td><td>嵌入式系统软件工程</td><td>别买，血亏；很厚，没时间看</td></tr><tr><td>商务智能</td><td>没有教材</td><td>可以买复旦老师的《商务智能》，但是和贝佳的重点不一样，贝佳重点是数据仓库，复旦老师重点是数据挖掘</td></tr></tbody></table><h2 id="书籍的pdf资源"><a href="#书籍的pdf资源" class="headerlink" title="书籍的pdf资源"></a>书籍的pdf资源</h2><p>TODO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件学院大三上教材推荐&quot;&gt;&lt;a href=&quot;#软件学院大三上教材推荐&quot; class=&quot;headerlink&quot; title=&quot;软件学院大三上教材推荐&quot;&gt;&lt;/a&gt;软件学院大三上教材推荐&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;来源：根据某朱姓学长的聊天记录整理&lt;/p&gt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="软件工程" scheme="http://QQ876684433.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 技术书籍大全</title>
    <link href="http://QQ876684433.github.io/2019/07/16/Java%20%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E5%A4%A7%E5%85%A8/"/>
    <id>http://QQ876684433.github.io/2019/07/16/Java 技术书籍大全/</id>
    <published>2019-07-16T01:33:19.000Z</published>
    <updated>2019-09-15T04:29:52.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载原文：<a href="https://github.com/sorenduan/awesome-java-books" target="_blank" rel="noopener">https://github.com/sorenduan/awesome-java-books</a></p></blockquote><h1 id="Java-技术书籍大全"><a href="#Java-技术书籍大全" class="headerlink" title="Java 技术书籍大全"></a>Java 技术书籍大全</h1><p>本文档目前已收录 <b>277</b>本 Java相关领域经典技术书籍，从初级开发者到资深架构师，涵盖 Java 从业者的各个阶段，并持续更新。</p><p>涵盖领域：Java入门书籍，Java基础及进阶书籍，框架与中间件，架构设计，设计模式，数学与算法，JVM周边语言，项目管理&amp;领导力&amp;流程，职业素养与个人成长，格局与视野，面试参考书等。</p><p>推荐书籍可以点击 -&gt; <strong><a href="https://github.com/sorenduan/awesome-java-books/issues" target="_blank" rel="noopener">点击这里</a></strong></p><p>书籍列表 -&gt; <strong><a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md" target="_blank" rel="noopener">点击这里</a></strong></p><h2 id="入门书籍"><a href="#入门书籍" class="headerlink" title="入门书籍"></a>入门书籍</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TA6z3m" target="_blank" rel="noopener">《明解Java》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7urNtH" target="_blank" rel="noopener">《Java从入门到精通（第4版 附光盘）》</a> - 豆瓣评分 6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/2dDnsY" target="_blank" rel="noopener">《入门很简单丛书：Java Web开发入门很简单》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7zm17P" target="_blank" rel="noopener">《程序员炼成记 从小白到工程师》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZCbVjQ" target="_blank" rel="noopener">《Java从小白到大牛》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mnkAJR" target="_blank" rel="noopener">《JavaWeb项目开发实战入门（全彩版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/9TGA0S" target="_blank" rel="noopener">《Java精彩编程200例（全彩版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zMDeI7" target="_blank" rel="noopener">《Java轻松学》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/td3bUo" target="_blank" rel="noopener">《大话Java：程序设计从入门到精通（含DVD光盘1张）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HOFu01" target="_blank" rel="noopener">《Java语言袖珍指南（第二版）》</a></li></ul><h2 id="基础书籍"><a href="#基础书籍" class="headerlink" title="基础书籍"></a>基础书籍</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ajylTp" target="_blank" rel="noopener">《Java编程思想（第4版） [thinking in java]》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/tp87o1" target="_blank" rel="noopener">《Java核心技术 卷I：基础知识（原书第10版）》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fYGMsC" target="_blank" rel="noopener">《Java核心技术卷II：高级特性（原书第10版）》</a> - 豆瓣评分 7.7</li></ul><h3 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ERgtGV" target="_blank" rel="noopener">《华章专业开发者丛书·Java并发编程实战》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XRUB8H" target="_blank" rel="noopener">《Java多线程编程实战指南（设计模式篇）》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/LDOFjh" target="_blank" rel="noopener">《图解Java多线程设计模式》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/WXhQuO" target="_blank" rel="noopener">《实战Java高并发程序设计》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/e5tZdf" target="_blank" rel="noopener">《Java高并发编程详解：多线程与架构设计》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5p2KoJ" target="_blank" rel="noopener">《Java核心技术系列：Java多线程编程核心技术 [Java Multi-thread Programming]》</a> - 豆瓣评分 5.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/RQu2W6" target="_blank" rel="noopener">《Java并发编程：核心方法与框架》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fkn9NP" target="_blank" rel="noopener">《Java多线程与Socket：实战微服务框架》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZwyPCp" target="_blank" rel="noopener">《NIO与Socket编程技术指南》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/vB6BA2" target="_blank" rel="noopener">《Java并发编程之美》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fthTzf" target="_blank" rel="noopener">《实战Java高并发程序设计（第2版）》</a></li></ul><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/osowEq" target="_blank" rel="noopener">《Java网络编程（第四版） [Java network programming, forth edition]》</a> - 豆瓣评分 7.6</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wdrJls" target="_blank" rel="noopener">《数据结构与算法分析：Java语言描述（原书第3版）》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/9GKS26" target="_blank" rel="noopener">《图解数据结构：使用Java》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DCJzy6" target="_blank" rel="noopener">《数据结构与算法Java语言描述》</a></li></ul><h3 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/MNwLHg" target="_blank" rel="noopener">《Java 8实战》</a> - 豆瓣评分 9.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/M6XqLp" target="_blank" rel="noopener">《Java函数式编程》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/YApFXv" target="_blank" rel="noopener">《Java编程的逻辑》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/UZgI0F" target="_blank" rel="noopener">《O’Reilly：Head First Java（中文版 第2版 涵盖Java5.0）》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZCMWOr" target="_blank" rel="noopener">《写给大忙人看的Java核心技术》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ajoGad" target="_blank" rel="noopener">《精通lambda表达式：Java多核编程 [Mastering Lambdas: Java Programming in a Multicore]》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5HXsKg" target="_blank" rel="noopener">《Java 9模块化开发：核心原则与实践》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/l7fy1C" target="_blank" rel="noopener">《Java JDK 9学习笔记》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/CqmtBM" target="_blank" rel="noopener">《Java 9编程参考官方大全（第10版） [Java：Thte Complete Reference，Tenth Edition]》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JMdy64" target="_blank" rel="noopener">《写给大忙人的Java SE 9核心技术》</a></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/MBhyO7" target="_blank" rel="noopener">《深入分析Java Web技术内幕（修订版）》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GEdlD0" target="_blank" rel="noopener">《Java RESTful Web Service实战（第2版）》</a></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qTFNCP" target="_blank" rel="noopener">《Java性能优化权威指南 [Java performance]》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6CYRQi" target="_blank" rel="noopener">《Java程序性能优化：让你的Java程序更快、更稳定》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/KmJo2x" target="_blank" rel="noopener">《Java性能权威指南》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GKe55M" target="_blank" rel="noopener">《51CTO学院系列丛书·实战Java虚拟机：JVM故障诊断与性能优化》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/sQPN8w" target="_blank" rel="noopener">《Java性能调优指南》</a> - 豆瓣评分 7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Uqaj5n" target="_blank" rel="noopener">《大话Java性能优化》</a> - 豆瓣评分 4.4</li></ul><h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/nvsfLb" target="_blank" rel="noopener">《响应式架构：消息模式Actor实现与Scala、Akka应用集成》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HeIp16" target="_blank" rel="noopener">《RxJava响应式编程》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/iIZc0A" target="_blank" rel="noopener">《RxJava 2.x 实战》</a></li></ul><h3 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DgTnN2" target="_blank" rel="noopener">《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/73DIJB" target="_blank" rel="noopener">《Java核心技术系列：Java虚拟机规范（Java SE 8版） [The Java Virtual Machine Specification Jave SE 8 Edition]》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ct4KRw" target="_blank" rel="noopener">《揭秘Java虚拟机：JVM设计原理与实现》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xJZjRH" target="_blank" rel="noopener">《HotSpot实战》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0ZMjqZ" target="_blank" rel="noopener">《Java从入门到动手写虚拟机1（套装共2册）》</a></li></ul><h3 id="代码-amp-设计优化"><a href="#代码-amp-设计优化" class="headerlink" title="代码&amp;设计优化"></a>代码&amp;设计优化</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/QSoCEv" target="_blank" rel="noopener">《重构 改善既有代码的设计 Java语言版》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wxQc3i" target="_blank" rel="noopener">《代码大全（第2版）》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/syzAFD" target="_blank" rel="noopener">《Effective Java中文版（原书第3版）》</a> - 豆瓣评分 9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Rt31CM" target="_blank" rel="noopener">《代码整洁之道 程序员的职业素养》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XBQxz8" target="_blank" rel="noopener">《代码整洁之道 [Clean Code A Handbook of Agile Software Craftsmanship]》</a> - 豆瓣评分 8.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ld8p0r" target="_blank" rel="noopener">《Spring实战（第4版）》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0hnAnw" target="_blank" rel="noopener">《代码不朽：编写可维护软件的10大要则（Java版）》</a> - 豆瓣评分 7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/tyYWro" target="_blank" rel="noopener">《Java代码与架构之完美优化 实战经典》</a></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/SJWtpV" target="_blank" rel="noopener">《反应式设计模式》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/IGKmVq" target="_blank" rel="noopener">《O’Reilly：Head First设计模式（中文版）》</a> - 豆瓣评分 9.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/D59mge" target="_blank" rel="noopener">《设计模式：可复用面向对象软件的基础》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/lFwQdc" target="_blank" rel="noopener">《实现领域驱动设计 [Implementing Domain-Driven Design]》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/yxTBEJ" target="_blank" rel="noopener">《原创精品系列：设计模式之禅（第2版）》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/H9tRFl" target="_blank" rel="noopener">《图解设计模式》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qfAaGS" target="_blank" rel="noopener">《大话设计模式》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/PllZtF" target="_blank" rel="noopener">《领域驱动设计 软件核心复杂性应对之道 修订版》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xRo8Ur" target="_blank" rel="noopener">《Java测试驱动开发》</a> - 豆瓣评分 6.6</li></ul><h2 id="框架与中间件"><a href="#框架与中间件" class="headerlink" title="框架与中间件"></a>框架与中间件</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/i4KCQO" target="_blank" rel="noopener">《高性能MySQL（第3版）》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Th90ra" target="_blank" rel="noopener">《MySQL技术内幕：InnoDB存储引擎（第2版）》</a> - 豆瓣评分 8.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/YivOvQ" target="_blank" rel="noopener">《大型网站系统与Java中间件实践》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HjaHc2" target="_blank" rel="noopener">《深入浅出MySQL 数据库开发 优化与管理维护 第2版》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oYHlHw" target="_blank" rel="noopener">《PostgreSQL修炼之道：从小工到专家》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/hKsMRX" target="_blank" rel="noopener">《PostgreSQL技术内幕：查询优化深度探索》</a></li></ul><h3 id="缓存与NoSQL"><a href="#缓存与NoSQL" class="headerlink" title="缓存与NoSQL"></a>缓存与NoSQL</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/uZirI6" target="_blank" rel="noopener">《Redis 深度历险：核心原理与应用实践》</a> - 豆瓣评分 9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VMo7w2" target="_blank" rel="noopener">《Redis实战》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GmFr7B" target="_blank" rel="noopener">《Redis入门指南（第2版）》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TKeCR2" target="_blank" rel="noopener">《深入分布式缓存：从原理到实践》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8DuE9W" target="_blank" rel="noopener">《人人都是架构师：分布式系统架构落地与瓶颈突破》</a> - 豆瓣评分 6.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qd9tLA" target="_blank" rel="noopener">《MongoDB应用设计模式》</a> - 豆瓣评分 6.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Mlefug" target="_blank" rel="noopener">《MongoDB实战 架构、开发与管理》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1QhhB6" target="_blank" rel="noopener">《NoSQL数据库入门与实践（基于MongoDB、Redis）》</a></li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4SyxGo" target="_blank" rel="noopener">《RabbitMQ实战指南》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qIwmGY" target="_blank" rel="noopener">《Kafka权威指南》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/hqBGgy" target="_blank" rel="noopener">《Kafka入门与实践》</a> - 豆瓣评分 7.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/vyU3eK" target="_blank" rel="noopener">《RocketMQ实战与原理解析》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GZh0yK" target="_blank" rel="noopener">《Kafka技术内幕 图文详解Kafka源码设计与实现》</a> - 豆瓣评分 6.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/sTtFQn" target="_blank" rel="noopener">《深入理解Kafka：核心设计与实践原理》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GzBNOZ" target="_blank" rel="noopener">《分布式消息中间件实践》</a></li></ul><h3 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0GXsRh" target="_blank" rel="noopener">《MyBatis从入门到精通》</a> - 豆瓣评分 7.7</li></ul><h3 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ohN8uh" target="_blank" rel="noopener">《Spring微服务实战》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/z1QvAP" target="_blank" rel="noopener">《Spring Cloud微服务实战》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/FfCbxt" target="_blank" rel="noopener">《深入理解Spring Cloud与微服务构建》</a> - 豆瓣评分 7.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wAPeEw" target="_blank" rel="noopener">《MyBatis技术内幕》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/BcQznU" target="_blank" rel="noopener">《Spring Boot实战》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/k0xgoA" target="_blank" rel="noopener">《深入浅出Spring Boot 2.x》</a> - 豆瓣评分 7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4Rtvg3" target="_blank" rel="noopener">《JavaEE开发的颠覆者：Spring Boot实战》</a> - 豆瓣评分 6.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/2rz8BY" target="_blank" rel="noopener">《Spring技术内幕：深入解析Spring架构与设计原理（第2版）》</a> - 豆瓣评分 5.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xrNcv1" target="_blank" rel="noopener">《Spring Boot 2精髓：从构建小系统到架构分布式大系统》</a> - 豆瓣评分 4.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/dtDOqc" target="_blank" rel="noopener">《Spring 5开发大全》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oFsaYt" target="_blank" rel="noopener">《Spring Cloud微服务架构进阶》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/SdhhtK" target="_blank" rel="noopener">《Spring源码深度解析 第2版》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ghc04R" target="_blank" rel="noopener">《Spring MVC实战》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fCZpVU" target="_blank" rel="noopener">《Spring Boot编程思想（核心篇）（限量版亲笔签名书签 随机发售）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HO244A" target="_blank" rel="noopener">《互联网轻量级SSM框架解密：Spring、Spring MVC、MyBatis源码深度剖析》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/O9L5Nb" target="_blank" rel="noopener">《Spring学习指南 第3版》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/k4WSg3" target="_blank" rel="noopener">《精通Spring MVC 4》</a></li></ul><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/htIJgi" target="_blank" rel="noopener">《Netty实战》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/81Pbod" target="_blank" rel="noopener">《七周七并发模型》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7tGXx5" target="_blank" rel="noopener">《Netty权威指南（第2版）》</a> - 豆瓣评分 6.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VBYLE0" target="_blank" rel="noopener">《Netty进阶之路：跟着案例学Netty》</a></li></ul><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/3rp1Hv" target="_blank" rel="noopener">《从Paxos到Zookeeper分布式一致性原理与实践》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/LAyupw" target="_blank" rel="noopener">《ZooKeeper：分布式过程协同技术详解》</a> - 豆瓣评分 7.2</li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/IdftoH" target="_blank" rel="noopener">《从Lucene到Elasticsearch：全文检索实战》</a></li></ul><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/BlEDc7" target="_blank" rel="noopener">《Hadoop权威指南：大数据的存储与分析(第4版)》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/dW1kpa" target="_blank" rel="noopener">《Hadoop构建数据仓库实践》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wqb9z0" target="_blank" rel="noopener">《HBase权威指南 [HBase： The Definitive Guide]》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/azPD8S" target="_blank" rel="noopener">《图解Spark：核心技术与案例实战》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/bd1YCS" target="_blank" rel="noopener">《Hive编程指南 [Programming Hive]》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/kFRuj2" target="_blank" rel="noopener">《HBase应用架构》</a></li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pTZ8xk" target="_blank" rel="noopener">《Web性能权威指南》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7tOuAz" target="_blank" rel="noopener">《从零开始学架构：照着做，你也能成为架构师》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Qs9SXn" target="_blank" rel="noopener">《Java应用架构设计：模块化模式与OSGi》</a> - 豆瓣评分 6.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GVYZr9" target="_blank" rel="noopener">《大型网站技术架构演进与性能优化》</a> - 豆瓣评分 6.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7y5NpR" target="_blank" rel="noopener">《高可用架构（第1卷）》</a> - 豆瓣评分 6.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/kPGIoj" target="_blank" rel="noopener">《Java架构师指南》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Bc2TLN" target="_blank" rel="noopener">《大话代码架构（项目实战版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mzqn7f" target="_blank" rel="noopener">《小团队构建大网站：中小研发团队架构实践》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zDMNQs" target="_blank" rel="noopener">《未来架构 从服务化到云原生(限量签名 随机发放)》</a></li></ul><h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zpE3MI" target="_blank" rel="noopener">《可伸缩架构：面向增长应用的高可用》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HQHcMY" target="_blank" rel="noopener">《分布式服务架构：原理、设计与实战》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/9JXTi8" target="_blank" rel="noopener">《亿级流量网站架构核心技术 跟开涛学搭建高可用高并发系统》</a> - 豆瓣评分 6.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zzctjK" target="_blank" rel="noopener">《大型分布式网站架构设计与实践》</a> - 豆瓣评分 6.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/l4UA35" target="_blank" rel="noopener">《可伸缩服务架构：框架与中间件》</a> - 豆瓣评分 5.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1YUJxK" target="_blank" rel="noopener">《架构探险：从零开始写分布式服务框架》</a> - 豆瓣评分 5.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4trb76" target="_blank" rel="noopener">《Cloud Native分布式架构原理与实践》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/QWumiy" target="_blank" rel="noopener">《分布式系统常用技术及案例分析（第2版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/53hDaR" target="_blank" rel="noopener">《云原生Java：Spring Boot、Spring Cloud与Cloud Foundry弹性系统设计》</a></li></ul><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5KB81a" target="_blank" rel="noopener">《微服务设计》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/LF3vzd" target="_blank" rel="noopener">《生产微服务》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xoCkW1" target="_blank" rel="noopener">《架构解密：从分布式到微服务》</a> - 豆瓣评分 5.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/jk1V1F" target="_blank" rel="noopener">《Java微服务》</a> - 豆瓣评分 5.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/QvfyPI" target="_blank" rel="noopener">《Spring Cloud 微服务架构开发实战（全新升级版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DyZQbc" target="_blank" rel="noopener">《微服务实践》</a></li></ul><h3 id="架构方法论"><a href="#架构方法论" class="headerlink" title="架构方法论"></a>架构方法论</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/k8yxj0" target="_blank" rel="noopener">《架构整洁之道》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pQOd7z" target="_blank" rel="noopener">《企业应用架构模式 [Patterns of Enterprise Application Architecture]》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ipHhzt" target="_blank" rel="noopener">《企业IT架构转型之道 阿里巴巴中台战略思想与架构实战》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/jRMw2b" target="_blank" rel="noopener">《聊聊“架构”》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1gr9nd" target="_blank" rel="noopener">《架构真经：互联网技术架构的设计原则（原书第2版）》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4Y77J0" target="_blank" rel="noopener">《软件架构设计：程序员向架构师转型必备（第2版）》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XOr8py" target="_blank" rel="noopener">《恰如其分的软件架构 [Just Enough Software Architecture]》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/lSUYn8" target="_blank" rel="noopener">《软件架构设计：大型网站技术架构与业务架构融合之道》</a></li></ul><h2 id="JVM周边语言"><a href="#JVM周边语言" class="headerlink" title="JVM周边语言"></a>JVM周边语言</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/R0JT1a" target="_blank" rel="noopener">《Scala编程（第3版）》</a> - 豆瓣评分 9.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/AMZkGX" target="_blank" rel="noopener">《Groovy程序设计》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/h6Gnct" target="_blank" rel="noopener">《快学Scala（第2版）》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/loJfwO" target="_blank" rel="noopener">《Kotlin极简教程》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/WvMNgs" target="_blank" rel="noopener">《Scala集合技术手册》</a></li></ul><h2 id="项目管理-amp-领导力-amp-流程"><a href="#项目管理-amp-领导力-amp-流程" class="headerlink" title="项目管理&amp;领导力&amp;流程"></a>项目管理&amp;领导力&amp;流程</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5OmcTI" target="_blank" rel="noopener">《构建之法 现代软件工程（第三版）》</a> - 豆瓣评分 9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/gcHfSY" target="_blank" rel="noopener">《精益思想（白金版）》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/uZ2nZV" target="_blank" rel="noopener">《给产品经理讲技术》</a></li></ul><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TzKtiz" target="_blank" rel="noopener">《持续交付：发布可靠软件的系统方法》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qEOLhm" target="_blank" rel="noopener">《名家经典系列：人件（原书第3版） [Peopleware: Productive Projects and Teams]》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/gc719a" target="_blank" rel="noopener">《硝烟中的Scrum和XP：我们如何实施Scrum》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZHeyFS" target="_blank" rel="noopener">《敏捷软件开发实践 估算与计划》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mUkwcD" target="_blank" rel="noopener">《人月神话（40周年中文纪念版） [The Mythical Man-Month：Essays on Software Engineering Anniversary Edition]》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/T9HSMS" target="_blank" rel="noopener">《Scrum敏捷软件开发》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/D8oZoG" target="_blank" rel="noopener">《用户故事与敏捷方法 [User Stories Applied:For Agile Software Development]》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/P6RDR3" target="_blank" rel="noopener">《用户故事地图 [User Story Mapping]》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1zgjNd" target="_blank" rel="noopener">《知行合一 实现价值驱动的敏捷和精益开发》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Dtrvqn" target="_blank" rel="noopener">《互联网项目管理实践精粹》</a></li></ul><h3 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/f2kMe8" target="_blank" rel="noopener">《卓有成效的管理者（珍藏版） [The Effective Executive]》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xLBU9J" target="_blank" rel="noopener">《跃迁：从技术到管理的硅谷路径》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/w4p97S" target="_blank" rel="noopener">《告别失控 软件开发团队管理必读》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/K5DiJn" target="_blank" rel="noopener">《赋能：打造应对不确定性的敏捷团队 [Team of Teams]》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8Gsrin" target="_blank" rel="noopener">《OKR工作法：谷歌、领英等顶级公司的高绩效秘籍 [Radical Focus]》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/PchUJJ" target="_blank" rel="noopener">《CTO说》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wGQe5I" target="_blank" rel="noopener">《轻流程 IT团队的积分式绩效管理》</a> - 豆瓣评分 7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/spqdp1" target="_blank" rel="noopener">《技术领导力：程序员如何才能带团队》</a> - 豆瓣评分 5.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pSHHhA" target="_blank" rel="noopener">《敏捷文化：如何打造优秀的高效能团队 [The Agile Culture: Leading through Trust and Owner]》</a></li></ul><h2 id="数学与算法"><a href="#数学与算法" class="headerlink" title="数学与算法"></a>数学与算法</h2><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/lcuOQq" target="_blank" rel="noopener">《数学之美（第二版）》</a> - 豆瓣评分 8.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Yte3WW" target="_blank" rel="noopener">《程序员的数学2 概率统计》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/WiKN9k" target="_blank" rel="noopener">《程序员的数学3 线性代数》</a> - 豆瓣评分 8.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/iwv4Zd" target="_blank" rel="noopener">《程序员的数学》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qhD5IJ" target="_blank" rel="noopener">《程序员的数学思维修炼（趣味解读）》</a> - 豆瓣评分 5.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/vBLDyU" target="_blank" rel="noopener">《统计之美：人工智能时代的科学思维》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/iCEv9a" target="_blank" rel="noopener">《统计思维：程序员数学之概率统计（第2版）》</a></li></ul><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/AmwANr" target="_blank" rel="noopener">《算法导论（原书第3版）/计算机科学丛书 [Introduction to Algorithms, third edition]》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/J7HWa6" target="_blank" rel="noopener">《算法图解》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Jt8KBI" target="_blank" rel="noopener">《漫画算法：小灰的算法之旅（全彩）》</a></li></ul><h2 id="职业素养与个人成长"><a href="#职业素养与个人成长" class="headerlink" title="职业素养与个人成长"></a>职业素养与个人成长</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DGNxfn" target="_blank" rel="noopener">《我编程，我快乐：程序员职业规划之道》</a> - 豆瓣评分 7.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/THQJSq" target="_blank" rel="noopener">《程序员的自我修养》</a> - 豆瓣评分 6.5</li></ul><h3 id="职业素养提升"><a href="#职业素养提升" class="headerlink" title="职业素养提升"></a>职业素养提升</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/J7iABA" target="_blank" rel="noopener">《码农翻身：用故事给技术加点料》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TL272C" target="_blank" rel="noopener">《程序员修炼之道：从小工到专家》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mAbLoA" target="_blank" rel="noopener">《极客与团队：软件工程师的团队生存秘笈》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8l5o8l" target="_blank" rel="noopener">《程序员思维修炼(修订版)》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/s1OiZc" target="_blank" rel="noopener">《高效能程序员的修炼》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XxVx3J" target="_blank" rel="noopener">《O’Reilly：卓有成效的程序员 [Productive programmer]》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ODjq2h" target="_blank" rel="noopener">《Java工程师修炼之道》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DKrbwc" target="_blank" rel="noopener">《程序员的成长课》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/y36OqE" target="_blank" rel="noopener">《高效程序员的45个习惯：敏捷开发修炼之道(修订版)》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JKgll1" target="_blank" rel="noopener">《温伯格技术思想三部曲：颠覆完美软件 软件测试必须知道的几件事》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0K8XDo" target="_blank" rel="noopener">《温伯格技术思想三部曲：程序开发心理学（银年纪念版）》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/AlxMcW" target="_blank" rel="noopener">《软件开发本质论：追求简约、体现价值、逐步构建》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/W0uA76" target="_blank" rel="noopener">《内外兼修：程序员的成长之路》</a> - 豆瓣评分 6.6</li></ul><h3 id="个人软技能"><a href="#个人软技能" class="headerlink" title="个人软技能"></a>个人软技能</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/I3D7Z0" target="_blank" rel="noopener">《把时间当作朋友（第3版 全彩）》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GZgwi5" target="_blank" rel="noopener">《暗时间》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/jpIkyt" target="_blank" rel="noopener">《关键对话：如何高效能沟通（原书第2版） [Crucial Conversations: Tools for Talking When Stak]》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/N6YwQD" target="_blank" rel="noopener">《温伯格技术思想三部曲：成为技术领导者 掌握全面解决问题的方法》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/KkL3kA" target="_blank" rel="noopener">《软技能 代码之外的生存指南》</a> - 豆瓣评分 8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8YQH5T" target="_blank" rel="noopener">《程序员健康指南》</a> - 豆瓣评分 7.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/NS6cLf" target="_blank" rel="noopener">《如何把事情做到最好：改变全球9800万人的人生指导书 [Mastery]》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Gt5VDT" target="_blank" rel="noopener">《程序员的英语》</a> - 豆瓣评分 5.9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oG641c" target="_blank" rel="noopener">《高效能人士的七个习惯（30周年纪念版）》</a></li></ul><h2 id="大厂出品"><a href="#大厂出品" class="headerlink" title="大厂出品"></a>大厂出品</h2><h3 id="阿里巴巴技术丛书"><a href="#阿里巴巴技术丛书" class="headerlink" title="阿里巴巴技术丛书"></a>阿里巴巴技术丛书</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mIi1ic" target="_blank" rel="noopener">《码出高效：Java开发手册》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4888rh" target="_blank" rel="noopener">《大数据之路 阿里巴巴大数据实践》</a> - 豆瓣评分 7.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xHqHfG" target="_blank" rel="noopener">《技术之瞳 阿里巴巴技术笔试心得》</a> - 豆瓣评分 7.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/uZYvrV" target="_blank" rel="noopener">《淘宝技术这十年》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VA9xEV" target="_blank" rel="noopener">《尽在双11 阿里巴巴技术演进与超越》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5NdzxY" target="_blank" rel="noopener">《逆流而上：阿里巴巴技术成长之路》</a> - 豆瓣评分 6.9</li></ul><h3 id="京东技术丛书"><a href="#京东技术丛书" class="headerlink" title="京东技术丛书"></a>京东技术丛书</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ET1NkI" target="_blank" rel="noopener">《京东基础架构建设之路（全彩）》</a> - 豆瓣评分 6.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0OOBCc" target="_blank" rel="noopener">《京东系统质量保障技术实战》</a> - 豆瓣评分 6.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/V6tLFs" target="_blank" rel="noopener">《京东技术解密》</a> - 豆瓣评分 6.1</li></ul><h2 id="工具书"><a href="#工具书" class="headerlink" title="工具书"></a>工具书</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5U9zkK" target="_blank" rel="noopener">《Linux命令行与shell脚本编程大全（第3版）》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/28U5lx" target="_blank" rel="noopener">《阿里巴巴Java开发手册》</a> - 豆瓣评分 8.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/d5ADPR" target="_blank" rel="noopener">《SQL即查即用 （全彩版）》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VgrIgv" target="_blank" rel="noopener">《Linux命令速查手册（第三版）》</a></li></ul><h2 id="面试求职"><a href="#面试求职" class="headerlink" title="面试求职"></a>面试求职</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/IgfC55" target="_blank" rel="noopener">《剑指Offer：名企面试官精讲典型编程题（第2版）》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/E4WimD" target="_blank" rel="noopener">《编程之美：微软技术面试心得》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/UqcYlU" target="_blank" rel="noopener">《Java程序员面试笔试宝典》</a> - 豆瓣评分 7.6</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/tm79JE" target="_blank" rel="noopener">《Java程序员面试宝典（第4版）》</a> - 豆瓣评分 5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7ujWIz" target="_blank" rel="noopener">《编程之法：面试和算法心得》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/eE9uWg" target="_blank" rel="noopener">《Java程序员面试算法宝典》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Jc9Xlt" target="_blank" rel="noopener">《Java程序员面试笔试真题库》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VqoEj5" target="_blank" rel="noopener">《Java程序员面试笔试真题与解析》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pfIsU6" target="_blank" rel="noopener">《Java核心技术及面试指南》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/j0XMdh" target="_blank" rel="noopener">《解忧程序员：高薪编程、求职面试与成长转型宝典》</a></li></ul><h2 id="格局与视野"><a href="#格局与视野" class="headerlink" title="格局与视野"></a>格局与视野</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/bgG9yE" target="_blank" rel="noopener">《全球科技通史》</a> - 豆瓣评分 9.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/koCTxD" target="_blank" rel="noopener">《浪潮之巅 第三版 套装上下册》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/KbwmLQ" target="_blank" rel="noopener">《黑客与画家：硅谷创业之父Paul Graham文集 [Hackers and Painters Big Ldeas From the Computer Age]》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/EcKZym" target="_blank" rel="noopener">《软件随想录 卷1》</a> - 豆瓣评分 8.8</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/px8Sgu" target="_blank" rel="noopener">《软件随想录 卷2》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6jRwgY" target="_blank" rel="noopener">《编程人生：15位软件先驱访谈录》</a> - 豆瓣评分 8.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6Y4Mcd" target="_blank" rel="noopener">《大教堂与集市（最新版） [The Cathedral &amp; the Bazaar]》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/3yyV1D" target="_blank" rel="noopener">《硅谷之谜：浪潮之巅 续集》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/M7OrgY" target="_blank" rel="noopener">《原则 [Principles]》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/PxHueV" target="_blank" rel="noopener">《精益创业》</a> - 豆瓣评分 8.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/rdipjJ" target="_blank" rel="noopener">《态度：吴军博士新书》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/cP4xDs" target="_blank" rel="noopener">《见识》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oGJFTx" target="_blank" rel="noopener">《极限创新 35岁之前改变世界的全球科技精英》</a> - 豆瓣评分 7.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/FBINiB" target="_blank" rel="noopener">《大学的终结：泛在大学与高等教育革命》</a> - 豆瓣评分 7.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZfHw4B" target="_blank" rel="noopener">《未来版图 全球聪明公司的科技创新趋势和商业化路径》</a> - 豆瓣评分 7.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/cNCbEF" target="_blank" rel="noopener">《你好哇，程序员——漫话程序员面试求职、升职加薪、创业与生活》</a> - 豆瓣评分 6.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/S1ZQhz" target="_blank" rel="noopener">《图灵和ACM图灵奖（1966-2015 第五版） 纪念计算机诞生70周年》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/M3PkIU" target="_blank" rel="noopener">《文明之光（全彩印刷套装1-4册）入选2014中国好书/第六届中华优秀出版物获奖图书》</a></li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JHxmei" target="_blank" rel="noopener">《大师访谈录：成就非凡的软件人生》</a></li></ul><h2 id="Java之外"><a href="#Java之外" class="headerlink" title="Java之外"></a>Java之外</h2><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/RCgC9H" target="_blank" rel="noopener">《计算机科学丛书：计算机程序的构造和解释（原书第2版）》</a> - 豆瓣评分 9.5</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/URRIW5" target="_blank" rel="noopener">《计算机科学丛书：编译原理（第2版） [Compilers:Principle,Techniques and Tools]》</a> - 豆瓣评分 9.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fbemS8" target="_blank" rel="noopener">《一个APP的诞生——从零开始设计你的手机应用》</a> - 豆瓣评分 6.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/F4SUYQ" target="_blank" rel="noopener">《大型网站性能优化实战：从前端、网络、CDN到后端、大促的全链路性能优化详解》</a></li></ul><h3 id="网络知识"><a href="#网络知识" class="headerlink" title="网络知识"></a>网络知识</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/q3lNRK" target="_blank" rel="noopener">《图解HTTP》</a> - 豆瓣评分 8.1</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Ip1U7X" target="_blank" rel="noopener">《图解TCP/IP 第5版》</a> - 豆瓣评分 7.8</li></ul><h3 id="安全知识"><a href="#安全知识" class="headerlink" title="安全知识"></a>安全知识</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6oCOp8" target="_blank" rel="noopener">《白帽子讲Web安全（纪念版）》</a> - 豆瓣评分 7.4</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/gecmeS" target="_blank" rel="noopener">《Web安全攻防：渗透测试实战指南》</a></li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Fv9ksZ" target="_blank" rel="noopener">《Maven实战》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JvxLfz" target="_blank" rel="noopener">《大象：Thinking in UML（第2版）》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/x06AA6" target="_blank" rel="noopener">《Git学习指南》</a> - 豆瓣评分 6.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/W50GoO" target="_blank" rel="noopener">《UML基础、案例与应用（第3版 修订版）》</a></li></ul><h3 id="运维-amp-DevOps"><a href="#运维-amp-DevOps" class="headerlink" title="运维&amp;DevOps"></a>运维&amp;DevOps</h3><ul><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/3ejMcd" target="_blank" rel="noopener">《编码：隐匿在计算机软硬件背后的语言 [Code:The Hidden Language of Computer Hardware and Software]》</a> - 豆瓣评分 9.3</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pVBguN" target="_blank" rel="noopener">《DevOps实践指南》</a> - 豆瓣评分 9</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/RXZBkB" target="_blank" rel="noopener">《性能之巅：洞悉系统、企业与云计算》</a> - 豆瓣评分 8.7</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/kzDG88" target="_blank" rel="noopener">《鸟哥的Linux私房菜 基础学习篇 第四版》</a> - 豆瓣评分 8.2</li><li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Slnb59" target="_blank" rel="noopener">《DevOps开发运维训练营》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;转载原文：&lt;a href=&quot;https://github.com/sorenduan/awesome-java-books&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sorenduan/a
      
    
    </summary>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="转载" scheme="http://QQ876684433.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>后端架构师技术图谱</title>
    <link href="http://QQ876684433.github.io/2019/07/16/%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E5%B8%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/"/>
    <id>http://QQ876684433.github.io/2019/07/16/后端架构师技术图谱/</id>
    <published>2019-07-16T01:33:06.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载原文：<a href="https://github.com/xingshaocheng/architect-awesome" target="_blank" rel="noopener">https://github.com/xingshaocheng/architect-awesome</a></p></blockquote><p><b style="color:red">推荐:</b> <a href="https://github.com/sorenduan/awesome-java-books" target="_blank" rel="noopener">《Java技术书籍大全》 - awesome-java-books</a></p><p>从初级开发者到资深架构师，看这些书就够了</p><hr><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul><li><a href="https://www.cnblogs.com/lemon-flm/p/7877898.html" target="_blank" rel="noopener">《java队列——queue详细分析》</a><ul><li>非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</li><li>阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</li></ul></li><li><a href="https://www.cnblogs.com/mantu/p/5802393.html" target="_blank" rel="noopener">《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》</a></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li><a href="https://blog.csdn.net/qq_33642117/article/details/52040345" target="_blank" rel="noopener">《Java Set集合的详解》</a></li></ul><h2 id="链表、数组"><a href="#链表、数组" class="headerlink" title="链表、数组"></a>链表、数组</h2><ul><li><a href="https://blog.csdn.net/wz249863091/article/details/52853360" target="_blank" rel="noopener">《Java集合详解–什么是List》</a></li></ul><h2 id="字典、关联数组"><a href="#字典、关联数组" class="headerlink" title="字典、关联数组"></a>字典、关联数组</h2><ul><li><a href="https://baike.xsoftlab.net/view/250.html" target="_blank" rel="noopener">《Java map 详解 - 用法、遍历、排序、常用API等》</a></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li><a href="https://blog.csdn.net/javazejian/article/details/53362993" target="_blank" rel="noopener">《java数据结构与算法之栈（Stack）设计与实现》</a></li><li><a href="http://www.runoob.com/java/java-stack-class.html" target="_blank" rel="noopener">《Java Stack 类》</a></li><li><a href="https://blog.csdn.net/f2006116/article/details/51375225" target="_blank" rel="noopener">《java stack的详细实现分析》</a><ul><li>Stack 是线程安全的。</li><li>内部使用数组保存数据，不够时翻倍。</li></ul></li></ul><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>每个节点最多有两个叶子节点。</p><ul><li><a href="https://blog.csdn.net/cai2016/article/details/52589952" target="_blank" rel="noopener">《二叉树》</a></li></ul><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><ul><li><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin" target="_blank" rel="noopener">《完全二叉树》</a><ul><li>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</li></ul></li></ul><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><ul><li><a href="http://www.cnblogs.com/polly333/p/4798944.html" target="_blank" rel="noopener">《浅谈数据结构-平衡二叉树》</a></li><li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html" target="_blank" rel="noopener">《浅谈算法和数据结构: 八 平衡查找树之2-3树》</a></li></ul><h3 id="二叉查找树（BST）"><a href="#二叉查找树（BST）" class="headerlink" title="二叉查找树（BST）"></a>二叉查找树（BST）</h3><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</p><ul><li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html" target="_blank" rel="noopener">《浅谈算法和数据结构: 七 二叉查找树》</a></li></ul><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><ul><li><a href="https://blog.csdn.net/sun_tttt/article/details/65445754" target="_blank" rel="noopener">《最容易懂得红黑树》</a><ul><li>添加阶段后，左旋或者右旋从而再次达到平衡。 </li></ul></li><li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html" target="_blank" rel="noopener">《浅谈算法和数据结构: 九 平衡查找树之红黑树》</a></li></ul><h3 id="B，B-，B-树"><a href="#B，B-，B-树" class="headerlink" title="B，B+，B*树"></a>B，B+，B*树</h3><p>MySQL是基于B+树聚集索引组织表</p><ul><li><a href="https://blog.csdn.net/aqzwss/article/details/53074186" target="_blank" rel="noopener">《B-树，B+树，B*树详解》</a></li><li><a href="https://blog.csdn.net/bigtree_3721/article/details/73632405" target="_blank" rel="noopener">《B-树，B+树与B*树的优缺点比较》</a><ul><li>B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。</li></ul></li></ul><h3 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h3><p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。<br>Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</p><ul><li><a href="https://blog.csdn.net/dbanote/article/details/8897599" target="_blank" rel="noopener">《LSM树 VS B+树》</a><ul><li>B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。</li><li>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</li></ul></li><li><a href="https://blog.csdn.net/u014774781/article/details/52105708" target="_blank" rel="noopener">《LSM树（Log-Structured Merge Tree）存储引擎》</a><ul><li>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</li><li>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</li><li>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</li></ul></li></ul><h2 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h2><p>经常用于大规模数据的排重检查。</p><ul><li><a href="http://www.runoob.com/java/java-bitset-class.html" target="_blank" rel="noopener">《Java Bitset类》</a></li><li><a href="https://blog.csdn.net/caiandyong/article/details/51581160" target="_blank" rel="noopener">《Java BitSet（位集）》</a></li></ul><h1 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h1><ul><li><a href="https://blog.csdn.net/gane_cheng/article/details/52652705" target="_blank" rel="noopener">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li></ul><h2 id="排序、查找算法"><a href="#排序、查找算法" class="headerlink" title="排序、查找算法"></a>排序、查找算法</h2><ul><li><a href="https://blog.csdn.net/gane_cheng/article/details/52652705" target="_blank" rel="noopener">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li><a href="https://www.cnblogs.com/shen-hua/p/5424059.html" target="_blank" rel="noopener">《Java中的经典算法之选择排序（SelectionSort）》</a><ul><li>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</li></ul></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul><li><a href="https://blog.csdn.net/shuaizai88/article/details/73250615" target="_blank" rel="noopener">《冒泡排序的2种写法》</a><ul><li>相邻元素前后交换、把最大的排到最后。</li><li>时间复杂度 O(n²) </li></ul></li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul><li><a href="https://www.cnblogs.com/hapjin/p/5517667.html" target="_blank" rel="noopener">《排序算法总结之插入排序》</a></li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li><a href="http://developer.51cto.com/art/201403/430986.htm" target="_blank" rel="noopener">《坐在马桶上看算法：快速排序》</a><ul><li>一侧比另外一侧都大或小。 </li></ul></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><a href="http://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">《图解排序算法(四)之归并排序》</a><ul><li>分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 </li></ul></li></ul><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>TODO</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">《图解排序算法(三)之堆排序》</a><ul><li>排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。</li></ul></li></ul><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><ul><li><a href="https://www.cnblogs.com/suvllian/p/5495780.html" target="_blank" rel="noopener">《计数排序和桶排序》</a><ul><li>和桶排序过程比较像，差别在于桶的数量。</li></ul></li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><ul><li><a href="http://blog.51cto.com/ahalei/1362789" target="_blank" rel="noopener">《【啊哈！算法】最快最简单的排序——桶排序》</a></li><li><a href="https://blog.csdn.net/sunjinshengli/article/details/70738527" target="_blank" rel="noopener">《排序算法（三）：计数排序与桶排序》</a><ul><li>桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。</li><li>每个桶单独进行排序，然后再遍历每个桶。</li></ul></li></ul><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>按照个位、十位、百位、…依次来排。</p><ul><li><a href="https://blog.csdn.net/lemon_tree12138/article/details/51695211" target="_blank" rel="noopener">《排序算法系列：基数排序》</a></li><li><a href="https://www.cnblogs.com/skywang12345/p/3603669.html" target="_blank" rel="noopener">《基数排序》</a></li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li><a href="https://www.cnblogs.com/coderising/p/5708632.html" target="_blank" rel="noopener">《二分查找(java实现)》</a><ul><li>要求待查找的序列有序。</li><li>时间复杂度 O(logN)。</li></ul></li><li><a href="https://blog.csdn.net/maoyuanming0806/article/details/78176957" target="_blank" rel="noopener">《java实现二分查找-两种方式》</a><ul><li>while + 递归。</li></ul></li></ul><h3 id="Java-中的排序工具"><a href="#Java-中的排序工具" class="headerlink" title="Java 中的排序工具"></a>Java 中的排序工具</h3><ul><li><a href="https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1" target="_blank" rel="noopener">《Arrays.sort和Collections.sort实现原理解析》</a><ul><li>Collections.sort算法调用的是合并排序。</li><li>Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。</li></ul></li></ul><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>常用于大数据的排重，比如email，url 等。<br>核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。<br>优点：空间和时间效率都很高。<br>缺点：随着存入的元素数量增加，误算率随之增加。</p><ul><li><a href="https://segmentfault.com/a/1190000002729689" target="_blank" rel="noopener">《布隆过滤器 – 空间效率很高的数据结构》</a></li><li><a href="https://blog.csdn.net/zdxiq000/article/details/57626464" target="_blank" rel="noopener">《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》</a></li><li><a href="https://blog.csdn.net/qq_30242609/article/details/71024458" target="_blank" rel="noopener">《基于Redis的布隆过滤器的实现》</a><ul><li>基于 Redis 的 Bitmap 数据结构。</li></ul></li><li><a href="https://blog.csdn.net/lemon_tree12138/article/details/47973715" target="_blank" rel="noopener">《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》</a><ul><li>使用Java中的 BitSet 类 和 加权和hash算法。</li></ul></li></ul><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><p>KMP：Knuth-Morris-Pratt算法（简称KMP）<br>核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</p><ul><li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">《字符串匹配的KMP算法》</a></li></ul><h2 id="深度优先、广度优先"><a href="#深度优先、广度优先" class="headerlink" title="深度优先、广度优先"></a>深度优先、广度优先</h2><ul><li><a href="https://www.cnblogs.com/0kk470/p/7555033.html" target="_blank" rel="noopener">《广度优先搜索BFS和深度优先搜索DFS》</a></li></ul><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ul><li><a href="https://www.cnblogs.com/MrSaver/p/8641971.html" target="_blank" rel="noopener">《算法：贪婪算法基础》</a></li><li><a href="https://blog.csdn.net/a345017062/article/details/52443781" target="_blank" rel="noopener">《常见算法及问题场景——贪心算法》</a></li></ul><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><ul><li><a href="https://blog.csdn.net/qfikh/article/details/51960331" target="_blank" rel="noopener">《 五大常用算法之四：回溯法》</a></li></ul><h2 id="剪枝算法"><a href="#剪枝算法" class="headerlink" title="剪枝算法"></a>剪枝算法</h2><ul><li><a href="https://blog.csdn.net/luningcsdn/article/details/50930276" target="_blank" rel="noopener">《α-β剪枝算法》</a></li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><a href="https://www.cnblogs.com/little-YTMM/p/5372680.html" target="_blank" rel="noopener">《详解动态规划——邹博讲动态规划》</a></li><li><a href="https://blog.csdn.net/yao_zi_jie/article/details/54580283" target="_blank" rel="noopener">《动态规划算法的个人理解》</a></li></ul><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><ul><li><a href="https://blog.csdn.net/amds123/article/details/70173402" target="_blank" rel="noopener">《带你搞懂朴素贝叶斯分类算法》</a><ul><li>P(B|A)=P(A|B)P(B)/P(A)</li></ul></li><li><a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html" target="_blank" rel="noopener">《贝叶斯推断及其互联网应用1》</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html" target="_blank" rel="noopener">《贝叶斯推断及其互联网应用2》</a></li></ul><h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h2><ul><li><a href="http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01" target="_blank" rel="noopener">《推荐算法综述》</a></li><li><a href="https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems" target="_blank" rel="noopener">《TOP 10 开源的推荐系统简介》</a></li></ul><h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><ul><li><a href="https://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">《算法导论–最小生成树（Kruskal和Prim算法）》</a></li></ul><h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><ul><li><a href="https://blog.csdn.net/qq_35644234/article/details/60870719" target="_blank" rel="noopener">《Dijkstra算法详解》</a></li></ul><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h2><ul><li><a href="https://github.com/CL0610/Java-concurrency" target="_blank" rel="noopener">Java 并发知识合集</a></li><li><a href="https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png" target="_blank" rel="noopener">JAVA并发知识图谱</a></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li><a href="http://www.importnew.com/18459.html" target="_blank" rel="noopener">《40个Java多线程问题总结》</a></li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul><li><a href="https://www.cnblogs.com/zhanht/p/5450325.html" target="_blank" rel="noopener">《Java并发编程——线程安全及解决机制简介》</a></li></ul><h2 id="一致性、事务"><a href="#一致性、事务" class="headerlink" title="一致性、事务"></a>一致性、事务</h2><h3 id="事务-ACID-特性"><a href="#事务-ACID-特性" class="headerlink" title="事务 ACID 特性"></a>事务 ACID 特性</h3><ul><li><a href="https://blog.csdn.net/u012440687/article/details/52116108" target="_blank" rel="noopener">《数据库事务ACID特性》</a></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</li><li>读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</li><li>可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</li><li>序列化：所有事物串行处理（牺牲了效率）</li><li><a href="https://blog.csdn.net/qq_33290787/article/details/51924963" target="_blank" rel="noopener">《理解事务的4种隔离级别》</a></li><li><a href="https://www.cnblogs.com/z-sm/p/7245981.html" target="_blank" rel="noopener">数据库事务的四大特性及事务隔离级别</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html" target="_blank" rel="noopener">《MySQL的InnoDB的幻读问题 》</a><ul><li>幻读的例子非常清楚。</li><li>通过 SELECT … FOR UPDATE 解决。</li></ul></li><li><a href="https://draveness.me/mysql-innodb" target="_blank" rel="noopener">《一篇文章带你读懂MySQL和InnoDB》</a><ul><li>图解脏读、不可重复读、幻读问题。</li></ul></li></ul><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><ul><li><a href="https://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">《【mysql】关于innodb中MVCC的一些理解》</a><ul><li>innodb 中 MVCC 用在 Repeatable-Read 隔离级别。</li><li>MVCC 会产生幻读问题（更新时异常。）</li></ul></li><li><a href="https://blog.csdn.net/whoamiyang/article/details/51901888" target="_blank" rel="noopener">《轻松理解MYSQL MVCC 实现机制》</a><ul><li>通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间</li><li>每次只操作比当前版本小（或等于）的 行。</li></ul></li></ul><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="Java中的锁和同步类"><a href="#Java中的锁和同步类" class="headerlink" title="Java中的锁和同步类"></a>Java中的锁和同步类</h3><ul><li><a href="https://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">《Java中的锁分类》</a><ul><li>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 </li></ul></li><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">《Java并发之AQS详解》</a></li><li><a href="http://cuisuqiang.iteye.com/blog/2020146" target="_blank" rel="noopener">《Java中信号量 Semaphore》</a><ul><li>有数量控制</li><li>申请用 acquire，申请不要则阻塞；释放用 release。</li></ul></li><li><a href="https://www.cnblogs.com/davidwang456/p/6094947.html" target="_blank" rel="noopener">《java开发中的Mutex vs Semaphore》</a><ul><li>简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。     </li></ul></li></ul><h3 id="公平锁-amp-非公平锁"><a href="#公平锁-amp-非公平锁" class="headerlink" title="公平锁 &amp; 非公平锁"></a>公平锁 &amp; 非公平锁</h3><p>公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。</p><ul><li><a href="https://blog.csdn.net/EthanWhite/article/details/55508357" target="_blank" rel="noopener">《公平锁与非公平锁》</a><ul><li>默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。</li></ul></li></ul><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。</p><ul><li><a href="https://www.cnblogs.com/zhiqian-ali/p/6200874.html" target="_blank" rel="noopener">《【MySQL】悲观锁&amp;乐观锁》</a><ul><li>乐观锁的方式：版本号+重试方式</li><li>悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。</li></ul></li><li><a href="https://www.cnblogs.com/Lawson/p/5008741.html" target="_blank" rel="noopener">《Mysql查询语句使用select.. for update导致的数据库死锁分析》</a><ul><li>mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。</li><li>锁相同数据的不同索引条件可能会引起死锁。</li></ul></li><li><a href="https://www.cnblogs.com/zejin2008/p/5262751.html" target="_blank" rel="noopener">《Mysql并发时经典常见的死锁原因及解决方法》</a></li></ul><h3 id="乐观锁-amp-CAS"><a href="#乐观锁-amp-CAS" class="headerlink" title="乐观锁 &amp; CAS"></a>乐观锁 &amp; CAS</h3><ul><li><a href="http://www.importnew.com/20472.html" target="_blank" rel="noopener">《乐观锁的一种实现方式——CAS》</a><ul><li>和MySQL乐观锁方式相似，只不过是通过和原值进行比较。     </li></ul></li></ul><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。</p><ul><li><a href="https://www.cnblogs.com/549294286/p/3766717.html" target="_blank" rel="noopener">《Java CAS 和ABA问题》</a></li><li><a href="https://blog.csdn.net/li954644351/article/details/50511879" target="_blank" rel="noopener">《Java 中 ABA问题及避免》</a><ul><li>AtomicStampedReference 和 AtomicStampedReference。 </li></ul></li></ul><h3 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h3><p>可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p><ul><li><a href="https://www.cnblogs.com/hapjin/p/4840107.html" target="_blank" rel="noopener">《JAVA中写时复制(Copy-On-Write)Map实现》</a><ul><li>实现读写分离，读取发生在原始数据上，写入发生在副本上。  </li><li>不用加锁，通过最终一致实现一致性。</li></ul></li><li><a href="https://blog.csdn.net/a494303877/article/details/53404623" target="_blank" rel="noopener">《聊聊并发-Java中的Copy-On-Write容器》</a></li></ul><h3 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h3><ul><li><a href="http://www.cnblogs.com/l00l/p/4115001.html" target="_blank" rel="noopener">《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》</a></li></ul><h3 id="可重入锁-amp-不可重入锁"><a href="#可重入锁-amp-不可重入锁" class="headerlink" title="可重入锁 &amp; 不可重入锁"></a>可重入锁 &amp; 不可重入锁</h3><ul><li><a href="https://www.cnblogs.com/dj3839/p/6580765.html" target="_blank" rel="noopener">《可重入锁和不可重入锁》</a><ul><li>通过简单代码举例说明可重入锁和不可重入锁。</li><li>可重入锁指同一个线程可以再次获得之前已经获得的锁。</li><li>可重入锁可以用户避免死锁。</li><li>Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</li></ul></li><li><a href="https://www.cnblogs.com/baizhanshi/p/7211802.html" target="_blank" rel="noopener">《ReenTrantLock可重入锁（和synchronized的区别）总结》</a><ul><li>synchronized 使用方便，编译器来加锁，是非公平锁。</li><li>ReenTrantLock 使用灵活，锁的公平性可以定制。</li><li>相同加锁场景下，推荐使用 synchronized。</li></ul></li></ul><h3 id="互斥锁-amp-共享锁"><a href="#互斥锁-amp-共享锁" class="headerlink" title="互斥锁 &amp; 共享锁"></a>互斥锁 &amp; 共享锁</h3><p>互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。<br>共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。</p><ul><li><a href="https://www.cnblogs.com/liang1101/p/6475555.html" target="_blank" rel="noopener">《ReadWriteLock场景应用》</a></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li><a href="https://blog.csdn.net/yunfenglw/article/details/45950305" target="_blank" rel="noopener">《“死锁”四个必要条件的合理解释》</a><ul><li>互斥、持有、不可剥夺、环形等待。</li></ul></li><li><a href="https://blog.csdn.net/u014039577/article/details/52351626" target="_blank" rel="noopener">Java如何查看死锁？</a><ul><li>JConsole 可以识别死锁。</li></ul></li><li><a href="https://blog.csdn.net/bohu83/article/details/51135061" target="_blank" rel="noopener">java多线程系列：死锁及检测</a><ul><li>jstack 可以显示死锁。</li></ul></li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><ul><li><a href="https://segmentfault.com/a/1190000003692840" target="_blank" rel="noopener">《操作系统基础知识——操作系统的原理，类型和结构》</a></li></ul><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。</p><ul><li><a href="https://blog.csdn.net/zero__007/article/details/54089730" target="_blank" rel="noopener">《从Java视角理解CPU缓存和伪共享》</a></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>TODO</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li><a href="https://blog.csdn.net/asdf_1024/article/details/78978437" target="_blank" rel="noopener">《线程的生命周期及状态转换详解》</a></li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul><li><a href="https://www.thinksaas.cn/group/topic/839375/" target="_blank" rel="noopener">《终结python协程—-从yield到actor模型的实现》</a><ul><li>线程的调度是由操作系统负责，协程调度是程序自行负责</li><li>与线程相比，协程减少了无谓的操作系统切换.</li><li>实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.</li></ul></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li><a href="http://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">《Linux 命令大全》</a></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><ul><li><a href="https://blog.csdn.net/q291611265/article/details/48465113" target="_blank" rel="noopener">《设计模式的六大原则》</a><ul><li>开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li><li>里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li><li>依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li><li>接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li><li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li><li>合成复用原则：尽量使用合成/聚合,而不是使用继承。</li></ul></li></ul><h2 id="23种常见设计模式"><a href="#23种常见设计模式" class="headerlink" title="23种常见设计模式"></a>23种常见设计模式</h2><ul><li><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">《设计模式》</a></li><li><a href="https://www.cnblogs.com/susanws/p/5510229.html" target="_blank" rel="noopener">《23种设计模式全解析》</a></li><li><a href="https://github.com/ToryZhou/design-pattern" target="_blank" rel="noopener">《设计模式类图与示例》</a></li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li><a href="http://blog.jobbole.com/62314/" target="_blank" rel="noopener">《细数JDK里的设计模式》</a><ul><li>结构型模式：<ul><li>适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。</li><li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li><li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。</li><li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li><li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li><li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy</li></ul></li><li>创建模式:<ul><li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。</li><li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li><li>工厂方法：就是 <strong>一个返*</strong> 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li><li>原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。</li><li>单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。</li></ul></li><li>行为模式：<ul><li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。</li><li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。</li><li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。</li><li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。</li><li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。</li><li>空对象模式：如 java.util.Collections#emptyList()。</li><li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。</li><li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。</li></ul></li></ul></li><li><a href="https://www.cnblogs.com/hwaggLee/p/4510687.html" target="_blank" rel="noopener">《Spring-涉及到的设计模式汇总》</a></li><li><a href="https://blog.csdn.net/u012387062/article/details/54719114" target="_blank" rel="noopener">《Mybatis使用的设计模式》</a></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li><a href="https://blog.csdn.net/YECrazy/article/details/79481964" target="_blank" rel="noopener">《单例模式的三种实现 以及各自的优缺点》</a></li><li><a href="https://www.cnblogs.com/ttylinux/p/6498822.html" target="_blank" rel="noopener">《单例模式－－反射－－防止序列化破坏单例模式》</a><ul><li>使用枚举类型。</li></ul></li></ul><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>TODO</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><ul><li><a href="http://www.runoob.com/design-pattern/mvc-pattern.html" target="_blank" rel="noopener">《MVC 模式》</a><ul><li>模型(model)－视图(view)－控制器(controller) </li></ul></li></ul><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><ul><li><a href="https://www.zhihu.com/question/23277575" target="_blank" rel="noopener">《理解 IOC》</a></li><li><a href="https://www.cnblogs.com/NancyStartOnce/p/6813162.html" target="_blank" rel="noopener">《IOC 的理解与解释》</a><ul><li>正向控制：传统通过new的方式。反向控制，通过容器注入对象。</li><li>作用：用于模块解耦。</li><li>DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。</li></ul></li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ul><li><a href="https://blog.csdn.net/yanquan345/article/details/19760027" target="_blank" rel="noopener">《轻松理解AOP(面向切面编程)》</a></li><li><a href="https://www.cnblogs.com/hongwz/p/5764917.html" target="_blank" rel="noopener">《Spring AOP详解》</a></li><li><a href="http://www.importnew.com/24305.html" target="_blank" rel="noopener">《Spring AOP的实现原理》</a><ul><li>Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。</li></ul></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="noopener">《Spring AOP 实现原理与 CGLIB 应用》</a><ul><li>Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 </li></ul></li></ul><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><ul><li><a href="https://www.w3cschool.cn/uml_tutorial/" target="_blank" rel="noopener">《UML教程》</a></li></ul><h2 id="微服务思想"><a href="#微服务思想" class="headerlink" title="微服务思想"></a>微服务思想</h2><ul><li><a href="https://www.cnblogs.com/wintersun/p/6219259.html" target="_blank" rel="noopener">《微服务架构设计》</a></li><li><a href="http://www.infoq.com/cn/articles/micro-service-technology-stack" target="_blank" rel="noopener">《微服务架构技术栈选型手册》</a></li></ul><h3 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h3><ul><li><a href="https://yq.aliyun.com/articles/8611" target="_blank" rel="noopener">《微服务架构的理论基础 - 康威定律》</a><ul><li>定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。</li><li>定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。</li><li>定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。</li><li>定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。</li></ul></li><li><a href="https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf" target="_blank" rel="noopener">《微服务架构核⼼20讲》</a></li></ul><h1 id="运维-amp-统计-amp-技术支持"><a href="#运维-amp-统计-amp-技术支持" class="headerlink" title="运维 &amp; 统计 &amp; 技术支持"></a>运维 &amp; 统计 &amp; 技术支持</h1><h2 id="常规监控"><a href="#常规监控" class="headerlink" title="常规监控"></a>常规监控</h2><ul><li><a href="https://blog.csdn.net/enweitech/article/details/77849205" target="_blank" rel="noopener">《腾讯业务系统监控的修炼之路》</a><ul><li>监控的方式：主动、被动、旁路(比如舆情监控)</li><li>监控类型： 基础监控、服务端监控、客户端监控、<br>监控、用户端监控</li><li>监控的目标：全、块、准</li><li>核心指标：请求量、成功率、耗时</li></ul></li><li><a href="https://www.oschina.net/news/67525/monitoring-tools" target="_blank" rel="noopener">《开源还是商用？十大云运维监控工具横评》</a><ul><li>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</li></ul></li><li><a href="http://developer.51cto.com/art/201612/525373.htm" target="_blank" rel="noopener">《监控报警系统搭建及二次开发经验》</a></li></ul><p><strong>命令行监控工具</strong></p><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html" target="_blank" rel="noopener">《常用命令行监控工具》</a><ul><li>top、sar、tsar、nload</li></ul></li><li><a href="http://blog.jobbole.com/96846/" target="_blank" rel="noopener">《20个命令行工具监控 Linux 系统性能》</a></li><li><a href="https://my.oschina.net/feichexia/blog/196575" target="_blank" rel="noopener">《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》</a></li></ul><h2 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h2><p>APM —  Application Performance Management</p><ul><li><a href="http://bigbully.github.io/Dapper-translation/" target="_blank" rel="noopener">《Dapper，大规模分布式系统的跟踪系统》</a></li><li><a href="http://opentracing.io" target="_blank" rel="noopener">CNCF OpenTracing</a>，<a href="https://github.com/opentracing-contrib/opentracing-specification-zh" target="_blank" rel="noopener">中文版</a></li><li>主要开源软件，按字母排序<ul><li><a href="https://github.com/apache/incubator-skywalking" target="_blank" rel="noopener">Apache SkyWalking</a></li><li><a href="https://github.com/dianping/cat" target="_blank" rel="noopener">CAT</a></li><li><a href="https://github.com/jaegertracing/jaeger" target="_blank" rel="noopener">CNCF jaeger</a></li><li><a href="https://github.com/naver/pinpoint" target="_blank" rel="noopener">Pinpoint</a></li><li><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">Zipkin</a></li></ul></li><li><a href="http://www.infoq.com/cn/articles/apm-Pinpoint-practice" target="_blank" rel="noopener">《开源APM技术选型与实战》</a><ul><li>主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。</li></ul></li></ul><h2 id="统计分析"><a href="#统计分析" class="headerlink" title="统计分析"></a>统计分析</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/25195217" target="_blank" rel="noopener">《流量统计的基础：埋点》</a><ul><li>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</li></ul></li><li><a href="http://www.25xt.com/company/17066.html" target="_blank" rel="noopener">《APP埋点常用的统计工具、埋点目标和埋点内容》</a><ul><li>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</li></ul></li><li><a href="https://tech.meituan.com/mt_mobile_analytics_practice.html" target="_blank" rel="noopener">《美团点评前端无痕埋点实践》</a><ul><li>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 </li></ul></li></ul><h2 id="持续集成-CI-CD"><a href="#持续集成-CI-CD" class="headerlink" title="持续集成(CI/CD)"></a>持续集成(CI/CD)</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">《持续集成是什么？》</a></li><li><a href="https://www.testwo.com/article/1170" target="_blank" rel="noopener">《8个流行的持续集成工具》</a></li></ul><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><ul><li><a href="https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000" target="_blank" rel="noopener">《使用Jenkins进行持续集成》</a></li></ul><h3 id="环境分离"><a href="#环境分离" class="headerlink" title="环境分离"></a>环境分离</h3><p>开发、测试、生成环境分离。</p><ul><li><a href="https://my.oschina.net/sancuo/blog/214904" target="_blank" rel="noopener">《开发环境、生产环境、测试环境的基本理解和区》</a></li></ul><h2 id="自动化运维"><a href="#自动化运维" class="headerlink" title="自动化运维"></a>自动化运维</h2><h3 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h3><ul><li><a href="http://www.ansible.com.cn/" target="_blank" rel="noopener">《Ansible中文权威指南》</a></li><li><a href="https://www.cnblogs.com/heiye123/articles/7855890.html" target="_blank" rel="noopener">《Ansible基础配置和企业级项目实用案例》</a></li></ul><h3 id="puppet"><a href="#puppet" class="headerlink" title="puppet"></a>puppet</h3><ul><li><a href="https://www.cnblogs.com/keerya/p/8040071.html" target="_blank" rel="noopener">《自动化运维工具——puppet详解》</a></li></ul><h3 id="chef"><a href="#chef" class="headerlink" title="chef"></a>chef</h3><ul><li><a href="https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/" target="_blank" rel="noopener">《Chef 的安装与使用》</a></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="TDD-理论"><a href="#TDD-理论" class="headerlink" title="TDD 理论"></a>TDD 理论</h3><ul><li><a href="https://www.jianshu.com/p/62f16cd4fef3" target="_blank" rel="noopener">《深度解读 - TDD（测试驱动开发）》</a><ul><li>基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li><li>好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； </li></ul></li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li><a href="https://www.cnblogs.com/happyzm/p/6482886.html" target="_blank" rel="noopener">《Java单元测试之JUnit篇》</a></li><li><a href="https://blog.csdn.net/hotdust/article/details/53406086" target="_blank" rel="noopener">《JUnit 4 与 TestNG 对比》</a><ul><li>TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 </li></ul></li><li><a href="https://blog.csdn.net/wqetfg/article/details/50900512" target="_blank" rel="noopener">《单元测试主要的测试功能点》</a><ul><li>模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 </li></ul></li></ul><h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><ul><li><a href="https://blog.csdn.net/blueheart20/article/details/52170790" target="_blank" rel="noopener">《Apache ab 测试使用指南》</a></li><li><a href="https://www.cnblogs.com/binyue/p/6141088.html" target="_blank" rel="noopener">《大型网站压力测试及优化方案》</a></li><li><a href="http://news.chinabyte.com/466/14126966.shtml" target="_blank" rel="noopener">《10大主流压力/负载/性能测试工具推荐》</a></li><li><a href="http://quentinxxz.iteye.com/blog/2249799" target="_blank" rel="noopener">《真实流量压测工具 tcpcopy应用浅析》</a></li><li><a href="https://www.cnblogs.com/jwentest/p/7136727.html" target="_blank" rel="noopener">《nGrinder 简易使用教程》</a></li></ul><h3 id="全链路压测"><a href="#全链路压测" class="headerlink" title="全链路压测"></a>全链路压测</h3><ul><li><a href="http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot" target="_blank" rel="noopener">《京东618：升级全链路压测方案，打造军演机器人ForceBot》</a></li><li><a href="https://zhuanlan.zhihu.com/p/30306892" target="_blank" rel="noopener">《饿了么全链路压测的探索与实践》</a></li><li><a href="https://zhuanlan.zhihu.com/p/28355759" target="_blank" rel="noopener">《四大语言，八大框架｜滴滴全链路压测解决之道》</a></li><li><a href="https://www.jianshu.com/p/27060fd61f72" target="_blank" rel="noopener">《全链路压测经验》</a></li></ul><h3 id="A-B-、灰度、蓝绿测试"><a href="#A-B-、灰度、蓝绿测试" class="headerlink" title="A/B 、灰度、蓝绿测试"></a>A/B 、灰度、蓝绿测试</h3><ul><li><a href="https://testerhome.com/topics/11165" target="_blank" rel="noopener">《技术干货 | AB 测试和灰度发布探索及实践》</a></li><li><a href="http://blog.51cto.com/purplegrape/1403123" target="_blank" rel="noopener">《nginx 根据IP 进行灰度发布》</a></li><li><a href="https://www.v2ex.com/t/344341" target="_blank" rel="noopener">《蓝绿部署、A/B 测试以及灰度发布》</a></li></ul><h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><ul><li><a href="https://blog.csdn.net/enweitech/article/details/52910082" target="_blank" rel="noopener">《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》</a></li></ul><h3 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h3><ul><li><a href="http://blog.chinaunix.net/uid-20201831-id-5775661.html" target="_blank" rel="noopener">《KVM详解，太详细太深入了，经典》</a></li><li><a href="https://www.coderxing.com/kvm-install.html" target="_blank" rel="noopener">《【图文】KVM 虚拟机安装详解》</a></li></ul><h3 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a>Xen</h3><ul><li><a href="https://www.cnblogs.com/sddai/p/5931201.html" target="_blank" rel="noopener">《Xen虚拟化基本原理详解》</a></li></ul><h3 id="OpenVZ"><a href="#OpenVZ" class="headerlink" title="OpenVZ"></a>OpenVZ</h3><ul><li><a href="https://blog.csdn.net/longerzone/article/details/44829255" target="_blank" rel="noopener">《开源Linux容器 OpenVZ 快速上手指南》</a></li></ul><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li><a href="https://www.cnblogs.com/SzeCheng/p/6822905.html" target="_blank" rel="noopener">《几张图帮你理解 docker 基本原理及快速入门》</a></li><li><a href="https://draveness.me/docker" target="_blank" rel="noopener">《Docker 核心技术与实现原理》</a></li><li><a href="http://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">《Docker 教程》</a></li></ul><h2 id="云技术"><a href="#云技术" class="headerlink" title="云技术"></a>云技术</h2><h3 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h3><ul><li><a href="https://www.cnblogs.com/klb561/p/8660264.html" target="_blank" rel="noopener">《OpenStack构架知识梳理》</a></li></ul><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><ul><li><a href="https://www.cnblogs.com/jetzhang/p/6068773.html" target="_blank" rel="noopener">《一分钟告诉你究竟DevOps是什么鬼？》</a></li><li><a href="http://www.infoq.com/cn/articles/detail-analysis-of-devops" target="_blank" rel="noopener">《DevOps详解》</a></li></ul><h2 id="文档管理"><a href="#文档管理" class="headerlink" title="文档管理"></a>文档管理</h2><ul><li><a href="http://www.confluence.cn/" target="_blank" rel="noopener">Confluence-收费文档管理系统</a></li><li>GitLab?</li><li>Wiki</li></ul><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul><li><a href="https://blog.csdn.net/qq_25797077/article/details/52200722" target="_blank" rel="noopener">《Ngnix的基本学习-多进程和Apache的比较》</a><ul><li>Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。</li><li>事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  </li></ul></li><li><a href="https://www.cnblogs.com/cunkouzh/p/5410154.html" target="_blank" rel="noopener">《nginx与Apache的对比以及优缺点》</a><ul><li>nginx只适合静态和反向代理，不适合处理动态请求。</li></ul></li></ul><h3 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h3><ul><li><a href="http://openresty.org/cn/" target="_blank" rel="noopener">官方网站</a></li><li><a href="http://www.linkedkeeper.com/detail/blog.action?bid=1034" target="_blank" rel="noopener">《浅谈 OpenResty》</a><ul><li>通过 Lua 模块可以在Nginx上进行开发。   </li></ul></li><li><a href="https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html" target="_blank" rel="noopener">agentzh 的 Nginx 教程</a>  </li></ul><h3 id="Tengine"><a href="#Tengine" class="headerlink" title="Tengine"></a>Tengine</h3><ul><li><a href="http://tengine.taobao.org/" target="_blank" rel="noopener">官方网站</a>  </li></ul><h3 id="Apache-Httpd"><a href="#Apache-Httpd" class="headerlink" title="Apache Httpd"></a>Apache Httpd</h3><ul><li><a href="http://httpd.apache.org/" target="_blank" rel="noopener">官方网站</a></li></ul><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><h4 id="架构原理"><a href="#架构原理" class="headerlink" title="架构原理"></a>架构原理</h4><ul><li><a href="https://www.cnblogs.com/hggen/p/6264475.html" target="_blank" rel="noopener">《TOMCAT原理详解及请求过程》</a></li><li><a href="https://www.cnblogs.com/crazylqy/p/4706223.html" target="_blank" rel="noopener">《Tomcat服务器原理详解》</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/" target="_blank" rel="noopener">《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》</a></li><li><a href="https://blog.csdn.net/xlgen157387/article/details/79006434" target="_blank" rel="noopener">《四张图带你了解Tomcat系统架构》</a></li><li><a href="https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/" target="_blank" rel="noopener">《JBoss vs. Tomcat: Choosing A Java Application Server》</a><ul><li>Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。</li><li>Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li></ul></li></ul><h4 id="调优方案"><a href="#调优方案" class="headerlink" title="调优方案"></a>调优方案</h4><ul><li><a href="https://www.cnblogs.com/sunfenqing/p/7339058.html" target="_blank" rel="noopener">《Tomcat 调优方案》</a><ul><li>启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； </li></ul></li><li><a href="http://blog.chinaunix.net/uid-20662363-id-3012760.html" target="_blank" rel="noopener">《tomcat http协议与ajp协议》</a></li><li><a href="http://dmouse.iteye.com/blog/1354527" target="_blank" rel="noopener">《AJP与HTTP比较和分析》</a><ul><li>AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li><li>并发高时，AJP协议优于HTTP协议。</li></ul></li></ul><h3 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h3><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jetty/" target="_blank" rel="noopener">《Jetty 的工作原理以及与 Tomcat 的比较》</a></li><li><a href="https://blog.csdn.net/doutao6677/article/details/51957288" target="_blank" rel="noopener">《jetty和tomcat优势比较》</a><ul><li>架构比较:Jetty的架构比Tomcat的更为简单。</li><li>性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。</li><li>其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 </li></ul></li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li><a href="https://blog.csdn.net/clementad/article/details/48229243" target="_blank" rel="noopener">《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》</a></li></ul><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><ul><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html" target="_blank" rel="noopener">《HashMap本地缓存》</a></p></li><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html" target="_blank" rel="noopener">《EhCache本地缓存》</a></p><ul><li>堆内、堆外、磁盘三级缓存。</li><li>可按照缓存空间容量进行设置。</li><li>按照时间、次数等过期策略。</li></ul></li><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html" target="_blank" rel="noopener">《Guava Cache》</a></p><ul><li>简单轻量、无堆外、磁盘缓存。</li></ul></li><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html" target="_blank" rel="noopener">《Nginx本地缓存》</a></p></li><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html" target="_blank" rel="noopener">《Pagespeed—懒人工具，服务器端加速》</a></p></li></ul><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html" target="_blank" rel="noopener">《浏览器端缓存》</a><ul><li>主要是利用 Cache-Control 参数。</li></ul></li><li><a href="https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w" target="_blank" rel="noopener">《H5 和移动端 WebView 缓存机制解析与实战》</a></li></ul><h2 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h2><h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><ul><li><a href="https://github.com/jiangwenyuan/nuster" target="_blank" rel="noopener">nuster</a> - nuster cache</li><li><a href="https://github.com/varnishcache/varnish-cache" target="_blank" rel="noopener">varnish</a> - varnish cache</li><li><a href="https://github.com/squid-cache/squid" target="_blank" rel="noopener">squid</a> - squid cache</li></ul><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><ul><li><a href="http://www.runoob.com/Memcached/Memcached-tutorial.html" target="_blank" rel="noopener">《Memcached 教程》</a></li><li><a href="https://blog.csdn.net/chenleixing/article/details/47035453" target="_blank" rel="noopener">《深入理解Memcached原理》</a><ul><li>采用多路复用技术提高并发性。</li><li>slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。</li></ul></li><li><a href="https://www.jianshu.com/p/36e5cd400580" target="_blank" rel="noopener">《Memcached软件工作原理》</a></li><li><a href="http://zhihuzeye.com/archives/2361" target="_blank" rel="noopener">《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》</a></li><li><a href="https://blog.csdn.net/liu251890347/article/details/37690045" target="_blank" rel="noopener">《memcache 中 add 、 set 、replace 的区别》</a><ul><li>区别在于当key存在还是不存在时，返回值是true和false的。</li></ul></li><li><a href="https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=" target="_blank" rel="noopener"><strong>《memcached全面剖析》</strong></a></li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">《Redis 教程》</a></li><li><a href="https://blog.csdn.net/wcf373722432/article/details/78678504" target="_blank" rel="noopener">《redis底层原理》</a><ul><li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li><li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li></ul></li><li><a href="http://doc.redisfans.com/topic/persistence.html" target="_blank" rel="noopener">《Redis持久化方式》</a><ul><li>RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。</li><li>AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。</li><li>也可以两者结合使用。</li></ul></li><li><a href="https://blog.csdn.net/chunlongyu/article/details/53346436" target="_blank" rel="noopener">《分布式缓存–序列3–原子操作与CAS乐观锁》</a></li></ul><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><ul><li><a href="https://blog.csdn.net/sunhuiliang85/article/details/73656830" target="_blank" rel="noopener">《Redis单线程架构》</a></li></ul><h4 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h4><ul><li><a href="https://blog.csdn.net/qq_29108585/article/details/63251491" target="_blank" rel="noopener">《redis的回收策略》</a></li></ul><h3 id="Tair"><a href="#Tair" class="headerlink" title="Tair"></a>Tair</h3><ul><li><a href="https://github.com/alibaba/tair" target="_blank" rel="noopener">官方网站</a></li><li><a href="http://blog.csdn.net/farphone/article/details/53522383" target="_blank" rel="noopener">《Tair和Redis的对比》</a></li><li>特点：可以配置备份节点数目，通过异步同步到备份节点</li><li>一致性Hash算法。</li><li>架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。</li></ul><p>几种存储引擎:</p><ul><li>MDB，完全内存性，可以用来存储Session等数据。</li><li>Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作</li><li>LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。</li><li>Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。</li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li><a href="https://www.cnblogs.com/charlesblc/p/6045238.html" target="_blank" rel="noopener">《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》</a><ul><li>RabbitMQ 消费者默认是推模式（也支持拉模式）。</li><li>Kafka 默认是拉模式。</li><li>Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。</li><li>Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。</li></ul></li><li><a href="https://blog.csdn.net/yunfeng482/article/details/72856762" target="_blank" rel="noopener">《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》</a></li></ul><h3 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h3><p>消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。</p><ul><li><a href="https://blog.csdn.net/yanghua_kobe/article/details/43877281" target="_blank" rel="noopener">《消息总线VS消息队列》</a></li></ul><h3 id="消息的顺序"><a href="#消息的顺序" class="headerlink" title="消息的顺序"></a>消息的顺序</h3><ul><li><a href="https://www.cnblogs.com/cjsblog/p/8267892.html" target="_blank" rel="noopener">《如何保证消费者接收消息的顺序》</a></li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。</p><ul><li><a href="https://blog.csdn.net/whoamiyang/article/details/54954780" target="_blank" rel="noopener">《RabbitMQ的应用场景以及基本原理介绍》</a></li><li><a href="https://www.jianshu.com/p/79ca08116d57" target="_blank" rel="noopener">《消息队列之 RabbitMQ》</a> </li><li><a href="https://blog.csdn.net/u013256816/article/details/55515234" target="_blank" rel="noopener">《RabbitMQ之消息确认机制（事务+Confirm）》</a></li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。</p><ul><li><a href="https://www.jianshu.com/p/824066d70da8" target="_blank" rel="noopener">《RocketMQ 实战之快速入门》</a></li><li><a href="http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome" target="_blank" rel="noopener">《RocketMQ 源码解析》</a></li></ul><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>纯Java实现，兼容JMS，可以内嵌于Java应用中。</p><ul><li><a href="https://www.cnblogs.com/wintersun/p/3962302.html" target="_blank" rel="noopener">《ActiveMQ消息队列介绍》</a></li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>高吞吐量、采用拉模式。适合高IO场景，比如日志同步。</p><ul><li><a href="http://kafka.apache.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://blog.csdn.net/allthesametome/article/details/47362451" target="_blank" rel="noopener">《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》</a></li><li><a href="http://lxw1234.com/archives/2015/10/538.htm" target="_blank" rel="noopener">《Kafka分区机制介绍与示例》</a></li></ul><h3 id="Redis-消息推送"><a href="#Redis-消息推送" class="headerlink" title="Redis 消息推送"></a>Redis 消息推送</h3><p>生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。</p><ul><li><a href="https://blog.csdn.net/qq_34212276/article/details/78455004" target="_blank" rel="noopener">《Redis学习笔记之十：Redis用作消息队列》</a></li></ul><h3 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h3><p> TODO</p><h2 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h2><h3 id="单机定时调度"><a href="#单机定时调度" class="headerlink" title="单机定时调度"></a>单机定时调度</h3><ul><li><a href="https://www.cnblogs.com/shuaiqing/p/7742382.html" target="_blank" rel="noopener">《linux定时任务cron配置》</a></li><li><a href="https://my.oschina.net/daquan/blog/483305" target="_blank" rel="noopener">《Linux cron运行原理》</a><ul><li>fork 进程 + sleep 轮询</li></ul></li><li><a href="https://www.cnblogs.com/drift-ice/p/3817269.html" target="_blank" rel="noopener">《Quartz使用总结》</a></li><li><a href="https://blog.csdn.net/wenniuwuren/article/details/42082981/" target="_blank" rel="noopener">《Quartz源码解析 —- 触发器按时启动原理》</a></li><li><a href="https://www.jianshu.com/p/bab8e4e32952" target="_blank" rel="noopener">《quartz原理揭秘和源码解读》</a><ul><li>定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。</li></ul></li></ul><h3 id="分布式定时调度"><a href="#分布式定时调度" class="headerlink" title="分布式定时调度"></a>分布式定时调度</h3><ul><li><a href="https://blog.csdn.net/qq_16216221/article/details/70314337" target="_blank" rel="noopener">《这些优秀的国产分布式任务调度系统，你用过几个？》</a><ul><li>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li></ul></li><li><a href="https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html" target="_blank" rel="noopener">《Quartz任务调度的基本实现原理》</a><ul><li>Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 </li></ul></li><li><a href="http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome" target="_blank" rel="noopener">《Elastic-Job-Lite 源码解析》</a></li><li><a href="http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome" target="_blank" rel="noopener">《Elastic-Job-Cloud 源码解析》</a></li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><ul><li><a href="https://blog.csdn.net/top_code/article/details/54615853" target="_blank" rel="noopener">《从零开始实现RPC框架 - RPC原理及实现》</a><ul><li>核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。</li></ul></li><li><a href="https://blog.csdn.net/testcs_dn/article/details/78050590" target="_blank" rel="noopener">《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》</a></li></ul><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><ul><li><a href="http://dubbo.apache.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://www.cnblogs.com/steven520213/p/7606598.html" target="_blank" rel="noopener">dubbo实现原理简单介绍</a></li></ul><p>** SPI **<br>TODO</p><h3 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h3><ul><li><a href="http://thrift.apache.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://blog.csdn.net/kesonyk/article/details/50924489" target="_blank" rel="noopener">《Thrift RPC详解》</a><ul><li>支持多语言，通过中间语言定义接口。</li></ul></li></ul><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>服务端可以认证加密，在外网环境下，可以保证数据安全。</p><ul><li><a href="https://grpc.io/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://www.cnblogs.com/LBSer/p/4853234.html" target="_blank" rel="noopener">《你应该知道的RPC原理》</a></li></ul><h2 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h2><h3 id="Sharding-Jdbc"><a href="#Sharding-Jdbc" class="headerlink" title="Sharding Jdbc"></a>Sharding Jdbc</h3><ul><li><a href="http://shardingjdbc.io/" target="_blank" rel="noopener">官网</a></li><li><a href="http://www.iocoder.cn/categories/Sharding-JDBC/?vip&architect-awesome" target="_blank" rel="noopener">源码解析</a></li></ul><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><h3 id="日志搜集"><a href="#日志搜集" class="headerlink" title="日志搜集"></a>日志搜集</h3><ul><li><a href="http://cjting.me/misc/build-log-system-with-elkb/" target="_blank" rel="noopener">《从零开始搭建一个ELKB日志收集系统》</a></li><li><a href="https://blog.csdn.net/lzw_2006/article/details/51280058" target="_blank" rel="noopener">《用ELK搭建简单的日志收集分析系统》</a></li><li><a href="https://www.cnblogs.com/beginmind/p/6058194.html" target="_blank" rel="noopener">《日志收集系统-探究》</a></li></ul><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><ul><li><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">Apollo - 携程开源的配置中心应用</a><ul><li>Spring Boot 和 Spring Cloud</li><li>支持推、拉模式更新配置</li><li>支持多种语言 </li></ul></li><li><a href="https://blog.csdn.net/u011320740/article/details/78742625" target="_blank" rel="noopener">《基于zookeeper实现统一配置管理》</a></li><li><a href="https://www.cnblogs.com/shamo89/p/8016908.html" target="_blank" rel="noopener">《 Spring Cloud Config 分布式配置中心使用教程》</a></li></ul><p>servlet 3.0 异步特性可用于配置中心的客户端</p><ul><li><a href="https://www.cnblogs.com/dogdogwang/p/7151866.html" target="_blank" rel="noopener">《servlet3.0 新特性——异步处理》</a></li></ul><h2 id="API-网关"><a href="#API-网关" class="headerlink" title="API 网关"></a>API 网关</h2><p>主要职责：请求转发、安全认证、协议转换、容灾。</p><ul><li><a href="http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/" target="_blank" rel="noopener">《API网关那些儿》</a></li><li><a href="http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo" target="_blank" rel="noopener">《谈API网关的背景、架构以及落地方案》</a></li><li><a href="https://blog.csdn.net/zhanglh046/article/details/78651993" target="_blank" rel="noopener">《使用Zuul构建API Gateway》</a></li><li><a href="http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome" target="_blank" rel="noopener">《Spring Cloud Gateway 源码解析》</a></li><li><a href="https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A" target="_blank" rel="noopener">《HTTP API网关选择之一Kong介绍》</a></li></ul><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="OSI-七层协议"><a href="#OSI-七层协议" class="headerlink" title="OSI 七层协议"></a>OSI 七层协议</h3><ul><li><a href="https://www.cnblogs.com/Robin-YB/p/6668762.html" target="_blank" rel="noopener">《OSI七层协议模型、TCP/IP四层模型学习笔记》</a></li></ul><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><ul><li><a href="https://www.cnblogs.com/onepixel/p/7092302.html" target="_blank" rel="noopener">《深入浅出 TCP/IP 协议》</a></li><li><a href="https://blog.csdn.net/whuslei/article/details/6667471/" target="_blank" rel="noopener">《TCP协议中的三次握手和四次挥手》</a></li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li><a href="https://www.cnblogs.com/wangning528/p/6388464.html" target="_blank" rel="noopener">《http协议详解(超详细)》</a></li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul><li><a href="https://blog.csdn.net/zhuyiquan/article/details/69257126" target="_blank" rel="noopener">《HTTP 2.0 原理详细分析》</a></li><li><a href="https://blog.csdn.net/u012657197/article/details/77877840" target="_blank" rel="noopener">《HTTP2.0的基本单位为二进制帧》</a><ul><li>利用二进制帧负责传输。</li><li>多路复用。</li></ul></li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul><li><a href="https://www.cnblogs.com/zhangshitong/p/6478721.html" target="_blank" rel="noopener">《https原理通俗了解》</a><ul><li>使用非对称加密协商加密算法</li><li>使用对称加密方式传输数据</li><li>使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。</li></ul></li><li><a href="https://blog.csdn.net/enweitech/article/details/53213862" target="_blank" rel="noopener">《八大免费SSL证书-给你的网站免费添加Https安全加密》</a></li></ul><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><ul><li><a href="http://blog.51cto.com/litaotao/1289790" target="_blank" rel="noopener">《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》</a><ul><li>五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。</li><li>三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。</li></ul></li><li><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">《select、poll、epoll之间的区别总结》</a><ul><li>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li><li>select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。</li><li>select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。</li><li>poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。</li></ul></li><li><a href="http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/" target="_blank" rel="noopener">《select，poll，epoll比较  》</a><ul><li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li></ul></li><li><a href="https://www.cnblogs.com/geason/p/5774096.html" target="_blank" rel="noopener">《深入理解Java NIO》</a><ul><li>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务</li></ul></li><li><a href="https://blog.csdn.net/skiof007/article/details/52873421" target="_blank" rel="noopener">《BIO与NIO、AIO的区别》</a></li><li><a href="https://blog.csdn.net/u013074465/article/details/46276967" target="_blank" rel="noopener">《两种高效的服务器设计模型：Reactor和Proactor模型》</a></li></ul><h3 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h3><ul><li><a href="https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html" target="_blank" rel="noopener">《epoll使用详解（精髓）》</a></li></ul><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><ul><li><a href="https://www.cnblogs.com/geason/p/5774096.html" target="_blank" rel="noopener">《深入理解Java NIO》</a></li><li><a href="https://blog.csdn.net/xidianliuy/article/details/51612676" target="_blank" rel="noopener">《Java NIO编写Socket服务器的一个例子》</a></li></ul><h3 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h3><ul><li><a href="http://www.cnblogs.com/luminocean/p/5631336.html" target="_blank" rel="noopener">《kqueue用法简介》</a></li></ul><h2 id="连接和短连接"><a href="#连接和短连接" class="headerlink" title="连接和短连接"></a>连接和短连接</h2><ul><li><a href="https://www.cnblogs.com/pangguoping/p/5571422.html" target="_blank" rel="noopener">《TCP/IP系列——长连接与短连接的区别》</a></li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ul><li><a href="https://blog.csdn.net/excellentyuxiao/article/details/53390408" target="_blank" rel="noopener">《Netty原理剖析》</a><ul><li>Reactor 模式介绍。</li><li>Netty 是 Reactor 模式的一种实现。</li></ul></li></ul><h2 id="零拷贝（Zero-copy）"><a href="#零拷贝（Zero-copy）" class="headerlink" title="零拷贝（Zero-copy）"></a>零拷贝（Zero-copy）</h2><ul><li><a href="https://www.cnblogs.com/xys1228/p/6088805.html" target="_blank" rel="noopener">《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》</a><ul><li>多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。</li></ul></li></ul><h2 id="序列化-二进制协议"><a href="#序列化-二进制协议" class="headerlink" title="序列化(二进制协议)"></a>序列化(二进制协议)</h2><h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h3><ul><li><a href="https://www.cnblogs.com/happyday56/p/4268249.html" target="_blank" rel="noopener">《Hessian原理分析》</a><br>Binary-RPC;不仅仅是序列化</li></ul><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><ul><li><a href="https://blog.csdn.net/antgan/article/details/52103966" target="_blank" rel="noopener">《Protobuf协议的Java应用例子》</a><br>Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。</li><li><a href="https://worktile.com/tech/share/prototol-buffers" target="_blank" rel="noopener">《Protocol Buffers序列化协议及应用》</a><ul><li>关于协议的解释；缺点：可读性差;</li></ul></li><li><a href="https://blog.csdn.net/eric520zenobia/article/details/53766571" target="_blank" rel="noopener">《简单的使用 protobuf 和 protostuff》</a><ul><li>protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。</li></ul></li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><h3 id="关系数据库设计的三大范式"><a href="#关系数据库设计的三大范式" class="headerlink" title="关系数据库设计的三大范式"></a>关系数据库设计的三大范式</h3><ul><li><a href="https://www.cnblogs.com/waj6511988/p/7027127.html" target="_blank" rel="noopener">《数据库的三大范式以及五大约束》</a><ul><li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li><li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li><li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li></ul></li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><a href="http://www.admin10000.com/document/5372.html" target="_blank" rel="noopener">《MySQL的InnoDB索引原理详解》</a></li><li><a href="https://blog.csdn.net/xifeijian/article/details/20316775" target="_blank" rel="noopener">《MySQL存储引擎－－MyISAM与InnoDB区别》</a><ul><li>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁</li></ul></li><li><a href="https://www.2cto.com/database/201211/172380.html" target="_blank" rel="noopener">《myisam和innodb索引实现的不同》</a></li></ul><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><ul><li><a href="https://my.oschina.net/kailuncen/blog/1504217" target="_blank" rel="noopener">《一篇文章带你读懂Mysql和InnoDB》</a></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><a href="http://vdisk.weibo.com/s/muWOT" target="_blank" rel="noopener">《MySQL36条军规》</a></li><li><a href="https://www.cnblogs.com/zhouyusheng/p/8038224.html" target="_blank" rel="noopener">《MYSQL性能优化的最佳20+条经验》</a></li><li><a href="https://blog.csdn.net/when_less_is_more/article/details/70187459" target="_blank" rel="noopener">《SQL优化之道》</a></li><li><a href="https://www.cnblogs.com/sivkun/p/7518540.html" target="_blank" rel="noopener">《mysql数据库死锁的产生原因及解决办法》</a></li><li><a href="https://blog.csdn.net/monkey_d_feilong/article/details/52291556" target="_blank" rel="noopener">《导致索引失效的可能情况》</a></li><li><a href="https://blog.csdn.net/zy_281870667/article/details/51604540" target="_blank" rel="noopener">《 MYSQL分页limit速度太慢优化方法》</a><ul><li>原则上就是缩小扫描范围。</li></ul></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="聚集索引-非聚集索引"><a href="#聚集索引-非聚集索引" class="headerlink" title="聚集索引, 非聚集索引"></a>聚集索引, 非聚集索引</h4><ul><li><a href="https://blog.csdn.net/no_endless/article/details/77073549" target="_blank" rel="noopener">《MySQL 聚集索引/非聚集索引简述》</a></li><li><a href="https://www.cnblogs.com/zlcxbb/p/5757245.html" target="_blank" rel="noopener">《MyISAM和InnoDB的索引实现》</a></li></ul><p>MyISAM 是非聚集，InnoDB 是聚集</p><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><ul><li><p><a href="https://www.cnblogs.com/summer0space/p/7247778.html" target="_blank" rel="noopener">《复合索引的优点和注意事项》</a></p><ul><li>文中有一处错误：</li></ul><blockquote><p>对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高; select * from table1 where col1=A AND col2=B AND col3=D 如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引</p></blockquote><ul><li>原文中提到索引是按照“col1，col2，col3”的顺序创建的，而mysql在按照最左前缀的索引匹配原则，且会自动优化 where 条件的顺序，当条件中只有 col2=B AND col1=A 时，会自动转化为 col1=A AND col2=B，所以依然会使用索引。</li></ul></li><li><p><a href="https://www.cnblogs.com/acode/p/7489258.html" target="_blank" rel="noopener">《MySQL查询where条件的顺序对查询效率的影响》</a></p></li></ul><h4 id="自适应哈希索引-AHI"><a href="#自适应哈希索引-AHI" class="headerlink" title="自适应哈希索引(AHI)"></a>自适应哈希索引(AHI)</h4><ul><li><a href="https://blog.csdn.net/Linux_ever/article/details/62043708" target="_blank" rel="noopener">《InnoDB存储引擎——自适应哈希索引》</a></li></ul><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><ul><li><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">《MySQL 性能优化神器 Explain 使用分析》</a></li></ul><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><ul><li><a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">MongoDB 教程</a></li><li><a href="http://mxdxm.iteye.com/blog/2093603" target="_blank" rel="noopener">《Mongodb相对于关系型数据库的优缺点》</a><ul><li>优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；</li><li>缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；</li></ul></li></ul><h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><ul><li><p><a href="http://www.thebigdata.cn/HBase/35831.html" target="_blank" rel="noopener">《简明 HBase 入门教程（开篇）》</a></p></li><li><p><a href="https://www.cnblogs.com/qiaoyihang/p/6246424.html" target="_blank" rel="noopener">《深入学习HBase架构原理》</a></p></li><li><p><a href="https://blog.csdn.net/youzhouliu/article/details/67632882" target="_blank" rel="noopener">《传统的行存储和（HBase）列存储的区别》</a></p></li><li><p><a href="https://blog.csdn.net/lifuxiangcaohui/article/details/39891099" target="_blank" rel="noopener">《Hbase与传统数据库的区别》</a></p><ul><li>空数据不存储，节省空间，且适用于并发。</li></ul></li><li><p><a href="https://blog.csdn.net/u014091123/article/details/73163088" target="_blank" rel="noopener">《HBase Rowkey设计》</a></p><ul><li>rowkey 按照字典顺序排列，便于批量扫描。</li><li>通过散列可以避免热点。</li></ul></li></ul><h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><h2 id="搜索引擎原理"><a href="#搜索引擎原理" class="headerlink" title="搜索引擎原理"></a>搜索引擎原理</h2><ul><li><a href="https://www.jianshu.com/p/0193dc44135b" target="_blank" rel="noopener">《倒排索引–搜索引擎入门》</a></li></ul><h2 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h2><ul><li><a href="https://www.cnblogs.com/rodge-run/p/6551152.html" target="_blank" rel="noopener">《Lucene入门简介》</a></li></ul><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul><li><a href="https://blog.csdn.net/laoyang360/article/details/52244917" target="_blank" rel="noopener">《Elasticsearch学习，请先看这一篇！》</a></li><li><a href="https://blog.csdn.net/cyony/article/details/65437708" target="_blank" rel="noopener">《Elasticsearch索引原理》</a></li></ul><h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><ul><li><a href="https://blog.csdn.net/u011936655/article/details/51960005" target="_blank" rel="noopener">《 Apache Solr入门教程》</a></li><li><a href="https://blog.csdn.net/convict_eva/article/details/53537837" target="_blank" rel="noopener">《elasticsearch与solr比较》</a></li></ul><h2 id="sphinx"><a href="#sphinx" class="headerlink" title="sphinx"></a>sphinx</h2><ul><li><a href="http://blog.jobbole.com/101672/" target="_blank" rel="noopener">《Sphinx 的介绍和原理探索》</a></li></ul><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><h2 id="性能优化方法论"><a href="#性能优化方法论" class="headerlink" title="性能优化方法论"></a>性能优化方法论</h2><ul><li><a href="https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread" target="_blank" rel="noopener">《15天的性能优化工作，5方面的调优经验》</a><ul><li>代码层面、业务层面、数据库层面、服务器层面、前端优化。</li></ul></li><li><a href="https://blog.csdn.net/tenglizhe/article/details/44563135" target="_blank" rel="noopener">《系统性能优化的几个方面》</a></li></ul><h2 id="容量评估"><a href="#容量评估" class="headerlink" title="容量评估"></a>容量评估</h2><ul><li><a href="https://blog.csdn.net/u012528360/article/details/70054156" target="_blank" rel="noopener">《联网性能与容量评估的方法论和典型案例》</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959542&idx=1&sn=2494bbea9a855e0e1c3ccd6d2562a600&scene=21#wechat_redirect" target="_blank" rel="noopener">《互联网架构，如何进行容量设计？》</a><ul><li>评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS</li></ul></li></ul><h2 id="CDN-网络"><a href="#CDN-网络" class="headerlink" title="CDN 网络"></a>CDN 网络</h2><ul><li><a href="https://www.cnblogs.com/wxiaona/p/5867685.html" target="_blank" rel="noopener">《CDN加速原理》</a></li><li><a href="https://www.zhihu.com/question/20536932" target="_blank" rel="noopener">《国内有哪些比较好的 CDN？》</a></li></ul><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><ul><li><a href="https://blog.csdn.net/fysuccess/article/details/66972554" target="_blank" rel="noopener">《主流Java数据库连接池比较与开发配置实战》</a></li></ul><h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><ul><li><a href="https://blog.csdn.net/yethyeth/article/details/73266455" target="_blank" rel="noopener">《九大Java性能调试工具，必备至少一款》</a></li></ul><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h2 id="流式计算"><a href="#流式计算" class="headerlink" title="流式计算"></a>流式计算</h2><h3 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h3><ul><li><a href="http://storm.apache.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://blog.csdn.net/uisoul/article/details/77989927" target="_blank" rel="noopener">《最详细的Storm入门教程》</a></li></ul><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><ul><li><a href="https://blog.csdn.net/lisi1129/article/details/54844919" target="_blank" rel="noopener">《Flink之一 Flink基本原理介绍》</a></li></ul><h3 id="Kafka-Stream"><a href="#Kafka-Stream" class="headerlink" title="Kafka Stream"></a>Kafka Stream</h3><ul><li><a href="https://yq.aliyun.com/articles/58382" target="_blank" rel="noopener">《Kafka Stream调研：一种轻量级流计算模式》</a></li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>例如：</p><ul><li>广告相关实时统计；</li><li>推荐系统用户画像标签实时更新；</li><li>线上服务健康状况实时监测；</li><li>实时榜单；</li><li>实时数据统计。</li></ul><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><ul><li><a href="https://blog.csdn.net/houbin0912/article/details/72967178" target="_blank" rel="noopener">《用通俗易懂的话说下hadoop是什么,能做什么》</a></li><li><a href="http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html" target="_blank" rel="noopener">《史上最详细的Hadoop环境搭建》</a></li></ul><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><ul><li><a href="https://segmentfault.com/a/1190000011575458" target="_blank" rel="noopener">《【Hadoop学习】HDFS基本原理》</a></li></ul><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><ul><li><a href="https://blog.csdn.net/oppo62258801/article/details/72884633" target="_blank" rel="noopener">《用通俗易懂的大白话讲解Map/Reduce原理》</a></li><li><a href="https://blog.csdn.net/foye12/article/details/78358292" target="_blank" rel="noopener">《 简单的map-reduce的java例子》</a></li></ul><h3 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h3><ul><li><a href="http://www.cnblogs.com/codeOfLife/p/5492740.html" target="_blank" rel="noopener">《初步掌握Yarn的架构及原理》</a></li></ul><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><ul><li><a href="http://www.cnblogs.com/tgzhu/p/5818374.html" target="_blank" rel="noopener">《Spark(一): 基本架构及原理》</a></li><li><a href="http://dblab.xmu.edu.cn/blog/1709-2/" target="_blank" rel="noopener">《子雨大数据之Spark入门教程(Python版)》</a></li></ul><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="web-安全"><a href="#web-安全" class="headerlink" title="web 安全"></a>web 安全</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><ul><li><a href="https://blog.csdn.net/qq_21956483/article/details/54377947" target="_blank" rel="noopener">《xss攻击原理与解决方法》</a></li></ul><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html" target="_blank" rel="noopener">《CSRF原理及防范》</a></li></ul><h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html" target="_blank" rel="noopener">《SQL注入》</a></li></ul><h3 id="Hash-Dos"><a href="#Hash-Dos" class="headerlink" title="Hash Dos"></a>Hash Dos</h3><ul><li><a href="http://www.freebuf.com/articles/web/14199.html" target="_blank" rel="noopener">《邪恶的JAVA HASH DOS攻击》</a><ul><li>利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。</li></ul></li><li><a href="http://blog.it2048.cn/article_hash-collision.html" target="_blank" rel="noopener">《一种高级的DoS攻击-Hash碰撞攻击》</a></li><li><a href="http://www.iteye.com/news/23939/" target="_blank" rel="noopener">《关于Hash Collision DoS漏洞：解析与解决方案》</a></li></ul><h3 id="脚本注入"><a href="#脚本注入" class="headerlink" title="脚本注入"></a>脚本注入</h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html" target="_blank" rel="noopener">《上传文件漏洞原理及防范》</a></li></ul><h3 id="漏洞扫描工具"><a href="#漏洞扫描工具" class="headerlink" title="漏洞扫描工具"></a>漏洞扫描工具</h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html" target="_blank" rel="noopener">《DVWA》</a></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html" target="_blank" rel="noopener">W3af</a></li><li><a href="https://blog.csdn.net/xygg0801/article/details/53610640" target="_blank" rel="noopener">OpenVAS详解</a></li></ul><h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><ul><li><a href="https://blog.csdn.net/niaonao/article/details/51112686" target="_blank" rel="noopener">《验证码原理分析及实现》</a></li><li><a href="https://my.oschina.net/jiangbianwanghai/blog/1031031" target="_blank" rel="noopener">《详解滑动验证码的实现原理》</a><ul><li>滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。</li></ul></li><li><a href="https://www.cnblogs.com/xcj26/p/5242758.html" target="_blank" rel="noopener">《淘宝滑动验证码研究》</a></li></ul><h2 id="DDoS-防范"><a href="#DDoS-防范" class="headerlink" title="DDoS 防范"></a>DDoS 防范</h2><ul><li><a href="http://netsecurity.51cto.com/art/201601/503799.htm" target="_blank" rel="noopener">《学习手册：DDoS的攻击方式及防御手段》</a></li><li><a href="http://netsecurity.51cto.com/art/201406/442756.htm" target="_blank" rel="noopener">《免费DDoS攻击测试工具大合集》</a></li></ul><h2 id="用户隐私信息保护"><a href="#用户隐私信息保护" class="headerlink" title="用户隐私信息保护"></a>用户隐私信息保护</h2><ol><li>用户密码非明文保存，加动态salt。</li><li>身份证号，手机号如果要显示，用 “*” 替代部分字符。</li><li>联系方式在的显示与否由用户自己控制。</li><li>TODO</li></ol><ul><li><a href="https://zhidao.baidu.com/question/1988017976673661587.html" target="_blank" rel="noopener">《个人隐私包括哪些》</a></li><li><a href="https://www.zhihu.com/question/20137108" target="_blank" rel="noopener">《在互联网上，隐私的范围包括哪些？》</a></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html" target="_blank" rel="noopener">《用户密码保存》</a></li></ul><h2 id="序列化漏洞"><a href="#序列化漏洞" class="headerlink" title="序列化漏洞"></a>序列化漏洞</h2><ul><li><a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/" target="_blank" rel="noopener">《Lib之过？Java反序列化漏洞通用利用分析》</a></li></ul><h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html" target="_blank" rel="noopener">《常见对称加密算法》</a><ul><li>DES、3DES、Blowfish、AES</li><li>DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。</li><li>DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。</li></ul></li></ul><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html" target="_blank" rel="noopener">《常用的哈希算法》</a><ul><li>MD5 和 SHA-1 已经不再安全，已被弃用。</li><li>目前 SHA-256 是比较安全的。</li></ul></li><li><a href="https://blog.csdn.net/zhangruhong168/article/details/78033202" target="_blank" rel="noopener">《基于Hash摘要签名的公网URL签名验证设计方案》</a></li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul><li><p><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html" target="_blank" rel="noopener">《常见非对称加密算法》</a></p><ul><li><p>RSA、DSA、ECDSA(螺旋曲线加密算法)</p></li><li><p>和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</p></li><li><p>256位的ECC秘钥的安全性等同于3072位的RSA秘钥。</p><p><a href="http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc" target="_blank" rel="noopener">《区块链的加密技术》</a>    </p></li></ul></li></ul><h2 id="服务器安全"><a href="#服务器安全" class="headerlink" title="服务器安全"></a>服务器安全</h2><ul><li><a href="http://www.freebuf.com/articles/system/121540.html" target="_blank" rel="noopener">《Linux强化论：15步打造一个安全的Linux服务器》</a></li></ul><h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p>TODO</p><h2 id="网络隔离"><a href="#网络隔离" class="headerlink" title="网络隔离"></a>网络隔离</h2><h3 id="内外网分离"><a href="#内外网分离" class="headerlink" title="内外网分离"></a>内外网分离</h3><p>TODO</p><h3 id="登录跳板机"><a href="#登录跳板机" class="headerlink" title="登录跳板机"></a>登录跳板机</h3><p>在内外环境中通过跳板机登录到线上主机。</p><ul><li><a href="http://blog.51cto.com/zero01/2062618" target="_blank" rel="noopener">《搭建简易堡垒机》</a></li></ul><h2 id="授权、认证"><a href="#授权、认证" class="headerlink" title="授权、认证"></a>授权、认证</h2><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><ul><li><a href="https://www.cnblogs.com/zq8024/p/5003050.html" target="_blank" rel="noopener">《基于组织角色的权限设计》</a></li><li><a href="https://www.cnblogs.com/shijiaqi1066/p/3793894.html" target="_blank" rel="noopener">《权限系统与RBAC模型概述》</a></li><li><a href="https://blog.csdn.net/he90227/article/details/38663553" target="_blank" rel="noopener">《Spring整合Shiro做权限控制模块详细案例分析》</a></li></ul><h3 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">《理解OAuth 2.0》</a></li><li><a href="https://www.cnblogs.com/flashsun/p/7424071.html" target="_blank" rel="noopener">《一张图搞定OAuth2.0》</a></li></ul><h3 id="双因素认证（2FA）"><a href="#双因素认证（2FA）" class="headerlink" title="双因素认证（2FA）"></a>双因素认证（2FA）</h3><p>2FA - Two-factor authentication，用于加强登录验证</p><p>常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）</p><ul><li>【《双因素认证（2FA）教程》】(<a href="http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html</a>)</li></ul><h3 id="单点登录-SSO"><a href="#单点登录-SSO" class="headerlink" title="单点登录(SSO)"></a>单点登录(SSO)</h3><ul><li><a href="https://www.cnblogs.com/ywlaker/p/6113927.html" target="_blank" rel="noopener">《单点登录原理与简单实现》</a></li><li><a href="https://github.com/apereo/cas" target="_blank" rel="noopener">CAS单点登录框架</a></li></ul><h1 id="常用开源框架"><a href="#常用开源框架" class="headerlink" title="常用开源框架"></a>常用开源框架</h1><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html" target="_blank" rel="noopener">《开源协议的选择》</a></li><li><a href="http://choosealicense.online/" target="_blank" rel="noopener">如何选择一个开源软件协议</a></li></ul><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><h3 id="Log4j、Log4j2"><a href="#Log4j、Log4j2" class="headerlink" title="Log4j、Log4j2"></a>Log4j、Log4j2</h3><ul><li><a href="https://blog.csdn.net/u012422446/article/details/51199724" target="_blank" rel="noopener">《log4j 详细讲解》</a></li><li><a href="https://blog.csdn.net/vbirdbest/article/details/71751835" target="_blank" rel="noopener">《log4j2 实际使用详解》</a></li><li><a href="https://my.oschina.net/OutOfMemory/blog/789267" target="_blank" rel="noopener">《Log4j1,Logback以及Log4j2性能测试对比》</a><ul><li>Log4J 异步日志性能优异。 </li></ul></li></ul><h3 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h3><ul><li><a href="https://blog.csdn.net/rulon147/article/details/52620541" target="_blank" rel="noopener">《最全LogBack 详解、含java案例和配置说明》</a></li></ul><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><ul><li><a href="https://blog.csdn.net/sinat_34093604/article/details/53082000" target="_blank" rel="noopener">《ORM框架使用优缺点》</a><ul><li>主要目的是为了提高开发效率。 </li></ul></li></ul><p><strong>MyBatis：</strong></p><ul><li><a href="https://www.cnblogs.com/winclpt/articles/7511672.html" target="_blank" rel="noopener">《mybatis缓存机制详解》</a><ul><li>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效</li><li>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  </li></ul></li><li><a href="https://blog.csdn.net/baidu_32877851/article/details/53959268" target="_blank" rel="noopener">《MyBatis学习之代码生成器Generator》</a></li></ul><h2 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h2><p>TODO</p><h2 id="Web-框架"><a href="#Web-框架" class="headerlink" title="Web 框架"></a>Web 框架</h2><h3 id="Spring-家族"><a href="#Spring-家族" class="headerlink" title="Spring 家族"></a>Spring 家族</h3><p><strong>Spring</strong></p><ul><li><a href="https://www.w3cschool.cn/wkspring/" target="_blank" rel="noopener">Spring 简明教程</a></li></ul><p><strong>Spring Boot</strong></p><ul><li><a href="http://projects.spring.io/spring-boot/" target="_blank" rel="noopener">官方网站</a></li><li><a href="http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">《Spring Boot基础教程》</a></li></ul><p><strong>Spring Cloud</strong></p><ul><li><a href="http://springboot.fun/" target="_blank" rel="noopener">Spring Boot 中文索引站</a></li><li><a href="https://springcloud.cc/" target="_blank" rel="noopener">Spring Cloud 中文文档</a></li><li><a href="http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">《Spring Cloud基础教程》</a></li></ul><h2 id="工具框架"><a href="#工具框架" class="headerlink" title="工具框架"></a>工具框架</h2><ul><li><a href="https://www.cnblogs.com/crazylqy/p/4872236.html" target="_blank" rel="noopener">《Apache Commons 工具类介绍及简单使用》</a></li><li><a href="http://ifeve.com/google-guava/" target="_blank" rel="noopener">《Google guava 中文教程》</a></li></ul><h1 id="分布式设计"><a href="#分布式设计" class="headerlink" title="分布式设计"></a>分布式设计</h1><h2 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h2><ul><li><a href="https://blog.csdn.net/hemin1003/article/details/53633926" target="_blank" rel="noopener">《架构师不可不知的十大可扩展架构》</a><ul><li>总结下来，通用的套路就是分布、缓存及异步处理。 </li></ul></li><li><a href="https://yq.aliyun.com/articles/38119" target="_blank" rel="noopener">《可扩展性设计之数据切分》</a><ul><li>水平切分+垂直切分</li><li>利用中间件进行分片如，MySQL Proxy。</li><li>利用分片策略进行切分，如按照ID取模。 </li></ul></li><li><a href="https://blog.csdn.net/deniro_li/article/details/78458306" target="_blank" rel="noopener">《说说如何实现可扩展性的大型网站架构》</a><ul><li>分布式服务+消息队列。</li></ul></li><li><a href="https://blog.csdn.net/chaofanwei/article/details/29191073" target="_blank" rel="noopener">《大型网站技术架构（七）–网站的可扩展性架构》</a></li></ul><h2 id="稳定性-amp-高可用"><a href="#稳定性-amp-高可用" class="headerlink" title="稳定性 &amp; 高可用"></a>稳定性 &amp; 高可用</h2><ul><li><p><a href="https://blog.csdn.net/hustspy1990/article/details/78008324" target="_blank" rel="noopener">《系统设计：关于高可用系统的一些技术方案》</a></p><ul><li>可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。</li><li>隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。</li><li>解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。</li><li>限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。</li><li>降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。</li><li>熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。</li><li>自动化测试：通过完善的测试，减少发布引起的故障。</li><li>灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。</li></ul></li><li><p><a href="https://coolshell.cn/articles/17459.html" target="_blank" rel="noopener">《关于高可用的系统》</a></p><ul><li>设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。     </li></ul></li></ul><h3 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h3><ul><li><a href="https://www.cnblogs.com/wuyun-blog/p/6186198.html" target="_blank" rel="noopener">《转！！负载均衡器技术Nginx和F5的优缺点对比》</a><ul><li>主要是和F5对比。</li></ul></li><li><a href="https://www.cnblogs.com/lcword/p/5773296.html" target="_blank" rel="noopener">《软/硬件负载均衡产品 你知多少？》</a></li></ul><h3 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h3><ul><li><a href="https://www.cnblogs.com/tianzhiliang/articles/2317808.html" target="_blank" rel="noopener">《几种负载均衡算法》</a><br>轮寻、权重、负载、最少连接、QoS</li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html" target="_blank" rel="noopener">《DNS负载均衡》</a><ul><li>配置简单，更新速度慢。 </li></ul></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html" target="_blank" rel="noopener">《Nginx负载均衡》</a><ul><li>简单轻量、学习成本低；主要适用于web应用。</li></ul></li><li><a href="https://www.cnblogs.com/edisonchou/p/4281978.html" target="_blank" rel="noopener">《借助LVS+Keepalived实现负载均衡 》</a><ul><li>配置比较负载、只支持到4层，性能较高。</li></ul></li><li><a href="http://www.ttlsa.com/linux/haproxy-study-tutorial/" target="_blank" rel="noopener">《HAProxy用法详解 全网最详细中文文档》</a><ul><li>支持到七层（比如HTTP）、功能比较全面，性能也不错。</li></ul></li><li><a href="http://blog.itpub.net/25704976/viewspace-1319781/" target="_blank" rel="noopener">《Haproxy+Keepalived+MySQL实现读均衡负载》</a><ul><li>主要是用户读请求的负载均衡。</li></ul></li><li><a href="https://www.cnblogs.com/lylife/p/5584019.html" target="_blank" rel="noopener">《rabbitmq+haproxy+keepalived实现高可用集群搭建》</a></li></ul><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><ul><li><a href="https://www.cnblogs.com/haoxinyue/p/6792309.html" target="_blank" rel="noopener">《谈谈高并发系统的限流》</a><ul><li>计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。</li><li>漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。</li><li>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。</li><li>Nginx 限流：通过 <code>limit_req</code> 等模块限制并发连接数。</li></ul></li></ul><h3 id="应用层容灾"><a href="#应用层容灾" class="headerlink" title="应用层容灾"></a>应用层容灾</h3><ul><li><a href="https://segmentfault.com/a/1190000005988895" target="_blank" rel="noopener">《防雪崩利器：熔断器 Hystrix 的原理与使用》</a><ul><li>雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 </li><li>雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。</li><li>Hystrix设计原则：<ul><li>资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。</li><li>熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。</li><li>命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 </li></ul></li></ul></li><li><a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" target="_blank" rel="noopener">《缓存穿透，缓存击穿，缓存雪崩解决方案分析》</a></li><li><a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" target="_blank" rel="noopener">《缓存击穿、失效以及热点key问题》</a> <ul><li>主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；</li><li>热点数据：热点数据单独存储；使用本地缓存；分成多个子key；</li></ul></li></ul><h3 id="跨机房容灾"><a href="#跨机房容灾" class="headerlink" title="跨机房容灾"></a>跨机房容灾</h3><ul><li><a href="http://dc.idcquan.com/ywgl/71559.shtml" target="_blank" rel="noopener">《“异地多活”多机房部署经验谈》</a><ul><li>通过自研中间件进行数据同步。 </li></ul></li><li><a href="https://blog.csdn.net/jeffreynicole/article/details/48135093" target="_blank" rel="noopener">《异地多活（异地双活）实践经验》</a><ul><li>注意延迟问题，多次跨机房调用会将延时放大数倍。</li><li>建房间专线很大概率会出现问题，做好运维和程序层面的容错。</li><li>不能依赖于程序端数据双写，要有自动同步方案。 </li><li>数据永不在高延迟和较差网络质量下，考虑同步质量问题。</li><li>核心业务和次要业务分而治之，甚至只考虑核心业务。</li><li>异地多活监控部署、测试也要跟上。</li><li>业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。</li><li>控制跨机房消息体大小，越小越好。</li><li>考虑使用docker容器虚拟化技术，提高动态调度能力。</li></ul></li><li><a href="https://blog.csdn.net/yoara/article/details/38013751" target="_blank" rel="noopener">容灾技术及建设经验介绍</a></li></ul><h3 id="容灾演练流程"><a href="#容灾演练流程" class="headerlink" title="容灾演练流程"></a>容灾演练流程</h3><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5" target="_blank" rel="noopener">《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》</a><ul><li>常见故障画像</li><li>案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。</li></ul></li></ul><h3 id="平滑启动"><a href="#平滑启动" class="headerlink" title="平滑启动"></a>平滑启动</h3><ul><li>平滑重启应用思路<br>1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用</li><li><a href="https://blog.csdn.net/u011001084/article/details/73480432" target="_blank" rel="noopener">《JVM安全退出（如何优雅的关闭java服务）》</a><br>推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。</li><li><a href="http://ju.outofmemory.cn/entry/337235" target="_blank" rel="noopener">《常见Java应用如何优雅关闭》</a><br>Java、Spring、Dubbo 优雅关闭方式。</li></ul><h2 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h2><h3 id="读写分离模式"><a href="#读写分离模式" class="headerlink" title="读写分离模式"></a>读写分离模式</h3><ul><li><a href="https://www.cnblogs.com/houdj/p/6563771.html" target="_blank" rel="noopener">《Mysql主从方案的实现》</a></li><li><a href="https://www.cnblogs.com/edisonchou/p/4133148.html" target="_blank" rel="noopener">《搭建MySQL主从复制经典架构》</a></li><li><a href="https://blog.csdn.net/nimasike/article/details/48048341" target="_blank" rel="noopener">《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》</a></li><li><a href="https://www.cnblogs.com/zhangsubai/p/6801764.html" target="_blank" rel="noopener">《DRBD+Heartbeat+Mysql高可用读写分离架构》</a><ul><li>DRDB 进行磁盘复制，避免单点问题。</li></ul></li><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html" target="_blank" rel="noopener">《MySQL Cluster 方式》</a></li></ul><h3 id="分片模式"><a href="#分片模式" class="headerlink" title="分片模式"></a>分片模式</h3><ul><li><a href="https://www.jianshu.com/p/32b3e91aa22c" target="_blank" rel="noopener">《分库分表需要考虑的问题及方案》</a><ul><li>中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。</li><li>问题：事务、Join、迁移、扩容、ID、分页等。</li><li>事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。</li><li>分库策略：数值范围；取模；日期等。</li><li>分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 </li></ul></li><li><a href="https://www.2cto.com/database/201503/380348.html" target="_blank" rel="noopener">《MySql分表和表分区详解》</a><ul><li>分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。</li><li>分表：物理上创建不同的表、客户端需要管理分表路由。</li></ul></li></ul><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><ul><li><a href="https://blog.csdn.net/jiaolongdy/article/details/51188798" target="_blank" rel="noopener">《永不失联！如何实现微服务架构中的服务发现？》</a><ul><li>客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。</li><li>服务器端服务发现模式：客户端通过负载均衡查询服务实例。</li></ul></li><li><a href="https://blog.csdn.net/u010963948/article/details/71730165" target="_blank" rel="noopener">《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》</a><ul><li>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li><li>作者认为目前 Consul 对 Spring cloud 的支持比较好。</li></ul></li><li><a href="http://mobile.51cto.com/news-502394.htm" target="_blank" rel="noopener">《基于Zookeeper的服务注册与发现》</a><ul><li>优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 </li></ul></li></ul><h3 id="服务路由控制"><a href="#服务路由控制" class="headerlink" title="服务路由控制"></a>服务路由控制</h3><ul><li><a href="https://blog.csdn.net/xundh/article/details/59492750" target="_blank" rel="noopener">《分布式服务框架学习笔记4 服务路由》</a><ul><li>原则：透明化路由</li><li>负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接</li><li>本地路由优先策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。</li><li>配置方式：统一注册表；本地配置；动态下发。</li></ul></li></ul><h2 id="分布式一致"><a href="#分布式一致" class="headerlink" title="分布式一致"></a>分布式一致</h2><h3 id="CAP-与-BASE-理论"><a href="#CAP-与-BASE-理论" class="headerlink" title="CAP 与 BASE 理论"></a>CAP 与 BASE 理论</h3><ul><li><a href="http://www.cnblogs.com/szlbm/p/5588543.html" target="_blank" rel="noopener">《从分布式一致性谈到CAP理论、BASE理论》</a><ul><li>一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)</li><li>CAP：一致性、可用性、分区容错性(网络故障引起)</li><li>BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</li><li>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</li></ul></li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ul><li><a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">《分布式锁的几种实现方式》</a><ul><li>基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；</li><li>基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。</li><li>Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。</li></ul></li><li><a href="https://www.tuicool.com/articles/VZJr6fY" target="_blank" rel="noopener">《基于Zookeeper的分布式锁》</a><ul><li>清楚的原理描述 + Java 代码示例。 </li></ul></li><li><a href="https://www.cnblogs.com/0201zcr/p/5942748.html" target="_blank" rel="noopener">《jedisLock—redis分布式锁实现》</a><ul><li>基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。</li></ul></li><li><a href="https://blog.csdn.net/albertfly/article/details/77412333" target="_blank" rel="noopener">《Memcached 和 Redis 分布式锁方案》</a><ul><li>利用 memcached 的 add（有别于set）操作，当key存在时，返回false。</li></ul></li></ul><h3 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h3><h4 id="PAXOS"><a href="#PAXOS" class="headerlink" title="PAXOS"></a>PAXOS</h4><ul><li><a href="https://www.cnblogs.com/linbingdong/p/6253479.html" target="_blank" rel="noopener">《分布式系列文章——Paxos算法原理与推导》</a></li><li><a href="https://blog.csdn.net/u010039929/article/details/70171672" target="_blank" rel="noopener">《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》</a></li><li><a href="https://www.cnblogs.com/leesf456/p/6012777.html" target="_blank" rel="noopener">《【分布式】Zookeeper与Paxos》</a></li></ul><h4 id="Zab"><a href="#Zab" class="headerlink" title="Zab"></a>Zab</h4><ul><li><a href="https://www.jianshu.com/p/fb527a64deee" target="_blank" rel="noopener">《Zab：Zookeeper 中的分布式一致性协议介绍》</a></li></ul><h4 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h4><ul><li><a href="http://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">《Raft 为什么是更易理解的分布式一致性算法》</a><ul><li>三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）</li><li>通过随机等待的方式发出投票，得票多的获胜。</li></ul></li></ul><h4 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h4><ul><li><a href="http://blog.51cto.com/tianya23/530743" target="_blank" rel="noopener">《Gossip算法》</a></li></ul><h4 id="两阶段提交、多阶段提交"><a href="#两阶段提交、多阶段提交" class="headerlink" title="两阶段提交、多阶段提交"></a>两阶段提交、多阶段提交</h4><ul><li><a href="http://blog.jobbole.com/95632/" target="_blank" rel="noopener">《关于分布式事务、两阶段提交协议、三阶提交协议》</a></li></ul><h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><ul><li><a href="https://www.cnblogs.com/wxgblogs/p/6639272.html" target="_blank" rel="noopener">《分布式系统—幂等性设计》</a><ul><li>幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。</li><li>常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 </li></ul></li></ul><h3 id="分布式一致方案"><a href="#分布式一致方案" class="headerlink" title="分布式一致方案"></a>分布式一致方案</h3><ul><li><a href="http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency" target="_blank" rel="noopener">《分布式系统事务一致性解决方案》</a></li><li><a href="https://weibo.com/ttarticle/p/show?id=2309403965965003062676" target="_blank" rel="noopener">《保证分布式系统数据一致性的6种方案》</a></li></ul><h3 id="分布式-Leader-节点选举"><a href="#分布式-Leader-节点选举" class="headerlink" title="分布式 Leader 节点选举"></a>分布式 Leader 节点选举</h3><ul><li><a href="https://blog.csdn.net/johnson_moon/article/details/78809995" target="_blank" rel="noopener">《利用zookeeper实现分布式leader节点选举》</a></li></ul><h3 id="TCC-Try-Confirm-Cancel-柔性事务"><a href="#TCC-Try-Confirm-Cancel-柔性事务" class="headerlink" title="TCC(Try/Confirm/Cancel) 柔性事务"></a>TCC(Try/Confirm/Cancel) 柔性事务</h3><ul><li><a href="https://www.jianshu.com/p/ab1a1c6b08a1" target="_blank" rel="noopener">《传统事务与柔性事务》</a><ul><li>基于BASE理论：基本可用、柔性状态、最终一致。</li><li>解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。</li></ul></li></ul><h2 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/27666295" target="_blank" rel="noopener">说说分布式文件存储系统-基本架构</a> ？</li><li><a href="https://blog.csdn.net/gatieme/article/details/44982961" target="_blank" rel="noopener">《各种分布式文件系统的比较》</a> ？<ul><li>HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。</li><li>FastDFS：轻量级、适合小文件。</li></ul></li></ul><h2 id="唯一ID-生成"><a href="#唯一ID-生成" class="headerlink" title="唯一ID 生成"></a>唯一ID 生成</h2><h3 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h3><ul><li><a href="https://www.cnblogs.com/baiwa/p/5318432.html" target="_blank" rel="noopener">《高并发分布式系统中生成全局唯一Id汇总》</a><ul><li>Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)</li><li>Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” </li><li>UUID：缺点，无序，字符串过长，占用空间，影响检索性能。</li><li>MongoDB 方案：利用 ObjectId。缺点：不能自增。</li></ul></li><li><a href="https://blog.csdn.net/hdu09075340/article/details/79103851" target="_blank" rel="noopener">《TDDL 在分布式下的SEQUENCE原理》</a><ul><li>在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。</li><li>每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。</li><li>客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。</li></ul></li></ul><h2 id="一致性Hash算法"><a href="#一致性Hash算法" class="headerlink" title="一致性Hash算法"></a>一致性Hash算法</h2><ul><li><a href="https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html" target="_blank" rel="noopener">《一致性哈希算法》</a></li></ul><h1 id="设计思想-amp-开发模式"><a href="#设计思想-amp-开发模式" class="headerlink" title="设计思想 &amp; 开发模式"></a>设计思想 &amp; 开发模式</h1><h2 id="DDD-Domain-driven-Design-领域驱动设计"><a href="#DDD-Domain-driven-Design-领域驱动设计" class="headerlink" title="DDD(Domain-driven Design - 领域驱动设计)"></a>DDD(Domain-driven Design - 领域驱动设计)</h2><ul><li><a href="https://www.cnblogs.com/netfocus/p/5548025.html" target="_blank" rel="noopener">《浅谈我对DDD领域驱动设计的理解》</a><ul><li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。</li><li>过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。</li><li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li></ul></li><li><a href="https://www.cnblogs.com/butterfly100/p/7827870.html" target="_blank" rel="noopener">《领域驱动设计的基础知识总结》</a><ul><li>领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。</li><li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li><li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li><li>领域通用语言：领域专家、开发设计人员都能立即的语言或工具。</li><li>经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。</li><li>使用的模式：<ul><li>关联尽量少，尽量单项，尽量降低整体复杂度。</li><li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li><li>值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。</li><li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li><li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li><li>工厂（Factory）：类似于设计模式中的工厂模式。</li><li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li></ul></li></ul></li><li><a href="http://www.cnblogs.com/Leo_wl/p/3866629.html" target="_blank" rel="noopener">《领域驱动设计(DDD)实现之路》</a><ul><li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li></ul></li><li><a href="http://www.hollischuang.com/archives/553" target="_blank" rel="noopener">《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》</a></li></ul><h3 id="命令查询职责分离-CQRS"><a href="#命令查询职责分离-CQRS" class="headerlink" title="命令查询职责分离(CQRS)"></a>命令查询职责分离(CQRS)</h3><p>CQRS — Command Query Responsibility Seperation</p><ul><li><a href="https://www.cnblogs.com/cnblogsfans/p/4551990.html" target="_blank" rel="noopener">《领域驱动设计系列 (六)：CQRS》</a><ul><li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li></ul></li><li><a href="http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml" target="_blank" rel="noopener">《DDD CQRS架构和传统架构的优缺点比较》</a><ul><li>最终一致的设计理念；依赖于高可用消息中间件。</li></ul></li><li><a href="http://www.cnblogs.com/netfocus/p/4055346.html" target="_blank" rel="noopener">《CQRS架构简介》</a><ul><li>一个实现 CQRS 的抽象案例。</li></ul></li><li><a href="http://www.uml.org.cn/zjjs/201609221.asp" target="_blank" rel="noopener">《深度长文：我对CQRS/EventSourcing架构的思考》</a><ul><li>CQRS 模式分析 + 12306 抢票案例</li></ul></li></ul><h3 id="贫血，充血模型"><a href="#贫血，充血模型" class="headerlink" title="贫血，充血模型"></a>贫血，充血模型</h3><ul><li><a href="https://kb.cnblogs.com/page/520743/" target="_blank" rel="noopener">《贫血，充血模型的解释以及一些经验》</a><ul><li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li><li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li><li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li><li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li><li>作者主张使用贫血模式。</li></ul></li></ul><h2 id="Actor-模式"><a href="#Actor-模式" class="headerlink" title="Actor 模式"></a>Actor 模式</h2><p>TODO</p><h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>TODO</p><h3 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h3><p>TODO</p><h3 id="Vert-x"><a href="#Vert-x" class="headerlink" title="Vert.x"></a>Vert.x</h3><p>TODO</p><h2 id="DODAF2-0"><a href="#DODAF2-0" class="headerlink" title="DODAF2.0"></a>DODAF2.0</h2><ul><li><a href="http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml" target="_blank" rel="noopener">《DODAF2.0方法论》</a></li><li><a href="http://blog.51cto.com/xiaoyong/1553164" target="_blank" rel="noopener">《DODAF2.0之能力视角如何落地》</a></li></ul><h2 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h2><p>无需过多关系服务器的服务架构理念。</p><ul><li><a href="http://www.jdon.com/soa/serverless.html" target="_blank" rel="noopener">《什么是Serverless无服务器架构？》</a><ul><li>Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。</li><li>Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。</li><li>Serverless 不代表某个具体的框架。</li></ul></li><li><a href="http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless" target="_blank" rel="noopener">《如何理解Serverless？》</a><ul><li>依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）</li></ul></li></ul><h2 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h2><ul><li><a href="https://time.geekbang.org/article/2355" target="_blank" rel="noopener">《什么是Service Mesh？》</a></li><li><a href="https://www.jianshu.com/p/e23e3e74538e" target="_blank" rel="noopener">《初识 Service Mesh》</a></li></ul><h1 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h1><h2 id="架构评审"><a href="#架构评审" class="headerlink" title="架构评审"></a>架构评审</h2><ul><li><a href="http://developer.51cto.com/art/201506/478486.htm" target="_blank" rel="noopener">《架构设计之如何评审架构设计说明书》</a></li><li><a href="https://blog.csdn.net/wireless_com/article/details/45935591" target="_blank" rel="noopener">《人人都是架构师：非功能性需求》</a></li></ul><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><ul><li><a href="http://www.infoq.com/cn/articles/architect-12-rules-complete/" target="_blank" rel="noopener">《架构之重构的12条军规》</a></li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ul><li><a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">《阿里巴巴Java开发手册》</a></li></ul><h2 id="代码-Review"><a href="#代码-Review" class="headerlink" title="代码 Review"></a>代码 Review</h2><p>制度还是制度!<br>另外，每个公司需要根据自己的需求和目标制定自己的 check list</p><ul><li><a href="http://www.sohu.com/a/229745352_181657" target="_blank" rel="noopener">《为什么你做不好 Code Review？》</a><ul><li>代码 review 做的好，在于制度建设。</li></ul></li><li><a href="https://blog.csdn.net/uxyheaven/article/details/49773619" target="_blank" rel="noopener">《从零开始Code Review》</a></li><li><a href="https://www.cnblogs.com/zuoping/p/5477047.html" target="_blank" rel="noopener">《Code Review Checklist》</a></li><li><a href="https://dzone.com/articles/java-code-review-checklist" target="_blank" rel="noopener">《Java Code Review Checklist》</a></li><li><a href="https://blog.csdn.net/legend0011/article/details/45585575" target="_blank" rel="noopener">《如何用 gitlab 做 code review》</a></li></ul><h2 id="RUP"><a href="#RUP" class="headerlink" title="RUP"></a>RUP</h2><ul><li><a href="https://blog.csdn.net/apanious/article/details/51011946" target="_blank" rel="noopener">《运用RUP 4+1视图方法进行软件架构设计》</a></li></ul><h2 id="看板管理"><a href="#看板管理" class="headerlink" title="看板管理"></a>看板管理</h2><ul><li><a href="https://blog.csdn.net/tkchen/article/details/51637643" target="_blank" rel="noopener">《说说看板在项目中的应用》</a></li></ul><h2 id="SCRUM"><a href="#SCRUM" class="headerlink" title="SCRUM"></a>SCRUM</h2><p>SCRUM - 争球</p><ul><li><p>3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。</p></li><li><p>3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；</p></li><li><p>五个价值观：专注、勇气、公开、承诺、尊重。</p></li><li><p><a href="https://blog.csdn.net/inny100_100/article/details/54633757" target="_blank" rel="noopener">《敏捷项目管理流程-Scrum框架最全总结！》</a></p></li><li><p><a href="https://blog.csdn.net/superkunkun/article/details/52951142" target="_blank" rel="noopener">《敏捷其实很简单3—敏捷方法之scrum》</a></p></li></ul><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><p>TODO</p><h2 id="极限编程（XP）"><a href="#极限编程（XP）" class="headerlink" title="极限编程（XP）"></a>极限编程（XP）</h2><p>XP - eXtreme Programming</p><ul><li><a href="http://www.woshipm.com/pmd/406917.html" target="_blank" rel="noopener">《主流敏捷开发方法：极限编程XP》</a><ul><li>是一种指导开发人员的方法论。</li><li>4大价值：<ul><li>沟通：鼓励口头沟通，提高效率。</li><li>简单：够用就好。</li><li>反馈：及时反馈、通知相关人。</li><li>勇气：提倡拥抱变化，敢于重构。</li></ul></li><li>5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。</li><li>5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。</li></ul></li></ul><h2 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h2><p>边写码，边review。能够增强代码质量、减少bug。</p><ul><li><a href="http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">《结对编程》</a></li></ul><h2 id="PDCA-循环质量管理"><a href="#PDCA-循环质量管理" class="headerlink" title="PDCA 循环质量管理"></a>PDCA 循环质量管理</h2><p>P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进</p><ul><li><a href="http://www.baike.com/wiki/PDCA" target="_blank" rel="noopener">《PDCA》</a></li></ul><h2 id="FMEA管理模式"><a href="#FMEA管理模式" class="headerlink" title="FMEA管理模式"></a>FMEA管理模式</h2><p>TODO</p><h1 id="通用业务术语"><a href="#通用业务术语" class="headerlink" title="通用业务术语"></a>通用业务术语</h1><p>TODO</p><h1 id="技术趋势"><a href="#技术趋势" class="headerlink" title="技术趋势"></a>技术趋势</h1><p>TODO</p><h1 id="政策、法规"><a href="#政策、法规" class="headerlink" title="政策、法规"></a>政策、法规</h1><h2 id="法律"><a href="#法律" class="headerlink" title="法律"></a>法律</h2><ul><li><p><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95/16843044" target="_blank" rel="noopener">《中华人民共和国网络安全法》</a></p><ul><li>2016年11月7日发布，自2017年6月1日起施行</li></ul></li><li><p><a href="https://baike.baidu.com/item/个人信息保护法/8343360" target="_blank" rel="noopener">《个人信息保护法》</a></p><ul><li>个人信息保护法是一部保护个人信息的法律条款，现尚在制订中，2019全国两会信息安全相关提案中，有政协委员呼吁关注大数据时代隐私保护，加速立法。</li></ul></li><li><p><a href="https://baike.baidu.com/item/最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释/20497481" target="_blank" rel="noopener">《最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》</a></p><ul><li>《解释》共十三条，自2017年6月1日起施行</li></ul><blockquote><ul><li>1、对于行踪轨迹信息、通信内容、征信信息、财产信息，非法获取、出售或者提供50条以上即算“情节严重”；</li><li>2、对于住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息，标准则是 500条以上；</li><li>3、对于其他公民个人信息，标准为 5000条以上。</li></ul></blockquote></li><li><p><a href="https://baike.baidu.com/item/中华人民共和国电子商务法/16467544" target="_blank" rel="noopener">《中华人民共和国电子商务法》</a></p><ul><li>2018年8月31日，十三届全国人大常委会第五次会议表决通过《电子商务法》，自2019年1月1日起施行</li><li><a href="https://v.youku.com/v_show/id_XNDAzNjAyNDM0MA==.html" target="_blank" rel="noopener">解读电子商务法（一）什么是电商</a></li><li><a href="https://v.youku.com/v_show/id_XNDA1OTc0OTQ5Mg==.html" target="_blank" rel="noopener">解读电子商务法（二）电商经营者</a></li><li><a href="https://v.youku.com/v_show/id_XNDA4NzIyNjI4MA==.html" target="_blank" rel="noopener">解读电子商务法（三）电商行为规范</a></li><li><a href="https://v.qq.com/x/page/e08443fc1cr.html" target="_blank" rel="noopener">解读电子商务法（四）电商的法律关系</a></li><li><a href="https://v.youku.com/v_show/id_XNDA4MTQ2Nzk4NA==.html" target="_blank" rel="noopener">解读电子商务法（外传）电商挣钱的秘密</a></li><li><a href="https://v.qq.com/x/page/j0844twjwr5.html" target="_blank" rel="noopener">解读电子商务法（外传）电商模式</a></li></ul></li><li><p><a href="https://blog.csdn.net/a331685690/article/details/79917772" target="_blank" rel="noopener">程序员需要知道的法律常识</a></p></li><li><p><a href="https://time.geekbang.org/column/132" target="_blank" rel="noopener">白话法律42讲-为程序员打造的专属法律武器</a></p></li></ul><h3 id="严格遵守刑法253法条"><a href="#严格遵守刑法253法条" class="headerlink" title="严格遵守刑法253法条"></a>严格遵守刑法253法条</h3><p>我国刑法第253条之一规定：</p><blockquote><ul><li>国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。</li><li>窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 </li><li>单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。</li></ul></blockquote><p>最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”</p><ul><li><a href="https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA" target="_blank" rel="noopener">《非法获取公民个人信息罪》</a></li></ul><h3 id="避风港原则"><a href="#避风港原则" class="headerlink" title="避风港原则"></a>避风港原则</h3><p>“避风港”原则是指在发生著作权侵权案件时，当ISP（网络服务提供商）只提供空间服务，并不制作网页内容，如果ISP被告知侵权，则有删除的义务，否则就被视为侵权。如果侵权内容既不在ISP的服务器上存储，又没有被告知哪些内容应该删除，则ISP不承担侵权责任。 后来避风港原则也被应用在搜索引擎、网络存储、在线图书馆等方面。</p><ul><li><a href="https://baike.baidu.com/item/%E9%81%BF%E9%A3%8E%E6%B8%AF%E5%8E%9F%E5%88%99/588459?fr=aladdin" target="_blank" rel="noopener">《避风港原则》</a></li></ul><h1 id="架构师素质"><a href="#架构师素质" class="headerlink" title="架构师素质"></a>架构师素质</h1><ul><li><a href="http://hellojava.info/?p=430" target="_blank" rel="noopener">《架构师画像》</a><ul><li>业务理解和抽象能力</li><li>NB的代码能力</li><li>全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； </li><li>全局：是否考虑到了对上下游的系统的影响。</li><li>权衡：权衡投入产出比；优先级和节奏控制；</li></ul></li><li><a href="http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know" target="_blank" rel="noopener">《关于架构优化和设计，架构师必须知道的事情》</a><ul><li>要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。</li><li>基础设施、配置、测试、开发、运维综合考虑。</li><li>考虑人、团队、和组织的影响。 </li></ul></li><li><a href="https://www.zhihu.com/question/19841397" target="_blank" rel="noopener">《如何才能真正的提高自己，成为一名出色的架构师？》</a> </li><li><a href="https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129" target="_blank" rel="noopener">《架构师的必备素质和成长途径》</a><ul><li>素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。</li><li>成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 </li></ul></li><li><a href="http://blog.51cto.com/frankfan/1248401" target="_blank" rel="noopener">《架构设计师—你在哪层楼？》</a><ul><li>第一层的架构师看到的只是产品本身</li><li>第二层的架构师不仅看到自己的产品，还看到了整体的方案</li><li>第三层的架构师看到的是商业价值 </li></ul></li></ul><h1 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h1><p>TODO</p><h2 id="招聘"><a href="#招聘" class="headerlink" title="招聘"></a>招聘</h2><h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><h2 id="行业资讯"><a href="#行业资讯" class="headerlink" title="行业资讯"></a>行业资讯</h2><ul><li><a href="http://36kr.com/" target="_blank" rel="noopener">36kr</a></li><li><a href="http://www.techweb.com.cn/" target="_blank" rel="noopener">Techweb</a></li></ul><h2 id="公众号列表"><a href="#公众号列表" class="headerlink" title="公众号列表"></a>公众号列表</h2><p>TODO</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><h3 id="团队博客"><a href="#团队博客" class="headerlink" title="团队博客"></a>团队博客</h3><ul><li><a href="http://jm.taobao.org/" target="_blank" rel="noopener">阿里中间件博客</a></li><li><a href="https://tech.meituan.com" target="_blank" rel="noopener">美团点评技术团队博客</a></li></ul><h3 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h3><ul><li><a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰的网络日志</a></li><li><a href="https://coolshell.cn/" target="_blank" rel="noopener">酷壳 - COOLSHELL-陈皓</a></li><li><a href="http://hellojava.info/" target="_blank" rel="noopener">hellojava-阿里毕玄</a></li><li><a href="http://cmsblogs.com/" target="_blank" rel="noopener">Cm’s Blog</a></li><li><a href="http://blog.didispace.com/" target="_blank" rel="noopener">程序猿DD-翟永超-《Spring Cloud微服务实战》作者</a></li></ul><h2 id="综合门户、社区"><a href="#综合门户、社区" class="headerlink" title="综合门户、社区"></a>综合门户、社区</h2><p><strong>国内：</strong></p><ul><li><a href="http://csdn.net" target="_blank" rel="noopener">CSDN</a><br>老牌技术社区、不必解释。</li><li><a href="http://www.51cto.com/" target="_blank" rel="noopener">51cto.com</a></li><li><a href="http://www.iteye.com/" target="_blank" rel="noopener">ITeye</a><ul><li>偏 Java 方向 </li></ul></li><li><a href="https://www.cnblogs.com" target="_blank" rel="noopener">博客园</a></li><li><a href="http://www.chinaunix.net/" target="_blank" rel="noopener">ChinaUnix</a><ul><li>偏 Linux 方向 </li></ul></li><li><a href="https://www.oschina.net/" target="_blank" rel="noopener">开源中国社区</a></li><li><a href="https://www.infoq.cn/" target="_blank" rel="noopener">InfoQ</a></li><li><a href="http://www.open-open.com/" target="_blank" rel="noopener">深度开源</a></li><li><a href="http://www.jobbole.com/" target="_blank" rel="noopener">伯乐在线</a><ul><li>涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。</li></ul></li><li><a href="http://www.itpub.net/" target="_blank" rel="noopener">ITPUB</a></li><li><a href="https://cloud.tencent.com/developer/column" target="_blank" rel="noopener">腾讯云— 云+社区</a></li><li><a href="https://yq.aliyun.com/" target="_blank" rel="noopener">阿里云— 云栖社区</a></li><li><a href="https://www.ibm.com/developerworks/cn/" target="_blank" rel="noopener">IBM DeveloperWorks</a></li><li><a href="https://toutiao.io/" target="_blank" rel="noopener">开发者头条</a></li><li><a href="http://www.linkedkeeper.com" target="_blank" rel="noopener">LinkedKeeper</a></li></ul><p><strong>国外：</strong></p><ul><li><a href="https://dzone.com" target="_blank" rel="noopener">DZone</a></li><li><a href="https://www.reddit.com" target="_blank" rel="noopener">Reddit</a></li></ul><h2 id="问答、讨论类社区"><a href="#问答、讨论类社区" class="headerlink" title="问答、讨论类社区"></a>问答、讨论类社区</h2><ul><li><a href="https://segmentfault.com" target="_blank" rel="noopener">segmentfault</a><ul><li>问答+专栏 </li></ul></li><li><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a></li><li><a href="https://stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a></li></ul><h2 id="行业数据分析"><a href="#行业数据分析" class="headerlink" title="行业数据分析"></a>行业数据分析</h2><ul><li><a href="http://report.iresearch.cn/" target="_blank" rel="noopener">艾瑞网</a></li><li><a href="https://www.questmobile.com.cn" target="_blank" rel="noopener">QUEST MOBILE</a></li><li><a href="http://data.stats.gov.cn/" target="_blank" rel="noopener">国家数据</a></li><li><a href="http://www.talkingdata.com/" target="_blank" rel="noopener">TalkingData</a></li></ul><h2 id="专项网站"><a href="#专项网站" class="headerlink" title="专项网站"></a>专项网站</h2><ul><li>测试:<ul><li><a href="http://www.ltesting.net/" target="_blank" rel="noopener">领测国际</a> </li><li><a href="https://www.testwo.com/" target="_blank" rel="noopener">测试窝</a></li><li><a href="https://testerhome.com" target="_blank" rel="noopener">TesterHome</a></li></ul></li><li>运维:<ul><li><a href="http://www.yunweipai.com/" target="_blank" rel="noopener">运维派</a> </li></ul></li><li><a href="https://www.abcdocker.com/" target="_blank" rel="noopener">Abcdocker</a></li><li>Java:<ul><li><a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew</a><ul><li>专注于 Java 技术分享</li></ul></li><li><a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a><ul><li>英文博客</li></ul></li></ul></li><li>安全<ul><li><a href="https://www.2cto.com/" target="_blank" rel="noopener">红黑联盟</a> </li><li><a href="http://www.freebuf.com/" target="_blank" rel="noopener">FreeBuf</a></li></ul></li><li>大数据<ul><li><a href="http://www.thebigdata.cn/" target="_blank" rel="noopener">中国大数据</a> </li></ul></li><li>其他专题网站：<ul><li><a href="http://www.infoq.com/cn/" target="_blank" rel="noopener">InfoQ</a><ul><li>偏重于基础架构、运维方向</li></ul></li><li><a href="http://www.dockerinfo.net/" target="_blank" rel="noopener">DockerInfo</a><ul><li>专注于 Docker 应用及咨询、教程的网站</li></ul></li><li><a href="https://www.linuxidc.com/" target="_blank" rel="noopener">Linux公社</a><ul><li>Linux 主题社区</li></ul></li></ul></li></ul><h2 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h2><ul><li><a href="https://github.com/TeamStuQ/skill-map" target="_blank" rel="noopener">程序员技能图谱</a></li></ul><h2 id="推荐参考书"><a href="#推荐参考书" class="headerlink" title="推荐参考书"></a>推荐参考书</h2><h3 id="在线电子书"><a href="#在线电子书" class="headerlink" title="在线电子书"></a>在线电子书</h3><ul><li><p><a href="https://github.com/forezp/SpringCloudLearning" target="_blank" rel="noopener">《深入理解Spring Cloud与微服务构建》</a></p></li><li><p><a href="http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf" target="_blank" rel="noopener">《阿里技术参考图册-研发篇》</a></p></li><li><p><a href="http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf" target="_blank" rel="noopener">《阿里技术参考图册-算法篇》</a></p></li><li><p><a href="http://dpurl.cn/n/1lqcX" target="_blank" rel="noopener">《2018美团点评技术年货（合辑）》70M</a></p></li><li><p><a href="http://www.infoq.com/cn/architect/" target="_blank" rel="noopener">InfoQ《架构师》月刊</a></p></li><li><p><a href="https://www.w3cschool.cn/architectroad/" target="_blank" rel="noopener">《架构师之路》</a></p></li></ul><h3 id="纸质书"><a href="#纸质书" class="headerlink" title="纸质书"></a>纸质书</h3><p><b style="color:red">更多架构方面书籍参考:</b> <a href="https://github.com/sorenduan/awesome-java-books/blob/master/README.md#%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener">awesome-java-books</a></p><h4 id="开发方面"><a href="#开发方面" class="headerlink" title="开发方面"></a>开发方面</h4><ul><li>《阿里巴巴Java开发手册》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BfL5CR" target="_blank" rel="noopener">详情</a></li></ul><h4 id="架构方面"><a href="#架构方面" class="headerlink" title="架构方面"></a>架构方面</h4><ul><li>《软件架构师的12项修炼：技术技能篇》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=rTlo0m" target="_blank" rel="noopener">详情</a></li><li>《架构之美》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=1KECBZ" target="_blank" rel="noopener">详情</a> </li><li>《分布式服务架构》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=hkzqtK" target="_blank" rel="noopener">详情</a> </li><li>《聊聊架构》 <a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=A8Nd6Z" target="_blank" rel="noopener">详情</a> </li><li>《云原生应用架构实践》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=D4WCpd" target="_blank" rel="noopener">详情</a> </li><li>《亿级流量网站架构核心技术》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Rdmd21" target="_blank" rel="noopener">详情</a></li><li>《淘宝技术这十年》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=CoUdGG" target="_blank" rel="noopener">详情</a></li><li>《企业IT架构转型之道-中台战略思想与架构实战》 <a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BxS6eI" target="_blank" rel="noopener">详情</a> </li><li>《高可用架构（第1卷）》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BcjUwS" target="_blank" rel="noopener">详情</a> </li></ul><h4 id="技术管理方面"><a href="#技术管理方面" class="headerlink" title="技术管理方面"></a>技术管理方面</h4><ul><li>《CTO说》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Gl3QAo" target="_blank" rel="noopener">详情</a> </li><li>《技术管理之巅》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=MeloLt" target="_blank" rel="noopener">详情</a></li><li>《网易一千零一夜：互联网产品项目管理实战》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=qPuqMg" target="_blank" rel="noopener">详情</a> </li></ul><h4 id="基础理论-1"><a href="#基础理论-1" class="headerlink" title="基础理论"></a>基础理论</h4><ul><li>《数学之美》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=0seUpO" target="_blank" rel="noopener">详情</a> </li><li>《编程珠玑》<a href="https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=I7jj9r" target="_blank" rel="noopener">详情</a> </li></ul><h4 id="工具方面"><a href="#工具方面" class="headerlink" title="工具方面"></a>工具方面</h4><p>TODO</p><h4 id="大数据方面"><a href="#大数据方面" class="headerlink" title="大数据方面"></a>大数据方面</h4><h1 id="技术资源"><a href="#技术资源" class="headerlink" title="技术资源"></a>技术资源</h1><h2 id="开源资源"><a href="#开源资源" class="headerlink" title="开源资源"></a>开源资源</h2><ul><li><a href="https://github.com" target="_blank" rel="noopener">github</a></li><li><a href="https://www.apache.org/index.html" target="_blank" rel="noopener">Apache 软件基金会</a></li></ul><h2 id="手册、文档、教程"><a href="#手册、文档、教程" class="headerlink" title="手册、文档、教程"></a>手册、文档、教程</h2><p><strong>国内：</strong></p><ul><li><a href="http://w3cschool.cn" target="_blank" rel="noopener">W3Cschool</a> </li><li><a href="http://www.runoob.com/" target="_blank" rel="noopener">Runoob.com</a><ul><li>HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。</li></ul></li><li><a href="https://love2.io/" target="_blank" rel="noopener">Love2.io</a><ul><li>很多很多中文在线电子书，是一个全新的开源技术文档分享平台。</li></ul></li><li><a href="http://gitbook.cn/" target="_blank" rel="noopener">gitbook.cn</a><ul><li>付费电子书。 </li></ul></li><li><a href="http://www.apachecn.org/" target="_blank" rel="noopener">ApacheCN</a><ul><li>AI、大数据方面系列中文文档。</li></ul></li></ul><p><strong>国外：</strong></p><ul><li><a href="http://www.quickcode.co/" target="_blank" rel="noopener">Quick Code</a><ul><li>免费在线技术教程。</li></ul></li><li><a href="http://gitbook.com" target="_blank" rel="noopener">gitbook.com</a><ul><li>有部分中文电子书。</li></ul></li><li><a href="https://www.cheatography.com/" target="_blank" rel="noopener">Cheatography</a><ul><li>Cheat Sheets 大全，单页文档网站。</li></ul></li><li><a href="https://www.tutorialspoint.com/index.htm" target="_blank" rel="noopener">Tutorialspoint</a><ul><li>知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。</li></ul></li></ul><h2 id="在线课堂"><a href="#在线课堂" class="headerlink" title="在线课堂"></a>在线课堂</h2><ul><li><a href="http://www.xuetuwuyou.com/" target="_blank" rel="noopener">学徒无忧</a></li><li><a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a></li><li><a href="https://segmentfault.com/lives" target="_blank" rel="noopener">segmentfault</a></li><li><a href="https://new.stuq.org/course/explore" target="_blank" rel="noopener">斯达克学院</a></li><li><a href="http://nowcoder.com" target="_blank" rel="noopener">牛客网</a></li><li><a href="https://www.jikexueyuan.com/" target="_blank" rel="noopener">极客学院</a></li><li><a href="http://edu.51cto.com/" target="_blank" rel="noopener">51CTO学院</a></li></ul><h2 id="会议、活动"><a href="#会议、活动" class="headerlink" title="会议、活动"></a>会议、活动</h2><ul><li><a href="http://www.infoq.com/cn/qcon/" target="_blank" rel="noopener">QCon</a></li><li><a href="https://archsummit.com" target="_blank" rel="noopener">ArchSummit</a></li><li><a href="http://www.thegitc.com/" target="_blank" rel="noopener">GITC全球互联网技术大会</a></li></ul><p><strong>活动发布平台:</strong> </p><ul><li><a href="http://www.huodongxing.com/" target="_blank" rel="noopener">活动行</a></li></ul><h2 id="常用APP"><a href="#常用APP" class="headerlink" title="常用APP"></a>常用APP</h2><ul><li><a href="https://time.geekbang.org" target="_blank" rel="noopener">极客时间</a></li><li><a href="https://www.igetget.com" target="_blank" rel="noopener">得到</a></li></ul><h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a>找工作</h2><ul><li><a href="https://www.zhipin.com" target="_blank" rel="noopener">Boss直聘</a></li><li><a href="https://www.lagou.com" target="_blank" rel="noopener">拉勾网</a></li><li><a href="https://www.liepin.com" target="_blank" rel="noopener">猎聘</a></li><li><a href="https://cn.100offer.com/" target="_blank" rel="noopener">100Offer</a></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li><a href="https://s.geekbang.org/" target="_blank" rel="noopener">极客搜索</a><ul><li>技术文章搜索引擎。</li></ul></li></ul><h2 id="代码托管"><a href="#代码托管" class="headerlink" title="代码托管"></a>代码托管</h2><ul><li><a href="https://coding.net" target="_blank" rel="noopener">Coding</a></li><li><a href="https://gitee.com/" target="_blank" rel="noopener">码云</a></li></ul><h2 id="文件服务"><a href="#文件服务" class="headerlink" title="文件服务"></a>文件服务</h2><ul><li>七牛</li><li>又拍云</li></ul><h2 id="综合云服务商"><a href="#综合云服务商" class="headerlink" title="综合云服务商"></a>综合云服务商</h2><ul><li>阿里云</li><li><a href="https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c" target="_blank" rel="noopener">腾讯云</a></li><li>百度云</li><li>新浪云</li><li>金山云</li><li><a href="https://amazonaws-china.com/cn/" target="_blank" rel="noopener">亚马逊云(AWS)</a></li><li><a href="https://cloud.google.com/?hl=zh-cn" target="_blank" rel="noopener">谷歌云</a></li><li><a href="https://azure.microsoft.com/zh-cn/" target="_blank" rel="noopener">微软云</a></li></ul><h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><ul><li><a href="http://linode.com" target="_blank" rel="noopener">Linode</a></li><li><a href="https://www.digitalocean.com" target="_blank" rel="noopener">DigitalOcean</a></li><li><a href="https://www.vultr.com/" target="_blank" rel="noopener">Vultr</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;转载原文：&lt;a href=&quot;https://github.com/xingshaocheng/architect-awesome&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/xingshao
      
    
    </summary>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="转载" scheme="http://QQ876684433.github.io/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>精通Java之路-学习计划</title>
    <link href="http://QQ876684433.github.io/2019/07/16/%E7%B2%BE%E9%80%9AJava%E4%B9%8B%E8%B7%AF-%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://QQ876684433.github.io/2019/07/16/精通Java之路-学习计划/</id>
    <published>2019-07-16T01:22:52.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精通Java之路-学习计划"><a href="#精通Java之路-学习计划" class="headerlink" title="精通Java之路-学习计划"></a>精通Java之路-学习计划</h1><h2 id="玩好JDK"><a href="#玩好JDK" class="headerlink" title="玩好JDK"></a>玩好JDK</h2><blockquote><p>转载信息</p><p>作者：老刘</p><p>链接：<a href="https://www.zhihu.com/question/328775413/answer/741689212" target="_blank" rel="noopener">https://www.zhihu.com/question/328775413/answer/741689212</a></p><p>来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h3 id="Java运行时环境"><a href="#Java运行时环境" class="headerlink" title="Java运行时环境"></a>Java运行时环境</h3><p>学习资料：《深入理解Java虚拟机 周志明 第二版》、《Java虚拟机规范 Java SE8版》</p><p>目标：对Java虚拟机有深入的理解，能够动手实现Java虚拟机核心功能</p><p>方式：阅读书籍并撰写阅读笔记，完成实现Java虚拟机的开源项目</p><blockquote><p>所以，对于JVM，没什么可说的，就是往死里学，往死里研究，能有多深就多深！</p></blockquote><h3 id="Java的基础类库"><a href="#Java的基础类库" class="headerlink" title="Java的基础类库"></a>Java的基础类库</h3><p>学习资料：jdk源码、各源码类技术博客、Oracle官方Java tutorial、《Java编程思想》</p><h4 id="第一级别：精读源码"><a href="#第一级别：精读源码" class="headerlink" title="第一级别：精读源码"></a>第一级别：精读源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.io</span><br><span class="line">java.lang</span><br><span class="line">java.util</span><br><span class="line"><span class="comment">// 除了Exception和Error这一类的</span></span><br></pre></td></tr></table></figure><p>目标：深入理解jdk源码的设计原则、编程思想，包括里面使用到的数据结构、算法等知识，精通相关API的使用，能够实现上述类库的核心功能</p><p>方式：阅读源码并撰写源码阅读笔记，完成类库核心功能的开源项目</p><h4 id="第二级别：深刻理解"><a href="#第二级别：深刻理解" class="headerlink" title="第二级别：深刻理解"></a><strong>第二级别：深刻理解</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect</span><br><span class="line">java.net</span><br><span class="line">javax.net.*</span><br><span class="line">java.nio.*</span><br><span class="line">java.util.concurrent.*</span><br></pre></td></tr></table></figure><p>目标：熟练掌握类库的使用，对类库的设计有较为深入的理解，包括类库设计背后的计算机基础知识（操作系统、网络等），并对核心功能的源码有深入的研究</p><p>方式：研究类库的使用方法及常见并撰写学习笔记</p><blockquote><p>举个例子，反射你要了解清楚的话，你是不是要搞明白JVM的类加载机制？网络IO要搞清楚的话，你是不是要清楚TCP/IP和HTTP、HTTPS？包括并发包，如果你要搞清楚的话，是不是要了解并发的相关知识？因此，这四个包要彻底搞清楚，还是需要花费一定时间和精力的。但是，请相信我，这绝对是值得的，甚至可以说，这四个包用的够不够叼，基本决定了一个Java程序员所处的档次。</p></blockquote><h4 id="第三级别：会用即可"><a href="#第三级别：会用即可" class="headerlink" title="第三级别：会用即可"></a><strong>第三级别：会用即可</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">java.lang.annotation</span><br><span class="line">javax.annotation.*</span><br><span class="line">java.lang.ref</span><br><span class="line">java.math</span><br><span class="line">java.rmi.*</span><br><span class="line">javax.rmi.*</span><br><span class="line">java.security.*</span><br><span class="line">javax.security.*</span><br><span class="line">java.sql</span><br><span class="line">javax.sql.*</span><br><span class="line">javax.transaction.*</span><br><span class="line">java.text</span><br><span class="line">javax.xml.*</span><br><span class="line">org.w3c.dom.*</span><br><span class="line">org.xml.sax.*</span><br><span class="line">javax.crypto.*</span><br><span class="line">javax.imageio.*</span><br><span class="line">javax.jws.*</span><br><span class="line">java.util.jar</span><br><span class="line">java.util.logging</span><br><span class="line">java.util.prefs</span><br><span class="line">java.util.regex</span><br><span class="line">java.util.zip</span><br></pre></td></tr></table></figure><p>目标：了解上述类库的API及其应用场景</p><p>方式：学习常见API的功能并撰写学习笔记</p><p><em>ps：这些类库都是有特定的应用场景的，可以留到实际开发中遇到时再作深入研究</em></p><blockquote><p>就像sql包和transaction包，就是操作数据库时用到的。而xml、dom和sax这些，都是操作xml时用到的。其它的包也都是类似的，有使用注解时用的，有远程方法调用时用的，也有涉及到加密时用到的等等</p></blockquote><h4 id="四级别：直接无视"><a href="#四级别：直接无视" class="headerlink" title="四级别：直接无视"></a><strong>四级别：直接无视</strong></h4><p><del>能走到这一步，应该来说已经达到了熟悉/熟练使用Java的境界了，但是离精通Java还差得远</del></p><h3 id="Java的开发工具"><a href="#Java的开发工具" class="headerlink" title="Java的开发工具"></a>Java的开发工具</h3><blockquote><p>如果你有兴趣的话，也可以自己去JDK的bin目录下找找，看有没有什么更好玩的工具</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">steve<span class="meta">@ubuntu</span>-<span class="number">17</span>-<span class="number">10</span>:~$ ls /usr/lib/jvm/jdk1.8.0_201/bin/</span><br><span class="line">appletviewer  javafxpackager  jdb      jrunscript    pack200      unpack200</span><br><span class="line">ControlPanel  javah           jdeps    jsadebugd     policytool   wsgen</span><br><span class="line">extcheck      javap           jhat     jstack        rmic         wsimport</span><br><span class="line">idlj          javapackager    jinfo    jstat         rmid         xjc</span><br><span class="line">jar           java-rmi.cgi    jjs      jstatd        rmiregistry</span><br><span class="line">jarsigner     javaws          jmap     jvisualvm     schemagen</span><br><span class="line">java          jcmd            jmc      keytool       serialver</span><br><span class="line">javac         jconsole        jmc.ini  native2ascii  servertool</span><br><span class="line">javadoc       jcontrol        jps      orbd          tnameserv</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;精通Java之路-学习计划&quot;&gt;&lt;a href=&quot;#精通Java之路-学习计划&quot; class=&quot;headerlink&quot; title=&quot;精通Java之路-学习计划&quot;&gt;&lt;/a&gt;精通Java之路-学习计划&lt;/h1&gt;&lt;h2 id=&quot;玩好JDK&quot;&gt;&lt;a href=&quot;#玩好JD
      
    
    </summary>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb开发笔记</title>
    <link href="http://QQ876684433.github.io/2019/07/14/JavaWeb%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://QQ876684433.github.io/2019/07/14/JavaWeb开发笔记/</id>
    <published>2019-07-14T15:27:20.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaWeb开发学习笔记"><a href="#JavaWeb开发学习笔记" class="headerlink" title="JavaWeb开发学习笔记"></a>JavaWeb开发学习笔记</h1><h2 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h2><h3 id="Java基础（一）"><a href="#Java基础（一）" class="headerlink" title="Java基础（一）"></a>Java基础（一）</h3><h4 id="Java正则表达式"><a href="#Java正则表达式" class="headerlink" title="Java正则表达式"></a>Java正则表达式</h4><p>（1）参考博客：<a href="https://segmentfault.com/a/1190000009162306" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009162306</a></p><p>（2）对于<code>*?</code>这个符号，</p><blockquote><p>如果 <code>?</code> 是限定符 <code>*</code> 或 <code>+</code> 或 <code>?</code> 或 <code>{}</code> 后面的第一个字符，那么表示<strong>非贪婪模式</strong>（尽可能少的匹配字符），而不是默认的<strong>贪婪模式</strong></p></blockquote><p>意思是，正则表达式匹配时从左往右扫描，当已扫描的字符串片段已经符合正则规则，则将其提取出来，即使再往后扫描一个字符依然符合这个规则，用代码解释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"Hello###, world!"</span>;</span><br><span class="line">        String pattern1 = <span class="string">"([#]&#123;2,&#125;?)"</span>;</span><br><span class="line">        String pattern2 = <span class="string">"([#]&#123;2,&#125;)"</span>;</span><br><span class="line">        System.out.println(str.replaceAll(pattern1, <span class="string">"&amp;"</span>));</span><br><span class="line">        System.out.println(str.replaceAll(pattern2, <span class="string">"%"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello&amp;#, world!</span><br><span class="line">Hello%, world!</span><br></pre></td></tr></table></figure><p>可以看出，在{}后面使用了?后，正则的匹配是<strong>非贪婪模式</strong>，扫描到<code>##</code>时，就已经满足pattern1的规则，故不再扫描到第三个#，而pattern2使用<strong>贪婪模式</strong>，因此匹配的是<code>###</code></p><p>（3）分组和反向引用</p><blockquote><p>小括号 <code>()</code> 可以达到对正则表达式进行分组的效果。</p></blockquote><blockquote><p>在以正则表达式替换字符串的语法中，是通过 <code>$</code> 来引用分组的反向引用，<code>$0</code> 是匹配完整模式的字符串（注意在 JavaScript 中是用 <code>$&amp;</code> 表示）；<code>$1</code> 是第一个分组的反向引用；<code>$2</code> 是第二个分组的反向引用，以此类推。</p></blockquote><blockquote><p><code>String pattern = &quot;(\\w)(\\s+)([.,])&quot;;</code>使用了 <code>[.]</code> 来匹配普通字符 <code>.</code> 而不需要使用 <code>[\\.]</code>。因为正则对于 <code>[]</code> 中的 <code>.</code>，会自动处理为 <code>[\.]</code>，即普通字符 <code>.</code> 进行匹配。</p></blockquote><blockquote><p>在小括号 <code>()</code> 内的模式开头加入 <code>?:</code>，那么表示这个模式仅分组，但不创建反向引用。</p></blockquote><blockquote><p>在小括号中使用 <code>?&lt;name&gt;</code> 将小括号中匹配的内容保存为一个名字为 name 的副本。</p></blockquote><p>（4）Matcher、Pattern类的基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String text = <span class="string">"Hello Regex!"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">"\\w+"</span>);</span><br><span class="line"><span class="comment">// Java 中忽略大小写，有两种写法：</span></span><br><span class="line"><span class="comment">// Pattern pattern = Pattern.compile("\\w+", Pattern.CASE_INSENSITIVE);</span></span><br><span class="line"><span class="comment">// Pattern pattern = Pattern.compile("(?i)\\w+"); // 推荐写法</span></span><br><span class="line">Matcher matcher = pattern.matcher(text);</span><br><span class="line"><span class="comment">// 遍例所有匹配的序列</span></span><br><span class="line"><span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.print(<span class="string">"Start index: "</span> + matcher.start());</span><br><span class="line">    System.out.print(<span class="string">" End index: "</span> + matcher.end() + <span class="string">" "</span>);</span><br><span class="line">    System.out.println(matcher.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Pattern.compile(正则表达式)</code>返回Pattern对象，Pattern类的构造函数是私有的，不能通过new来创建</li><li><code>pattern.matcher(字符串)</code>使用已经解析出来的pattern对象取匹配要处理的字符串，返回Matcher对象</li><li>关于Matcher类和Pattern类，参考：<a href="https://blog.csdn.net/yin380697242/article/details/52049999" target="_blank" rel="noopener">https://blog.csdn.net/yin380697242/article/details/52049999</a></li></ul><blockquote><p>Pattern类<br>常用方法及介绍</p><p><code>Pattern complie(String regex)</code><br>由于Pattern的构造函数是私有的,不可以直接创建,所以通过静态方法compile(String regex)方法来创建,将给定的正则表达式编译并赋予给Pattern类</p><p><code>String pattern()</code> 返回正则表达式的字符串形式,其实就是返回Pattern.complile(String regex)的regex参数</p><p><code>Pattern.matcher(CharSequence input)</code> 对指定输入的字符串创建一个Matcher对象</p><p><code>Pattern.quote(String s)</code> 返回给定的字符串的字面量</p><p><code>matches()</code>方法编译给定的正则表达式并且对输入的字串以该正则表达式为模开展匹配,该方法适合于该正则表达式只会使用一次的情况,也就是只进行一次匹配工作,因为这种情况下并不需要生成一个Matcher实例</p></blockquote><blockquote><p>Matcher类 常用方法及介绍</p><p><code>boolean matches()</code> 最常用方法:尝试对整个目标字符展开匹配检测,也就是只有整个目标字符串完全匹配时才返回真值</p><p><code>boolean lookingAt()</code> 对前面的字符串进行匹配,只有匹配到的字符串在最前面才会返回true</p><p><code>boolean find()</code> 对字符串进行匹配,匹配到的字符串可以在任何位置</p><p><code>int start()</code> 返回当前匹配到的字符串在原目标字符串中的位置</p><p><code>int end()</code> 返回当前匹配的字符串的最后一个字符在原目标字符串中的索引位置</p><p><code>String group()</code> 返回匹配到的子字符串</p></blockquote><ul><li>对同一个Matcher对象，如果上一次find()方法调用成功，那么它会记录下上次match的start和end，当再一次执行find时，Matcher会在end后面继续匹配，而不是从头开始</li><li>Java正则源码解析参考：<a href="https://blog.csdn.net/li20081006/article/details/21999779" target="_blank" rel="noopener">https://blog.csdn.net/li20081006/article/details/21999779</a></li></ul><h4 id="Java基本运算符"><a href="#Java基本运算符" class="headerlink" title="Java基本运算符"></a>Java基本运算符</h4><p>（1）&amp;和&amp;&amp;的异同</p><blockquote><p><strong>电路问题：</strong></p><p>对于：&amp;   – &gt;  不管怎样，都会执行”&amp;”符号左右两边的程序</p><p>对于：&amp;&amp; – &gt;  只有当符号”&amp;&amp;”左边程序为真(true)后，才会执行符号”&amp;&amp;”右边的程序。</p><p><strong>运算规则：</strong></p><p>对于：&amp;  – &gt;  只要左右两边有一个为false，则为false；只有全部都为true的时候，结果为true</p><p>对于：&amp;&amp; – &gt; 只要符号左边为false，则结果为false；当左边为true，同时右边也为true，则结果为true</p><p>——来源：<a href="https://www.cnblogs.com/hongten/p/hongten_java_yu.html" target="_blank" rel="noopener">https://www.cnblogs.com/hongten/p/hongten_java_yu.html</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operatorTest</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; !str.equals(<span class="string">" "</span>)) System.out.println(<span class="string">"str != null &amp;&amp; !str.equals(\"\")"</span>);</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp; !str.equals(<span class="string">" "</span>)) System.out.println(<span class="string">"str != null &amp; !str.equals(\"\")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 第二个判断条件会抛出异常</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>&amp;可以是按位与运算和逻辑与运算，&amp;&amp;只能是逻辑与运算</p><p>（2）|和||的异同</p><p>类似于（1）中的&amp;和&amp;&amp;，||和|都是表示“或”，区别是||只要满足第一个条件，后面的条件就不再判断，而|要对所有的条件进行判断</p><h4 id="基本数据类型及其包装类"><a href="#基本数据类型及其包装类" class="headerlink" title="基本数据类型及其包装类"></a>基本数据类型及其包装类</h4><p>（1）参考博客：<a href="https://alexyyek.github.io/2014/12/29/wrapperClass/" target="_blank" rel="noopener">https://alexyyek.github.io/2014/12/29/wrapperClass/</a></p><p>（2）自动装箱和自动拆箱</p><p>简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>; <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> index = i;  <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer test = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> f = test.intValue();</span><br></pre></td></tr></table></figure><p>这种写法会抛出空指针异常，编译不通过，因为将null赋值给Integer，这个时候不会进行自动装箱，也就没有创建Integer实例</p><p>（2）实现机制：在装箱的时候自动调用的是Integer的<code>valueOf(int)</code>方法。而在拆箱的时候自动调用的是Integer的<code>intValue()</code>方法。对其他的类型也类似，<strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的xxxValue方法实现的。（xxx代表对应的基本数据类型）</strong></p><p>（3）关于null、void和Void的一些比较</p><blockquote><p>void不是函数，是方法的修饰符，void的意思是该方法没有返回值，意思就是方法只会运行方法中的语句，但是不返回任何东西。 java.lang.Void是一种类型。例如给Void引用赋值null。通过Void类的源代码可以看到，Void类型不可以继承与实例化。</p></blockquote><ul><li><a href="https://blog.csdn.net/f641385712/article/details/80409211" target="_blank" rel="noopener">https://blog.csdn.net/f641385712/article/details/80409211</a></li><li><a href="https://blog.csdn.net/claram/article/details/52053798" target="_blank" rel="noopener">https://blog.csdn.net/claram/article/details/52053798</a></li></ul><p>摘录一些比较重要的知识如下：</p><ul><li><p>如果使用了带有null值的引用类型变量，instanceof操作将会返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出是false</span></span><br><span class="line">BoxingAndUnboxingTest test = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(test <span class="keyword">instanceof</span> BoxingAndUnboxingTest);</span><br></pre></td></tr></table></figure></li><li><p>可以使用或者!=操作来比较null值，但是不能使用其他算法或者逻辑操作，例如小于或者大于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">null</span>;</span><br><span class="line">Integer j = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(i == j);</span><br><span class="line">System.out.println(i &gt; j);</span><br></pre></td></tr></table></figure><p>输出是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException</span><br><span class="line">at tk.chph.demo.box.BoxingAndUnboxingTest.test5(BoxingAndUnboxingTest.java:<span class="number">16</span>)</span><br><span class="line">at tk.chph.demo.box.BoxingAndUnboxingTest.main(BoxingAndUnboxingTest.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure></li><li><p>class关键字用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Void.class); <span class="comment">//class java.lang.Void</span></span><br><span class="line">System.out.println(<span class="keyword">void</span>.class); <span class="comment">//void</span></span><br><span class="line"><span class="comment">//类似于下面的</span></span><br><span class="line">System.out.println(Integer.class); <span class="comment">//class java.lang.Integer</span></span><br><span class="line">System.out.println(<span class="keyword">int</span>.class); <span class="comment">//int</span></span><br></pre></td></tr></table></figure></li><li><p>Void类的用法：</p><ul><li><p>用于反射中判断某方法的返回值是否为void</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Method method : Test.class.getMethods()) &#123;</span><br><span class="line"><span class="comment">//判断返回值类型 用到了Void类</span></span><br><span class="line"><span class="keyword">if</span>(method.getReturnType().equals(Void.TYPE)) &#123;</span><br><span class="line">System.out.println(method.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为equals方法中不能传递关键字void，其中Void.TYPE源代码是<code>public static final Class&lt;Void&gt; TYPE = (Class&lt;Void&gt;) Class.getPrimitiveClass(&quot;void&quot;);</code></p></li><li><p>使用泛型时函数并不需要返回结果或某个对象不需要值时候这是可以使用java.lang.Void类型表示</p></li><li><p>==操作符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoUnboxingTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">        Integer b = <span class="number">3</span>;                  <span class="comment">// 将3自动装箱成Integer类型</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">        System.out.println(a == b);     <span class="comment">// false 两个引用没有引用同一对象</span></span><br><span class="line">        System.out.println(a == c);     <span class="comment">// true a自动拆箱成int类型再和c比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h4><p>（1）参考博客：<a href="https://my.oschina.net/mojiewhy/blog/177473" target="_blank" rel="noopener">https://my.oschina.net/mojiewhy/blog/177473</a></p><p>（2）主要有<code>getBytes(Charset charset)</code>和<code>String(byte bytes[], String charsetName)</code>两个方法：</p><blockquote><p><code>getBytes(Charset charset)</code>：Encodes this {@code String} into a sequence of bytes using the charset, storing the result into a new byte array.</p><p><code>String(byte bytes[], String charsetName)</code>：Constructs a new {@code String} by decoding the specified array of bytes using the specified {@linkplain java.nio.charset.Charset charset}.</p></blockquote><ul><li>字符串在java中统一用unicode表示( 即utf-16 LE)</li></ul><blockquote><p>Case mapping is based on the Unicode Standard version specified by the {@link java.lang.Character Character} class.</p></blockquote><ul><li><p>对于<code>String gbkStr = &quot;你好哦!&quot;;</code>这个方法：</p><p>如果源码文件是GBK编码, 操作系统（windows）默认的环境编码为GBK，那么编译时,  JVM将 按照GBK编码将字节数组解析成字符，然后将字符转换为unicode格式的字节数组，<strong>作为内部存储</strong>。</p><p>当打印这个字符串时，JVM 根据操作系统本地的语言环境，将unicode转换为GBK，然后操作系统将GBK格式的内容显示出来。</p></li><li><p><code>str.getBytes(Charset charset)</code>是按照给定的编码方式charset，将str内部存储的字节数据（实际上String类的内部实现里是维护一个私有的byte数组的）转换成一个新的byte数组并返回，这个时候新的byte数组的编码方式就是charset了</p></li><li><p><code>new String(bytes, charset)</code>是使用charset这个编码来对字节数组bytes进行解码，得到新的字符串，这个字符串内部依然会维护一个byte数组，编码方式就是charset指定的</p></li><li><p><strong>getBytes 和 new String() 来进行编码转换</strong>，核心工作都是在getbytes这个方法内部实现了，即将原编码方式的byte数组转换成给定的新的编码方式的byte数组，这时候实际上就已经完成了编码转换，new String只是按照新的编码方式将byte数组转出字符串对象而已，便于进行输出</p></li><li><p><strong>如何正确的将GBK转UTF-8 ? （实际上是unicode转UTF-8)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用getBytes将unicode字符串转成UTF-8格式的字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] utf8Bytes = gbkStr.getBytes(<span class="string">"UTF-8"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后用utf-8 对这个字节数组解码成新的字符串</span></span><br><span class="line">String utf8Str = <span class="keyword">new</span> String(utf8Bytes, <span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化后就是:</span></span><br><span class="line">unicodeToUtf8 (String s) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String( s.getBytes(<span class="string">"utf-8"</span>) , <span class="string">"utf-8"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UTF-8 转GBK原理也是一样</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String( s.getBytes(<span class="string">"GBK"</span>) , <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure></li><li><p>String类默认的编码是UTF-8（参考：<a href="https://blog.csdn.net/sugar_rainbow/article/details/76945323" target="_blank" rel="noopener">https://blog.csdn.net/sugar_rainbow/article/details/76945323</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"数据结构与算法"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes(<span class="string">"utf8"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">byte</span> b : str.getBytes()) &#123;</span><br><span class="line">System.out.print(b);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">System.out.print(b);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(bytes, <span class="string">"unicode"</span>));</span><br></pre></td></tr></table></figure><p>输出结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-26-107-80-26-115-82-25-69-109-26-98-124-28-72-114-25-82-105-26-77-107</span><br><span class="line">-26-107-80-26-115-82-25-69-109-26-98-124-28-72-114-25-82-105-26-77-107</span><br><span class="line">냦趮鏦麄軧꺗�</span><br></pre></td></tr></table></figure><p>可见，<code>getBytes(&quot;utf8&quot;)</code>和<code>getBytes()</code>返回的byte数组是一样的，而且最后一句可以看到，utf-8和Unicode是不一样的</p></li><li><p>不同的编码在Java中所占用的字节数：<a href="https://www.cnblogs.com/Qian123/p/5799835.html" target="_blank" rel="noopener">https://www.cnblogs.com/Qian123/p/5799835.html</a></p></li></ul><h4 id="String-、StringBuffer和StringBuilder"><a href="#String-、StringBuffer和StringBuilder" class="headerlink" title="String 、StringBuffer和StringBuilder"></a>String 、StringBuffer和StringBuilder</h4><p>（1）参考：<a href="https://blog.csdn.net/weixin_41101173/article/details/79677982" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41101173/article/details/79677982</a></p><table><thead><tr><th align="center">String</th><th align="center">StringBuffer</th><th align="center">StringBuilder</th></tr></thead><tbody><tr><td align="center">String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td><td align="center">是可变类和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的<strong>缓冲区容量</strong>，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td><td align="center">可变类，速度更快</td></tr><tr><td align="center">不可变</td><td align="center">可变</td><td align="center">可变</td></tr><tr><td align="center"></td><td align="center">线程安全</td><td align="center">线程不安全</td></tr><tr><td align="center"></td><td align="center">多线程操作字符串</td><td align="center">单线程操作字符串</td></tr></tbody></table><h3 id="Java基础（二）"><a href="#Java基础（二）" class="headerlink" title="Java基础（二）"></a>Java基础（二）</h3><h4 id="数组（Array）和列表（ArrayList）的区别"><a href="#数组（Array）和列表（ArrayList）的区别" class="headerlink" title="数组（Array）和列表（ArrayList）的区别"></a>数组（Array）和列表（ArrayList）的区别</h4><p>（1）参考：<a href="https://blog.csdn.net/m0_37683661/article/details/78778483" target="_blank" rel="noopener">https://blog.csdn.net/m0_37683661/article/details/78778483</a></p><table><thead><tr><th></th><th>Array</th><th>ArrayList</th></tr></thead><tbody><tr><td>空间大小</td><td>空间大小是固定的，空间不够时也不能再次申请，所以需要事前确定合适的空间大小</td><td>动态增长，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够</td></tr><tr><td>存储内容</td><td>Array数组可以包含基本类型和对象类型；Array数组在存放的时候一定是<strong>同种类型的元素</strong></td><td>ArrayList却<strong>只能包含对象类型</strong>；ArrayList可以存储不同类型的对象，因为ArrayList可以存储Object</td></tr><tr><td>方法</td><td></td><td>添加全部addAll()、删除全部removeAll()、返回迭代器iterator()等</td></tr><tr><td>应用场景</td><td>如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里</td><td>如果需要频繁对数组进行增删改查操作，使用ArrayList会很方便；但是如果需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，使用ArrayList的效率很低，而使用Array进行这样的动作很麻烦，那么，我们可以考虑选择LinkedList</td></tr></tbody></table><p>（2）值得注意的是，Array中的包装类和基本类型可以混用（本质上是自动装箱和自动拆箱）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = <span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">2</span>] = Integer.valueOf(<span class="string">"2"</span>);</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer i : arr) System.out.println(i);</span><br></pre></td></tr></table></figure><p>for循环使用的是Integer，所以null可以正常输出，如果改成int，那么null就会报错，因为没法自动拆箱成基本类型</p><h4 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h4><p>（1）首先，Java内的传递使用的都是<strong>值传递</strong>，这里面有两层意思：</p><ul><li><p>对于基本数据类型，传递的是变量的值</p></li><li><p>对于对象的引用传递，传递的只是对象引用的值（即只是传递引用指向的对象的地址，而不是对象本身，也不是<strong>对象的引用的引用</strong>）</p></li><li><p>参考博客：<a href="https://blog.csdn.net/javazejian/article/details/51192130" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/51192130</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValue</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> User user=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> User stu=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换两个对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(User x,User y)</span></span>&#123;</span><br><span class="line">User temp =x;</span><br><span class="line">x=y;</span><br><span class="line">y=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">user = <span class="keyword">new</span> User(<span class="string">"user"</span>,<span class="number">26</span>);</span><br><span class="line">stu = <span class="keyword">new</span> User(<span class="string">"stu"</span>,<span class="number">18</span>);</span><br><span class="line">System.out.println(<span class="string">"调用前user的值："</span>+user.toString());</span><br><span class="line">System.out.println(<span class="string">"调用前stu的值："</span>+stu.toString());</span><br><span class="line">swap(user,stu);</span><br><span class="line">System.out.println(<span class="string">"调用后user的值："</span>+user.toString());</span><br><span class="line">System.out.println(<span class="string">"调用后stu的值："</span>+stu.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">调用前user的值：User [name=user, age=26]</span><br><span class="line"></span><br><span class="line">调用前stu的值：User [name=stu, age=18]</span><br><span class="line"></span><br><span class="line">调用后user的值：User [name=user, age=26]</span><br><span class="line"></span><br><span class="line">调用后stu的值：User [name=stu, age=18]</span><br></pre></td></tr></table></figure><p>可以这么理解：<code>Object obj = new Object();</code>变量obj的<strong>值</strong>是新的对象<code>new Objext()</code>的地址，obj在方法调用时<code>call(Object obj1)</code>传递是值传递，<em>就是把obj的值（新对象的地址）拷贝到了obj1中</em>，这时候obj1持有的引用是<code>new Object()</code>，而不是obj，所以obj所做的任何修改只是对对象的修改，而对obj不会产生任何影响，只是副作用是obj指向的对象自身属性可能被（obj1）修改了</p></li></ul><h4 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h4><h5 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h5><p>（1）对于只有一个抽象方法（可以是<strong>重载</strong>的方法）的接口称为<strong>函数式接口</strong>，函数式接口与lambda兼容；实际上Java中的lambda表达式能做的也就是转换为函数式接口而已</p><p>（2）方法引用：使用<code>::</code>操作符来分隔对象或类与方法</p><ul><li>object::instanceMethod（等价于(..)-&gt;object.instanceMethod(..)）</li><li>Class::staticMethod（等价于(..)-&gt;Class.staticMethod(..)）</li><li><strong>Class::instanceMethod</strong></li></ul><p>特别注意的是第三个方法，它的参数列表中第一个参数会成为方法的目标（即调用该方法的对象），例如：<code>String::compareToIngnoreCase</code>等同于<code>(x, y)-&gt;x.compareToIgnoreCase(y)</code></p><p>（3）当有多个同名的重载方法时，编译器会自动选择最符合的那个版本</p><p>（4）lambda表达式中可以有<strong>this</strong>和<strong>super</strong>关键字</p><p>（5）<code>Class::new</code>可以调用一个构造器，具体是哪个构造器会根据上下文进行推导</p><p>（6）lambda表达式的三个部分：</p><ul><li>一个代码块</li><li>参数</li><li>自由变量的值，指的是非参数而且不是在代码块中定义的变量</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> delay)</span></span>&#123;</span><br><span class="line">ActionListener listener = event -&gt; &#123;</span><br><span class="line">        <span class="comment">//注意text变量</span></span><br><span class="line">System.out.println(text);</span><br><span class="line">Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">new</span> Timer(delay, listener).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的text就是自由变量；由于repeatMessage和listener方法不是同步调用的，有可能出现repeatMessage调用结束后，listener才调用，而这时候text这个变量很可能已经被回收了，因此listener要正常运行，必须捕获自由变量的值</p><p>（7）<strong>闭包</strong></p><p>（8）lambda表达式中只能引用值不会改变的变量，而且lambda表达式中捕获的变量必须实际上是最终变量（final或者像String这种不会改变的变量）</p><p>（9）lambda表达式与嵌套块有相同的作用域，因此lambda表达式中声明一个与局部变量同名的参数或者局部变量是不合法的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错：Variable ‘event’ is already defined in the scope</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> delay)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> event = <span class="number">1</span>;</span><br><span class="line">    ActionListener listener = event -&gt; &#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错：Variable ‘i’ is already defined in the scope</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> delay)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    ActionListener listener = event -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（10）lambda表达式中的this关键字是指创建这个lambda表达式的方法的this参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tk.chph.demo.lambda;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Listener"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> LambdaTest().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Lambda Test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Listener listener = () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 这里的this关键字指的都是LambdaTest这个类的实例的引用，而不是listener的引用</span></span><br><span class="line">            <span class="keyword">this</span>.method1();</span><br><span class="line">            method1();</span><br><span class="line">        &#125;;</span><br><span class="line">        listener.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lambda Test</span><br><span class="line">Lambda Test</span><br></pre></td></tr></table></figure><h4 id="各个jdk版本的新特性"><a href="#各个jdk版本的新特性" class="headerlink" title="各个jdk版本的新特性"></a>各个jdk版本的新特性</h4><p>（1）</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>（1）Java中实现一个线程的方法有：</p><ul><li><p>继承Thread类</p></li><li><p>实现Runnable接口</p><p>事实上，Thread类也实现了Runnable接口，并且自动获得了run方法</p></li></ul><p>（2）为什么通过实现Runnable接口来实现线程的方法好？</p><ul><li>因为Java中类是单继承的，如果使用继承Thread类的方式来实现线程，那么他就不能再继承其他的类了</li><li>从面向对象的角度来看，继承一个类的目的更多是在原有类的基础上提供新的特征或者功能；如果我们只是想使用run()方法来使得我们的代码能够和主线程并行运行，实现Runnable接口是个更好的选择</li></ul><p>（3）Java线程的生命周期</p><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/20/5ce1fb9627bff98011.png" alt="Thread in Java.png](https://i.loli.net/2019/05/20/5ce1fb9627bff98011.png)" title>                </div>                <div class="image-caption">Thread in Java.png](https://i.loli.net/2019/05/20/5ce1fb9627bff98011.png)</div>            </figure></p><ul><li>当我们创建实现了Runnable接口或者继承了Thread类的实例后，我们只是创建了一个线程对象（处在图中的<strong>NEW状态</strong>），只有当我们调用start()方法后，这个线程才会启动（这时是在<strong>RUNNABLE状态</strong>），在start方法内部会调用run方法</li><li>处于RUNNABLE状态的线程还不一定在执行，需要等待线程调度器分配CPU资源去运行线程，也就是说，线程的<strong>run方法是由JVM调用的</strong></li><li>run()方法和start方法的区别<ul><li>when program calls start() method a <strong>new Thread</strong> is created and code inside run() method is executed in new Thread</li><li>if you call run()method directly <strong>no new Thread is created</strong> and code inside run() will execute on <strong>current Thread</strong></li><li>Another <strong>difference between start vs run in Java thread</strong> is that you <strong>can not call start() method twice</strong> on thread object. once started, second call of start() will throw <code>IllegalStateException</code> in Java while you can call run() method twice</li></ul></li><li>小知识点<ul><li>线程执行完毕的顺序和线程start的顺序并不一致，这取决于jvm的线程调度器</li><li>当线程中的run方法运行结束后，线程进入<strong>DEAD状态</strong>，这时候再调用start方法，线程也无法再次启动</li></ul></li></ul><p>（4）线程与进程的区别</p><ul><li>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务</li><li>不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间（<strong>堆内存</strong>）</li><li>每个线程都拥有单独的<strong>栈内存</strong>用来存储本地数据</li></ul><p>（5）Java内存模型(JMM)的Happens-before规则</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/20/5ce207dc2cb5916216.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</p></li><li><p>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</p><p>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</p></li><li><p>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</p></li><li><p>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</p></li><li><p>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</p></li><li><p>程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</p></li><li><p>对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</p></li></ul><p>（6）volatile变量</p><blockquote><p>参考：<a href="https://javarevisited.blogspot.com/2011/06/volatile-keyword-java-example-tutorial.html" target="_blank" rel="noopener">https://javarevisited.blogspot.com/2011/06/volatile-keyword-java-example-tutorial.html</a></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/20/5ce20ac393e1935315.png" alt="volatile variable in Java.png" title>                </div>                <div class="image-caption">volatile variable in Java.png</div>            </figure><ul><li><p>Java中的<strong>volatile</strong>关键字是用来指示Java编译器和线程不要缓存这个变量的值，始终都从主存中读取变量的值</p><blockquote><p>Anyway,  the volatile keyword in Java is used as an indicator to Java compiler and Thread that do not cache value of this variable and always read it from main memory</p></blockquote></li><li><p>当我们需要使得对某个变量的读或者写操作是原子性的（例如对int或者boolean变量的读或者写），那么我们可以将其声明为volatile</p><blockquote><p>So if you want to share any variable in which read and write operation is atomic by implementation e.g. read and write in an int or a boolean variable then  you can declare them as volatile variable</p></blockquote></li><li><p>volatile关键字只能用在变量上，不能用在类或者方法上</p><blockquote><p>The Java volatile keyword cannot be used with method or class and it can only be used with a variable</p></blockquote></li><li><p>volatile关键字可以用在多线程环境的单例模式中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton _instance; <span class="comment">//volatile variable </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(_instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">              <span class="keyword">if</span>(_instance == <span class="keyword">null</span>)</span><br><span class="line">              _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> _instance;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不将_instance声明为volatile，其中一个线程在创建了_instance后就失去了CPU资源，这时候其他线程的看到的_instance变量依然是null的，这时候其他线程就有可能再次创建_instance对象，这样Singleton类的实例就有可能不是单例模式的了</p></li></ul><p>（7）如何停止一个线程</p><ul><li><p>JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用</p></li><li><p>当run方法执行结束或者跑出异常时，线程会自动结束（<u><em>简单的说，如果线程运行过程中抛出的异常没有被捕获，该线程将会停止执行</em></u>）</p></li><li><p>可以通过结合volatile设置标记位来手动中断线程的执行</p><ul><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Runner</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> bExit = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">boolean</span> bExit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bExit = bExit;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!bExit)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread is running"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    Logger.getLogger(ThreadTester.class.getName()).log(Level.SEVERE, <span class="keyword">null</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用exit()方法将bExit设置为true时，run方法就会在新一轮迭代开始时检测到，然后终止循环</p></li><li><p>要注意，每个线程都有自己的本地内存，bExit变量也一样，因此要使得bExit值的改变能够立即被其他线程看到，需要将bExit设置为volatile变量</p></li></ul></li></ul><p>（8）线程之间的消息传递</p><ul><li><p>生产者消费者模式：where One thread produce and put something on shared bucket, and then tell other thread that there is an item for your interest in shared object, consumer thread than pick than item and do his job</p></li><li><p>如果不使用wait()和notify()/notifyAll()方式，消费者线程就必须得周期性地轮询bucket（一个共享对象），即使bucket的状态没有发生变化</p></li><li><p><strong>消费者在检查条件的时候，要使用while循环而不是if判断</strong></p><p>主要是为了避免虚假唤醒的情况，这样线程在休眠前和唤醒后都会进行条件的检查；因为有可能有多个线程在条件改变时同时被唤醒，其中的一些线程由于没有得到即使的响应，被其他唤醒的线程将条件改变了，那些没有及时响应的线程在获得CPU资源后，如果使用的是if检查添加，那么它就不会再去检查条件而是直接对共享对象进行操作，导致出错；如果使用的是while检查条件，那么它被唤醒之后，无论如何都回再去检查条件，如果条件没有满足，它会再次进入休眠状态而不是取操作共享对象</p><blockquote><p>While if you call notifyAll method, all threads waiting on that lock will be woken up, but again all woken thread will fight for lock before executing remaining code and that’s why wait is called on loop because if multiple threads are woken up, the thread which will get lock will first execute and it may reset waiting for condition, which will force subsequent threads to <a href="http://javarevisited.blogspot.sg/2011/12/difference-between-wait-sleep-yield.html" target="_blank" rel="noopener">wait</a>.</p></blockquote></li></ul><p>（9）notify()和notifyAll()的区别</p><blockquote><p>The main difference between notify and notifyAll is that notify method will only notify one <a href="http://javarevisited.blogspot.sg/2011/02/how-to-implement-thread-in-java.html" target="_blank" rel="noopener">Thread</a> and notifyAll method will notify all Threads  which are waiting on that monitor or lock</p></blockquote><ul><li><p>notify()唤醒的线程是哪一个是无法保证的，这由线程调度器来决定</p></li><li><p>当我们的程序中唤醒休眠中的线程，最终只会有一个线程会获得资源对共享对象进行操作的时候，我们应该使用notify()而不是notifyAll()，而且这样还能够节省CPU资源</p><blockquote><p>You can use notify over notifyAll if all thread are waiting for the same condition and only one Thread at a time can benefit from condition becoming true. In this case, notify is optimized call over notifyAll because waking up all of them because we know that only one thread will benefit and all other will wait again, so calling notifyAll method is just waste of CPU cycles</p></blockquote></li></ul><p>（10）为什么wait、notify和notifyAll是在Object类中定义的而不是Thread类</p><blockquote><p>参考：<a href="https://javarevisited.blogspot.com/2012/02/why-wait-notify-and-notifyall-is.html" target="_blank" rel="noopener">https://javarevisited.blogspot.com/2012/02/why-wait-notify-and-notifyall-is.html</a></p></blockquote><p>（11）Thread.interrupted和isInterrupted的区别</p><blockquote><p><em>interrupted()</em> 和 <em>isInterrupted()<em>的主要区别是*</em><u>*前者会将中断状态清除而后者不会</u></em>*<em>。Java多线程的中断机制是用内部标识来实现的，调用</em>Thread.interrupt()<em>来中断一个线程就会设置中断标识为true。当中断线程调用<a href="https://link.juejin.im/?target=http%3A%2F%2Fjava67.blogspot.com%2F2012%2F11%2Fwhat-is-static-class-variable-method.html" target="_blank" rel="noopener">静态方法</a></em>Thread.interrupted()*来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p></blockquote><p>（12）如果wait和nofity不在同步块中调用，代码就会抛出IllegalMonitorStateException异常</p><h3 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>（1）接口中的所有方法自动地属于public ，因此, 在接口中声明方法时 , 不必提供关键字<br>public；但是在实现接口时，必须把方法声明为public，否则编译器认为该方法的访问属性是包可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里会报错</span></span><br><span class="line">    <span class="comment">// Error:(4, 10) java: tk.chph.demo.interface_.ImplA中的method1()无法实现tk.chph.demo.interface_.InterfaceA中的method1()正在尝试分配更低的访问权限; 以前为public</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）接口可以定义常量，但是不能有实例域；在jdk8之前，接口中的方法也不能含有实现</p><p>（3）可以使用<code>instanceof</code>检查一个类的实例是否实现了特定的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ImplA() <span class="keyword">instanceof</span> InterfaceA;</span><br></pre></td></tr></table></figure><p>（4）接口中不能包含<strong>实例域</strong>或者<strong>静态方法（1.8之前）</strong>，但是可以包含<strong>常量</strong>；接口中的方法自动的设置为<code>public</code>，而接口中的域也自动被设置为<code>public static final</code></p><p>（5）使用接口不使用抽象类的原因：Java中的类只能扩展一个抽象类或者超类，而可以实现多个接口；多重继承会使得语言本身变得复杂，同时效率低下</p><p>（6）jdk1.8之后interface中允许有静态方法，即static修饰的类方法，但是必须为其提供实现体；同时interface中也允许提供以default修饰的成员方法的默认实现，且默认方法可以调用任何其他的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        method1();</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（7）默认方法冲突：如果一个接口中的一个默认方法和另一个超类或者接口中定义的方法签名相同，这是就产生了默认方法冲突问题，解决方法如下：</p><ul><li><strong>超类优先</strong>：如果超类提供了一个具体方法（如果是抽象的方法，那么实现类要么是实现该方法，要么是让该方法依旧抽象，从这一点来看，超接口的默认方法依然是被忽略的），且签名和默认方法相同，那么具体的实现是选择超类中的实现，忽略超接口的所有同签名方法不论是否是默认的</li><li>（ps：超类优先原则可以保证jdk8之前的代码兼容性，jdk8之后的接口提供签名相同的默认方法并不会造成冲突）</li><li>（pss：默认方法重新定义Object类中的方法无效，因为所有的类都继承自Object，如果为toString或者equals这样的Object类方法定义默认方法，由于类优先原则，Object.toString或者Objects.equals方法会覆盖该默认方法）</li><li><strong>接口冲突</strong>：如果是超接口提供了一个同签名的默认方法，那么实现类必须覆盖该默认方法以解决冲突</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tk.chph.demo.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplA</span> <span class="keyword">extends</span> <span class="title">AbstractA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ImplA().method5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AbstractA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"InterfaceA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"InterfaceB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：AbstractA</p><p>如果将AbstractA这个抽象类去掉，那么输出结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(<span class="number">3</span>, <span class="number">8</span>) java: 类 tk.chph.demo.interface_.ImplA从类型 tk.chph.demo.interface_.InterfaceA 和 tk.chph.demo.interface_.InterfaceB 中继承了method5() 的不相关默认值</span><br></pre></td></tr></table></figure><p>必须在ImplA中覆盖method5方法后才能编译通过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tk.chph.demo.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplA</span> <span class="keyword">implements</span> <span class="title">InterfaceA</span>, <span class="title">InterfaceB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ImplA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ImplA().method5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：ImplA</p><p>当然也可以在ImplA中选择超接口的其中一个method5实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InterfaceA.<span class="keyword">super</span>.method5();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的例子是两个超接口都的冲突默认方法都提供了实现，然而实际上是，InterfaceA和InterfaceB只要至少一个提供了默认方法，那个实现类都必须覆盖该默认方法了</p><h4 id="Comparable-和-Comparator接口"><a href="#Comparable-和-Comparator接口" class="headerlink" title="Comparable 和 Comparator接口"></a>Comparable 和 Comparator接口</h4><p>（1）参考博客：<a href="https://www.cnblogs.com/skywang12345/p/3324788.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3324788.html</a></p><p>（2）若一个类实现了Comparable接口，就意味着“<strong>该类支持排序</strong>”。  “实现Comparable接口的类的对象的List列表(或数组)”，可以通过 Collections.sort（或 Arrays.sort）进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 x.compareTo(y) 来“比较x和y的大小”。若返回“负数”，意味着“x比y小”；返回“零”，意味着“x等于y”；返回“正数”，意味着“x大于y”。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）Comparator 是比较器接口，通过实现Comparator构建一个比较器，可以用来对某个没有实现Comparable接口的类进行排序</p><blockquote><p>也就是说，我们可以通过“<strong>实现Comparator类来新建一个比较器</strong>”，然后通过该比较器对类进行排序。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若一个类要实现Comparator接口：它一定要实现compareTo(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。理由还是“类优先原则”，所有类都继承了Object的equals方法，因此超接口中的equals不用去实现也可以编译通过</p><p>（4）Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p><h4 id="Cloneable接口和clone-方法"><a href="#Cloneable接口和clone-方法" class="headerlink" title="Cloneable接口和clone()方法"></a>Cloneable接口和clone()方法</h4><p>（1）参考博客：<a href="https://www.cnblogs.com/xrq730/p/4858937.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/4858937.html</a></p><p>（2）Cloneable接口</p><ul><li>实现Cloneable接口（该接口是一个标记接口，内部没有任何方法），以指示Object的clone()方法<strong>可以合法地对该类实例进行按字段复制</strong></li><li>如果在<strong>没有实现Cloneable接口的实例上调用Object的clone()方法，则会导致抛出CloneNotSupporteddException</strong></li><li>实现此接口的类应该<strong>使用公共方法重写Object的clone()方法</strong>，Object的clone()方法在定义时是protected的，即只能在java.lang包下的类和子类能够调用clone()方法，所以在重写clone方法时要将修饰符改成public，以便重写的clone方法能够被其他类调用</li></ul><p>（3）clone方法应该满足以下条件：</p><ul><li><strong>x.clone() != x为true</strong></li><li><strong>x.clone().getClass() == x.getClass()为true</strong></li><li>x.clone().equals(x)一般情况下为true，但这并不是必须要满足的要求</li></ul><p>（4）<strong>clone方法不会调用类的构造函数</strong></p><p>（5）<strong>浅克隆和深克隆</strong></p><p>​        浅克隆（shallow clone）和深克隆（deep clone）反映的是，当对象中还有对象的时候，那么：</p><ul><li>浅克隆，即很表层的克隆，如果我们要克隆对象，只克隆它自身以及它所包含的所有<strong>对象的引用地址</strong></li><li>深克隆，克隆除自身对象以外的所有对象，包括自身所包含的<strong>所有对象实例</strong></li></ul><p>（6）其实Object的clone()方法，提供的是一种<strong>浅克隆的机制</strong>，如果想要实现对对象的深克隆，在不引入第三方jar包的情况下，可以使用两种办法：</p><ul><li>先对对象进行序列化，紧接着马上反序列化出</li><li>先调用super.clone()方法克隆出一个新对象来，然后在子类的clone()方法中手动给克隆出来的非基本数据类型（引用类型）赋值，比如ArrayList的clone()方法</li></ul><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>（1）内部类的特点：</p><ul><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据</li><li>可以对同一个包中的其他类隐藏起来</li><li>当要定义一个回调函数且不想编写大量代码时，可以使用<strong>匿名内部类</strong></li></ul><p>（2）内部类可以访问自己定义的成员，也可以访问创建它的外围类对象的成员（包括私有的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tk.chph.demo.inner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 访问外围类的成员变量a</span></span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译class文件后是这样的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerClassTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 注意这里</span></span><br><span class="line">            System.out.println(InnerClassTest.<span class="keyword">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上内部类的对象中有一个<strong>隐式的引用</strong>指向了创建它的外围类的对象；实际上编译器修改了所有内部类的构造函数，添加了一个外围类引用的参数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了便于说明，将外围对象的引用定义为outer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">(InnerClassTest test)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.outer = test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当InnerClassTest创建Inner类时，会这样调用构造函数：<code>Inner inner = new Inner(this);</code>将自身的引用传递到内部类对象中</p><p>（3）只有内部类可以是<strong>私有类</strong>, 而常规类只可以具有包可见性 , 或公有可见性</p><p>（4）内部类对外围类的引用正式语法是：<code>OuterClass.this</code></p><p>（5）外围类对象调用内部类的构造器的正式语法是：<code>outerObject.new InnerClass(construction parameters)</code></p><p>（6）在外围类的作用域外，可以这样引用其内部类：<code>OuterClass.InnerClass</code></p><p>（7）内部类声明的所有静态域都必须是final，原因是我们希望每一个静态域都只有一个实例，但是对每一个外部对象，它都会被分配一个单独的内部类实例（就是说不同外部对象的内部类实例都是不一样的对象），如果内部类静态域不是final，那么就可能出现不是唯一的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="comment">// 报错：Inner classes cannot have static declarations</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 报错：Inner classes cannot have static declarations</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（8）外围类可以访问内部类的任何成员，包括私有的</p><p>（9）局部内部类：定义在一个方法内的类</p><ul><li>据不累不能用public或private访问修饰符声明，因为它的作用域被限制在声明这个局部内部类的块中</li><li>对外部世界，局部内部类可以完全隐藏起来</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tk.chph.demo.inner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（10）局部内部类可以访问其所在块的作用域内的局部变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> InnerClass().test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和lambda的捕获一样，由于可能出现test1方法执行结束后局部变量消失，而内部类还未执行的情况，内部类会在外部块释放局部变量之前，将局部变量进行备份，实际上的实现是这样的：</p><p><u><em>编译器会修改局部内部类的成员和构造函数，开始时先检测局部内部类对局部变量的访问，为每个局部变量建立相应的数据域，然后将局部变量拷贝到构造器中，以便这些局部内部类的数据域初始化为局部变量的副本</em></u></p><p>而且，引用的局部变量必须是final的或者是实际上不变的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 报错：Variable 'a' is accessed from within inner class, needs to be final or effectively final</span></span><br><span class="line">            a = <span class="number">10</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> InnerClass().test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此上面划线部分补充一下，内部类建立的数据域实际上是final的，对它初始化后不能够再进行修改，所以出现<code>a=10</code>时会报错，即使是在内部类外面修改也不行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这里修改</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 报错：Variable 'a' is accessed from within inner class, needs to be final or effectively final</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> InnerClass().test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，只要局部变量被局部内部类引用了，它就必须是final或者实际上的final了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">90</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> InnerClass().test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（11）如果一个类只被创建一个对象，那就不必命名了，这种类称为<strong>匿名内部类</strong></p><ul><li>如果构造参数的括号后面跟一个大括号，那么正在定义的是一个匿名内部类</li><li>由于匿名内部类没有类名，自然就没有构造函数，取而代之的是将构造器参数传递给超类的构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tk.chph.demo.inner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    AbstractClass(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass c = <span class="keyword">new</span> AbstractClass(<span class="number">10</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.i + <span class="string">": "</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        c.test(<span class="string">"steve"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于AbstractClass是抽象类，他不能直接被实例化，new出来的实际上是AbstractClass的一个子类（实现类），这个子类没有类名，是个匿名内部类，没有自己的构造函数，要将构造参数传递给超类的构造器</p><ul><li>匿名内部类（子类）进行<code>getClass() != other.getClass()</code>测试时会失败：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AbstractClass c = <span class="keyword">new</span> AbstractClass(<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.i + <span class="string">": "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">AbstractClass abstractClass = <span class="keyword">new</span> AbstractClass(<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="keyword">this</span>.i + <span class="string">": "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(c.getClass() != abstractClass.getClass());</span><br><span class="line">StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">StringBuilder sb2 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">System.out.println(sb1.getClass() != sb2.getClass());</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span><span class="comment">//注意这个</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>（12）静态内部类</p><ul><li><p>只有内部类可以声明为static，静态内部类除了没有外围类的引用外，其他功能和所有内部类相同</p></li><li><p>静态内部类的初始化实在静态方法中完成的</p></li><li><p>静态内部类可以有静态域和方法</p></li><li><p>声明在接口中的内部类自动成为static和public类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tk.chph.demo.inner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"InnerClass in InterfaceA"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClassA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassA</span></span>&#123;</span><br><span class="line">        <span class="comment">// 静态内部类拥有静态域</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"InnerClassA"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态内部类拥有静态方法，普通的内部类不能拥有静态方法，自然就不能有main方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里直接通过接口名引用接口中定义的内部类</span></span><br><span class="line">            InterfaceA.InnerClass innerClass = <span class="keyword">new</span> InterfaceA.InnerClass();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于方法内部不能用static修饰变量，因此无法在方法内部声明一个静态局部内部类</p></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>（1）可以通过在修饰符（例如public static）后面、返回类型前面添加类型变量&lt;T&gt;来声明一个泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tk.chph.demo.generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）泛型方法的调用是在方法名前面加上&lt;类型变量&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> GenericTest().&lt;String&gt;test1(<span class="string">"string"</span>);</span><br><span class="line">    <span class="comment">// It's also ok like this</span></span><br><span class="line">    <span class="comment">// new GenericTest().test1("string");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然调用时的类型变量是可以省略的，编译器可以通过上下文推断出来</p><h4 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h4><p>（1）可以使用<code>&lt;T extends SuperClass/SuperInterface&gt;</code>的语法来对类型变量T做限定，意思是T是绑定类型的子类型（subtype），这里的extends关键字不是继承的意思，因为绑定类型是接口也是可以的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tk.chph.demo.generic;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceA</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &lt;T extends InterfaceA&gt; <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这时候就会报错：</span></span><br><span class="line">    <span class="comment">// Error:(13, 26) java: 无法将类 tk.chph.demo.generic.GenericTest中的方法 test1应用到给定类型;</span></span><br><span class="line">        <span class="comment">//  需要: T</span></span><br><span class="line">        <span class="comment">//  找到: java.lang.String</span></span><br><span class="line">        <span class="comment">//  原因: 显式类型参数java.lang.String不符合声明的范围tk.chph.demo.generic.InterfaceA</span></span><br><span class="line">        <span class="keyword">new</span> GenericTest().&lt;String&gt;test1(<span class="string">"string"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）一个类型变量或通配符可以有多个限定，限定类型用&amp;分隔，逗号用来分隔类型变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends InterfaceA &amp; Comparable, U extends InterfaceA &amp; Cloneable&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    System.out.println(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）根据Java的继承和实现接口原则，只能够单继承多实现，而且继承在实现前面，所以如果使用类作为限定，它必须是限定列表的第一个</p><h4 id="泛型和虚拟机：类型擦除"><a href="#泛型和虚拟机：类型擦除" class="headerlink" title="泛型和虚拟机：类型擦除"></a>泛型和虚拟机：类型擦除</h4><p>（1）有关 Java 泛型转换的事实 :</p><ul><li>虚拟机中没有泛型 , 只有普通的类和方法 </li><li>所有的类型参数都用它们的限定类型替换 </li><li>桥方法被合成来保持多态 </li><li>为保持类型安全性, 必要时插人强制类型转换</li></ul><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><h4 id="对象的访问方法"><a href="#对象的访问方法" class="headerlink" title="对象的访问方法"></a>对象的访问方法</h4><p>对象Person的<strong>字面量创建</strong>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name : &#123;</span><br><span class="line">  first : <span class="string">'Bob'</span>,</span><br><span class="line">  last : <span class="string">'Smith'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  age : <span class="number">32</span>,</span><br><span class="line">  gender : <span class="string">'male'</span>,</span><br><span class="line">  interests : [<span class="string">'music'</span>, <span class="string">'skiing'</span>],</span><br><span class="line">  bio : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name[<span class="number">0</span>] + <span class="string">' '</span> + <span class="keyword">this</span>.name[<span class="number">1</span>] + <span class="string">' is '</span> + <span class="keyword">this</span>.age + <span class="string">' years old. He likes '</span> + <span class="keyword">this</span>.interests[<span class="number">0</span>] + <span class="string">' and '</span> + <span class="keyword">this</span>.interests[<span class="number">1</span>] + <span class="string">'.'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name[<span class="number">0</span>] + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="点表示法"><a href="#点表示法" class="headerlink" title="点表示法"></a>点表示法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.age</span><br><span class="line">person.interests[<span class="number">1</span>]</span><br><span class="line">person.bio()</span><br></pre></td></tr></table></figure><h5 id="括号表示法"><a href="#括号表示法" class="headerlink" title="括号表示法"></a>括号表示法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="string">'age'</span>]</span><br><span class="line">person[<span class="string">'name'</span>][<span class="string">'first'</span>]</span><br></pre></td></tr></table></figure><p>在这个意义上，使用了<strong>关联了值的名字</strong>，而不是<strong>索引</strong>去选择元素，因此对象有时被称之为关联数组(associative array)——对象做了<strong>字符串到值的映射</strong>，而数组做的是<strong>数字到值的映射</strong>。</p><h5 id="创建对象成员"><a href="#创建对象成员" class="headerlink" title="创建对象成员"></a>创建对象成员</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="string">'eyes'</span>] = <span class="string">'hazel'</span><span class="comment">// 括号表示法</span></span><br><span class="line">person.farewell = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"Bye everybody!"</span>) &#125;<span class="comment">// 点表示法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试新成员</span></span><br><span class="line">person[<span class="string">'eyes'</span>]</span><br><span class="line">person.farewell()</span><br></pre></td></tr></table></figure><p>此外，使用括号表示法可以动态设置成员的名字，而点表示法不可以（点表示法只能接受字面量的成员的名字，不接受变量作为名字）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myDataName = nameInput.value</span><br><span class="line"><span class="keyword">var</span> myDataValue = nameValue.value</span><br><span class="line">person[myDataName] = myDataValue</span><br></pre></td></tr></table></figure><p>这里的nameInput里的值完全可以在运行脚本的时候，通过&lt;input/&gt;标签让用户动态输入</p><h4 id="构建函数和对象"><a href="#构建函数和对象" class="headerlink" title="构建函数和对象"></a>构建函数和对象</h4><h5 id="构建函数"><a href="#构建函数" class="headerlink" title="构建函数"></a>构建函数</h5><p>JavaScript 用一种称为<strong>构建函数</strong>的特殊函数来定义对象和它们的特征</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构建函数是 JavaScript 版本的类。它只定义了对象的属性和方法，除了没有明确创建一个对象和返回任何值和之外，它有了函数所拥有的全部功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Bob'</span>);</span><br></pre></td></tr></table></figure><p>这样使用new，通过构建函数创建了类Person的一个实例（*<u>实际的方法，比如greeting()仍然是定义在类里面， 而不是在对象里面</u>*）</p><h5 id="创建对象的其他方法"><a href="#创建对象的其他方法" class="headerlink" title="创建对象的其他方法"></a>创建对象的其他方法</h5><p>使用<code>Object()</code>构造函数来创建一个新对象。一般对象都有构造函数，它创建了一个空的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>这样创建了一个空的对象person，然后, 可以根据需要, 使用点或括号表示法向此对象添加属性和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person.name = <span class="string">'Chris'</span>;</span><br><span class="line">person[<span class="string">'age'</span>] = <span class="number">38</span>;</span><br><span class="line">person.greeting = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将对象文本传递给Object() 构造函数作为参数， 以便用属性/方法填充它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">  name : <span class="string">'Chris'</span>,</span><br><span class="line">  age : <span class="number">38</span>,</span><br><span class="line">  greeting : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="使用create-方法"><a href="#使用create-方法" class="headerlink" title="使用create()方法"></a>使用create()方法</h5><p>JavaScript有个内嵌的方法<code>Object.create()</code>, 它允许您基于现有对象创建新的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newPerson = <span class="built_in">Object</span>.create(person);</span><br></pre></td></tr></table></figure><p>newPerson和person具有相同的属性和方法，即create方法创建了原对象的一个副本</p><h4 id="JavaScript原型链与继承"><a href="#JavaScript原型链与继承" class="headerlink" title="JavaScript原型链与继承"></a>JavaScript原型链与继承</h4><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ul><li><a href="https://juejin.im/post/58f94c9bb123db411953691b" target="_blank" rel="noopener">https://juejin.im/post/58f94c9bb123db411953691b</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes</a></li></ul><h5 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sonProperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承 Father</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();<span class="comment">//Son.prototype被重写,导致Son.prototype.constructor也一同被重写</span></span><br><span class="line">Son.prototype.getSonVaule = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.sonProperty;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> Son();</span><br></pre></td></tr></table></figure><p>（1）instanceof操作符来测试实例(instance)与原型链中出现过的构造函数，结果就会返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> Father);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> Son);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>（2）使用 <strong>isPrototypeOf()</strong> 方法, 同样只要是原型链中出现过的原型，isPrototypeOf() 方法就会返回true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(Father.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(Son.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h5 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h5><p>即在子类型构造函数的内部调用超类型构造函数，也叫作经典继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Father.call(<span class="keyword">this</span>);<span class="comment">//继承了Father,且向父类型传递参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//"red,blue,green" 可见引用类型值是独立的</span></span><br></pre></td></tr></table></figure><p>这样就保证了原型链中的引用类型的值是独立的，不会被所有实例共享</p><p>这里本质上是Son类通过this来调用Father构造函数中的方法实现，用来构造Son实例，但是Son类、实例和Father类之间<strong>不具有任何继承关系</strong>，因此Father类中定义的方法对Son是不可见的，因为无法通过原型链到达Father类</p><h5 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h5><p>使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">Father.call(<span class="keyword">this</span>,name);<span class="comment">//继承实例属性，第一次调用Father()</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();<span class="comment">//继承父类方法,第二次调用Father()</span></span><br><span class="line">Son.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Father.call(this, name)</code>借用构造函数继承了Father类中的属性，如上一小节所说，这样继承的属性在Son类的不同实例中是独立的；<code>Son.prototype = new Father()</code>修改了Son类的原型，这样Son类的实例就能够通过原型链找到Father类中定义的方法</p><h5 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h5><p>在object()函数内部, 先创建一个临时性的构造函数, 然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">// 创建一个临时性的构造函数</span></span><br><span class="line">F.prototype = o;<span class="comment">// 将传入的对象作为这个构造函数的原型</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();<span class="comment">// 返回这个临时类型的一个新实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上创建的新对象是传入的原对象o的一个浅复制，因为新的对象的原型被设置为了原对象o，所以新对象也就拥有了原对象的引用类型属性，即新对象与原对象的引用类型属性是共享的</p><p>前面提到的Object.create()就是原型继承的规范版本：</p><blockquote><p><strong>object.create()</strong> 接收两个参数:</p><ul><li>一个用作新对象原型的对象</li><li>(可选的)一个为新对象定义额外属性的对象</li></ul></blockquote><p>只有一个参数时，就是上面实现的object方法，如果接受第二个参数，它会将原来的同名属性覆盖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">"Van"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">name : &#123;</span><br><span class="line">value : <span class="string">"Louis"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name);<span class="comment">//"Louis"</span></span><br></pre></td></tr></table></figure><h5 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h5><p>类似工厂模式，在原型继承的基础上，对新创建的对象增加了一些功能，然后再返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> clone = object(original);<span class="comment">//通过调用object函数创建一个新对象</span></span><br><span class="line">clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> clone;<span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="寄生组合式继承-不大明白"><a href="#寄生组合式继承-不大明白" class="headerlink" title="寄生组合式继承*(不大明白)"></a>寄生组合式继承*(不大明白)</h5><p>为了减小组合继承调用两次父类构造函数的开销提出的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">subClass,superClass</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> prototype = object(superClass.prototype);<span class="comment">//创建对象</span></span><br><span class="line">prototype.constructor = subClass;<span class="comment">//增强对象</span></span><br><span class="line">subClass.prototype = prototype;<span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><em>首先通过原型继承创建一个父类的实例，然后通过寄生式继承，为这个实例增加子类的构造函数，最后为子类指定原型为刚刚创建的父类的实例 ？</em></u></p><h5 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h5><p>new运算符实际上做的工作是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = &#123;&#125;;<span class="comment">// 创建了一个空对象obj</span></span><br><span class="line">obj.__proto__ = F.prototype;<span class="comment">// 将这个空对象的__proto__成员指向了F函数对象prototype成员对象</span></span><br><span class="line">F.call(obj);<span class="comment">// 将F函数对象的this指针替换成obj，然后再调用F函数</span></span><br></pre></td></tr></table></figure><blockquote><p>new 操作符调用构造函数的时候，函数内部实际上发生以下变化：</p><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</p><p>2、属性和方法被加入到 this 引用的对象中。</p><p>3、新创建的对象由 this 所引用，并且最后隐式的返回 this.</p></blockquote><h5 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h5><p>（1）当查找某个对象的属性时，JavaScript会沿着原型链一直寻找，直到Object.prototype，如果没有找到的话则会返回undefined</p><p>（2）如果想避免原型链查找，可以通过<code>hasOwnProperty</code>方法，它不会遍历原型链，只会在对象内部查找</p><p>（3）<strong>isPrototypeOf</strong>功能与instanceof相反，它是用来判断该方法所属的对象是不是参数的原型对象，是则返回true，否则返回false</p><p>（4）<code>this instanceof arguments.callee</code> 的值如果为 true 表示是作为构造函数被调用的,如果为 false 则表示是作为普通函数被调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">arguments</span>.callee)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'此处作为构造函数被调用'</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'此处作为普通函数被调用'</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();<span class="comment">//此处作为普通函数被调用</span></span><br><span class="line"><span class="keyword">new</span> f();<span class="comment">//此处作为构造函数被调用</span></span><br></pre></td></tr></table></figure><p>（5）<strong>typeof</strong> 则用以获取一个变量或者表达式的类型，如number，boolean，string，function（函数），object（NULL，数组，对象），undefined</p><h5 id="一般的继承实现方式"><a href="#一般的继承实现方式" class="headerlink" title="一般的继承实现方式"></a>一般的继承实现方式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last, age, gender, interests</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = &#123;</span><br><span class="line">            first,</span><br><span class="line">            last</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.interests = interests;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person.prototype.greeting = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name.first + <span class="string">'.'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params">first, last, age, gender, interests, subject</span>) </span>&#123;</span><br><span class="line">        Person.call(<span class="keyword">this</span>, first, last, age, gender, interests);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Teacher.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到这里的时候，Teacher.prototype.contructor === Person，所以下面这一步很有必要，否则就就破坏继承结构</span></span><br><span class="line"></span><br><span class="line">    Teacher.prototype.constructor = Teacher;</span><br></pre></td></tr></table></figure><blockquote><p>每一个函数对象（<code>Function</code>）都有一个<code>prototype</code>属性，并且<em>只有</em>函数对象有<code>prototype</code>属性，因为<code>prototype</code>本身就是定义在<code>Function</code>对象下的属性。当我们输入类似<code>var person1=new Person(...)</code>来构造对象时，JavaScript实际上参考的是<code>Person.prototype</code>指向的对象来生成<code>person1</code>。另一方面，<code>Person()</code>函数是<code>Person.prototype</code>的构造函数，也就是说<code>Person===Person.prototype.constructor</code>（不信的话可以试试）。</p><p>在定义新的构造函数<code>Teacher</code>时，我们通过<code>function.call</code>来调用父类的构造函数，但是这样无法自动指定<code>Teacher.prototype</code>的值，这样<code>Teacher.prototype</code>就只能包含在构造函数里构造的属性，而没有方法。因此我们利用<code>Object.create()</code>方法将<code>Person.prototype</code>作为<code>Teacher.prototype</code>的原型对象，并改变其构造器指向，使之与<code>Teacher</code>关联。</p><p><em>任何</em>您想要被继承的方法都应该定义在构造函数的<code>prototype</code>对象里，并且<em>永远</em>使用父类的<code>prototype</code>来创造子类的<code>prototype</code>，这样才不会打乱类继承结构。</p></blockquote><h5 id="三种对象成员"><a href="#三种对象成员" class="headerlink" title="三种对象成员"></a>三种对象成员</h5><blockquote><ol><li>那些定义在构造器函数中的、用于给予对象实例的。这些都很容易发现 - 在您自己的代码中，它们是构造函数中使用<code>this.x = x</code>类型的行；在内置的浏览器代码中，它们是可用于对象实例的成员（通常通过使用<code>new</code>关键字调用构造函数来创建，例如<code>var myInstance = new myConstructor()</code>）。</li><li>那些直接在构造函数上定义、仅在构造函数上可用的。这些通常仅在内置的浏览器对象中可用，并通过被直接链接到构造函数而不是实例来识别。 例如<code>Object.keys()</code>。</li><li>那些在构造函数原型上定义、由所有实例和对象类继承的。这些包括在构造函数的原型属性上定义的任何成员，如<code>myConstructor.prototype.x()</code>。</li></ol></blockquote><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><h5 id="Promise用法"><a href="#Promise用法" class="headerlink" title="Promise用法"></a>Promise用法</h5><blockquote><p>参考：</p><p>（1）<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises</a></p><p>（2）<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/promise</a></p></blockquote><h5 id="Promise实现原理"><a href="#Promise实现原理" class="headerlink" title="Promise实现原理"></a>Promise实现原理</h5><blockquote><p>参考：<a href="https://juejin.im/post/5b83cb5ae51d4538cc3ec354" target="_blank" rel="noopener">https://juejin.im/post/5b83cb5ae51d4538cc3ec354</a></p></blockquote><h4 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h4><blockquote><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch</a></p></blockquote><h5 id="fetch与jQuery-ajax-不同"><a href="#fetch与jQuery-ajax-不同" class="headerlink" title="fetch与jQuery.ajax() 不同"></a>fetch与jQuery.ajax() 不同</h5><p>（1）当接收到一个代表错误的 HTTP 状态码时，从 <code>fetch()</code>返回的 Promise <strong>不会被标记为 reject，</strong> 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 <code>ok</code> 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject</p><p>（2）默认情况下，<code>fetch</code> <strong>不会从服务端发送或接收任何 cookies</strong>, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch#参数" target="_blank" rel="noopener">credentials</a> 选项）</p><h5 id="进行fetch请求"><a href="#进行fetch请求" class="headerlink" title="进行fetch请求"></a>进行fetch请求</h5><p>（1）fetch的返回值是一个包含响应结果的Promise（一个Response对象，并非JSON）；为了获取JSON内容，需要使用json()方法</p><p>（2）fetch的第一个参数是请求的url，第二个参数是init，它的内容可以如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, &#123;</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(data), <span class="comment">// must match 'Content-Type' header</span></span><br><span class="line">    cache: <span class="string">'no-cache'</span>, <span class="comment">// *default, no-cache, reload, force-cache, only-if-cached</span></span><br><span class="line">    credentials: <span class="string">'same-origin'</span>, <span class="comment">// include, same-origin, *omit</span></span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">'user-agent'</span>: <span class="string">'Mozilla/4.0 MDN Example'</span>,</span><br><span class="line">        <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    method: <span class="string">'POST'</span>, <span class="comment">// *GET, POST, PUT, DELETE, etc.</span></span><br><span class="line">    mode: <span class="string">'cors'</span>, <span class="comment">// no-cors, cors, *same-origin</span></span><br><span class="line">    redirect: <span class="string">'follow'</span>, <span class="comment">// manual, *follow, error</span></span><br><span class="line">    referrer: <span class="string">'no-referrer'</span>, <span class="comment">// *client, no-referrer</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data)) <span class="comment">// JSON from `response.json()` call</span></span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error))</span><br></pre></td></tr></table></figure><ul><li>通过body设置请求实体，如果要传输json实体，则要在headers里面设置<code>&#39;content-type&#39;: &#39;application/json&#39;</code>，而且请求方式要是<code>method: &#39;POST&#39;</code></li><li>fetch返回的Promise对象通过<code>then(response =&gt; response.json())</code>转成json之后，便于后续的处理</li></ul><p>如果要上传文件，可以通过FormData()来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="keyword">var</span> fileField = <span class="built_in">document</span>.querySelector(<span class="string">"input[type='file']"</span>);</span><br><span class="line"></span><br><span class="line">formData.append(<span class="string">'username'</span>, <span class="string">'abc123'</span>);</span><br><span class="line">formData.append(<span class="string">'avatar'</span>, fileField.files[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'https://example.com/profile/avatar'</span>, &#123;</span><br><span class="line">  method: <span class="string">'PUT'</span>,</span><br><span class="line">  body: formData</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error:'</span>, error))</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Success:'</span>, response));</span><br></pre></td></tr></table></figure><p>这里的body不需要转成json；FormData对象实际上就是一个键值对列表</p><p>多文件上传可以使用<code>&lt;input type=&quot;file&quot; mutiple/&gt;</code>来配合FormData</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line"><span class="keyword">var</span> photos = <span class="built_in">document</span>.querySelector(<span class="string">"input[type='file'][multiple]"</span>);</span><br><span class="line"></span><br><span class="line">formData.append(<span class="string">'title'</span>, <span class="string">'My Vegas Vacation'</span>);</span><br><span class="line">formData.append(<span class="string">'photos'</span>, photos.files);</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">'https://example.com/posts'</span>, &#123;</span><br><span class="line">  method: <span class="string">'POST'</span>,</span><br><span class="line">  body: formData</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Success:'</span>, <span class="built_in">JSON</span>.stringify(response)))</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">'Error:'</span>, error));</span><br></pre></td></tr></table></figure><h5 id="检测请求是否成功"><a href="#检测请求是否成功" class="headerlink" title="检测请求是否成功"></a>检测请求是否成功</h5><p>由于返回resolved的Promise不一定是请求成功的，因此首先要判断Response.ok，再决定接下来的处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'flowers.jpg'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(response.ok) &#123;</span><br><span class="line">    <span class="comment">// 如果response.ok是false的，实际上是取不到response.blob()的</span></span><br><span class="line">    <span class="keyword">return</span> response.blob();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Network response was not ok.'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">myBlob</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> objectURL = URL.createObjectURL(myBlob); </span><br><span class="line">  myImage.src = objectURL; </span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'There has been a problem with your fetch operation: '</span>, error.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="自定义请求对象"><a href="#自定义请求对象" class="headerlink" title="自定义请求对象"></a>自定义请求对象</h5><p>fetch还可以直接将第一、第二个参数封装成Request对象后再传递进去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求头对象</span></span><br><span class="line"><span class="keyword">var</span> myHeaders = <span class="keyword">new</span> Headers();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myInit = &#123; <span class="attr">method</span>: <span class="string">'GET'</span>,</span><br><span class="line">               headers: myHeaders,</span><br><span class="line">               mode: <span class="string">'cors'</span>,</span><br><span class="line">               cache: <span class="string">'default'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myRequest = <span class="keyword">new</span> Request(<span class="string">'flowers.jpg'</span>, myInit);</span><br><span class="line"></span><br><span class="line">fetch(myRequest).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.blob();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">myBlob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  myImage.src = objectURL;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Request()和fetch()接受的参数是一样的；由于Request()和Resonse Body被设计成了<strong>流的形式</strong>，不能被两次请求和读取，但可以通过拷贝再次使用request和response</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherRequest = <span class="keyword">new</span> Request(myRequest,myInit);</span><br></pre></td></tr></table></figure><p>最佳实践是在使用响应的Promise之前检查 content type 是否正确</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(myRequest).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断响应头的contentType是不是json，是的话再将其转为json进行后续处理</span></span><br><span class="line">  <span class="keyword">if</span>(response.headers.get(<span class="string">"content-type"</span>) === <span class="string">"application/json"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.json().then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// process your JSON further</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Oops, we haven't got JSON!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h5><p>Response是fetch()处理完Promise后返回的，常见的属性有：</p><ul><li><strong>Response.status</strong> — 整数(默认值为200) 为response的状态码</li><li><strong>Response.statusText</strong> — 字符串(默认值为”OK”),该值与HTTP状态码消息对应</li><li><strong>Response.ok</strong> — 该属性是来检查response的状态是否在200-299(包括200,299)这个范围内.该属性返回一个布尔值</li></ul><h5 id="Body实体"><a href="#Body实体" class="headerlink" title="Body实体"></a>Body实体</h5><p>请求和响应都可以包含Body，常见的类型有：ArrayBuffer、ArrayBufferView、Blob/File、String、URLSearchParams和FormData</p><p>可以通过Body类的<strong>arrayBuffer()、blob()、json()、text()和formData()</strong>方法来获取请求和响应的实体数据</p><p>当我们设置了Body实体但是没有在headers中设置contentType时，request和response会进行自动设置</p><h5 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h5><p>在不支持Fetch的浏览器中可以使用Fetch Polyfill</p><h4 id="浏览器事件循环机制"><a href="#浏览器事件循环机制" class="headerlink" title="浏览器事件循环机制"></a>浏览器事件循环机制</h4><h5 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h5><blockquote><p>参考：<a href="https://juejin.im/post/5afbc62151882542af04112d" target="_blank" rel="noopener">https://juejin.im/post/5afbc62151882542af04112d</a></p></blockquote><p>事件循环可以简单描述为：</p><p>（1）函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空;</p><p>（2）在此期间WebAPIs完成这个事件，把回调函数放入CallbackQueue中等待;</p><p>（3）当执行栈为空时，Event Loop把Callback Queue中的一个任务放入Stack中,回到第1步。</p><p>其中第（2）步是由浏览器的线程去完成，不关js引擎的事情</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/5/16/163677dd81721ac8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><ul><li>Event Loop是由javascript宿主环境（像浏览器）来实现的;</li><li>WebAPIs是由C++实现的浏览器创建的线程，处理诸如DOM事件、http请求、定时器等异步事件;</li><li>JavaScript 的并发模型基于”事件循环”;</li><li>Callback Queue(Event Queue 或者 Message Queue) 任务队列,存放异步任务的回调函数</li></ul></blockquote><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start=<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"时间间隔："</span>,<span class="keyword">new</span> <span class="built_in">Date</span>()-start+<span class="string">'ms'</span>);</span><br><span class="line">&#125;,<span class="number">500</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">new</span> <span class="built_in">Date</span>()-start&lt;<span class="number">1000</span>)&#123;&#125;;</span><br></pre></td></tr></table></figure><p>执行过程：</p><ol><li>main(Script) 函数入栈,start变量开始初始化</li><li>setTimeout入栈,出栈,丢给WebAPIs,开始定时500ms;</li><li>while循环入栈,开始阻塞1000ms;</li><li>500ms过后,WebAPIs把cb()放入任务队列,此时while循环还在栈中,cb()等待;</li><li>又过了500ms,while循环执行完毕从栈中弹出,main()弹出,此时栈为空,Event Loop,cb()进入栈,log()进栈,输出’时间间隔：1003ms’,出栈,cb()出栈</li></ol><h5 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h5><p>（1）<strong>宏任务macro-task(Task)</strong>：一个event loop有一个或者多个task队列，task任务源有：</p><ul><li><strong>setTimeout</strong></li><li>setInterval</li><li>setImmediate</li><li>I/O</li><li>UI rendering</li></ul><p>（2）<strong>微任务micro-task(Job)</strong>：一个 event loop里只有一个microtask 队列，任务源有：</p><ul><li>process.nextTick</li><li><strong>promises</strong></li><li>Object.observe</li><li>MutationObserver</li></ul><p>（3）例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>  <span class="title">promise2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>执行过程（脚本代码本身是一个task，会被列入task队列）：</p><p><strong>循环1：</strong></p><p>【task队列：script ；microtask队列：】</p><p>1、从task队列中取出script任务，推入栈中执行。</p><p>2、promise1列为microtask，setTimeout1列为task，setTimeout2列为task。</p><p>【task队列：setTimeout1 setTimeout2；microtask队列：promise1】</p><p>3、script任务执行完毕，执行microtask checkpoint，取出microtask队列的promise1执行。</p><p><strong>循环2：</strong></p><p>【task队列：setTimeout1 setTimeout2；microtask队列：】 </p><p>4、从task队列中取出setTimeout1，推入栈中执行，将promise2列为microtask。</p><ul><li>【task队列：setTimeout2；microtask队列：promise2】</li></ul><p>5、执行microtask checkpoint，取出microtask队列的promise2执行。</p><p><strong>循环3：</strong></p><ul><li>【task队列：setTimeout2；microtask队列：】</li></ul><p>6、从task队列中取出setTimeout2，推入栈中执行。</p><p>7.setTimeout2任务执行完毕，执行microtask checkpoint。</p><ul><li>【task队列：；microtask队列：】</li></ul><p>*8、Update the rendering（更新渲染）</p><p><u><em>最关键的不同：<strong>每次event loop循环执行栈完成后，会继续执行完相应的microtask任务</strong>，最后每轮事件执行的最后，浏览器会去决定是否更新视图渲染（Update the rendering，也就是说可能不是每轮事件循环都去更新视图，只在有必要的时候才更新视图）</em></u></p><h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><blockquote><p>参考：<a href="https://www.jianshu.com/p/ffa5cbe9ab29" target="_blank" rel="noopener">https://www.jianshu.com/p/ffa5cbe9ab29</a></p></blockquote><h4 id="JavaScript闭包（Closure）"><a href="#JavaScript闭包（Closure）" class="headerlink" title="JavaScript闭包（Closure）"></a>JavaScript闭包（Closure）</h4><blockquote><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures</a></p></blockquote><p>（1）JavaScript中的函数会形成<em>闭包</em>。 闭包是由函数以及创建该函数的词法环境组合而成。<strong><u>这个环境包含了这个闭包创建时所能访问的所有局部变量</u></strong></p><p>（2）在循环中创建闭包的常见错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">"help"</span>&gt;Helpful notes will appear here&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;E-mail: &lt;input type="text" id="email" name="email"&gt;&lt;/</span>p&gt;</span><br><span class="line">&lt;p&gt;Name: &lt;input type="text" id="name" name="name"&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;Age: &lt;input type="text" id="age" name="age"&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'help'</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'email'</span>, <span class="string">'help'</span>: <span class="string">'Your e-mail address'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'name'</span>, <span class="string">'help'</span>: <span class="string">'Your full name'</span>&#125;,</span><br><span class="line">      &#123;<span class="string">'id'</span>: <span class="string">'age'</span>, <span class="string">'help'</span>: <span class="string">'Your age (you must be over 16)'</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><ul><li>无论焦点在哪个<code>input</code>上，显示的都是关于年龄的信息，原因是赋值给onfocus的闭包是由他们的<strong>函数定义</strong>以及<strong>setupHelp作用域捕获的环境</strong>组成的，三个闭包在循环中被创建，但他们共享了同一个词法作用域，在这个作用域中存在一个变量item。当onfocus的回调执行时，<code>item.help</code>的值被决定。由于循环在事件触发之前早已执行完毕，变量对象<code>item</code>（被三个闭包所共享）已经指向了<code>helpText</code>的最后一项；</li><li>简单来说就是，三个闭包是共享词法作用域，而不是各自拥有不同的词法作用域，在setupHelp执行完毕时，他们共享的item已经指向了<code>helpText</code>最后一项</li></ul><p>（3）解决方法</p><ul><li><p>使用更多的闭包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeHelpCallback</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    showHelp(help);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = makeHelpCallback(item.help);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样赋值给onfocus的三个闭包不再共享词法作用域，而是各自拥有<code>makeHelpCallback(help)</code>中的不同词法作用域</p></li><li><p>使用匿名闭包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">       <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         showHelp(item.help);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;)(); <span class="comment">// 马上把当前循环项的item与事件回调相关联起来</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样每次循环中赋值给onfocus的闭包拥有的此法环境就限制在了匿名函数内部</p></li><li><p>使用let而不是var关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><em>关于let关键字，查看 1.5.12 节</em></p></li></ul><p>（4）使用闭包的注意点</p><ul><li><strong>滥用闭包，会造成内存泄漏</strong>：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li><li><strong>会改变父函数内部变量的值</strong>：如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li></ul><h4 id="this、-call、bind和apply"><a href="#this、-call、bind和apply" class="headerlink" title="this、 call、bind和apply"></a>this、 call、bind和apply</h4><blockquote><p>参考：<a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="noopener">https://juejin.im/post/59bfe84351882531b730bac2</a></p></blockquote><h5 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h5><p>this 的指向并不是在创建的时候就可以确定的，在 es5 中，<strong>this永远指向最后调用它的那个对象</strong>（例子见参考链接）</p><h5 id="改变this的指向"><a href="#改变this的指向" class="headerlink" title="改变this的指向"></a>改变this的指向</h5><ul><li>可以通过call、bind和apply改变this的指向</li><li>使用箭头函数</li><li>在函数内部使用<code>_this = this</code>临时保存定义函数的对象的this调用</li></ul><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p><strong>箭头函数的 this 始终指向函数定义时的 this，而非执行时。</strong>使用箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 <strong>this 绑定的是最近一层非箭头函数的 this</strong>，否则，this 为 undefined”</p><h5 id="apply、call、bind-区别"><a href="#apply、call、bind-区别" class="headerlink" title="apply、call、bind 区别"></a>apply、call、bind 区别</h5><ul><li><p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure><ul><li>thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象</li><li>argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。</li></ul></li><li><p>apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure></li><li><p>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列；即<strong>bind 是创建一个新的函数，我们必须要手动去调用</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.bind(a,<span class="number">1</span>,<span class="number">2</span>)()</span><br></pre></td></tr></table></figure></li></ul><h5 id="再补充一点"><a href="#再补充一点" class="headerlink" title="再补充一点"></a>再补充一点</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name:<span class="string">'steve'</span>,</span><br><span class="line">    b : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="keyword">this</span>.name),<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.b()<span class="comment">//steve</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name:<span class="string">'steve'</span>,</span><br><span class="line">    b : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)&#125;,<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.b()<span class="comment">//windowsName</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name:<span class="string">'steve'</span>,</span><br><span class="line">    b : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.b()<span class="comment">//steve</span></span><br></pre></td></tr></table></figure><ul><li>（1）中使用的是箭头函数，由于函数闭包的作用，箭头函数里面的this.name是定义时的a对象的name属性，因此是steve，即使这个箭头函数是延迟执行的</li><li>如果没有使用箭头函数，由于setTimeout里面回调函数延迟执行的缘故，this指向的实际上是window对象，因此打印了windowsName</li><li>如果没有延迟执行，那么this.name指向的是最后调用的对象，在（3）中是使用a.b()来调用的，因此最后调用的对象是a，所以结果是steve</li></ul><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>函数调用在js中一共有四种，如下</p><h5 id="作为一个函数调用"><a href="#作为一个函数调用" class="headerlink" title="作为一个函数调用"></a>作为一个函数调用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Cherry"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);          <span class="comment">// windowsName</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inner:"</span> + <span class="keyword">this</span>);    <span class="comment">// inner: Window</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer:"</span> + <span class="keyword">this</span>)         <span class="comment">// outer: Window</span></span><br></pre></td></tr></table></figure><p>这样定义的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined</p><h5 id="函数作为（对象的）方法调用"><a href="#函数作为（对象的）方法调用" class="headerlink" title="函数作为（对象的）方法调用"></a>函数作为（对象的）方法调用</h5><blockquote><p>在js中，函数是一个对象，它的内部有自己的属性和方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">"Cherry"</span>,</span><br><span class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// Cherry</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();</span><br></pre></td></tr></table></figure><p>在这里，fn最后调用的对象是a，所以this.name指向的是a的name属性</p><p><strong>*note</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line"></span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1()</span><br><span class="line">        &#125;,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">a.func2()     <span class="comment">// this.func1 is not a function</span></span><br></pre></td></tr></table></figure><p>这个例子中，由于func2中调用了setTimeout方法，这个方法里面的回调函数不是立即执行的，因此当回调函数执行的时候，它的this指向已经不是对象a了，而是window对象，因此this.func1()函数不存在</p><h5 id="（作为构造函数调用"><a href="#（作为构造函数调用" class="headerlink" title="（作为构造函数调用"></a>（作为构造函数调用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = arg1;</span><br><span class="line">    <span class="keyword">this</span>.lastName  = arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This    creates a new object</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myFunction(<span class="string">"Li"</span>,<span class="string">"Cherry"</span>);</span><br><span class="line">a.lastName;</span><br></pre></td></tr></table></figure><p>作为构造函数调用后，创建了对象，自然里面的this也是指向创建的对象的</p><h5 id="使用apply、call和bind调用"><a href="#使用apply、call和bind调用" class="headerlink" title="使用apply、call和bind调用"></a>使用apply、call和bind调用</h5><p><em>这个就不多解释了</em></p><h4 id="Currying柯里化"><a href="#Currying柯里化" class="headerlink" title="Currying柯里化"></a>Currying柯里化</h4><blockquote><p>参考：<a href="https://juejin.im/post/5af13664f265da0ba266efcf" target="_blank" rel="noopener">https://juejin.im/post/5af13664f265da0ba266efcf</a></p></blockquote><p>（1）Currying的作用之一是 可以实现参数的复用，例如有一个多参数函数，当传递了第一个参数之后，得到一个柯里化后的函数用来接受剩下的参数，这样这个函数在调用时，第一个参数就已经是固定的，即被复用</p><p>（2）基于Currying原理的一个函数库lodash，参考：<a href="https://www.jianshu.com/p/d46abfa4ddc9" target="_blank" rel="noopener">https://www.jianshu.com/p/d46abfa4ddc9</a></p><h4 id="let、var和const"><a href="#let、var和const" class="headerlink" title="let、var和const"></a>let、var和const</h4><blockquote><p>参考：<a href="https://www.jianshu.com/p/4e9cd99ecbf5" target="_blank" rel="noopener">https://www.jianshu.com/p/4e9cd99ecbf5</a></p></blockquote><p>（1）ES6才添加的let和const</p><p>（2）js中没有块级作用域，因此<strong>在JS函数中的var声明，其作用域是函数体的全部</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>（3）在循环中容易出现变量过度共享</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是setTimeout中的回调函数是延迟调用的，可以肯定的是必然晚于循环的执行完毕，而当循环调用完毕时，var i其实已经是3了，因此打印的是3 3 3而不是0 1 2</p><p>（4）将var换成let可以解决以上两个bug（<strong>note：必须声明 ‘use strict’ 后才能使用let声明变量，否则浏览器并不能显示结果</strong>）</p><ul><li><p>let声明的变量拥有块级作用域</p></li><li><p>let声明的全局变量不是全局对象的属性</p></li><li><p><strong>形如for (let x…)的循环在每次迭代时都为x创建新的绑定。</strong></p><p>如果一个for (let…)循环执行多次并且循环保持了一个闭包，那么<strong>每个闭包将捕捉一个循环变量的不同值作为副本</strong>，而不是所有闭包都捕捉循环变量的同一个值</p></li><li><p>用let重定义变量会抛出一个语法错误（SyntaxError）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'b'</span>;<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ul><p>（5）let和var都支持<strong>解构</strong>赋值</p><p>（6）const 就是用来定义常量的：<strong>只声明不赋值</strong>、<strong>重复声明常量</strong>和<strong>修改常量的值</strong>都是不允许的</p><p>（7）如果在函数体内部声明变量时<strong>没有使用var、const或者let，那么声明的变量实际上是一个全局变量</strong>，函数体外部也能访问</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h4><blockquote><p>参考：<a href="https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb" target="_blank" rel="noopener">https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb</a></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://lc-gold-cdn.xitu.io/0dd26d8e99257ff36443.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title>                </div>                <div class="image-caption"></div>            </figure><p>1.6.2 </p><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>（1）实现循环队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tk.chph.demo.ds_alg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front, end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize your data structure here. Set the size of the queue to be k.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Insert an element into the circular queue. Return true if the operation is successful.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        data[end++] = value;</span><br><span class="line">        end = end % data.length;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Delete an element from the circular queue. Return true if the operation is successful.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        front = (++front) % data.length;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the front item from the queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> data[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the last item from the queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> data[(end - <span class="number">1</span>+data.length)%data.length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks whether the circular queue is empty or not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks whether the circular queue is full or not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (end - (front - data.length) +<span class="number">1</span>) % (data.length) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现方法：以长度为k的数组实现，data数组要长度为k+1，原因是要使得<code>front==end</code>能够作为isEmpty的条件，isFull判断条件是：<code>(end - (front - data.length) +1) % (data.length) == 0</code>，enQueue和deQueue时要注意end和front越界，同时由于end指向的元素是空的，因此Rear时要注意end-1可能会出现&lt;1的情况</p><p>（2）<strong>添加顺序</strong>和<strong>处理顺序</strong>相同时，可以考虑使用队列来解决</p><h2 id="SSM-Redis框架"><a href="#SSM-Redis框架" class="headerlink" title="SSM+Redis框架"></a>SSM+Redis框架</h2><h3 id="Java动态代理技术和设计模式"><a href="#Java动态代理技术和设计模式" class="headerlink" title="Java动态代理技术和设计模式"></a>Java动态代理技术和设计模式</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>（1）建立动态代理的步骤：</p><ul><li>代理对象和真实对象建立代理关系</li><li>实现代理对象的逻辑方法</li></ul><p>（2）在 JDK 动态代理中，要实现<strong>代理逻辑类</strong>必须去实现 <code>java.lang.reflect.InvocationHandler</code>接口，它里面定义了 一个 invoke 方法，并提供接口数组用于下挂代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JdkProxyExample</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立代理对象和真是对象的关系，并返回代理对象</span></span><br><span class="line">    <span class="function">Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理方法的逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入代理逻辑方法"</span>);</span><br><span class="line">        System.out.println(<span class="string">"调度真实对象前的服务"</span>);</span><br><span class="line">        Object obj = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"调度真实对象后的服务"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JdkProxyExample jdk = <span class="keyword">new</span> JdkProxyExample();</span><br><span class="line">        <span class="comment">// 进行代理，并获得代理对象，这时候外部只能直接访问代理对象，不能直接访问真实对象</span></span><br><span class="line">        HelloWorld proxy = (HelloWorld) jdk.bind(<span class="keyword">new</span> HelloWorldImpl());</span><br><span class="line">        proxy.sayHelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法中返回的HelloWorld对象已经是一个代理对象，<code>proxy.sayHelloWorld();</code>的调用会进入invoke方法中</p><p>（3）JDK动态代理必须提供接口才能使用，比如例子中的HelloWorld接口；<code>Proxy.newProxyInstance(target.getClass().getClassLoader(),                target.getClass().getInterfaces(), this);</code>中的<code>target.getClass().getInterfaces()</code>就是获取真是对象实现的接口，并将真实对象挂靠在接口下，<code>HelloWorld proxy = (HelloWorld) jdk.bind(new HelloWorldImpl());</code>也得通过接口来引用代理对象</p><h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><p>（1） CGLIB 动态代理的优势在于不需要提供接口，只要一个非抽象类就<br>能实现动态代理 </p><p>（2）代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真实对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"调用真实对象前"</span>);</span><br><span class="line">        Object result = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.err.println(<span class="string">"调用真实对象后"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Enhancer建立代理对象与真实对象之间的关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class cls)</span></span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(cls);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> Interceptor());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CglibProxyExample cglibProxyExample = <span class="keyword">new</span> CglibProxyExample();</span><br><span class="line">        HelloWorldImpl helloWorld = (HelloWorldImpl) cglibProxyExample.getProxy(HelloWorldImpl.class);</span><br><span class="line">        helloWorld.sayHelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代理类要<strong>实现MethodInterceptor接口</strong>，并在invoke方法中实现代理逻辑方法</li><li>注意，通过反射调用真实对象的方法时是invokeSuper方法，如<code>Object result = methodProxy.invokeSuper(proxy, args);</code>，因为Enhancer建立代理对象与真实对象的关系时是将超类设为真实类，setCallback将代理类设为我们定义的Interceptor</li></ul><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>（1）代码实例</p><ul><li><p>设计者提供的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorJdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> String interceptorClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InterceptorJdkProxy</span><span class="params">(Object target, String interceptorClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.interceptorClass = interceptorClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">bind</span><span class="params">(Object target, String interceptorClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), <span class="keyword">new</span> InterceptorJdkProxy(target, interceptorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interceptorClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        Interceptor interceptor = (Interceptor) Class.forName(interceptorClass).newInstance();</span><br><span class="line">        <span class="comment">// 调用前置方法</span></span><br><span class="line">        <span class="keyword">if</span> (interceptor.before(proxy, target, method, args)) &#123;</span><br><span class="line">            <span class="comment">// 前置方法返回true，反射原对象方法</span></span><br><span class="line">            result = method.invoke(target, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则执行around方法</span></span><br><span class="line">            interceptor.around(proxy, target, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用后置方法</span></span><br><span class="line">        interceptor.after(proxy, target, method, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开发者提供的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"反射方法前逻辑"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"反射方法后逻辑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"取代了被代理对象的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorld proxy = (HelloWorld) InterceptorJdkProxy.bind(<span class="keyword">new</span> HelloWorldImpl(), <span class="string">"tk.chph.demo.proxy.interceptor.MyInterceptor"</span>);</span><br><span class="line">        proxy.sayHelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里使用的是JDK动态代理，对开发者来说，只需要实现设计者提供的拦截器接口Interceptor，然后通过bind方法将拦截器（代理对象）和自己的业务对象（真实对象）建立代理关系就可以了；而设计动态代理的代码全部由设计者来实现，开发者无需关心</p><p>另外拦截器实例化是被延迟到了代理方法（invoke）调用的时候才进行的，在此之前，代理对象只是保存了拦截器的全限定名</p><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>（1）说白了就是：当一个对象在一条链上被多个拦截器拦截处理（拦截器也可以选择不拦截处理它）时，<br>我们把这样的设计模式称为责任链模式</p><p>（2）责任链模式和拦截器的一点不同在于，要注意责任链模式上每个拦截器的before、after方法的执行顺序；责任链模式实质上是对代理对象进行代理，这样层层叠加：</p><blockquote><p>proxy3代理proxy2，proxy2代理proxy1，proxy1代理真实对象</p></blockquote><p>这样在调用的时候，对proxy3来说，proxy2是它的真实对象，因此执行顺序是：proxy3.before-&gt;proxy2-&gt;proxy3.after，而proxy2的真实对象是proxy1，因此执行顺序变成了：proxy3.before-&gt;proxy2.before-&gt;proxy1-&gt;proxy2.after-&gt;proxy3.after，以此类推</p><h4 id="观察者模式（发布订阅模式）"><a href="#观察者模式（发布订阅模式）" class="headerlink" title="观察者模式（发布订阅模式）"></a>观察者模式（发布订阅模式）</h4><p>（1）观察者模式定义了 一种<strong>一对多</strong><br>的依赖关系，让多个观察者对象同时监视着被观察者的状态，当被观察者的状态发生变化<br>时 ， 会通知所有观察者 ， 并让其自动更新自己 </p><p>（2）代码实例</p><ul><li><p>被观察者，要继承Observable类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductList</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; productList=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ProductList instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ProductList</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProductList <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ProductList();</span><br><span class="line">            instance.productList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProduct</span><span class="params">(String newProduct)</span></span>&#123;</span><br><span class="line">        productList.add(newProduct);</span><br><span class="line">        System.out.println(<span class="string">"产品列表新增了产品："</span>+newProduct);</span><br><span class="line">        <span class="comment">// =====注意这里=====</span></span><br><span class="line">        <span class="keyword">this</span>.setChanged();</span><br><span class="line">        <span class="keyword">this</span>.notifyObservers(newProduct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意的是，被观察者状态改变后，要调用setChanged将changed变量设为true，否则后面的notifyObservers方法没有效果；同时，notifyObservers方法调用完成后，changed为会被重新设置为false，等待下一次状态更新</p></li><li><p>观察者，要实现Observer接口及其接口里的update方法，因为被观察者调用notifyObservers方法，实际上是调用所有观察者的update方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JingDongObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object product)</span> </span>&#123;</span><br><span class="line">        String newProduct = (String) product;</span><br><span class="line">        System.err.println(<span class="string">"发送新产品【"</span>+newProduct+<span class="string">"】到京东商城"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaoBaoObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object product)</span> </span>&#123;</span><br><span class="line">        String newProduct = (String) product;</span><br><span class="line">        System.err.println(<span class="string">"发送新产品【"</span>+newProduct+<span class="string">"】到淘宝商城"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProductList productList = ProductList.getInstance();</span><br><span class="line">        productList.addObserver(<span class="keyword">new</span> TaoBaoObserver());</span><br><span class="line">        productList.addObserver(<span class="keyword">new</span> JingDongObserver());</span><br><span class="line">        productList.addProduct(<span class="string">"MacBook Pro"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h4><p>（1）很多时候由于对象的创建比较复杂，这时候就可以使用Builder模式，通过提供配置类来帮助创建复杂对象</p><p>（2）Builder 模式是一种<strong>分步构建对象</strong>的模式 </p><h3 id="Mybatis框架"><a href="#Mybatis框架" class="headerlink" title="Mybatis框架"></a>Mybatis框架</h3><h4 id="Mybatis的核心组件"><a href="#Mybatis的核心组件" class="headerlink" title="Mybatis的核心组件"></a>Mybatis的核心组件</h4><p>（1）mybatis核心组件由四部分组成</p><ul><li><strong>SqlSessionFactoryBuilder（构造器）</strong>：通过配置或者代码来生成SqlSessionFacotry对象，采用分步构建的<strong>Builder模式</strong></li><li><strong>SqlSessionFactory（工厂接口）</strong>：依靠它来生成SqlSession，使用<strong>工厂模式</strong></li><li><strong>SqlSession（会话）</strong>： 一个既可以发送 SQL 执行返回结果，也可以获取 Mapper 的接口。在现有的技术中， 一般我们会让其在业务逻辑代码中“消失”，而使用的是<br>MyBatis 提供的 SQLMapper 接口编程技术，它能提高代码的可读性和可维护性 </li><li><strong>SQL Mapper（映射器）</strong>：MyBatis 新设计存在的组件，它由一个 <strong>Java 接口和 XML</strong><br><strong>文件（或注解）</strong>构成，需要给出对应的 SQL 和映射规则。它负责发送 SQL 去执行，<br>并返回结果 </li></ul><p>*Note：无论是映射器还是 SqlSession 都可以发送 SQL 到数据库执行</p><p>（2）SqlSessionFactory （工厂接口）</p><ul><li><p>Mybatis提供构造器SqlSessionFactoryBuilder以及配置类org.apache.ibatis.session.Configuration来生产SqlSessionFactory对象</p></li><li><p>org.apache.ibatis.session.Configuration对象既可以通过读取XML文件来生成，也可以直接通过Java代码来定义，它是整个mybatis的上下文</p></li><li><p>SqlSessionFactory是一个接口，它的实现类有SqlSessionManager和DefaultSqlSessionFactory；一般而言都是使用DefaultSqlSessionFactory，而SqlSessionManager用在多线程里，它的实现依靠DefaultSqlSessionFactory</p></li><li><p>SqlSessionFactory唯一的作用是生产Mybatis的核心接口对象SqlSession，因此它一般来说是单例模式</p></li><li><p>使用XML文件描述SqlSessionFactory的配置文件就是mybatis-config.xml，然后就可以创建SqlSessionFactory对象了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = Resource.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure></li><li><p>采用XML配置的形式好处是：信息在配置文件中，便于后期维护和修改；同时不需要重新编译代码</p></li></ul><p>（3）SqlSession</p><ul><li><p>有两个实现类：DefaultSqlSession（用于单线程）和SqlSessionManager（用于多线程）</p></li><li><p>SqlSession类似一个JDBC中的一个Connection，管理者一个连接中的资源启用</p><ul><li><p>获取Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);</span><br></pre></td></tr></table></figure></li><li><p>发送SQL给数据库</p></li><li><p>控制数据库事务（提交和回滚）</p></li></ul></li><li><p>使用SqlsessionFactory创建SqlSession的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure></li><li><p>SqlSession只是一个门面接口，底层真正在工作的是Executor</p></li></ul><p>（4）映射器</p><ul><li>它由一个接口和对应的XML（或者注解）组成</li><li>映射器的主要作用就是将 SQL 查询到的<strong>结果映射为一个 POJO</strong>，或者<strong>将 POJO 的数据</strong><br><strong>插入到数据库</strong>中 ， 并定义一些关于缓存等的重要内容</li><li>Mybatis使用动态代理技术，根据XML或者注解的描述为接口创建一个代理对象去处理相关的逻辑</li><li>同时使用注解和XML创建映射器时，XML的方式会覆盖注解的定义</li></ul><p>（5）发送SQL语句到数据库</p><ul><li><p>SqlSession方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Role role = (Role) sqlSession.selectOne(<span class="string">"com.learn.ssm.chapter3.mapper.RoleMapper.getRole"</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure></li><li><p>Mapper接口方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);</span><br><span class="line">Role role = roleMapper.getRole(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure></li></ul><p>（6）生命周期</p><ul><li>SqlSessionFactoryBuilder：它的作用是创建SqlSessionFactory，创建完后就失去了作用，可以被JVM回收了</li><li>SqlSessionFactory：作用相当于一个数据库连接池，一旦创建了 SqlSessionFactory ， 就要长期保存它，直至<br>不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的<br>应用周期；同时一般要求SqlSessionFactory是一个单例，在应用中被共享</li><li>SqlSession：SqlSession 就相当于一个数据库<br>连接（ Connection 对象），它应该存活在一个业务请求中，处理完整个请求<br>后，应该关闭这条连接，让它归还给 SqlSessionFactory ， 否则数据库资源就很快被耗费精光，系统就会瘫痪</li><li>Mapper：它由 SqlSession 所创建，所以它的最大生命周期至多和 SqlSession<br>保持一致；但由于SqlSession关闭后，它的数据库连接资源也会消失，<br>所以它的生命周期应该小于等于 SqlSession 的生命周期 ；Mapper 代表的是一个请求中业务处理的一个步骤，所以它应该在一个请求中，一旦处理完了相关的业务，就应该随着SqlSession的关闭而废弃它</li></ul><h4 id="MyBatis-的解析和运行原理"><a href="#MyBatis-的解析和运行原理" class="headerlink" title="MyBatis 的解析和运行原理"></a>MyBatis 的解析和运行原理</h4><h4 id="Spring-Mybatis整合"><a href="#Spring-Mybatis整合" class="headerlink" title="Spring-Mybatis整合"></a>Spring-Mybatis整合</h4><p>（1）配置数据源</p><ul><li>简单数据源SimpleDriverDataSource，没有提供数据库连接池功能<ul><li>数据库驱动driver</li><li>数据库连接url</li><li>用户名username</li><li>密码password</li></ul></li><li>第三方数据库连接池数据源DBCP（dbcp.BasicDataSource），提供了数据库连接池功能<ul><li>数据库驱动driver</li><li>数据库连接url</li><li>用户名username</li><li>密码password</li><li>数据库连接池配置：maxActive、maxIdle、maxWait等</li></ul></li><li>从web服务器获取数据源JNDI（jndi.JndiObjectFactoryBean）<ul><li>web服务器配置的数据源名称 jndiName</li></ul></li></ul><p>（2）配置SqlSessionFactoryBean</p><ul><li>数据源datasource</li><li>mybatis配置文件configLocation</li></ul><p>（3）配置MapperScannerConfigurer</p><ul><li>扫描路径basePackages</li><li>SqlSessionFactoryBeanName</li><li>映射器的注解annotationClass</li></ul><h3 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h3><h4 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h4><p>（1）控制反转是一种通过描述（在 Java<br>中可以是 XML 或者注解）并通过第三方去产生或获取特定对象的方式。在 Spring 中实现控制反转的是 IoC 容器，其实现方法是依赖注入 （Dependency Injection, DI ）</p><p>（2）Spring IoC容器主要是基于BeanFactory 和 ApplicationContext 两个接口，其中ApplicationContext 是 BeanFactory 的子接口之一，在绝大部分的工作场景下 ， 都会使用 ApplicationContext 作为<br>Spring IoC 容器 </p><p>（3）Spring IoC的初始化包括<strong>Bean的初始化</strong>和<strong>依赖注入</strong>两个步骤</p><ul><li>Bean初始化<ul><li>Resource 定位，这步是 Spring IoC 容器根据开发者的配置，进行资源定位，在 Spring<br>的开发中，通过 XML 或者注解都是十分常见的方式</li><li>BeanDefinition 的载入，这个过程就是 Spring 根据开发者的配置获取对应的 POJO,<br>用以生成对应实例的过程</li><li>BeanDefinition 的注册 ，这个步骤就相当于把之前通过 BeanDefinition 载入的 POJO<br>往 Spring IoC 容器中注册，这样就可以使得开发和测试人员都可以通过描述从中得到 Spring<br>IoC 容器的 Bean 了</li></ul></li><li>依赖注入：在完成依赖注入之前的Bean还不能够使用，对于依赖注入，spring中默认的lazy-init（是否初始化Bean）是false，即 Spring IoC 默认会自动初始化 Bean；如果将其设置为 true，那么只有当我们使用 Spring IoC 容器的 getBean 方法获取它时，它才<br>会进行初始化， 完成依赖注入。</li></ul><p>（4）Spring Bean的生命周期</p><ul><li>（占个坑orz）</li></ul><h4 id="Spring-Bean的装配"><a href="#Spring-Bean的装配" class="headerlink" title="Spring Bean的装配"></a>Spring Bean的装配</h4><p>（1）依赖注入的三种方式</p><ul><li>构造器注入</li><li>setter注入</li><li><u><em>接口注入</em></u>？</li></ul><p>（2）将Bean装配进Spring IoC的配置方式（以<strong>注解为主，XML为辅</strong>）</p><ul><li>在XML中显式配置</li><li>在Java的接口和类中实现配置</li><li>隐式Bean的发现机制和自动装配原则</li></ul><p>（3）三种装配Bean方式的优先级</p><ul><li>基于约定优于配置的原则，优先选择隐式Bean的发现机制和自动装配原则</li><li>在没法使用自动配置原则情况下，优先使用在Java的接口和类中实现配置，这样可以避免XML配置泛滥；同时，当一个父类有多个子类时，如果想通过IoC容器初始化父类，容器将无法决定使用哪个子类去初始化，这时候可以通过Java注解的方式去指定一个子类</li><li>最后选用XML方式，因为有时候使用第三方库时，没法取修改这些类库代码，这时候就可以通过XML方式去配置，将第三方类库的Bean装配到Spring IoC容器中</li></ul><p>（4）XML装配Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role2"</span> <span class="attr">class</span>=<span class="string">"com.ssm.chapter9.pojo.Role"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"roleName"</span> <span class="attr">value</span>=<span class="string">"高级工程师"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">value</span>=<span class="string">"重要人员"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>id是spring找到这个Bean的编号，如果没有指定，则spring会自动生成“全限定名#{num}”格式的编号</li><li>class是这个Bean的类的全限定名</li><li>property是定义类的属性，name是属性名，value是属性值，另外属性的值如果是引用类型，可以通过ref=“{source.id}”来引用定义的其他bean</li></ul><p>当property是集合时，可以通过如下方式来定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-list-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-list-2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-list-3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key1"</span> <span class="attr">value</span>=<span class="string">"value-key-1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key2"</span> <span class="attr">value</span>=<span class="string">"value-key-2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key3"</span> <span class="attr">value</span>=<span class="string">"value-key-3"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Property --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"prop1"</span>&gt;</span>value-prop-1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"prop2"</span>&gt;</span>value-prop-2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"prop3"</span>&gt;</span>value-prop-3<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-set-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-set-2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-set-3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数组 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"array"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-array-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-array-2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>value-array-3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果list、map、set和array这些集合的元素是一个类而不是基本数据类型，那么可以将&lt;value/&gt;替换为&lt;ref bean=”xxx”/&gt;（map中&lt;entry/&gt;的key替换为key-ref、value替换为value-ref）来引用别处定义好的bean，这样就完成了类集合的Bean定义</p><p>（5）Spring中，Spring IoC容器发现Bean的方式有两中：</p><ul><li>组件扫描：通过定义资源的方式 ， 让 Spring IoC 容器扫描对应 的包 ，从而把 Bean<br>装配进来</li><li>自动装配：通过注解定义，使得一些依赖关系可以通过注解完成</li></ul><p>常见的注解如下：</p><ul><li><strong>@Component</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value = <span class="string">"role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span></span>&#123;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"role_name_1"</span>)</span><br><span class="line"><span class="keyword">private</span> String roleName;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"role_note_1"</span>)</span><br><span class="line"><span class="keyword">private</span> String note;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setters and getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中@Component表示Spring IoC会将这个类扫描成Bean实例，value后面的值是Bean在Spring中的id编号；如果不知道value，Spring会自动生成编号</p><p>@Value代表的是值的注入</p><ul><li><strong>@ComponentScan</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PojoConfig</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有@Component还不行，还得设置@ComponentScan告诉Spring要扫描的包路径，这里没有设置值，则默认是扫描PojoConfig所在包下的类，所以上面的Role要和PojoConfig放在一起才能被Spring扫描到</p><p>@ComponentScan有两个配置项：basePackages，接受一个Java包数组，Spring会根据配置来扫描对于的包和这些包下面的<strong>子包</strong>；basePackagesClasses，它接受一个类的数组，Spring会根据这些类所在的包，为<strong>包和子包</strong>进行扫描装配对应配置的<br>Bean </p><p>要注意的是：</p><ul><li>如果定义了多个@ComponentScan，每个@ComponentScan都会对扫描到的Bean生成一个实例，这就<strong>可能出现很多重复的实例</strong></li><li>但是对于同一个@ComponentScan里面的basePackages和basePackagesClasses，两者如果有出现扫描重复的Bean，也<strong>只会生成一个Bean实例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context =</span><br><span class="line"><span class="keyword">new</span> AnnotationConfigApplicationContext(PojoConfig.class);</span><br><span class="line">Role role= context.getBean(Role.class);</span><br></pre></td></tr></table></figure><p>接下来只需要将配置类PojoConfig添加到context中，就能通过context来获取Spring IoC扫描到的Bean实例了</p><ul><li><strong>自动装配@Autowired</strong></li></ul><p>Spring在生成所有Bean后，如果发现有这个注解，就会<strong>根据类型</strong>在Bean容器中查找对应的Bean，将其注入进来，这就是依赖注入</p><p>如果IoC容器寻找失败，默认情况下会抛出异常，如果有些字段的实例可有可无，可以设置@Autowired(require = false)，这样IoC在没有找到对应的Bean实例的时候就不会抛出异常了</p><p>根据类型注入的问题在于：当Java中的一个接口（或者抽象类）有多个实现类的时候，这样就会造成<br><strong>通过类型（ by type ）获取 Bean 的不唯一 ， 从而导致 Spring IoC 类似于按类型的方法无法获</strong><br><strong>得唯一的实例化类</strong>，这就是自动装配的歧义性。解决歧义性的方法是@Primary和@Qualifier：</p><ul><li><p>＠Primary 注解告诉 Spring IoC 容器，如果存在某个类型的多个子类型，无法判<br>断注入哪个的时候，优先将注解有@Primary 的实例注入</p></li><li><p>@Qualifier 注解是告诉Spring IoC容器根据Bean的名称而不是类型来进行注入，由于Bean的id的唯一性，这样就消除了歧义性</p></li><li><p>注意，<strong>@Primary是注解到Bean</strong>上的，<strong>@Quality是注解到Bean的引用变量</strong>上的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"roleService3"</span>)</span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleServiceimpl</span> <span class="keyword">implements</span> <span class="title">RoleService</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"roleService3"</span>)</span><br><span class="line"><span class="keyword">private</span> RoleService roleService = <span class="keyword">null</span> ;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Qualifier和@Autowired这两个注解可以注解到参数变量上</strong></p></li><li><p>@Component只能注解到类上，不能注解到方法上；可以通过注解@Bean注解到方法上（但不能注解到类上），将方法的返回值作为Spring的Bean存放到IoC容器中</p><p>@Bean有四个配置项</p><ul><li>name ： 是一个字符串数组，允许配置多个 BeanName </li><li>autowire：标志是否是一个引用的 Bean 对象，默认值是 Autowire.NO </li><li>initMethod ： 自定义初始化方法</li><li>destroyMethod ： 自定义销毁方法。</li></ul></li><li><p>＠ImportResource</p><p>如果使用XML和注解混用的方式配置Bean的时候，可以在配置类上面使用＠ImportResource来引入XML定义的Bean，这样就能将XML定义的Bean扫描进IoC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(&#123;<span class="string">"classpath:spring-dataSource.xml"</span>, <span class="string">"..."</span>, ...&#125;)<span class="comment">//接受一个数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Import</p><p>如果配置分散到多个配置类中，那么就可以在主配置类上使用@Import来引入其他的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;ApplicationConfig2.class, ApplicationConfig3.class, ...&#125;)<span class="comment">//接受一个数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（6）使用Profile</p><ul><li><p>@Profile注解主要是配置Spring Bean的作用环境的（dev环境、test环境还是prod环境等）</p></li><li><p>@Profile注解在Bean上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"devDataSource"</span>)</span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDevDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"testDataSource"</span>)</span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDevDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>激活Profile</p><ul><li>在使用 Spring MVC 的情况下可以配置Web上下文参数 ，或者 DispatchServlet 参数</li><li>作为 JNDI 条目</li><li>配置环境变量</li><li>配置 JVM 启动参数</li><li><strong>在集成测试环境中使用＠ActiveProfiles</strong> </li></ul></li></ul><p>（9）加载属性（properties）文件</p><ul><li><p>使用注解@PropertySource来加载属性文件，它有四个配置项：</p><ul><li>name ： 字符串，配置这次属性配置的名称</li><li>value ： 字符串数组，可以配置多个属性文件</li><li>ignoreResourceNotFound : boolean 值，默认为false，其含义为如果找不到对应的属<br>性文件是否进行忽略处理，由于默认值为 false，所以在默认的情况下找不到对应的<br>配置文件会抛出异常 </li><li>encoding：编码，默认为””</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value=&#123;<span class="string">"classpath:database-config.properties"</span>&#125;,</span><br><span class="line">ignoreResourceNotFound=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用配置文件的属性</p><p>加载属性文件后，就可以通过<code>context.getEnvironment().getProperty(&quot;xxx&quot;)</code>来获得属性文件中的属性值，xxx是属性名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String url = context.getEnvironment().getProperty(<span class="string">"jdbc.database.url"</span>);</span><br></pre></td></tr></table></figure></li><li><p>属性文件解析类PropertySourcesPlaceholderConfigurer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value=&#123;<span class="string">"classpath:database-config.properties"</span>&#125;,</span><br><span class="line">ignoreResourceNotFound=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span></span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertySourcesPlaceholderConfigurer <span class="title">propertySourcesPlaceholderConfigurer</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以直接使用@Value来引用配置的属性和占位符了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> clss DataSourceBean&#123;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.datasource.driver&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String driver = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.datasource.url&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String driver = url;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>（10）条件化装配Bean</p><ul><li><p>@Conditional可以配置一个或者多个类，这些类都得实现接口Condition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"dataSource"</span>)</span><br><span class="line"><span class="meta">@Conditional</span>(&#123;DataSourceCondition.class, ...&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>&#123;</span><br><span class="line">Environment env = context.getEnvironment();</span><br><span class="line"><span class="keyword">return</span> env.containsProperty(<span class="string">"jdbc.database.driver"</span>) &amp;&amp; ...;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过context获得Spring的运行环境，当matches方法返回值为true时则装配Bean，返回false则不会创建对应Bean</p><p>这样的作用是，如果属性配置文件的属性没有配置完整的话，可能会导致对应的Bean初始化失败，配置了@Conditional之后，可以自定义在属性配置完整后才初始化Bean</p></li></ul><p>（11）Bean的作用域</p><ul><li><p>默认情况下，Spring IoC容器会为配置的Bean生成一个实例，而不是多个</p></li><li><p>Spring 提供了 4 种作用域，它会根据情况来决定是否生成新的对象：</p><ul><li>单例（ singleton ）：它是默认的选项，在整个应用中 ， Spring 只为其生成一个 Bean<br>的实例</li><li>原型（ prototype ） ： 当每次注入，或者通过 Spring IoC 容器获取 Bean 时， Spring 都<br>会为它创建一个新的实例</li><li>会话（ session ） ： 在 <strong>Web 应用</strong>中使用，就是在会话过程中 Spring 只创建一个实例 </li><li>请求（ request ） ： 在 <strong>Web 应用</strong>中使用的，就是在一次请求中 Spring 会创建一个实例，<br>但是不同的请求会创建不同的实例（和会话不同的是，一次会话中可能会有多次请求）</li></ul></li><li><p>使用@Scope注解在Bean上面来配置Bean的作用域</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br></pre></td></tr></table></figure></li></ul><h4 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h4><p>（1）AOP的流程<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/21/5ce351725257d97470.png" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>（2）常见术语</p><ul><li>切面（Aspect）：整个工作环境，想当一个拦截器</li><li>通知（Advice）：通知是切面开启后，切面的方法。它根据在代理对象真实方法调用前、后的顺序和逻<br>辑区分</li><li>引入（Introduction）：引入允许我们<strong>在现有的类里添加自定义的类和方法</strong></li><li>切点（Pointcut）：动态代理中，被切面拦截的方法就是一个切点</li><li>连接点（join point）：连接点是一个判断条件，由它可以<strong>指定哪些是切点</strong>。对于指定的切点， Spring 会生成<br>代理对象去<strong>使用对应的切面对其拦截</strong>，否则就不会拦截它</li><li>织入（Weaving）：生成代理对象的过程，Spring中使用JDK动态代理技术来织入</li></ul><p>（3） SpringAOP 是一种基于方法拦截的 AOP，换句话说 <strong>Spring 只能支持方法拦截的 AOP</strong></p><p>（4）Spring 中有 4 种方式去实现 AOP 的拦截功能：</p><ul><li>使用 ProxyFactoryBean 和对应的接口实现 AOP </li><li>使用 XML 配置 AOP </li><li><strong>使用＠AspectJ 注解驱动切面（最常用）</strong> </li><li>使用 AspectJ 注入切面</li></ul><p>（5）使用＠AspectJ 注解驱动切面</p><ul><li><p>创建切面</p><p>Spring中只需要使用@Aspect注解一个类，那么Spring IoC容器就会认为这是一个切面</p></li><li><p>添加通知（各个通知的调用顺序如下图）</p><p><img src="https://i.loli.net/2019/05/21/5ce3564e073da46274.png" alt></p></li><li><p>连接点：连接点是添加在通知注解里的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(*com.ssm.chapter11.aop.service.impl.RoleService.printRole(...))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Before里面的正则表达式就是连接点</p><ul><li>execution ： 代表执行方法的时候会触发</li><li>*： 代表任意返回类型的方法</li><li>com.ssm.chapter11.aop .service.impl.RoleServicelmpl：代表类的全限定名</li><li><strong>printRole ： 被拦截方法名称</strong></li><li>(…) ： 任意的参数</li></ul></li><li><p>切点：如果每个通知里面都重复写一样的连接点会很麻烦，这时候可以使用切点@Pointcut来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(*com.ssm.chapter11.aop.service.impl.RoleService.printRole(...))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 可以是空的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"print()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span>(<span class="string">"print()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样print()就变成了这个切面的切点了，在<strong>通知</strong>中只需要将<strong>切点方法</strong>作为<strong>连接点</strong>就行了，避免重复书写冗长的正则表达式</p></li><li><p>启用AspectJ自动代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span></span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RoleAspect <span class="title">getRoleAspect</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RoleAspect();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@EnableAspectJAutoProxy</strong>代表着启用 AspectJ 框架的 自动代理，这个时候 Spring 才会生成动<br>态代理对象，进而可以使用 AOP；然后将我们定义的RoleAspect这个切面通过@Bean初始化到IoC容器中，这样就可以拦截printRole方法了</p></li><li><p>环绕通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"print()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span></span>&#123;</span><br><span class="line">...<span class="comment">// 语句1</span></span><br><span class="line">jp.proceed();</span><br><span class="line">...<span class="comment">// 语句2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>环绕通知Spring会提供一个参数ProceedingJoinPoint用来反射调用被代理对象的原有方法，这样实际上环绕通知可以在jp.proceed()前后实现@Before和@After一样的功能了;</p><p>假如也实现了@Before和@After通知的话，Spring调用的顺序是：</p><p>​    <strong>语句1-&gt;@Before-&gt;print()-&gt;语句2-&gt;@After-&gt;@AtfterReturning/@AfterThrowing</strong></p></li><li><p>织入</p><p>织入是生成代理对象的过程，在上述的代码中，切点方法所在的类都是拥有接口的类，<br>而事实上即使没有接口 ， Spring 也能提供 AOP 的功能</p><ul><li>当类的实现存在接口的<br>时候， Spring 将提供 JDK 动态代理，从而织入各个通知</li><li>当类不存在接口的时候没有办法使用 JDK 动态代理，<br>Spring 会采用 CGLIB 来生成代理对象</li></ul></li><li><p>给通知传递参数</p><p>使用args()函数来给各类通知传递切点方法的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(*com.ssm.chapter11.aop.service.impl.RoleService.printRole(...)) &amp;&amp; args(role, sort)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Role role, <span class="keyword">int</span> sort)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里，传给通知的参数是和传递给通知方法printRole(role, sort)一样的，这样就能够在前置方法中对传递的参数进行检查，不合法的话可以拦截下来，从而不调用拦截方法</p></li><li><p>引入</p><p>可以通过定义一个接口，在生成动态代理对象时将被拦截对象挂靠在这个接口上，就可以为被拦截对象添加新的功能了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RoleVerifier</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(Role role)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoleVerifierImpl</span> <span class="keyword">implements</span> <span class="title">RoleVerifier</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(Role role)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> role != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在切面类中添加如下代码</span></span><br><span class="line"><span class="meta">@DeclareParents</span>(value = <span class="string">"com.ssm.chapter11.aop.service.impl.RoleServiceImpl+"</span>, defaultImpl = RoleVerifierImpl.class)</span><br><span class="line"><span class="keyword">public</span> RoleVerifier roleVerifier;</span><br></pre></td></tr></table></figure><p>@DeclareParents配置项：</p><ul><li>value=”com.ssm.chapter11.aop.service.impl.RoleServiceImpl+”： 表示对 RoleServicelmpl<br>类进行增强，也就是在 RoleServicelmpl 中引入一个新的接口</li><li>defaultlmpl：代表其默认的实现类，这里是 RoleVerifierlmpl </li></ul><p>实现的原理其实是在生成代理对象时，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><p><code>obj.getClass().getInterfaces()</code>是用来给被代理对象添加挂靠接口的，只要生成代理对象时将它挂靠在我们声明的RoleVerifier接口上面，这样我们就能够通过强制类型装换将被代理对象转化为RoleVerifier，进而调用我们引入的方法（CGLIB动态代理也一样，Enhancer也有个提供挂靠接口的方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RoleService roleService = ctx.getBean(RoleService.class );</span><br><span class="line">RoleVerifier roleVerifier = (RoleVerifier) roleService;</span><br><span class="line"><span class="comment">// 调用引入的方法</span></span><br><span class="line"><span class="keyword">if</span>(roleVerifier.verify(role))&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个方法有多个切面时，这些切面的调用顺序是根据切面在配置类中的配置顺序来调用的；也可以通过注解<strong>@Order</strong>来<u><em>在切面声明时</em></u>给这些切面设置优先级（优先级一样时，依旧是按照配置顺序来调用的）；这其实就是一种<strong>责任链模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aspect1</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以通过<strong>实现Ordered接口</strong>，在<strong>gerOrder()方法</strong>中返回优先级也可以实现和@Order注解一样的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aspect1</span> <span class="keyword">implements</span> <span class="title">Ordered</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/21/5ce3a97351a4e69123.png" alt></p></li></ul><h4 id="Spring数据库事务管理"><a href="#Spring数据库事务管理" class="headerlink" title="Spring数据库事务管理"></a>Spring数据库事务管理</h4><p>（1） MyBatis 框架用得最多的事务管理器是 <strong>DataSourceTransactionManager</strong>，配置事务管理器要提供数据源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>＝"<span class="attr">transactionManager</span>" <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）数据库资源的产生和释放如果没有委托给数据库管理器，那么就由 jdbcTemplate 管理 ，但是此时已经委托给了事务管理器，所以<br>jdbcTemplate 的<strong>数据库资源和事务</strong>己经由事务管理器处理了</p><p>（3）在配置类中使用注解＠EnableTransactionManagement<br>后 ， 在 Spring 上下文中使用事务注解＠Transactional, Spring 就会知道使用这个数据库事务管理器管理事务了</p><p>（4）用 Java 配置的方式来实现 Spring 数据库事务，需要在配置类中实现接口<br><strong>TransactionManagementConfigurer 的 annotationDrivenTransactionManager 方法</strong> 。 Spring 会把<br>annotationDrivenTransactionManager 方法返回的事务管理器作为程序中的事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现接口方法 ， 使得返回数据库事务管理器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Bean</span>(name=<span class="string">"transactionManager"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">annotationDrivenTransactionManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">DataSourceTransactionManager transactionManager = <span class="keyword">new</span> DataSourceTransactionManager();</span><br><span class="line"><span class="comment">// initDataSource()是配置类中配置的数据源Bean</span></span><br><span class="line">transactionManager.setDataSource(initDataSource());</span><br><span class="line"><span class="keyword">return</span> transactionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）声明式事务（一种约定式事务）</p><ul><li>如果使用的是声明式事务，那么当你的业务方法不发生异常（或者发生异常 ， 但该异常也<br>被配置信息允许提交事务）时， Spring 就会让事务管理器提交事务 </li><li>发生异常（并且该<br>异常不被你的配置信息所允许提交事务）时，则让事务管理器回滚事务。</li></ul><p>（6）＠Transactional </p><p><img src="https://i.loli.net/2019/05/26/5cea055fa7d5578783.png" alt></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/26/5cea05d2bac5676266.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（7）数据库事务</p><ul><li>ACID特性<ul><li>原子性：一个事务中的操作要么全部成功，要么全部失败，不可能停滞在中间的某个状态</li><li>一致性：事务可以修改数据库封装的状态，但是无论并发的事务有多少，数据库封装的状态都是一致的</li><li>隔离性：不同事务之间的隔离程度</li><li>持久性：事务一旦执行成功，那么该事务对数据库所做的修改就是永久保存的，不会被回滚</li></ul></li><li>丢失更新<ul><li>第一类丢失更新：一个事务提交、一个事务回滚导致的提交事务的更新丢失（当前主流数据库已经克服了此类更新）</li><li>第二类丢失更新：由于无法探知其他事务中的操作，导致两个或多个事务都提交后的更新丢失（即一个事务将之前事务的更新给覆盖掉）</li></ul></li><li>隔离级别<ul><li><strong>脏读</strong>：允许一个事务去读取其他事务中已经修改但尚未提交的数据（如果被脏读的事务回滚了，这属于第一类更新丢失的情况，但是主流数据库已经克服了此类更新丢失，这样回滚的事务不会覆盖成功提交的事务，出现的问题就是相当于回滚的事务不起作用，成功提交的事务使用了脏读的数据进行数据库更新导致数据库最终的状态是保存了错误的数据）</li><li><strong>读/写提交</strong>：一个事务只能读或者写另一个事务已经提交的数据（这样在一个事务成功提交、一个事务回滚的情况下，成功提交的事务没有脏读，回滚的事务由于第一类更新丢失被数据库的设计克服了，不会覆盖成功提交的事务；但是会出现的一个情况是，如果另一个事务B没有回滚，而是在另一个事务成功提交前也成功提交了，会导致最后提交的事务A出现<strong>不可重复读</strong>的现象，即 A在B提交前和B提交后读取的数据不一致）</li><li><strong>可重复读</strong>：可重复读是针对<strong>同一条记录</strong>而言的，即不同事务对<strong>同一条记录</strong>的读/写按照一个序列化进行操作，不会产生交叉现象，保证了<strong>同一条数据</strong>的一致性（这个级别的隔离会导致<strong>幻读现象</strong>，幻读是针对多条记录而言的，即事务A在查询数据库多条记录，同时事务B往数据库添加或者删除了一条记录并成功提交后，事务A在提交时会幻读多出/少掉一条）</li><li><strong>序列化</strong>：让SQL按照序列化的顺序进行读写操作，即所有事务对数据库的读写操作都是按照顺序执行的，不会产生交叉，这样就可以克服幻读现象了</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/26/5cea37aba16ad75008.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（8）隔离级别和传播行为的选择</p><ul><li><p>选择隔离级别的出发点在于两点 ： <strong>性能和数据一致性</strong>，从脏读到序列化，系统性能直线下降，例如序列化，直接就抑制了并发，导致大量的请求被挂起</p></li><li><p>@Transactional通过Isolation设置隔离级别，通过propagation设置传播行为</p><ul><li>＠Transactional 隔离级别的默认值为 Isolation .DEFAULT，其含义<br>是默认的，随数据库默认值的变化而变化</li></ul></li><li><p>传播行为是指<strong>方法之间</strong>的调用事务策略的问题，<strong>一个方法调度另外一个方法时，可以对事务的特性进行传播配置</strong>；即当一个事务中是由多个数据库操作完成的（不同的方法），而这些操作之间是相互独立的，那么其中一个操作失败时，没必要回滚整个事务，而只需要将失败的那个操作回滚就可以了，因为这个回滚操作对其他的独立的操作不会造成数据不一致性的影响</p><p><img src="https://i.loli.net/2019/05/26/5cea3aebe3b5d83195.png" alt></p></li></ul><p>（9）@Transactional 的自调用失效问题</p><ul><li><p>注解＠Transaction 的底层实现是 SpringAOP 技术，而 SpringAOP 技术使用 的是动态代<br>理 。 这就意味着对于<strong>静态（ static ）方法和非 public 方法 ， 注解＠Transactional 是失效的</strong> </p></li><li><p>由于＠Transactional 的实现原理是<br>AOP ，而 AOP 的实现原理是动态代理 ，如果是自己调用自己的过<br>程，并不存在代理对象的调用，这样就不会产生 AOP 去为我们设置＠Transactional<br>配置的参数，这样就出现了自调用注解失效的 问题；解决的方法时，<strong>不直接进行自调用，而是通过从容器中获取代理对象来间接进行自调用，这样就能够启用AOP技术了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从容器中获取 RoleService 对象 ，实际是一个代理对象</span></span><br><span class="line">RoleService service = ctx.getBean(RoleService.class);</span><br></pre></td></tr></table></figure></li></ul><p>（10）使用@Transactional时的一些注意点</p><ul><li>如果前后调用带有@Transactional的方法，那么这两次调用不在同一个事务中</li><li>不要长时间占用事务，比如在事务中长时间处理和数据库事务无关的东西，这样会严重浪费数据库资源</li><li>在@Transactional方法中捕获到异常时一定要再将其抛出，让Spring的事务管理器去处理；否则如果没有抛出，事务管理器就会任务代码运行正常，不会对出错的事务进行回滚</li></ul><h3 id="SpringMVC框架"><a href="#SpringMVC框架" class="headerlink" title="SpringMVC框架"></a>SpringMVC框架</h3><h4 id="SpringMVC的组件和流程"><a href="#SpringMVC的组件和流程" class="headerlink" title="SpringMVC的组件和流程"></a>SpringMVC的组件和流程</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/21/5ce3adec9efd490462.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images2017.cnblogs.com/blog/764313/201708/764313-20170801160342599-1885837375.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（1）Servlet在初始化时，SpringMVC会根据配置获取配置信息，从而得到<strong>统一资源标识符URI</strong>和<strong>处理器Handler</strong>之间的<strong>映射关系（HandlerMapping）</strong>；同时为了更加灵活和增强功能，SpringMVC还给处理器加入了<strong>拦截器Interceptor</strong>，可以在处理器执行前后加入自己的功能，这样就构成了一个<strong>处理器执行链（HandlerExecutionChain）</strong>（拦截器+处理器）</p><p>（2）当一个请求过来时，DispatchServlet首先通过请求和实现解析好的HandlerMapping，找到对应的处理器Handler，然后就准备开始执行拦截器和处理器</p><p>（3）由于运行处理器需要有一个对应的环境，它可以通过请求类型找到<strong>处理器适配器HandlerAdapter</strong>来运行对应的处理器及其拦截器，然后处理器将<strong>模型和视图ModalAndView</strong>返回给DispatchServlet</p><p>（4）如果是逻辑视图，那么DispatchServlet就会将它传递给<strong>视图解析器ViewResolver</strong>解析它，将模型渲染到视图中去；如果不是逻辑视图，则不会进行处理，直接通过视图渲染数据模型</p><p>（5）最后将渲染好的视图返回给客户端</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/05/21/5ce3b52f06a5095490.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="SpringMVC的初始化"><a href="#SpringMVC的初始化" class="headerlink" title="SpringMVC的初始化"></a>SpringMVC的初始化</h4><p>（1）初始化 Spring IoC 容器上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化Spring IoC容器，使用的是满足ApplicationContext接口的Spring Web IoC容器</span></span><br><span class="line">        <span class="keyword">this</span>.initWebApplicationContext(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 关闭Web IoC容器</span></span><br><span class="line">        <span class="keyword">this</span>.closeWebApplicationContext(event.getServletContext());</span><br><span class="line">        <span class="comment">// 清除相关参数</span></span><br><span class="line">ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DispatcherServlet 初始化前完成 Spring IoC 容器的初始化</li><li>在结束期完成对Spring IoC 容器的销毁</li></ul><p>（2）初始化映射请求上下文</p><p>（略orz，SSM框架书籍P379页）</p><p>（3）使用注解配置方式初始化</p><ul><li><p>继承一个名字比较长的类 AbstractAnnotationConfigDispatcherServletlnitializer，然后实现它所定义的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppinitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfig</span></span></span><br><span class="line"><span class="class"><span class="title">DispatcherServletinitializer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Spring IoC 容器配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 可以返回 Spring 的 Java 配置文件数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt; [] &#123;&#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//DispatcherServlet 的 URI 映射关系配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="comment">// 可以返回 Spring 的 Java 配置文件数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[] &#123; WebConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DispatcherServlet 拦截内容</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"*.do"</span>&#125;；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要实现了 WebApplicationlnitializer 接口的 onStartup 方法，<br>Spring MVC 就会把类当作一个初始化器加载进来；上面代码继承的是<br>AbstractAnnotationConfigDispatcherServletlnitializer，它们的关系如下：</p><p><img src="https://i.loli.net/2019/05/21/5ce3c0c8bb9db12310.png" alt></p><p>这就是只要继承 AbstractAnnotationConfigDispatcherServletlnitializer 类就完成了<br>DispatcherServlet 映射关系和 Spring IoC 容器的初始化工作的原因。</p></li><li><p>MyWebApplnitializer 配置类</p><ul><li><p>getRootConfigClasses 获取 <strong>Spring IoC 容器的 Java 配置类</strong>，用以装载各类 Spring Bean </p><p>getRootConfigClasses 方法返回为空，就不加载自定义的 Bean 到 Spring IoC 容器<br>中</p></li><li><p>getServletConfigClasses 获取各类 Spring MVC 的 <strong>URI 和控制器的配置关系类</strong>，用以生成 <strong>Web 请求的上下文</strong></p><p>getServletConfigClasses 加载了 WebConfig，则它就是一个 URI和控制器的映射关系<br>类</p></li><li><p>getServletMappings 定义 <strong>DispatcherServlet 拦截的请求</strong></p></li></ul></li><li><p>WebConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//定义扫描的包，加载控制器</span></span><br><span class="line"><span class="meta">@ComponentScan</span> (<span class="string">"com.*"</span>)</span><br><span class="line"><span class="comment">//启用 Spring Web MVC</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">    * 创建视图解析器</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 视图解析器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">""</span>viewResolver<span class="string">")</span></span><br><span class="line"><span class="string">    public ViewResolver initViewResolver () &#123;</span></span><br><span class="line"><span class="string">        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();</span></span><br><span class="line"><span class="string">        viewResolver.setPrefix("</span>/WEB-INF/jsp/<span class="string">") ;</span></span><br><span class="line"><span class="string">        viewResolver.setSuffix ("</span>.jsp<span class="string">") ;</span></span><br><span class="line"><span class="string">        return viewResolver ;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>和 Spring IoC 使用 Java 的配置也是一样的， 只是多 了一个注解＠EnableWebMvc,<br>它代表启动 Spring MVC 框架的配置</p></li></ul><h4 id="SpringMVC开发流程"><a href="#SpringMVC开发流程" class="headerlink" title="SpringMVC开发流程"></a>SpringMVC开发流程</h4><p>（1）@RequestMapping</p><p>＠RequestMapping 可以配置在类或者方法之上，它的作用是指定 URI 和哪个类（或者方法）作为一个处理请求的处理器； Spring MVC 还定义了处理器的<br>拦截器 ， 当启动 Spring MVC 的 时候 ， Spring MVC 就会去解析＠Controller 中的<br>@RequestMapping 的配置 ， 再结合所配置的拦截器，这样它就会组成多个拦截器和一个控<br>制器的形式 ， 存放到一个 HandlerMapping 中去</p><p>如果没有配置@RequestMapping中的method属性，那么它会响应所有类型请求</p><p>（2）控制器开发</p><ul><li><p>获取请求参数</p><ul><li>@RequestParam 获取请求参数，默认情况下不为空，设置required为false实可以为空；为空时，可以通过设置defaultValue来设置默认值</li><li>Spring MVC 还提供了注解＠SessionAtrribute 去从 Session 中获取对应的<br>数据</li></ul></li><li><p>处理业务逻辑</p></li><li><p>绑定模型和视图</p><ul><li><p>Spring MVC 会默认使用 JstlView 进行渲染，也就是<br>它将查询出来的<strong>模型绑定到 JSTL</strong> （JSP 标准标签库）模型中</p></li><li><p>使用JSON视图MappingJackson2JsonView（非逻辑视图，井不需要<br>视图解析器进行解析）可以将模型转化成JSON字符串返回到前端，一般用于Ajax请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">mv.setObject(<span class="string">"role"</span>, role);</span><br><span class="line">mv.setView(<span class="keyword">new</span> MappingJackson2JsonView());</span><br></pre></td></tr></table></figure><p>这样SpringMVC就会将对象role转成json字符串；但是也可以使用@ResponseBody使得返回结果变成JSON</p></li></ul></li></ul><h4 id="深入SpringMVC组件开发"><a href="#深入SpringMVC组件开发" class="headerlink" title="深入SpringMVC组件开发"></a>深入SpringMVC组件开发</h4><p>（1）控制器接收各类请求参数</p><ul><li><p>接受普通参数</p><ul><li>如果请求的参数名和控制器的参数名一致，则无需任何注解都能够正确接收；这种方式允许参数为空（基本数据类型除外，因为基本数据类型没有null这种值）</li><li>在没有任何注解的情况下，SpringMVC有映射POJO的能力，直接将请求参数与POJO内部的属性对应来生成POJO参数实例</li></ul></li><li><p>使用＠RequestParam 注解获取参数</p><ul><li>如果参数被＠RequestParam 注解，那么<strong>默认的情况下该参数不能为空</strong>，如果为<br>空则系统会抛出异常。如果希望允许它为空，那么要修改它的配置项 required 为 false</li><li>＠RequestParam(“xxx”)中的xxx与请求的参数名对应</li></ul></li><li><p>使用 ＠RequestMapping 和 ＠PathVariable 两个注解共同协作传递URL参数</p><ul><li>＠PathVariable允许对应的参数为空</li></ul></li><li><p><strong>传递JSON参数</strong></p><ul><li>控制器使用@RequestBody接收JSON参数，而且一个控制器只能有一个@RequestBody，如果有多个会报错，大概是第二个之后的@RequestBody要解析时，输入流已经关闭</li><li>@RequestBody也具备映射POJO的能力</li><li>客户端请求时要将json转为字符串传递<code>JSON.stringify(data)</code>，同时要蛇者<strong>ContentType为”application/json”</strong></li><li>如果是手写json来请求的话，不能使用单引号，而是要使用双引号，否则SpringMVC会解析失败</li></ul></li><li><p>接收列表数据和表单序列化</p><ul><li><p>Spring MVC 将传递过来的 JSON 数组数据（基本类型或者POJO都可以，只要请求的数据格式和控制器的参数一致即可） ， 转换为对应的 Java 集合类型。 把 List 转化为数组（ Long[] ）也是可行的</p></li><li><p>将 form 数据序列化，传递给后台，则数据将以 roleName=xxx &amp;&amp; note=xxx 传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"form"</span>).serialize()</span><br></pre></td></tr></table></figure><p>这样控制器只需要像接收普通参数一样接收即可（@RequestParam或者不用任何注解，具有解析POJO能力）</p></li></ul></li></ul><p>（2）重定向</p><ul><li><p>给数据模型Model附上对应的数据（作为重定向的控制器的参数），然后返回带有redirect的字符串来实现重定向功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addRole</span><span class="params">(Model model, ...)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">model.addAttribute(<span class="string">"roleName"</span>, roleName);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:./showRoleJsonInfo.do"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SpringMVC有个约定：当返回的字符串带有 redirect 的时候，它就会认为需要的是一个重定向</strong>，重定向redirect后面的内容是要重定向的url</p></li><li><p>通过返回视图来实现重定向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">addRole2</span><span class="params">(ModelAndView mv, ...)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">mv.addObject(<span class="string">"roleName"</span>, roleName);</span><br><span class="line">mv.setViewName(<span class="string">"redirect:./showRoleJsonInfo.do"</span>);</span><br><span class="line"><span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HTTP的重定向以字符串来传递参数，因此不能有效传递对象，这个时候 SpringMVC<br>提供了 一个方法——<strong>flash 属性</strong>，需要提供的数据模型就是一个 <strong>RedirectAttribute</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addRole3</span><span class="params">(RedirectAttributes ra, ...)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">ra.addFlashAttribute(<span class="string">"role"</span>, role);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:./showRoleJsonInfo.do"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能给重定向的地址传递POJO对象参数了</p><p>使用<br>addFlashAttribute 方法后， Spring MVC 会<strong>将数据保存到 Session</strong> 中 （Session 在一个会话期<br>有效），<strong>重定向后就会将其清除</strong>，这样就能够传递数据给下一个地址了</p><p><img src="https://i.loli.net/2019/05/21/5ce3fb60a042f27164.png" alt></p></li></ul><p>（3）拦截器</p><ul><li><p>拦截器可以在请求进入控制器前、后以及视图渲染完成后进行相关的操作</p></li><li><p>Spring 要求 处 理器 的 拦截器 都 要实 现 接 口 org.springframework. web.servlet.<br>HandlerInterceptor，也可以继承HandlerInterceptorAdapter（实现了HandlerInterceptor接口）</p><ul><li>preHandle：在处理器之前执行的前置方法，这样 SpringMVC 可以在进入处理<br>器前处理一些方法了。注意，它将返回一个 boolean 值，会影响到后面 Spring MVC<br>的流程</li><li>postHandle：在处理器之后执行的后置方法，处理器的逻辑完成后运行它</li><li>afterCompletion：无论是否产生异常都会<strong>在渲染视图后</strong>执行的方法</li></ul><p><img src="https://i.loli.net/2019/05/26/5cea5390c7bac23050.png" alt></p></li><li><p>springboot中使用拦截器，只需要在配置类（继承了WebMvcConfigurer且注解了@Configuration类）中重写addInterceptors方法即可，使用InterceptorRegistry来添加拦截器及拦截规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String SESSION_KEY = <span class="string">"user"</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AudienceInteceptor audienceInteceptor;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AdminInterceptor adminInterceptor;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ManagerInterceptor managerInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(audienceInteceptor).addPathPatterns(<span class="string">"/user/**"</span>);</span><br><span class="line">        registry.addInterceptor(adminInterceptor).addPathPatterns(<span class="string">"/admin/**"</span>);</span><br><span class="line">        registry.addInterceptor(managerInterceptor).addPathPatterns(<span class="string">"/manager/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多个拦截器的执行顺序和责任链模式的执行顺序一致</p><p><img src="https://i.loli.net/2019/05/26/5cea54b87799b56654.png" alt></p><p>当其中的一个 preHandle 方法返回为 false 后，按配置顺序，后面的 preHandle<br>方法都不会运行了，而控制器和所有的后置方法 postHandle 也不会再运行。执行过 preHandle<br>方法且该方法返回为 true 的拦截器的完成方法 （afterCompletion）会按照配置的逆序运行 </p><p><img src="https://i.loli.net/2019/05/26/5cea55177a5f619765.png" alt></p></li></ul><h2 id="附：随手记"><a href="#附：随手记" class="headerlink" title="附：随手记"></a>附：随手记</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>1.1、Java接口多继承</p><p>第一次注意到这个玩意是springMVC框架源码里面出现的接口多继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> GenericConverter&#125; that may conditionally execute based on attributes</span></span><br><span class="line"><span class="comment"> * of the &#123;<span class="doctag">@code</span> source&#125; and &#123;<span class="doctag">@code</span> target&#125; &#123;<span class="doctag">@link</span> TypeDescriptor&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;See &#123;<span class="doctag">@link</span> ConditionalConverter&#125; for details.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Keith Donald</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> GenericConverter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConditionalConverter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalGenericConverter</span> <span class="keyword">extends</span> <span class="title">GenericConverter</span>, <span class="title">ConditionalConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜了一下，摘录如下：</p><blockquote><p>先从Java 8之前说起。要区分“声明多继承”与“实现多继承”。<br>Java是不允许“实现多继承”，简称不允许“多继承”。但是Java支持“声明多继承”——Java的接口的多继承——一个类可以实现多个接口（“继承”了多个接口上的方法声明），而一个接口可以继承多个接口（同样是“继承”了多个接口上的方法声明）。<br>接口只允许有方法声明而不允许有实现，因而不会出现像C++那样的实现多继承的决议问题；抽象类可以有方法实现，但要遵循Java类的单继承限制，也避免了实现多继承的问题。这是早期Java为了与C++区分开的一个决定。</p><p>然后，从Java 8开始，接口允许为方法提供“默认实现”了——默认方法（default method）。因而实质上Java 8的接口多继承其实也会涉及到实现多继承，并且语言层面有专门规定去解决实现多继承时选择哪个版本的问题——哪个都不选择，而是在发现会继承多个默认方法实现并且没有override时报错，逼使用户显式override可能冲突的方法。<br>这使得Java 8开始接口可以当作traits来使用，达到实现多继承的目的。</p><p>作者：RednaxelaFX</p><p>链接：<a href="https://www.zhihu.com/question/24317891/answer/65097560" target="_blank" rel="noopener">https://www.zhihu.com/question/24317891/answer/65097560</a></p><p>来源：知乎</p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>1.2、Java中的byte，short，char进行计算时都会提升为int类型。（来源：<a href="https://www.nowcoder.com/test/question/done?tid=23696962&amp;qid=25211#summary" target="_blank" rel="noopener">https://www.nowcoder.com/test/question/done?tid=23696962&amp;qid=25211#summary</a>）</p><p>1.3、依赖倒置原则</p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/24175489" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24175489</a></p></blockquote><p>1.4、Spring循环依赖问题</p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/34923466" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34923466</a></p></blockquote><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p>2.1 GET与POST的区别</p><ul><li>GET 基本上用于从服务器获得（取回）数据。注释：GET 方法可能返回缓存数据。</li><li>POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。</li></ul><p>2.2 同源策略</p><blockquote><p>参见：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></p></blockquote><p>2.3 jsonp</p><blockquote><p>参考：<a href="https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" target="_blank" rel="noopener">https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html</a></p></blockquote><p>2.4 jQuery.validate插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd ) &#123;</span><br><span class="line">define( [<span class="string">"jquery"</span>], factory );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">factory( jQuery );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解释：<a href="https://stackoverflow.com/questions/30953589/what-is-typeof-define-function-defineamd-used-for" target="_blank" rel="noopener">https://stackoverflow.com/questions/30953589/what-is-typeof-define-function-defineamd-used-for</a></p><p>2.5 require.js模块开发</p><blockquote><p>参见：<a href="https://javascript.ruanyifeng.com/tool/requirejs.html" target="_blank" rel="noopener">https://javascript.ruanyifeng.com/tool/requirejs.html</a></p></blockquote><p>2.6 jQuery 库中的 $() 是什么？</p><p>$() 函数是 <strong>jQuery() 函数的别称</strong>。$() 函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你可以将一个选择器字符串传入 $() 函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象</p><p>2.7 $(document).ready()方法和window.onload有什么区别？</p><ul><li>window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。</li><li>$(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。</li></ul><p>2.8 jquery中$.get()提交和$.post()提交有区别吗？</p><p>相同点：都是异步请求的方式来获取服务端的数据；</p><p>异同点：</p><ul><li>请求方式不同：$.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。</li><li>参数传递方式不同：get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。</li><li>数据传输大小不同：get方式传输的数据大小不能超过2KB 而POST要大的多</li><li>安全问题： GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。</li></ul><p>2.9 简单的$.ajax()的请求方式（$.ajax()接受的参数是键值对列表）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">'http://www.baidu.com'</span>,</span><br><span class="line">    type:<span class="string">'POST'</span>,</span><br><span class="line">    data:data,</span><br><span class="line">    cache:<span class="literal">true</span>,</span><br><span class="line">    headers:&#123;&#125;,</span><br><span class="line">    beforeSend：<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    complete:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="JavaScript面试题"><a href="#JavaScript面试题" class="headerlink" title="JavaScript面试题"></a>JavaScript面试题</h3><p>（1）参考自：<a href="https://www.cnblogs.com/wdlhao/p/8290436.html#_label1" target="_blank" rel="noopener">https://www.cnblogs.com/wdlhao/p/8290436.html#_label1</a></p><p>（2）<strong>比较typeof与instanceof？</strong></p><ul><li>相同点：JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。</li><li>typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。</li><li>细节：</li><li>(1)、typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。</li><li>(2)、typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错。</li><li>(3)、对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。</li><li>Instanceof定义和用法：instanceof 用于判断一个变量是否属于某个对象的实例。</li></ul><p>（3）细节：</p><p>​    如下，得到的结果为‘N’,这里的 <strong>instanceof 测试的 object 是指 js 语法中的 object</strong>，不是指 dom 模型对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>)&#123; alert(<span class="string">'Y'</span>)&#125; <span class="keyword">else</span> &#123;  alert(<span class="string">'N'</span>);&#125;  <span class="comment">// 'N'</span></span><br></pre></td></tr></table></figure><p>（4）跨域访问</p><ul><li><p>什么是跨域：由于浏览器同源策略，凡是发送请求url的<strong>协议、域名、端口</strong>三者之间任意一与当前页面地址不同即为跨域</p><blockquote><p>存在跨域的情况：</p><ul><li>网络协议不同，如http协议访问https协议。</li><li>端口不同，如80端口访问8080端口。</li><li>域名不同，如qianduanblog.com访问baidu.com。</li><li>子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。</li><li>域名和域名对应ip,如<a href="http://www.a.com访问20.205.28.90" target="_blank" rel="noopener">www.a.com访问20.205.28.90</a>.</li></ul></blockquote></li><li><p>Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）；客户端请求js文件获取到本地之后<strong>会立即执行</strong></p></li><li><p>为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是<u><em>允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了</em></u></p></li></ul><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>（1）限制查询范围时，offset要和limit配合使用，单独使用offset会报错</p><p>（2）mysql中不等号使用&lt;&gt;, !=均可；但如果是在mybatis中书写mysql查询语句时，由于&lt;&gt;得进行转义，使用不方便，因此推荐使用!=；mysql中的等号是=而不是==</p><p>（3）mysql中的比较符号可以直接用在时间类型的字段比较中；current_timestamp()函数可以返回当前的时间戳</p><p>（4）mysql更新语句的update是和set一起配合使用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause]</span><br></pre></td></tr></table></figure><p>（5）删除记录的语法是delete from</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name [WHERE Clause]</span><br></pre></td></tr></table></figure><p>（6）插入记录的语法是insert into</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name ( field1, field2,...fieldN )</span><br><span class="line">                       VALUES</span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure><p>（7）MySQL LIKE 子句</p><ul><li><p>LIKE 通常与 <strong>%</strong> 一同使用，类似于一个元字符的搜索，<strong>%</strong>字符表示匹配任意字符</p></li><li><p>like语句用在where条件中，用于进行模糊匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos;</span><br></pre></td></tr></table></figure></li></ul><p>（8）MySQL UNION 操作符</p><ul><li><p>MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中；多个 SELECT 语句会删除重复的数据</p></li><li><p>语法格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions]</span><br><span class="line">UNION [ALL | DISTINCT]</span><br><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions];</span><br></pre></td></tr></table></figure><p>distinct：删除结果集中重复的数据【这是默认值】</p><p>all：返回所有结果集，包含重复数据</p><p>另外，union的结果集<strong>必须含有相同的列</strong>数，属性不同可以，但是会<strong>以第一个结果集的列属性为准</strong>；如果列属性不一样，那么distinct就会起作用了，它会<strong>根据数据的值来判断是否一致而不是属性类型来判断</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from demo;</span><br><span class="line">+----+------+------+</span><br><span class="line">| id | name | note |</span><br><span class="line">+----+------+------+</span><br><span class="line">|  1 | test | test |</span><br><span class="line">+----+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select id, name from demo union select id, note from demo;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | test |</span><br><span class="line">+----+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select id, name from demo union all select id, note from demo;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | test |</span><br><span class="line">|  1 | test |</span><br><span class="line">+----+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到，union的两个结果集的列不一致，但是合并之后，以第一个结果集的属性最终结果集的属性（id   name），然后使用union distinct时，它判断的是数据的值，发现name=’test’和note=’test’值相同，因此只有最终结果集中只有一条记录返回</p></li></ul><p>（9）排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN table_name1, table_name2...</span><br><span class="line">ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]</span><br></pre></td></tr></table></figure><p>通过order by设置排序的字段，可以有多个；默认按照升序排序ASC，也可以设置DESC设置降序排列</p><p>（10）分组</p><p>在MYSQL中使用GROUP BY对表中的数据进行分组时：</p><ul><li><strong>GROUP BY X意思是将所有具有相同X字段值的记录放到一个分组里，</strong></li><li><strong>GROUP BY X, Y意思是将所有具有相同X字段值和Y字段值的记录放到一个分组里。</strong></li></ul><p>分组之后需要对分组进行操作，这时候需要用到 COUNT, SUM, AVG,等函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name, function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name;</span><br></pre></td></tr></table></figure><p>function指的就是COUNT, SUM, AVG,等函数，函数里面的列是select后面的列中的一个或者多个，也可以是全部列(*)</p><p><code>GROUP BY column_name</code>后面在使用rollup关键字可以在分组统计数据的基础上在进行相同的统计（SUM,AVG,COUNT…）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name, SUM(singin) as singin_count FROM  employee_tbl GROUP BY name WITH ROLLUP;</span><br><span class="line">+--------+--------------+</span><br><span class="line">| name   | singin_count |</span><br><span class="line">+--------+--------------+</span><br><span class="line">| 小丽 |            2 |</span><br><span class="line">| 小明 |            7 |</span><br><span class="line">| 小王 |            7 |</span><br><span class="line">| NULL   |           16 |</span><br><span class="line">+--------+--------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>这个就是在计算了每个分组的sum之后，对所有的分组进行sum，即将所有分组看成一个大的分组进行sum</p><p>（11）JOIN</p><ul><li><p><strong>INNER JOIN（或者JOIN）</strong>：获取两个表中字段匹配关系的记录</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/03/img_innerjoin.gif" alt></p></li><li><p><strong>LEFT JOIN（左连接）：</strong>获取左表所有记录，即使右表没有对应匹配的记录（（没有记录的字段为NULL））</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/03/img_leftjoin.gif" alt></p></li><li><p><strong>RIGHT JOIN（右连接）：</strong> 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录（没有记录的字段为NULL）</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/03/img_rightjoin.gif" alt></p><p>示例代码</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.runoob_id, a.runoob_author, a.runoob_title, b.runoob_count from runoob_tbl a right join tcount_tbl b on a.runoob_author = b.runoob_author;</span><br></pre></td></tr></table></figure><p>使用<code>...  left join/join/right   ...  on   [条件]</code> 的语法</p><p>（12）NULL值比较</p><ul><li><p><strong>IS NULL:</strong> 当列的值是 NULL,此运算符返回 true。</p></li><li><p><strong>IS NOT NULL:</strong> 当列的值不为 NULL, 运算符返回 true。</p></li><li><p><strong>&lt;=&gt;:</strong> 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。</p><p>&lt;=&gt;可以代替=运算符，好处是当其中一个值为null时返回false，都为null时返回true，即使得null可以进行比较</p></li><li><p>NULL 值与任何其它值的比较（即使是 NULL）永远返回 false，即 <strong>NULL = NULL 返回false</strong> ，同时<strong>NULL != NULL也返回false</strong></p></li></ul><p>（13）正则表达式</p><p>​    在Mysql中可以使用REGEXP操作符来进行正则表达式匹配，可以起到和LIKE操作符模糊匹配一样的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &apos;^st&apos;;</span><br><span class="line">mysql&gt; select * from runoob_tbl where runoob_author regexp &apos;^[^a-zA-Z]+$&apos;;</span><br></pre></td></tr></table></figure><p>（14）alter命令</p><ul><li><p><code>ALTER TABLE testalter_tbl  DROP i;</code>用于删除表的i字段；如果标准只有一个字段，drop命令会失败</p></li><li><p><code>ALTER TABLE testalter_tbl ADD i INT;</code>用于添加表字段；新添加的字段i会追加在原有表字段的末尾</p><p>如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 <strong>FIRST (设定位第一列)</strong>， <strong>AFTER 字段名（设定位于某个字段之后）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE testalter_tbl DROP i;</span><br><span class="line">ALTER TABLE testalter_tbl ADD i INT FIRST;</span><br><span class="line">ALTER TABLE testalter_tbl DROP i;</span><br><span class="line">ALTER TABLE testalter_tbl ADD i INT AFTER c;</span><br></pre></td></tr></table></figure></li><li><p><code>ALTER TABLE testalter_tbl MODIFY c CHAR(10);</code>用于修改现有表字段的描述，新的描述直接覆盖原有字段的描述；</p><p><strong>modify不能修改字段名，而change可以修改字段名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE testalter_tbl CHANGE i j BIGINT;</span><br></pre></td></tr></table></figure><p>这个表示将原字段i修改名称为j，并且描述是BIGINT</p></li><li><p>也可以直接修改表的类型，<code>ALTER TABLE testalter_tbl ENGINE = MYISAM;</code>这个是修改数据表的存储引擎，可以通过<code>SHOW TABLE STATUS LIKE &#39;testalter_tbl&#39;\G</code>来查看表的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show table status like &apos;runoob_tbl&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           Name: runoob_tbl</span><br><span class="line">         Engine: MyISAM</span><br><span class="line">        Version: 10</span><br><span class="line">     Row_format: Dynamic</span><br><span class="line">           Rows: 5</span><br><span class="line"> Avg_row_length: 3276</span><br><span class="line">    Data_length: 16384</span><br><span class="line">Max_data_length: 0</span><br><span class="line">   Index_length: 0</span><br><span class="line">      Data_free: 0</span><br><span class="line"> Auto_increment: 6</span><br><span class="line">    Create_time: 2019-05-24 16:04:59</span><br><span class="line">    Update_time: 2019-05-24 15:10:46</span><br><span class="line">     Check_time: NULL</span><br><span class="line">      Collation: utf8_general_ci</span><br><span class="line">       Checksum: NULL</span><br><span class="line"> Create_options: </span><br><span class="line">        Comment: </span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>可以使用<code>rename to</code>来修改数据表的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE testalter_tbl RENAME TO alter_tbl;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML+CSS"></a>HTML+CSS</h3><p>（1）盒子模型</p><p>在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。</p><p>（2）src与href的区别</p><ul><li><strong>href 是指向网络资源所在位置</strong>，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。</li><li><strong>src是指向外部资源的位置</strong>，<strong>指向的内容将会嵌入到文档中当前标签所在位置</strong>；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。</li><li>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源<strong>加载、编译、执行完毕（如果是js文件的话，会将js文件里面的代码执行完再接着往下处理）</strong>，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</li></ul><p>（3）同步和异步的区别</p><ul><li><strong>同步是阻塞模式，异步是非阻塞模式</strong></li><li>同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；<br>异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。</li></ul><p>（4）px和em的区别</p><ul><li>相同点：px和em都是长度单位；</li><li>异同点：px的值是固定的，指定是多少就是多少，计算比较容易。<strong>em得值不是固定的，并且em会继承父级元素的字体大小</strong>。<br>浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。</li></ul><blockquote><p>px、em、rem区别介绍，参考：<a href="http://www.runoob.com/w3cnote/px-em-rem-different.html" target="_blank" rel="noopener">http://www.runoob.com/w3cnote/px-em-rem-different.html</a></p></blockquote><p>（5）sessionStorage 、localStorage 和 cookie 之间的区别</p><blockquote><p>Web Storage 包含如下两种机制：</p><ul><li><code>sessionStorage</code> 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即<strong>只要浏览器处于打开状态</strong>，包括页面重新加载和恢复）。</li><li><code>localStorage</code> 同样的功能，但是<strong>在浏览器关闭，然后重新打开后数据仍然存在</strong>。</li></ul></blockquote><p> 共同点：用于浏览器端存储的缓存数据</p><p>不同点：</p><ul><li>存储内容是否发送到服务器端<ul><li>当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费；</li><li>web storage,会将数据保存到本地，不会造成宽带浪费；</li></ul></li><li>数据存储大小不同<ul><li>Cookie数据不能超过4K,适用于会话标识；</li><li>web storage数据存储可以达到5M;</li></ul></li><li>数据存储的有效期限不同<ul><li>cookie只在设置了Cookid过期时间之前一直有效，即使关闭窗口或者浏览器；</li><li>sessionStorage,仅在关闭浏览器之前有效；</li><li>localStorage,数据存储永久有效；</li></ul></li><li>作用域不同<ul><li>cookie和localStorage是在同源同窗口中都是共享的；</li><li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li></ul></li></ul><p>（6）请指出document load和document ready的区别？</p><ul><li>共同点：这两种事件都代表的是页面文档加载时触发。</li><li>异同点：<ul><li>ready 事件的触发，表示文档结构已经加载完成（不包含图片等非文字媒体文件）。</li><li>onload 事件的触发，表示页面包含图片等文件在内的所有元素都加载完成。</li></ul></li></ul><h3 id="HTTP面试题"><a href="#HTTP面试题" class="headerlink" title="HTTP面试题"></a>HTTP面试题</h3><blockquote><p>参考：<a href="https://juejin.im/post/5a8102e0f265da4e710f5910" target="_blank" rel="noopener">https://juejin.im/post/5a8102e0f265da4e710f5910</a></p></blockquote><h3 id="web前端面试题"><a href="#web前端面试题" class="headerlink" title="web前端面试题"></a>web前端面试题</h3><h4 id="前端攻击方式-前端安全"><a href="#前端攻击方式-前端安全" class="headerlink" title="前端攻击方式/前端安全"></a>前端攻击方式/前端安全</h4><p>XSS攻击：跨站脚本攻击</p><p>CSRF攻击：跨站请求伪造攻击</p><h4 id="网站性能优化-js性能优化"><a href="#网站性能优化-js性能优化" class="headerlink" title="网站性能优化/js性能优化"></a>网站性能优化/js性能优化</h4><p><a href="https://juejin.im/post/59672fbff265da6c3f70cd53" target="_blank" rel="noopener">https://juejin.im/post/59672fbff265da6c3f70cd53</a></p><h4 id="跨浏览器兼容"><a href="#跨浏览器兼容" class="headerlink" title="跨浏览器兼容"></a>跨浏览器兼容</h4><h4 id="react性能优化"><a href="#react性能优化" class="headerlink" title="react性能优化"></a>react性能优化</h4><p>（1）重写shouldComponentUpdate来避免不必要的dom操作。</p><p>（2）使用 production 版本的react.js。</p><p>（3）使用key来帮助React识别列表中所有子组件的最小变化。</p><p>virtualDOM、合成事件系统</p><h4 id="事件冒泡机制"><a href="#事件冒泡机制" class="headerlink" title="事件冒泡机制"></a>事件冒泡机制</h4><h4 id="get和post有什么区别？"><a href="#get和post有什么区别？" class="headerlink" title="get和post有什么区别？"></a>get和post有什么区别？</h4><p>其实，GET和POST本质上两者没有任何区别。他们都是HTTP协议中的请求方法。底层实现都是基于TCP/IP协议。所谓区别，只是浏览器厂家根据约定，做得限制而已。</p><ul><li>get是通过明文发送数据请求，而post是通过密文；</li><li>get传输的数据量有限，因为url的长度有限，post则不受限；</li><li>GET请求的参数只能是ASCII码，所以中文需要URL编码，而POST请求传参没有这个限制</li><li>GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</li></ul><h4 id="document-onload和document-ready两个事件的区别"><a href="#document-onload和document-ready两个事件的区别" class="headerlink" title="document.onload和document.ready两个事件的区别"></a>document.onload和document.ready两个事件的区别</h4><p>页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页面包含图片等文件在内的所有元素都加载完成。</p><h4 id="计算机网络部分"><a href="#计算机网络部分" class="headerlink" title="计算机网络部分"></a>计算机网络部分</h4><h5 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h5><p>　 <strong>1）</strong> <strong>浏览器缓存</strong></p><p>　　当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；</p><p>　　<strong>2）</strong> <strong>系统缓存</strong></p><p>　　当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；</p><p>　　<strong>3）</strong> <strong>路由器缓存</strong></p><p>　　当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；</p><p>　　<strong>4）</strong> <strong>ISP（互联网服务提供商）DNS缓存</strong></p><p>　　当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；</p><p>　　<strong>5）</strong> <strong>根域名服务器</strong></p><p>　　当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；</p><p>　　<strong>6）</strong> <strong>顶级域名服务器</strong></p><p>　　顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；</p><p>　　<strong>7）</strong> <strong>主域名服务器</strong></p><p>　　主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；</p><p>　　<strong>8）保存结果至缓存</strong></p><p>　　本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。</p><h4 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/6/27/1643feb9f196b2c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaWeb开发学习笔记&quot;&gt;&lt;a href=&quot;#JavaWeb开发学习笔记&quot; class=&quot;headerlink&quot; title=&quot;JavaWeb开发学习笔记&quot;&gt;&lt;/a&gt;JavaWeb开发学习笔记&lt;/h1&gt;&lt;h2 id=&quot;Java-SE&quot;&gt;&lt;a href=&quot;#Ja
      
    
    </summary>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="javascript" scheme="http://QQ876684433.github.io/tags/javascript/"/>
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="JavaWeb" scheme="http://QQ876684433.github.io/tags/JavaWeb/"/>
    
      <category term="Spring" scheme="http://QQ876684433.github.io/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://QQ876684433.github.io/tags/SpringMVC/"/>
    
      <category term="Mybatis" scheme="http://QQ876684433.github.io/tags/Mybatis/"/>
    
      <category term="HTML" scheme="http://QQ876684433.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="http://QQ876684433.github.io/tags/CSS/"/>
    
      <category term="jQuery" scheme="http://QQ876684433.github.io/tags/jQuery/"/>
    
      <category term="面试" scheme="http://QQ876684433.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>64.最小路径和</title>
    <link href="http://QQ876684433.github.io/2019/07/14/64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <id>http://QQ876684433.github.io/2019/07/14/64-最小路径和/</id>
    <published>2019-07-14T15:23:52.000Z</published>
    <updated>2019-09-15T04:29:52.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h1><p>原题目如下：</p><blockquote><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例:</p><p>输入:<br>[<br>[1,3,1],<br>[1,5,1],<br>[4,2,1]<br>]</p><p>输出: 7</p><p>解释: 因为路径 1→3→1→1→1 的总和最小。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题比较简单，也是填表的问题，递推公式如下：<br>$$<br>dp[i][j] = dp[i][j]+min{dp[i+1][j]+dp[i][j+1]}<br>$$<br>意思是：从点(i, j)到终点有两个选择，从下边(i+1, j)或者右边(i, j+1)走，所以最短路径是下边或者右边走的最小值加上当前点的值，因此可以从右下角开始填表，注意处理好边界条件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[][]&#125; grid</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = grid.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = grid[<span class="number">0</span>].length<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==grid.length<span class="number">-1</span> &amp;&amp; j==grid[<span class="number">0</span>].length<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">let</span> right = <span class="literal">Infinity</span>, bottom = <span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=grid.length<span class="number">-1</span>) bottom = grid[i+<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j!=grid[<span class="number">0</span>].length<span class="number">-1</span>) right = grid[i][j+<span class="number">1</span>];</span><br><span class="line">            grid[i][j] = grid[i][j]+<span class="built_in">Math</span>.min(bottom, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ：O(m*n)。遍历整个矩阵恰好一次。</li><li>空间复杂度 ：O(1)<em>O</em>(1)。不需要额外空间。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>官方给的题解其实思路都差不多，只是具体实现有区别</p><ul><li><p>比如递归暴力解法，也是上面的思路，只是空间和时间开销巨大，我刚开始想的时候就直接拒绝了这种不优雅的做法；</p></li><li><p>二维数组动态规划和我的解法的唯一区别是它另外开辟了新的数组，这在一定情况下是必要的，当要求不能修改原数组时，就只能这么做；</p></li><li><p>针对二维数组动态规划的优化算法就是官解给出的一维动态规划，从我自己的解法中已经可以看出，我是从最下面一层开始往上面填表的，填完之后，下面的行就不再需要用了，所以可以复用一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = grid[grid.length<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = grid.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = grid[<span class="number">0</span>].length<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==grid.length<span class="number">-1</span> &amp;&amp; j==grid[<span class="number">0</span>].length<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">let</span> right = <span class="literal">Infinity</span>, bottom = <span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=grid.length<span class="number">-1</span>) bottom = res[j];</span><br><span class="line">            <span class="keyword">if</span>(j!=grid[<span class="number">0</span>].length<span class="number">-1</span>) right = res[j+<span class="number">1</span>];</span><br><span class="line">            res[j] = grid[i][j]+<span class="built_in">Math</span>.min(bottom, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>#### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;64-最小路径和&quot;&gt;&lt;a href=&quot;#64-最小路径和&quot; class=&quot;headerlink&quot; title=&quot;64. 最小路径和&quot;&gt;&lt;/a&gt;64. 最小路径和&lt;/h1&gt;&lt;p&gt;原题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个包含非负整数的 m x n
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>877.石子游戏</title>
    <link href="http://QQ876684433.github.io/2019/07/14/877-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/"/>
    <id>http://QQ876684433.github.io/2019/07/14/877-石子游戏/</id>
    <published>2019-07-14T15:22:39.000Z</published>
    <updated>2019-09-15T04:29:52.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="877-石子游戏"><a href="#877-石子游戏" class="headerlink" title="877. 石子游戏"></a>877. 石子游戏</h1><p>原题目如下：</p><blockquote><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p><p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p><p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p><p>示例：</p><p>输入：[5,3,4,5]</p><p>输出：true</p><p>解释：</p><p>亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。</p><p>假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</p><p>如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。</p><p>如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。</p><p>这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</p><p>提示：</p><p>2 &lt;= piles.length &lt;= 500<br>piles.length 是偶数。<br>1 &lt;= piles[i] &lt;= 500<br>sum(piles) 是奇数。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/stone-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="一个TLE的解法"><a href="#一个TLE的解法" class="headerlink" title="一个TLE的解法"></a>一个TLE的解法</h2><p>举个栗子，假设初始堆是：[1，2，3，4，5]，那么第一回合（即两个各拿一堆）后，会出现三种状态：</p><ul><li><p>亚4,李1，剩下[2，3]</p><p>ps：这里其实会出现“亚1,李4，剩下[2，3]”的情况，但是想想就知道，这两种情况的子问题都是[2，3]，如果“亚4,李1”不能保证亚赢的话，那“亚1,李4”就更不可能了，所以这种情况可以排除了</p></li><li><p>亚4,李3，剩下[1，2]</p></li><li><p>亚1,李2，剩下[3，4]</p></li></ul><p>然后接下来就是递归求解了，最后当剩下两堆时，可以保证亚取得最优解，直接返回两人的分差（亚-李）；然后递归计算完上面三个子问题之后，取最优的一种情况返回，最优的情况指的是两人得分差别最大的那种取法</p><p>代码不仅冗长，甚至还超时了orz：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; piles</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sub = <span class="function">(<span class="params">left, right, piles</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> l = piles[left], r = piles[right];</span><br><span class="line">    <span class="keyword">if</span>(right-left == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> [l, r];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> [r, l];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> subRes1 = sub(left+<span class="number">1</span>,right<span class="number">-1</span>,piles);</span><br><span class="line">        <span class="keyword">if</span> (l&gt;r)&#123;</span><br><span class="line">            subRes1[<span class="number">0</span>] += l;</span><br><span class="line">            subRes1[<span class="number">1</span>] += r;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            subRes1[<span class="number">0</span>] += r;</span><br><span class="line">            subRes1[<span class="number">1</span>] += l;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> subRes2 = sub(left+<span class="number">2</span>, right, piles);</span><br><span class="line">        subRes2[<span class="number">0</span>] += l;</span><br><span class="line">        subRes2[<span class="number">1</span>] += piles[left+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> subRes3 = sub(left, right<span class="number">-2</span>, piles);</span><br><span class="line">        subRes3[<span class="number">0</span>] += r;</span><br><span class="line">        subRes3[<span class="number">1</span>] += piles[right<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> res = subRes1;</span><br><span class="line">        <span class="keyword">if</span> (subRes2[<span class="number">0</span>]-subRes2[<span class="number">1</span>]&gt;res[<span class="number">0</span>]-res[<span class="number">1</span>]) res = subRes2;</span><br><span class="line">        <span class="keyword">if</span> (subRes3[<span class="number">0</span>]- subRes3[<span class="number">1</span>]&gt;res[<span class="number">0</span>]-res[<span class="number">1</span>]) res = subRes3;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stoneGame = <span class="function"><span class="keyword">function</span>(<span class="params">piles</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = sub(<span class="number">0</span>, piles.length<span class="number">-1</span>, piles);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>]&gt;res[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>让我们来见证一下真正的动态规划长啥样</p><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/stone-game/solution/dong-tai-gui-hua-by-cliant/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game/solution/dong-tai-gui-hua-by-cliant/</a></p></blockquote><p>首先将问题转换为<strong>先手所能拿到的石子总数减去对手能拿到的石子总数是否为正数</strong>，用f(i,j)来表示第i堆到第j堆的石子，先手比对手多拿的石子总数，那么有如下的递推关系式：<br>$$<br>\begin{equation}<br>    \left{<br>        \begin{array}{}<br>        f(i,j)=max(piles[i]-f(i+1,j),;piles[j]-f(i,j-1)),&amp;i\ne j \<br>        f(i,j)=f(i),&amp;i==j<br>\end{array}<br>    \right.<br>\end{equation}<br>$$<br>所以问题的解决过程就变成了已知对角线值的二维数组的填表，二维数组用dp[i][j]表示，dp[0][n-1]即为问题的解，n是石子的堆数</p><p>（1）初始条件，只有对角线的值已知，且是各堆石子的个数</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/07/5d219d5f0c51e87849.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（2）数组值的生成关系如图，红色星号是问题的解：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/07/5d219e07a8f2a48616.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（3）最终的计算顺序如红色箭头所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/07/5d219e70b890489832.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这样是为了保证不会产生重复计算问题，也便于编码</p><p>（4）代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stoneGame = <span class="function"><span class="keyword">function</span>(<span class="params">piles</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dp = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = piles.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        dp[i] = [];</span><br><span class="line">        dp[i][i] = piles[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>;j&lt;piles.length;j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">Math</span>.max(piles[i]-dp[i+<span class="number">1</span>][j], piles[j]-dp[i][j<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][piles.length<span class="number">-1</span>]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（5）这里其实可以优化一下，因为这个二维数组其实只有一半有数，而且随着填表的进行，之前的值不会再被使用到了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stoneGame = <span class="function"><span class="keyword">function</span>(<span class="params">piles</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dp = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = piles.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        dp[i] = piles[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>;j&lt;piles.length;j++)&#123;</span><br><span class="line">            dp[j] = <span class="built_in">Math</span>.max(piles[i]-dp[j], piles[j]-dp[j<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[piles.length<span class="number">-1</span>]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要的思想是，第i-1行的值可以覆盖到第i行上去，因为一旦第i-1行计算出来，第i行就不再需要了，计算i-2行只用到了第i-1行和第i-2行；所以填表的那个循环，只是单纯将dp数组与i有关的索引去掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原来的：dp[i][j] = <span class="built_in">Math</span>.max(piles[i]-dp[i+<span class="number">1</span>][j], piles[j]-dp[i][j<span class="number">-1</span>])</span><br><span class="line">优化后：dp   [j] = <span class="built_in">Math</span>.max(piles[i]-dp     [j], piles[j]-dp   [j<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h2 id="歪门邪道"><a href="#歪门邪道" class="headerlink" title="歪门邪道"></a>歪门邪道</h2><p><del>这道题可以钻空子，直接<code>return true</code>就可以AC了，不要问我为什么。。。</del></p><p>其实这是数学规律来的，leetcode官方已经给出了解释，但我还是根据自己的理解说一下：</p><ul><li>首先只有两堆（假设是x1，y1）的时候，一定可以保证先手胜（假设x1&gt;y1，那么先手可选x1）</li><li>然后当有四堆（假设是y2，x1，y1，x2）的时候，那么先手一定可以保证取到y1+y2或者x1+x2（因为取y2时，可以保证y1可以取到，x同理），所以先手只需取总和最大的一组即可</li><li>那么显然，先手可以保证取到奇数位置的堆或者偶数位置的堆，先手从总和大的堆下手即可保证稳赢，所以结果是true</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;877-石子游戏&quot;&gt;&lt;a href=&quot;#877-石子游戏&quot; class=&quot;headerlink&quot; title=&quot;877. 石子游戏&quot;&gt;&lt;/a&gt;877. 石子游戏&lt;/h1&gt;&lt;p&gt;原题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;亚历克斯和李用几堆石子在做游戏。偶
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>338.比特位计数</title>
    <link href="http://QQ876684433.github.io/2019/07/14/338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/"/>
    <id>http://QQ876684433.github.io/2019/07/14/338-比特位计数/</id>
    <published>2019-07-14T15:20:49.000Z</published>
    <updated>2019-09-15T04:29:52.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a>338. 比特位计数</h1><p>原题目如下：</p><blockquote><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p>示例 1:</p><p>输入: 2</p><p>输出: [0,1,1]</p><p>示例 2:</p><p>输入: 5</p><p>输出: [0,1,1,2,1,2]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/counting-bits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/counting-bits</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>其实这道题还算简单，看到题目的第一个想法就是首先列举一下，找找规律：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">二进制十进制 <span class="number">1</span>的个数</span><br><span class="line"><span class="number">0000</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0001</span><span class="number">1</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0010</span><span class="number">2</span><span class="number">1</span></span><br><span class="line"><span class="number">0011</span><span class="number">3</span><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">0100</span><span class="number">4</span><span class="number">1</span></span><br><span class="line"><span class="number">0101</span><span class="number">5</span><span class="number">2</span></span><br><span class="line"><span class="number">0110</span><span class="number">6</span><span class="number">2</span></span><br><span class="line"><span class="number">0111</span><span class="number">7</span><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span><span class="number">8</span><span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我给上面的结果分了个组，其实很容易看出来，<strong>每组的1的个数就是该组前面所有数的1的个数加一</strong>，所以答案已经很明显了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> len = res.length;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.length==num+<span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">            res.push(res[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是我的第一个版本的代码，一次过：</p><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时 :116 ms, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>内存消耗 :39.9 MB, 在所有 JavaScript 提交中击败了30.30%的用户</p></blockquote><h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><p>然后我看了一下其他的答案，感觉还是有些地方可以学习的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 奇数一定比上一个偶数多个 1，多的就是最低位的 1 </span></span><br><span class="line"><span class="comment">// 偶数中 1 的个数一定和除以 2 之后的那个数一样多。</span></span><br><span class="line"><span class="comment">// 因为最低位是0，除以 2 就是右移一位，也就是把那个0抹掉而已，所以1的个数是不变的。</span></span><br><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            result[i] = result[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i] = result[i / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个解释的已经很清晰了，就不多说了，这位老哥还提供了另一个更优化的解法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Time: O(n), Space: O(1)</span></span><br><span class="line"><span class="comment">// i &amp; (i-1) 消除二进制最低位的 1 </span></span><br><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        result[i] = result[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我发现有不少解法里有这个东西：<code>i &amp; (i - 1)</code>，他说的消除二进制最低位的1是什么意思？举两个例子：</p><ul><li><p>当i是奇数（例如xxx111），<code>i &amp; (i - 1)</code>很显然就是类似<code>xxx111 &amp; xxx110 = xxx110</code>，把xxx111的最低位1消去，效果相当于-1，和上上一个解法的这个说法</p><blockquote><p>奇数一定比上一个偶数多个 1</p></blockquote><p>道理一样</p></li><li><p>当i是偶数（例如xxx110），<code>i &amp; (i - 1)</code>类似于<code>xxx110 &amp; xxx101 = xxx100</code>，也是把最低位的1消掉，xxx110中1的个数和xxx100中1的个数相差1，这个是和上上个解法</p><blockquote><p>偶数中 1 的个数一定和除以 2 之后的那个数一样多</p></blockquote><p>有点不一样</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;338-比特位计数&quot;&gt;&lt;a href=&quot;#338-比特位计数&quot; class=&quot;headerlink&quot; title=&quot;338. 比特位计数&quot;&gt;&lt;/a&gt;338. 比特位计数&lt;/h1&gt;&lt;p&gt;原题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个非负整数 num。
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法介绍</title>
    <link href="http://QQ876684433.github.io/2019/07/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://QQ876684433.github.io/2019/07/14/动态规划算法介绍/</id>
    <published>2019-07-14T15:16:37.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划算法介绍"><a href="#动态规划算法介绍" class="headerlink" title="动态规划算法介绍"></a>动态规划算法介绍</h1><blockquote><p>参考：<a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html" target="_blank" rel="noopener">https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html</a></p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><p>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p><h2 id="基本思想与策略"><a href="#基本思想与策略" class="headerlink" title="基本思想与策略"></a><strong>基本思想与策略</strong></h2><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p><p>与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p><h2 id="适用的情况"><a href="#适用的情况" class="headerlink" title="适用的情况"></a>适用的情况</h2><p>能采用动态规划求解的问题的一般要具有3个性质：</p><p>(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p><p>(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>(3)有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p><h2 id="求解的基本步骤"><a href="#求解的基本步骤" class="headerlink" title="求解的基本步骤"></a><strong>求解的基本步骤</strong></h2><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p><p>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p><p>​                      图1 动态规划决策过程示意图</p><p>(1)<strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p><p>(2)<strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p><p>(3)<strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p><p>(4)<strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p><p>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p><p>实际应用中可以按以下几个简化的步骤进行设计：</p><p>（1）分析最优解的性质，并刻画其结构特征。</p><p>（2）递归的定义最优解。</p><p>（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p><p>（4）根据计算最优值时得到的信息，构造问题的最优解</p><h2 id="算法实现的说明"><a href="#算法实现的说明" class="headerlink" title="算法实现的说明"></a><strong>算法实现的说明</strong></h2><p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p><p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><p>（1）问题的阶段 （2）每个阶段的状态 （3）从前一个阶段转化到后一个阶段之间的递推关系。</p><p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n,m)=max&#123;f(n<span class="number">-1</span>,m), f(n<span class="number">-1</span>,m-w[n])+P(n,m)&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划算法基本框架"><a href="#动态规划算法基本框架" class="headerlink" title="动态规划算法基本框架"></a>动态规划算法基本框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i=i<span class="number">-1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=max（或min）&#123;g(xi<span class="number">-1</span>[j1:j2]), ......, g(xi<span class="number">-1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"></span><br><span class="line">t = g(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"></span><br><span class="line">print(x1[j1]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi<span class="number">-1</span>[ji];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划算法介绍&quot;&gt;&lt;a href=&quot;#动态规划算法介绍&quot; class=&quot;headerlink&quot; title=&quot;动态规划算法介绍&quot;&gt;&lt;/a&gt;动态规划算法介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.c
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法笔记</title>
    <link href="http://QQ876684433.github.io/2019/07/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>http://QQ876684433.github.io/2019/07/14/数据结构与算法笔记/</id>
    <published>2019-07-14T15:13:50.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="动态规划算法介绍"><a href="#动态规划算法介绍" class="headerlink" title="动态规划算法介绍"></a>动态规划算法介绍</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html" target="_blank" rel="noopener">https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html</a></p></blockquote><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><p>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p><h4 id="基本思想与策略"><a href="#基本思想与策略" class="headerlink" title="基本思想与策略"></a><strong>基本思想与策略</strong></h4><p>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p><p>与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p><h4 id="适用的情况"><a href="#适用的情况" class="headerlink" title="适用的情况"></a>适用的情况</h4><p>能采用动态规划求解的问题的一般要具有3个性质：</p><p>(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p><p>(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>(3)有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p><h4 id="求解的基本步骤"><a href="#求解的基本步骤" class="headerlink" title="求解的基本步骤"></a><strong>求解的基本步骤</strong></h4><p>动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p><p>初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态</p><p>​                      图1 动态规划决策过程示意图</p><p>(1)<strong>划分阶段</strong>：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p><p>(2)<strong>确定状态和状态变量</strong>：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p><p>(3)<strong>确定决策并写出状态转移方程</strong>：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p><p>(4)<strong>寻找边界条件</strong>：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。</p><p>一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p><p>实际应用中可以按以下几个简化的步骤进行设计：</p><p>（1）分析最优解的性质，并刻画其结构特征。</p><p>（2）递归的定义最优解。</p><p>（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值</p><p>（4）根据计算最优值时得到的信息，构造问题的最优解</p><h4 id="算法实现的说明"><a href="#算法实现的说明" class="headerlink" title="算法实现的说明"></a><strong>算法实现的说明</strong></h4><p>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。</p><p>使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><p>（1）问题的阶段 （2）每个阶段的状态 （3）从前一个阶段转化到后一个阶段之间的递推关系。</p><p>递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><p>确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n,m)=max&#123;f(n<span class="number">-1</span>,m), f(n<span class="number">-1</span>,m-w[n])+P(n,m)&#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划算法基本框架"><a href="#动态规划算法基本框架" class="headerlink" title="动态规划算法基本框架"></a>动态规划算法基本框架</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">   xn[j] = 初始值;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i=i<span class="number">-1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">     xi[j]=j=max（或min）&#123;g(xi<span class="number">-1</span>[j1:j2]), ......, g(xi<span class="number">-1</span>[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line"></span><br><span class="line">t = g(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line"></span><br><span class="line">print(x1[j1]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">     t = t-xi<span class="number">-1</span>[ji];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LeetCode刷题"><a href="#LeetCode刷题" class="headerlink" title="LeetCode刷题"></a>LeetCode刷题</h3><h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a>338. 比特位计数</h4><h5 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h5><p>原题目如下：</p><blockquote><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p>示例 1:</p><p>输入: 2</p><p>输出: [0,1,1]</p><p>示例 2:</p><p>输入: 5</p><p>输出: [0,1,1,2,1,2]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/counting-bits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/counting-bits</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>其实这道题还算简单，看到题目的第一个想法就是首先列举一下，找找规律：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">二进制十进制 <span class="number">1</span>的个数</span><br><span class="line"><span class="number">0000</span><span class="number">0</span><span class="number">0</span></span><br><span class="line"><span class="number">0001</span><span class="number">1</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">0010</span><span class="number">2</span><span class="number">1</span></span><br><span class="line"><span class="number">0011</span><span class="number">3</span><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">0100</span><span class="number">4</span><span class="number">1</span></span><br><span class="line"><span class="number">0101</span><span class="number">5</span><span class="number">2</span></span><br><span class="line"><span class="number">0110</span><span class="number">6</span><span class="number">2</span></span><br><span class="line"><span class="number">0111</span><span class="number">7</span><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span><span class="number">8</span><span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我给上面的结果分了个组，其实很容易看出来，<strong>每组的1的个数就是该组前面所有数的1的个数加一</strong>，所以答案已经很明显了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> len = res.length;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;len;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.length==num+<span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">            res.push(res[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是我的第一个版本的代码，一次过：</p><blockquote><p>执行结果：</p><p>通过</p><p>显示详情</p><p>执行用时 :116 ms, 在所有 JavaScript 提交中击败了100.00%的用户</p><p>内存消耗 :39.9 MB, 在所有 JavaScript 提交中击败了30.30%的用户</p></blockquote><h5 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h5><p>然后我看了一下其他的答案，感觉还是有些地方可以学习的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 奇数一定比上一个偶数多个 1，多的就是最低位的 1 </span></span><br><span class="line"><span class="comment">// 偶数中 1 的个数一定和除以 2 之后的那个数一样多。</span></span><br><span class="line"><span class="comment">// 因为最低位是0，除以 2 就是右移一位，也就是把那个0抹掉而已，所以1的个数是不变的。</span></span><br><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">            result[i] = result[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i] = result[i / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个解释的已经很清晰了，就不多说了，这位老哥还提供了另一个更优化的解法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Time: O(n), Space: O(1)</span></span><br><span class="line"><span class="comment">// i &amp; (i-1) 消除二进制最低位的 1 </span></span><br><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        result[i] = result[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我发现有不少解法里有这个东西：<code>i &amp; (i - 1)</code>，他说的消除二进制最低位的1是什么意思？举两个例子：</p><ul><li><p>当i是奇数（例如xxx111），<code>i &amp; (i - 1)</code>很显然就是类似<code>xxx111 &amp; xxx110 = xxx110</code>，把xxx111的最低位1消去，效果相当于-1，和上上一个解法的这个说法</p><blockquote><p>奇数一定比上一个偶数多个 1</p></blockquote><p>道理一样</p></li><li><p>当i是偶数（例如xxx110），<code>i &amp; (i - 1)</code>类似于<code>xxx110 &amp; xxx101 = xxx100</code>，也是把最低位的1消掉，xxx110中1的个数和xxx100中1的个数相差1，这个是和上上个解法</p><blockquote><p>偶数中 1 的个数一定和除以 2 之后的那个数一样多</p></blockquote><p>有点不一样</p></li></ul><h4 id="877-石子游戏"><a href="#877-石子游戏" class="headerlink" title="877. 石子游戏"></a>877. 石子游戏</h4><p>原题目如下：</p><blockquote><p>亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</p><p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p><p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p><p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p><p>示例：</p><p>输入：[5,3,4,5]</p><p>输出：true</p><p>解释：</p><p>亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。</p><p>假设他取了前 5 颗，这一行就变成了 [3,4,5] 。</p><p>如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。</p><p>如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。</p><p>这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。</p><p>提示：</p><p>2 &lt;= piles.length &lt;= 500<br>piles.length 是偶数。<br>1 &lt;= piles[i] &lt;= 500<br>sum(piles) 是奇数。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/stone-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h5 id="一个TLE的解法"><a href="#一个TLE的解法" class="headerlink" title="一个TLE的解法"></a>一个TLE的解法</h5><p>举个栗子，假设初始堆是：[1，2，3，4，5]，那么第一回合（即两个各拿一堆）后，会出现三种状态：</p><ul><li><p>亚4,李1，剩下[2，3]</p><p>ps：这里其实会出现“亚1,李4，剩下[2，3]”的情况，但是想想就知道，这两种情况的子问题都是[2，3]，如果“亚4,李1”不能保证亚赢的话，那“亚1,李4”就更不可能了，所以这种情况可以排除了</p></li><li><p>亚4,李3，剩下[1，2]</p></li><li><p>亚1,李2，剩下[3，4]</p></li></ul><p>然后接下来就是递归求解了，最后当剩下两堆时，可以保证亚取得最优解，直接返回两人的分差（亚-李）；然后递归计算完上面三个子问题之后，取最优的一种情况返回，最优的情况指的是两人得分差别最大的那种取法</p><p>代码不仅冗长，甚至还超时了orz：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; piles</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sub = <span class="function">(<span class="params">left, right, piles</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> l = piles[left], r = piles[right];</span><br><span class="line">    <span class="keyword">if</span>(right-left == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> [l, r];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> [r, l];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> subRes1 = sub(left+<span class="number">1</span>,right<span class="number">-1</span>,piles);</span><br><span class="line">        <span class="keyword">if</span> (l&gt;r)&#123;</span><br><span class="line">            subRes1[<span class="number">0</span>] += l;</span><br><span class="line">            subRes1[<span class="number">1</span>] += r;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            subRes1[<span class="number">0</span>] += r;</span><br><span class="line">            subRes1[<span class="number">1</span>] += l;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> subRes2 = sub(left+<span class="number">2</span>, right, piles);</span><br><span class="line">        subRes2[<span class="number">0</span>] += l;</span><br><span class="line">        subRes2[<span class="number">1</span>] += piles[left+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> subRes3 = sub(left, right<span class="number">-2</span>, piles);</span><br><span class="line">        subRes3[<span class="number">0</span>] += r;</span><br><span class="line">        subRes3[<span class="number">1</span>] += piles[right<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> res = subRes1;</span><br><span class="line">        <span class="keyword">if</span> (subRes2[<span class="number">0</span>]-subRes2[<span class="number">1</span>]&gt;res[<span class="number">0</span>]-res[<span class="number">1</span>]) res = subRes2;</span><br><span class="line">        <span class="keyword">if</span> (subRes3[<span class="number">0</span>]- subRes3[<span class="number">1</span>]&gt;res[<span class="number">0</span>]-res[<span class="number">1</span>]) res = subRes3;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stoneGame = <span class="function"><span class="keyword">function</span>(<span class="params">piles</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = sub(<span class="number">0</span>, piles.length<span class="number">-1</span>, piles);</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>]&gt;res[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>让我们来见证一下真正的动态规划长啥样</p><blockquote><p>参考：<a href="https://leetcode-cn.com/problems/stone-game/solution/dong-tai-gui-hua-by-cliant/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game/solution/dong-tai-gui-hua-by-cliant/</a></p></blockquote><p>首先将问题转换为<strong>先手所能拿到的石子总数减去对手能拿到的石子总数是否为正数</strong>，用f(i,j)来表示第i堆到第j堆的石子，先手比对手多拿的石子总数，那么有如下的递推关系式：<br>$$<br>\begin{equation}<br>    \left{<br>        \begin{array}{}<br>        f(i,j)=max(piles[i]-f(i+1,j),;piles[j]-f(i,j-1)),&amp;i\ne j \<br>        f(i,j)=f(i),&amp;i==j<br>\end{array}<br>    \right.<br>\end{equation}<br>$$<br>所以问题的解决过程就变成了已知对角线值的二维数组的填表，二维数组用dp[i][j]表示，dp[0][n-1]即为问题的解，n是石子的堆数</p><p>（1）初始条件，只有对角线的值已知，且是各堆石子的个数</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/07/5d219d5f0c51e87849.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（2）数组值的生成关系如图，红色星号是问题的解：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/07/5d219e07a8f2a48616.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（3）最终的计算顺序如红色箭头所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/07/5d219e70b890489832.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这样是为了保证不会产生重复计算问题，也便于编码</p><p>（4）代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stoneGame = <span class="function"><span class="keyword">function</span>(<span class="params">piles</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dp = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = piles.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        dp[i] = [];</span><br><span class="line">        dp[i][i] = piles[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>;j&lt;piles.length;j++)&#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">Math</span>.max(piles[i]-dp[i+<span class="number">1</span>][j], piles[j]-dp[i][j<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][piles.length<span class="number">-1</span>]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（5）这里其实可以优化一下，因为这个二维数组其实只有一半有数，而且随着填表的进行，之前的值不会再被使用到了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stoneGame = <span class="function"><span class="keyword">function</span>(<span class="params">piles</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dp = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = piles.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        dp[i] = piles[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>;j&lt;piles.length;j++)&#123;</span><br><span class="line">            dp[j] = <span class="built_in">Math</span>.max(piles[i]-dp[j], piles[j]-dp[j<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[piles.length<span class="number">-1</span>]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要的思想是，第i-1行的值可以覆盖到第i行上去，因为一旦第i-1行计算出来，第i行就不再需要了，计算i-2行只用到了第i-1行和第i-2行；所以填表的那个循环，只是单纯将dp数组与i有关的索引去掉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原来的：dp[i][j] = <span class="built_in">Math</span>.max(piles[i]-dp[i+<span class="number">1</span>][j], piles[j]-dp[i][j<span class="number">-1</span>])</span><br><span class="line">优化后：dp   [j] = <span class="built_in">Math</span>.max(piles[i]-dp     [j], piles[j]-dp   [j<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h5 id="歪门邪道"><a href="#歪门邪道" class="headerlink" title="歪门邪道"></a>歪门邪道</h5><p><del>这道题可以钻空子，直接<code>return true</code>就可以AC了，不要问我为什么。。。</del></p><p>其实这是数学规律来的，leetcode官方已经给出了解释，但我还是根据自己的理解说一下：</p><ul><li>首先只有两堆（假设是x1，y1）的时候，一定可以保证先手胜（假设x1&gt;y1，那么先手可选x1）</li><li>然后当有四堆（假设是y2，x1，y1，x2）的时候，那么先手一定可以保证取到y1+y2或者x1+x2（因为取y2时，可以保证y1可以取到，x同理），所以先手只需取总和最大的一组即可</li><li>那么显然，先手可以保证取到奇数位置的堆或者偶数位置的堆，先手从总和大的堆下手即可保证稳赢，所以结果是true</li></ul><h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h4><p>原题目如下：</p><blockquote><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例:</p><p>输入:<br>[<br>[1,3,1],<br>[1,5,1],<br>[4,2,1]<br>]</p><p>输出: 7</p><p>解释: 因为路径 1→3→1→1→1 的总和最小。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/minimum-path-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h5 id="我的解法-1"><a href="#我的解法-1" class="headerlink" title="我的解法"></a>我的解法</h5><p>这道题比较简单，也是填表的问题，递推公式如下：<br>$$<br>dp[i][j] = dp[i][j]+min{dp[i+1][j]+dp[i][j+1]}<br>$$<br>意思是：从点(i, j)到终点有两个选择，从下边(i+1, j)或者右边(i, j+1)走，所以最短路径是下边或者右边走的最小值加上当前点的值，因此可以从右下角开始填表，注意处理好边界条件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[][]&#125; grid</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = grid.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = grid[<span class="number">0</span>].length<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==grid.length<span class="number">-1</span> &amp;&amp; j==grid[<span class="number">0</span>].length<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">let</span> right = <span class="literal">Infinity</span>, bottom = <span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=grid.length<span class="number">-1</span>) bottom = grid[i+<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j!=grid[<span class="number">0</span>].length<span class="number">-1</span>) right = grid[i][j+<span class="number">1</span>];</span><br><span class="line">            grid[i][j] = grid[i][j]+<span class="built_in">Math</span>.min(bottom, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 ：O(m*n)。遍历整个矩阵恰好一次。</li><li>空间复杂度 ：O(1)<em>O</em>(1)。不需要额外空间。</li></ul><h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>官方给的题解其实思路都差不多，只是具体实现有区别</p><ul><li><p>比如递归暴力解法，也是上面的思路，只是空间和时间开销巨大，我刚开始想的时候就直接拒绝了这种不优雅的做法；</p></li><li><p>二维数组动态规划和我的解法的唯一区别是它另外开辟了新的数组，这在一定情况下是必要的，当要求不能修改原数组时，就只能这么做；</p></li><li><p>针对二维数组动态规划的优化算法就是官解给出的一维动态规划，从我自己的解法中已经可以看出，我是从最下面一层开始往上面填表的，填完之后，下面的行就不再需要用了，所以可以复用一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = grid[grid.length<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = grid.length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = grid[<span class="number">0</span>].length<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==grid.length<span class="number">-1</span> &amp;&amp; j==grid[<span class="number">0</span>].length<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">let</span> right = <span class="literal">Infinity</span>, bottom = <span class="literal">Infinity</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=grid.length<span class="number">-1</span>) bottom = res[j];</span><br><span class="line">            <span class="keyword">if</span>(j!=grid[<span class="number">0</span>].length<span class="number">-1</span>) right = res[j+<span class="number">1</span>];</span><br><span class="line">            res[j] = grid[i][j]+<span class="built_in">Math</span>.min(bottom, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a>96. 不同的二叉搜索树</h4><h5 id="我的解法-2"><a href="#我的解法-2" class="headerlink" title="我的解法"></a>我的解法</h5><h2 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h2><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><h2 id="随机化算法"><a href="#随机化算法" class="headerlink" title="随机化算法"></a>随机化算法</h2><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构与算法&quot;&gt;&lt;a href=&quot;#数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法&quot;&gt;&lt;/a&gt;数据结构与算法&lt;/h1&gt;&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="算法" scheme="http://QQ876684433.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>在React项目中使用Docz遇到的问题</title>
    <link href="http://QQ876684433.github.io/2019/07/14/%E5%9C%A8React%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Docz%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://QQ876684433.github.io/2019/07/14/在React项目中使用Docz遇到的问题/</id>
    <published>2019-07-14T14:53:48.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在React项目中使用Docz遇到的问题"><a href="#在React项目中使用Docz遇到的问题" class="headerlink" title="在React项目中使用Docz遇到的问题"></a>在React项目中使用Docz遇到的问题</h1><p>（1）按照官网的Getting Start添加依赖后执行<code>yarnpkg add docz</code>，出现的问题如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Failed to compile.</span><br><span class="line"></span><br><span class="line">./node_modules/docz/dist/index.esm.js <span class="number">23</span>:<span class="number">38</span></span><br><span class="line">Module parse failed: Unexpected token (<span class="number">23</span>:<span class="number">38</span>)</span><br><span class="line">Failed to compile.</span><br><span class="line"></span><br><span class="line">./node_modules/docz/dist/index.esm.js <span class="number">23</span>:<span class="number">38</span></span><br><span class="line">Module parse failed: Unexpected token (<span class="number">23</span>:<span class="number">38</span>)</span><br><span class="line">You may need an appropriate loader to handle <span class="keyword">this</span> file type, currently no loaders are configured to process <span class="keyword">this</span> file. See https:<span class="comment">//webpack.js.org/concepts#loaders</span></span><br><span class="line">| <span class="keyword">import</span> &#123; MDXProvider &#125; <span class="keyword">from</span> <span class="string">'@mdx-js/react'</span>;</span><br><span class="line">| </span><br><span class="line">&gt; <span class="keyword">const</span> BasePlayground = loadable(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Playground.esm.js'</span>));</span><br><span class="line">| <span class="keyword">const</span> Playground = <span class="function"><span class="params">props</span> =&gt;</span> <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> ? createElement(Suspense, &#123;</span><br><span class="line">|   fallback: <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>Github上面的相关issue是：<a href="https://github.com/pedronauck/docz/issues/596" target="_blank" rel="noopener">https://github.com/pedronauck/docz/issues/596</a></p><p>最关键的是这一个：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/05/5d1f4b5aed0f933839.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>他给出的解决方案是对webpack降级：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D webpack@<span class="number">4</span>.<span class="number">28</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure><p>问题解决！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/05/5d1f4ba8678ff64652.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>然而，事情远远没有那么简单，当再次运行<code>yarn start</code>启动项目时，爆炸了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/07/5d21d9ed878d544757.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>显然是docz和creact-react-app的webpack版本冲突了，我又在github搜罗了一番，解决方案是给docz单独指定一个webpack版本：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/07/5d21dacbda01361621.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>启动成功，舒服了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在React项目中使用Docz遇到的问题&quot;&gt;&lt;a href=&quot;#在React项目中使用Docz遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;在React项目中使用Docz遇到的问题&quot;&gt;&lt;/a&gt;在React项目中使用Docz遇到的问题&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="项目" scheme="http://QQ876684433.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="http://QQ876684433.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="React" scheme="http://QQ876684433.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Github开源项目license选择问题</title>
    <link href="http://QQ876684433.github.io/2019/07/14/Github%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AElicense%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98/"/>
    <id>http://QQ876684433.github.io/2019/07/14/Github开源项目license选择问题/</id>
    <published>2019-07-14T14:52:31.000Z</published>
    <updated>2019-09-15T04:29:52.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github开源项目license选择问题"><a href="#Github开源项目license选择问题" class="headerlink" title="Github开源项目license选择问题"></a>Github开源项目license选择问题</h1><p>简单一点，借用阮一峰博客上面的一张图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://www.ruanyifeng.com/blogimg/asset/201105/bg2011050101.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Github开源项目license选择问题&quot;&gt;&lt;a href=&quot;#Github开源项目license选择问题&quot; class=&quot;headerlink&quot; title=&quot;Github开源项目license选择问题&quot;&gt;&lt;/a&gt;Github开源项目license选择问题&lt;/
      
    
    </summary>
    
      <category term="项目" scheme="http://QQ876684433.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="http://QQ876684433.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>将React项目部署到GithubPages</title>
    <link href="http://QQ876684433.github.io/2019/07/14/%E5%B0%86React%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0GithubPages/"/>
    <id>http://QQ876684433.github.io/2019/07/14/将React项目部署到GithubPages/</id>
    <published>2019-07-14T14:50:59.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<h3 id="将React项目部署到Github-Pages"><a href="#将React项目部署到Github-Pages" class="headerlink" title="将React项目部署到Github Pages"></a>将React项目部署到Github Pages</h3><blockquote><p>参考：<a href="https://segmentfault.com/a/1190000019290048" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019290048</a></p></blockquote><p>一些注意事项：</p><p>（1）Github Pages自定义域名问题</p><ul><li><p>往gh-pages分支添加CNAME记录</p><p><img src="https://i.loli.net/2019/07/04/5d1e10ad9b6d873438.png" alt></p></li><li><p>将要添加的域名写入CNAME，但是注意不要加入<code>http://</code></p><p><img src="https://i.loli.net/2019/07/04/5d1e110ab54e333768.png" alt></p></li><li><p>这里还有个问题就是，由于gh-pages分支是将编译之后的内容上传的，如果直接在gh-pages分支添加CNAME文件，会导致出现重新部署的时候CNAME被删除，这时后如果再次访问自定义域名，就会出现Content Security Policy问题（参见：<a href="https://stackoverflow.com/questions/54380373/content-security-policy-while-deploying-to-github-pages-using-gatsby）" target="_blank" rel="noopener">https://stackoverflow.com/questions/54380373/content-security-policy-while-deploying-to-github-pages-using-gatsby）</a></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Refused to load the image 'http://www.alexingberg.com/favicon.ico' because it violates the following Content Security Policy directive: "img-src data:".</span><br></pre></td></tr></table></figure><p>你可以按照stackoverflow上面的方案解决（我没试过），但我这里提供一个简单的解决方案，就是将CNAME添加在项目的public文件夹下面，编译之后CNAME就会在build目录生成，这样就不会出现Content Security Policy问题了</p><p><img src="https://i.loli.net/2019/07/04/5d1e126fab25166732.png" alt></p></li></ul><p>（2）自定义域名后出现资源路径不正确的问题</p><ul><li><p>网上一些教程都是教你把Github Pages生成的那一串链接地址设置到<code>&quot;homepages&quot;</code>中</p><p><img src="https://i.loli.net/2019/07/04/5d1e1359bcf0850375.png" alt></p><p>这样会出现的问题就是，编译完成后，会在静态资源的路径前面都加上<code>/chph-blog</code>，这样肯定是找不到对应的资源的</p></li><li><p>可以通过把<code>&quot;homepages&quot;</code>设置成<code>&quot;./&quot;</code>即可</p><p><img src="https://i.loli.net/2019/07/04/5d1e13f324be160749.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;将React项目部署到Github-Pages&quot;&gt;&lt;a href=&quot;#将React项目部署到Github-Pages&quot; class=&quot;headerlink&quot; title=&quot;将React项目部署到Github Pages&quot;&gt;&lt;/a&gt;将React项目部署到Github
      
    
    </summary>
    
      <category term="项目" scheme="http://QQ876684433.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="http://QQ876684433.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="React" scheme="http://QQ876684433.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>ES6、ES7、ES8、ES9、ES10新特性一览</title>
    <link href="http://QQ876684433.github.io/2019/07/14/ES6%E3%80%81ES7%E3%80%81ES8%E3%80%81ES9%E3%80%81ES10%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%80%E8%A7%88/"/>
    <id>http://QQ876684433.github.io/2019/07/14/ES6、ES7、ES8、ES9、ES10新特性一览/</id>
    <published>2019-07-14T14:49:42.000Z</published>
    <updated>2019-09-15T04:29:52.251Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6、ES7、ES8、ES9、ES10新特性一览"><a href="#ES6、ES7、ES8、ES9、ES10新特性一览" class="headerlink" title="ES6、ES7、ES8、ES9、ES10新特性一览"></a>ES6、ES7、ES8、ES9、ES10新特性一览</h1><blockquote><p>参考：<a href="https://juejin.im/post/5ca2e1935188254416288eb2" target="_blank" rel="noopener">https://juejin.im/post/5ca2e1935188254416288eb2</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6、ES7、ES8、ES9、ES10新特性一览&quot;&gt;&lt;a href=&quot;#ES6、ES7、ES8、ES9、ES10新特性一览&quot; class=&quot;headerlink&quot; title=&quot;ES6、ES7、ES8、ES9、ES10新特性一览&quot;&gt;&lt;/a&gt;ES6、ES7、ES8
      
    
    </summary>
    
      <category term="前端" scheme="http://QQ876684433.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="http://QQ876684433.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>async/await的基础用法</title>
    <link href="http://QQ876684433.github.io/2019/07/14/async-await%E7%9A%84%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/"/>
    <id>http://QQ876684433.github.io/2019/07/14/async-await的基础用法/</id>
    <published>2019-07-14T14:47:48.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="async-await的基础用法"><a href="#async-await的基础用法" class="headerlink" title="async/await的基础用法"></a>async/await的基础用法</h1><blockquote><p>参考：<a href="https://www.jianshu.com/p/ffa5cbe9ab29" target="_blank" rel="noopener">https://www.jianshu.com/p/ffa5cbe9ab29</a></p><p>推荐阅读：<a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007535316</a></p><p>另外补充：进程、线程和协程的理解</p><p>参考<a href="https://blog.csdn.net/hairetz/article/details/16119911" target="_blank" rel="noopener">https://blog.csdn.net/hairetz/article/details/16119911</a></p></blockquote><h2 id="进程、线程和协程"><a href="#进程、线程和协程" class="headerlink" title="进程、线程和协程"></a>进程、线程和协程</h2><table><thead><tr><th align="center"></th><th align="center">堆</th><th align="center">栈</th><th align="center">调度</th></tr></thead><tbody><tr><td align="center">进程</td><td align="center">独立</td><td align="center">独立</td><td align="center">操作系统</td></tr><tr><td align="center">线程</td><td align="center">共享</td><td align="center">独立</td><td align="center">操作系统</td></tr><tr><td align="center">协程</td><td align="center">共享</td><td align="center">独立</td><td align="center">程序员在代码中显式调度</td></tr></tbody></table><ul><li>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。</li><li>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。</li><li>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。</li></ul><p>进程和其他两个的区别还是很明显的。</p><p>协程和线程的区别是：<strong>协程避免了无意义的调度，由此可以提高性能</strong>，但也因此，程序员必须自己承担调度的责任，同时，<strong>协程也失去了标准线程使用多CPU的能力</strong>。</p><h2 id="async-await的特点"><a href="#async-await的特点" class="headerlink" title="async/await的特点"></a>async/await的特点</h2><ul><li><code>Promise</code>主要用then函数的链式调用，一直点点点，是一种从左向右的横向写法。<br><code>async/await</code>从上到下，顺序执行，就像写同步代码一样。这更符合人编写代码的习惯</li><li><code>Promise</code>的then函数只能传递一个参数，虽然可以通过包装成对象，但是这会导致传递冗余信息，频繁的解析又重新组合参数，比较麻烦。<br><code>async/await</code>没有这个限制，就当做普通的局部变量来处理好了，用let或者const定义的块级变量，想怎么用就怎么用，想定义几个就定义几个，完全没有限制，也没有冗余的工作。</li><li><code>Promise</code>在使用的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰。<br><code>async/await</code>整个书写习惯都是同步的，不需要纠结同步和异步的区别。当然，异步过程需要包装成一个<code>Promise</code>对象，放在<code>await</code>关键字后面，这点还是要牢记的。</li><li><code>Promise</code>是根据函数式编程的范式，对异步过程进行了一层封装。<br><code>async/await</code>是基于协程的机制，是真正的“保存上下文，控制权切换 … … 控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述。</li><li><code>async/await</code>是基于<code>Promise</code>的，是进一步的一种优化。不过再写代码的时候，<code>Promise</code>本身的API出现得很少，很接近同步代码的写法。</li></ul><h2 id="await关键字使用的注意点"><a href="#await关键字使用的注意点" class="headerlink" title="await关键字使用的注意点"></a><strong>await关键字使用的注意点</strong></h2><ul><li><p>只能放在<code>async</code>函数内部使用，不能放在普通函数里面，否则会报错。</p></li><li><p>后面放<code>Promise</code>对象，在<code>Pending</code>状态时，相应的协程会交出控制权，进入等待状态。这个是本质。</p></li><li><p><code>await</code>是<code>async wait</code>的意思，<code>wait</code>的是<code>resolve(data)</code>消息，并把数据<code>data</code>返回。比如，下面代码中，当<code>Promise</code>对象由<code>Pending</code>变为<code>Resolved</code>的时候，变量<code>a</code>就等于<code>data</code>；然后再顺序执行下面的语句<code>console.log(a);</code><br>这真的是等待，真的是顺序执行，表现和同步代码几乎一模一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// async process ...</span></span><br><span class="line">    <span class="keyword">return</span> resolve(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure></li><li><p><code>await</code>后面也可以跟同步代码，不过系统会自动转化成一个<code>Promise</code>对象。<br>比如<br><code>const a = await &#39;hello world&#39;;</code><br>其实就相当于<br><code>const a = await Promise.resolve(&#39;hello world&#39;);</code><br>这跟同步代码<br><code>const a = &#39;hello world&#39;;</code>是一样的，还不如省点事，去掉这里的<code>await</code>关键字。</p></li><li><p><code>await</code>只关心异步过程成功的消息<code>resolve(data)</code>，拿到相应的数据<code>data</code>。至于失败消息<code>reject(error)</code>，不关心，不处理。<br>当然对于错误消息的处理，有以下几种方法供选择：<br>（1）让<code>await</code>后面的<code>Promise</code>对象自己<code>catch</code><br>（2）也可以让外面的<code>async</code>函数返回的<code>Promise</code>对象统一<code>catch</code><br>（3）像同步代码一样，放在一个<code>try...catch</code>结构中</p></li></ul><h2 id="async关键字使用的注意点"><a href="#async关键字使用的注意点" class="headerlink" title="async关键字使用的注意点"></a>async关键字使用的注意点</h2><ul><li>有了这个<code>async</code>关键字，只是表明里面可能有异步过程，里面可以有<code>await</code>关键字。当然，全部是同步代码也没关系。当然，这时候这个<code>async</code>关键字就显得多余了。不是不能加，而是不应该加。</li><li><code>async</code>函数，如果里面有异步过程，会等待；<br>但是<code>async</code>函数本身会马上返回，不会阻塞当前线程。</li></ul><blockquote><p>可以简单认为，<code>async</code>函数工作在主线程，同步执行，不会阻塞界面渲染。<br><code>async</code>函数内部由<code>async</code>关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回。</p></blockquote><ul><li><code>async</code>函数的返回值是一个<code>Promise</code>对象，这个是和普通函数本质不同的地方。这也是使用时重点注意的地方<br>（1）<code>return newPromise();</code>这个符合<code>async</code>函数本意；<br>（2）<code>return data;</code>这个是同步函数的写法，这里是要特别注意的。这个时候，其实就相当于<code>Promise.resolve(data);</code>还是一个<code>Promise</code>对象。<br>在调用<code>async</code>函数的地方通过简单的<code>=</code>是拿不到这个<code>data</code>的。<br>那么怎么样拿到这个<code>data</code>呢？<br>很简单，返回值是一个<code>Promise</code>对象，用<code>.then(data =&gt; { })</code>函数就可以。<br>（3）如果没有返回，相当于返回了<code>Promise.resolve(undefined);</code></li><li><code>await</code>是不管异步过程的<code>reject(error)</code>消息的，<code>async</code>函数返回的这个<code>Promise</code>对象的<code>catch</code>函数就负责统一抓取内部所有异步过程的错误。<br><code>async</code>函数内部只要有一个异步过程发生错误，整个执行过程就中断，这个返回的<code>Promise</code>对象的<code>catch</code>就能抓到这个错误。</li><li><code>async</code>函数执行和普通函数一样，函数名带个()就可以了，参数个数随意，没有限制；也需要有<code>async</code>关键字。<br>只是返回值是一个<code>Promise</code>对象，可以用then函数得到返回值，用catch抓去整个流程中发生的错误。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;async-await的基础用法&quot;&gt;&lt;a href=&quot;#async-await的基础用法&quot; class=&quot;headerlink&quot; title=&quot;async/await的基础用法&quot;&gt;&lt;/a&gt;async/await的基础用法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参
      
    
    </summary>
    
      <category term="前端" scheme="http://QQ876684433.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="http://QQ876684433.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>less的一个变量多次定义</title>
    <link href="http://QQ876684433.github.io/2019/07/14/less%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E5%A4%9A%E6%AC%A1%E5%AE%9A%E4%B9%89/"/>
    <id>http://QQ876684433.github.io/2019/07/14/less的一个变量多次定义/</id>
    <published>2019-07-14T14:46:30.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个变量多次定义"><a href="#一个变量多次定义" class="headerlink" title="一个变量多次定义"></a>一个变量多次定义</h1><p>首先<strong>一个变量不需要在使用之前就定义</strong>，而且也<strong>可以在不同地方重复定义同一个变量</strong>，下面两个编译的结果一样：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.lazy-eval</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">@var</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@var:</span><span class="variable">@a</span>;</span><br><span class="line"><span class="variable">@a:</span><span class="number">9%</span>;</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.lazy-eval</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">@var</span>;</span><br><span class="line">    <span class="variable">@a:</span><span class="number">9%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@var:</span><span class="variable">@a</span>;</span><br><span class="line"><span class="variable">@a:</span><span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义在块级作用域里的@a(9%)覆盖了全局作用域里的@a(100%)</span></span><br></pre></td></tr></table></figure><p>编译出来的css是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.lazy-eval</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">9%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官网里的原话是：</p><blockquote><p>When defining a variable twice, the last definition of the variable is used, <strong>searching from the current scope upwards</strong>. This is similar to css itself where the last property inside a definition is used to determine the value.</p></blockquote><p>更经典的例子是：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@var:</span> <span class="number">0</span>;</span><br><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">  <span class="variable">@var:</span> <span class="number">1</span>;</span><br><span class="line">  <span class="selector-class">.brass</span> &#123;</span><br><span class="line">    <span class="variable">@var:</span> <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">three</span>: <span class="variable">@var</span>;</span><br><span class="line">    <span class="variable">@var:</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">one</span>: <span class="variable">@var</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">  <span class="attribute">one</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.class</span> <span class="selector-class">.brass</span> &#123;</span><br><span class="line">  <span class="attribute">three</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，three首先被赋值<code>@var: 2;</code>，然后被下面定义的<code>@var: 3;</code>覆盖；而one的作用域内看不到<code>@var: 2;</code>和<code>@var: 3;</code>，因此最后被赋值为1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一个变量多次定义&quot;&gt;&lt;a href=&quot;#一个变量多次定义&quot; class=&quot;headerlink&quot; title=&quot;一个变量多次定义&quot;&gt;&lt;/a&gt;一个变量多次定义&lt;/h1&gt;&lt;p&gt;首先&lt;strong&gt;一个变量不需要在使用之前就定义&lt;/strong&gt;，而且也&lt;strong&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://QQ876684433.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="less" scheme="http://QQ876684433.github.io/tags/less/"/>
    
  </entry>
  
  <entry>
    <title>css中常见的选择符</title>
    <link href="http://QQ876684433.github.io/2019/07/14/css%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E9%80%89%E6%8B%A9%E7%AC%A6/"/>
    <id>http://QQ876684433.github.io/2019/07/14/css中常见的选择符/</id>
    <published>2019-07-14T14:45:02.000Z</published>
    <updated>2019-09-15T04:29:52.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css中常见的选择符"><a href="#css中常见的选择符" class="headerlink" title="css中常见的选择符"></a>css中常见的选择符</h1><blockquote><p>参考：<a href="https://yanhaijing.com/css/2014/01/04/the-30-css-selectors-you-must-memorize/" target="_blank" rel="noopener">https://yanhaijing.com/css/2014/01/04/the-30-css-selectors-you-must-memorize/</a></p><p>官网：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors#Simple_selectors" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors#Simple_selectors</a></p></blockquote><h2 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h2><ul><li><p>Type（类型）选择器</p><p>这种基本选择器会选择所有匹配给定元素名的元素。 </p><p><strong>语法：</strong><code>elename</code> </p><p><strong>例子：</strong>input 将会选择所有的 input 元素。</p></li><li><p>Class（类）选择器</p><p>这种基本选择器会基于类属性的值来选择元素。 </p><p><strong>语法：</strong> <code>.classname</code> </p><p><strong>例子：</strong> <code>.index</code> 会匹配所有包含 <code>index 类的元素</code> (由类似于<code>class=&quot;index&quot;</code>这样的属性定义的).</p></li><li><p>ID选择器</p><p>这种基本选择器会选择所有id属性与之匹配的元素。需要注意的是一个文档中每个id都应该是唯一的。 </p><p><strong>语法：</strong><code>#idname</code> </p><p><strong>例子：</strong><code>#toc</code> 将会匹配所有id属性为 toc 的元素 (类似于这样的定义 <code>id=&quot;toc&quot;</code>).</p></li><li><p>通用选择器</p><p>这个基本选择器选择所有节点。它也常常和一个名词空间配合使用，用来选择该空间下的所有元素。 </p><p><strong>语法：</strong> <code>* ns|* *|*</code> </p><p><strong>例子：</strong><code>*</code> （通配符）将会选择所有元素。</p></li><li><p>属性选择器</p><p>这个基本的选择器根据元素的属性来进行选择。（具体参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors）" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors）</a> </p><p><strong>语法：</strong><code>[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value]</code> </p><p><strong>例子：</strong><code>[autoplay]</code> 将会选择所有具有 autoplay 属性的元素（不论这个属性的值是什么）</p></li></ul><h2 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h2><ul><li><p>紧邻兄弟选择器</p><p><code>&#39;+&#39;</code> 操作符选择相邻元素，即第二个节点<strong>紧邻着第一个节点</strong>，并且<strong>拥有共同的父节点</strong>。</p><p><strong>语法:</strong> <code>A + B</code></p><p><strong>例子:</strong> <code>ul + li</code> 会匹配任何 ul 元素后紧邻的 li 元素。</p></li><li><p>一般兄弟选择器</p><p><code>&#39;~&#39;</code> 操作符选择兄弟元素，也就是说，第二个节点在第一个节点<strong>后面的任意位置</strong>，并且这俩<strong>节点的父节点相同</strong>。</p><p><strong>语法:</strong> <code>A ~ B</code></p><p><strong>例子:</strong> <code>p ~ span</code> 将会匹配同一父元素下，p 元素后的所有 span 元素。</p></li><li><p>子选择器</p><p><code>&#39;&gt;&#39;</code> 操作符选择第一个元素的<strong>直接子节点</strong>。</p><p><strong>语法:</strong> <code>A &gt; B</code></p><p><strong>例子:</strong> <code>ul &gt; li</code> 将会匹配直接嵌套在 ul 元素内的所有 li 元素。</p></li><li><p>后代选择器</p><p><code>&#39; &#39;</code>  (空格) 操作符将选择第一个元素的<strong>子代节点</strong>。</p><p><strong>语法:</strong> <code>A B</code></p><p><strong>例子:</strong> <code>div span</code> 将匹配 div 元素内所有的 span 元素。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;css中常见的选择符&quot;&gt;&lt;a href=&quot;#css中常见的选择符&quot; class=&quot;headerlink&quot; title=&quot;css中常见的选择符&quot;&gt;&lt;/a&gt;css中常见的选择符&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://yanha
      
    
    </summary>
    
      <category term="前端" scheme="http://QQ876684433.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="css" scheme="http://QQ876684433.github.io/tags/css/"/>
    
  </entry>
  
</feed>
