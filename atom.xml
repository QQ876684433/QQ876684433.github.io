<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>至繁归于至简 - chph&#39;s blog</title>
  
  <subtitle>steve_chph personal website</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://QQ876684433.github.io/"/>
  <updated>2019-12-21T01:53:32.524Z</updated>
  <id>http://QQ876684433.github.io/</id>
  
  <author>
    <name>steve_chph</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统-设备管理</title>
    <link href="http://QQ876684433.github.io/2019/12/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <id>http://QQ876684433.github.io/2019/12/21/操作系统-设备管理/</id>
    <published>2019-12-21T01:44:20.000Z</published>
    <updated>2019-12-21T01:53:32.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li></ul></blockquote><p>外部设备分类：</p><ul><li><p>存储型设备</p><p>磁带机、磁盘机等</p></li><li><p>I/O型设备</p><p>显示器、打印机、通信设备等</p></li></ul><p>设备管理通常使用I/O中断、缓冲区管理、通道、设备驱动调度等多种技术，这很好地克服了由于<strong>设备和CPU速度不匹配</strong>所引起的问题，使得主机和设备能够并行工作，提高设备的使用效率</p><p>另外操作系统将所有设备都<strong>抽象成文件</strong>，将其统一在文件系统之下，赋予文件属性，对设备的操作类似于对文件的操作，优点是：</p><ul><li>尽可能统一文件和设备的I/O的处理</li><li>尽可能把设备文件和普通文件纳入统一保护机制下</li></ul><p>为了方便用户或者高层软件使用，设备管理还<strong>对各种设备进行抽象</strong>，配置设备驱动程序，屏蔽物理细节和操作过程，提供统一使用界面，因此设备管理应该具备以下功能：</p><ul><li>设备中断处理</li><li>缓冲区管理</li><li>设备分配和去配</li><li>设备驱动调度</li><li>实现虚拟设备</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设备管理&quot;&gt;&lt;a href=&quot;#设备管理&quot; class=&quot;headerlink&quot; title=&quot;设备管理&quot;&gt;&lt;/a&gt;设备管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="设备管理" scheme="http://QQ876684433.github.io/tags/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CPP输入输出</title>
    <link href="http://QQ876684433.github.io/2019/12/17/CPP%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://QQ876684433.github.io/2019/12/17/CPP输入输出/</id>
    <published>2019-12-17T10:57:43.000Z</published>
    <updated>2019-12-17T15:15:32.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-输入输出"><a href="#C-输入输出" class="headerlink" title="C++输入输出"></a>C++输入输出</h1><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><blockquote><p>参考资料：<a href="https://liam.page/2017/12/31/buffer-of-stream-in-Cpp/" target="_blank" rel="noopener">https://liam.page/2017/12/31/buffer-of-stream-in-Cpp/</a></p></blockquote><p>C++ 中的流对象实际上是对缓冲区进行操作，因此只需要通过替换输入（cin）和输出（cout）的缓冲区即可实现输入或者输出重定向</p><p><code>std::basic_ios</code> 的成员函数 <code>rdbuf</code> 是读取和设置流对象（<code>std::basic_ios</code> 的对象）绑定缓冲区的成员函数，它有两个不同的重载形式，分别如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::basic_streambuf&lt;CharT, Traits&gt;*</span><br><span class="line">rdbuf() <span class="keyword">const</span>;                                      <span class="comment">// 1.</span></span><br><span class="line"><span class="built_in">std</span>::basic_streambuf&lt;CharT, Traits&gt;*</span><br><span class="line">rdbuf( <span class="built_in">std</span>::basic_streambuf&lt;CharT, Traits&gt;* sb );   <span class="comment">// 2.</span></span><br></pre></td></tr></table></figure><p>两个重载版本，第一版不接受任何参数，第二版接受一个指向 <code>std::basic_streambuf</code> 类型对象的指针。</p><p>不接受参数的版本返回流对象绑定的缓冲区对象的指针；而若流对象未绑定任何缓冲区对象，则返回空指针 <code>nullptr</code>。接受指针的版本首先返回上述指针，而后与先前绑定的缓冲区对象（如果有）解绑，再绑定参数中传入指针指向的缓冲区对象；而若传入空指针 <code>nullptr</code>，则流对象不与任何缓冲区对象绑定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"in.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"out.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">istrstream <span class="title">iss</span><span class="params">(<span class="string">"istream test"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cin</span>.rdbuf(in.rdbuf());</span><br><span class="line">    <span class="built_in">cout</span>.rdbuf(out.rdbuf());</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>.rdbuf(iss.rdbuf());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">steve@steve-PC:~/MasterCPP/src/io$ cat in.txt </span><br><span class="line">1 2 3</span><br><span class="line">1.2 3.4 5.6</span><br><span class="line">int float</span><br><span class="line">Hello world!</span><br><span class="line">steve@steve-PC:~/MasterCPP/src/io$</span><br></pre></td></tr></table></figure><h2 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h2><blockquote><p>参考来源：<a href="http://c.biancheng.net/view/1346.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1346.html</a></p></blockquote><h3 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h3><p>它会<strong>忽略掉所有前导空白字符</strong>，所以使用 cin&gt;&gt; 就不可能仅输入一个空格或回车符。除非用户输入了空格键、制表符之外的其他字符，否则程序将不可能通过 cin 语句继续执行（一旦输入了这样的字符，在程序可以继续下一个语句之前，仍然需要按回车键）；<strong>遇“空格”、“TAB”、“回车”都结束</strong></p><p>在cin完成一次输入之后，遇到的空白字符如“空格”，“tab”和“回车”等都会留在缓冲区中</p><h3 id="cin-get"><a href="#cin-get" class="headerlink" title="cin.get()"></a>cin.get()</h3><p>cin 对象有一个名为 get 的内置函数很有帮助。因为 get 函数是内置在 cin 对象中的，所以可称之为 cin 的一个成员函数。get 成员函数读取单个字符，包括任何白色空格字符。如果程序需要存储正在读取的字符，则可以通过以下任意一种方式调用 get 成员函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.get (ch);</span><br><span class="line">ch = <span class="built_in">cin</span>.get();</span><br></pre></td></tr></table></figure><p>将 cin &gt;&gt; 与 cin.get 混合使用可能会导致烦人且难以发现的问题。请看下面的代码段示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;    <span class="comment">//定义一个字符变量</span></span><br><span class="line"><span class="keyword">int</span> number; <span class="comment">//定义一个整型变量</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: ”;</span></span><br><span class="line"><span class="string">cin &gt;&gt; number;   // 读取整数</span></span><br><span class="line"><span class="string">cout &lt;&lt; "</span>Enter a character: <span class="string">";</span></span><br><span class="line"><span class="string">ch = cin.get() ;   // 读取字符</span></span><br><span class="line"><span class="string">cout &lt;&lt; "</span>Thank You!\n<span class="string">";</span></span><br></pre></td></tr></table></figure><p>这些语句允许用户输入一个数字，而不是一个字符。看来第 6 行的 cin.get 语句已经被跳过了。这是因为 cin&gt;&gt; 和 cin.get 使用略有不同的技术来读取数据。<br>在示例代码段中，当执行第 4 行时，用户输入一个数字，然后按回车键。假设输入的是数字 100。按回车键会导致一个换行符(‘\n’)存储在键盘缓冲区数字 100 之后，如图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://c.biancheng.net/uploads/allimg/181114/2-1Q114130JI45.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><p>当第 6 行中的 cin.get 函数执行时，它开始从先前输入操作停止的键盘缓冲区读取，并发现了换行符，所以它无须等待用户输入另一个值。这种问题最直接的解决办法是<strong>使用 cin.ignore 函数</strong>。</p><p><strong>cin.get(字符数组名,接收字符数目)用来接收一行字符串</strong>，但是实际上接受字符数目中最后一个字符是字符串的结束字符<code>\0</code>，例如：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/rAHeaftnWU4mEV1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/MisterLing/article/details/51697098" target="_blank" rel="noopener">https://blog.csdn.net/MisterLing/article/details/51697098</a></p></blockquote><ul><li><p>在头文件&lt;istream&gt;中，是istream类的成员函数，如cin.getline(…)，它有两种重载形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(<span class="keyword">char</span>* s, streamsize n )</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(<span class="keyword">char</span>* s, streamsize n, <span class="keyword">char</span> delim )</span></span>;</span><br></pre></td></tr></table></figure><p>作用是： 从istream中读取<strong>至多n个字符(包含结束标记符)</strong>（换行符会被丢弃）保存在s对应的数组中。即使还没读够n个字符，如果遇到delim或字数达到限制，则读取终止，<strong>delim都不会被保存进s对应的数组中</strong></p><p><img src="https://i.loli.net/2019/12/17/iSGwO9phq7VLjKg.png" alt></p></li><li><p>在&lt;string&gt;中的getline函数有四种重载形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;  is, <span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;&amp; is, <span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;  is, <span class="built_in">string</span>&amp; str)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;&amp; is, <span class="built_in">string</span>&amp; str)</span></span>;</span><br></pre></td></tr></table></figure><p>用法和上第一种类似，但是读取的istream是作为参数is传进函数的。读取的字符串<strong>保存在string类型的str中</strong></p><p>is   ：表示一个输入流，例如cin。</p><p>str  ：string类型的<strong>引用</strong>，用来<strong>存储输入流中的流信息</strong>。</p><p>delim ：char类型的变量，所设置的截断字符；在<strong>不自定义设置的情况下，遇到’\n’</strong>，则终止输入。</p><p><img src="https://i.loli.net/2019/12/17/em3f9dAXvhSyCG6.png" alt></p><p>getline不是C库函数，而是C++库函数。它遇到以下情况发生会导致生成的本字符串结束：</p><p>(1)到文件结束，(2)遇到函数的定界符，(3)输入达到最大限度</p></li></ul><p>getline()函数在while中作为条件判断时，while判断语句的真实判断对象是cin的状态，也就是判断当前是否存在有效的输入流；而输入流是对象，判断的是流返回的状态。所以正常的情况下，你怎么输入都是跳不出它的循环。我们可以手动输入输入流结束字符来跳出循环（<strong>按Ctrl+Z(Windows)(Ctrl+D(Linux))或键入EOF(参考MSDN)</strong>）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/8m3eD92tOSyKhGH.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>当设置了分隔符之后，输入回车也不会导致getline结束一次输入，只有遇到设置的分隔符才会完成一次输入：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/GYhpF2Dny5QlzbK.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/hustfoxy/article/details/23473805" target="_blank" rel="noopener">https://blog.csdn.net/hustfoxy/article/details/23473805</a></p></blockquote><h4 id="strtok函数"><a href="#strtok函数" class="headerlink" title="strtok函数"></a>strtok函数</h4><p>函数原型：char * strtok (char *str, const char * delimiters);<br>参数：str，待分割的字符串（c-string）；delimiters，分割符字符串。<br>该函数用来将字符串分割成一个个片段。参数str指向欲分割的字符串，参数delimiters则为分割字符串中包含的所有字符。当strtok()在参数s的字符串中发现参数delimiters中包涵的分割字符时，则会将该字符改为\0 字符。在第一次调用时，strtok()必需给予参数s字符串，往后的调用则将参数s设置成NULL。每次调用成功则返回指向被分割出片段的指针。<br>需要注意的是，使用该函数进行字符串分割时，会破坏被分解字符串的完整，调用前和调用后的s已经不一样了。第一次分割之后，原字符串str是分割完成之后的第一个字符串，剩余的字符串存储在一个静态变量中，因此多线程同时访问该静态变量时，则会出现错误。</p><p>在cpp中的例子（注意要引入cstring和cstdlib两个头文件）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"ab,cd,ef"</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"before strtok: str="</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"begin:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ptr = strtok(str, <span class="string">","</span>);</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="string">"str="</span>) &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="string">"ptr="</span>) &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ptr = strtok(<span class="literal">NULL</span>, <span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before strtok: str=ab,cd,ef</span><br><span class="line">begin:</span><br><span class="line">str=ab</span><br><span class="line">ptr=ab</span><br><span class="line">str=ab</span><br><span class="line">ptr=cd</span><br><span class="line">str=ab</span><br><span class="line">ptr=ef</span><br></pre></td></tr></table></figure><h4 id="strtok-s函数"><a href="#strtok-s函数" class="headerlink" title="strtok_s函数"></a>strtok_s函数</h4><p>strtok_s是windows下的一个分割字符串安全函数，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok_s</span><span class="params">( <span class="keyword">char</span> *strToken, <span class="keyword">const</span> <span class="keyword">char</span> *strDelimit, <span class="keyword">char</span> **buf)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数将剩余的字符串存储在buf变量中，而不是静态变量中，从而保证了安全性。</p><h4 id="strtok-r函数"><a href="#strtok-r函数" class="headerlink" title="strtok_r函数"></a>strtok_r函数</h4><p>strtok_s函数是linux下分割字符串的安全函数，函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok_r</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *delim, <span class="keyword">char</span> **saveptr)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数也会破坏带分解字符串的完整性，但是其将剩余的字符串保存在saveptr变量中，保证了安全性。</p><p>例子（注释里的是另一种写法，效果一样）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"ab,cd,ef"</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="comment">// char **tmpStr;</span></span><br><span class="line">    <span class="keyword">char</span> *tmpStr;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"before strtok: str="</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"begin:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// ptr = strtok_r(str, ",", tmpStr);</span></span><br><span class="line">    ptr = strtok_r(str, <span class="string">","</span>, &amp;tmpStr);</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="string">"str="</span>) &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="string">"ptr="</span>) &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// ptr = strtok_r(*tmpStr, ",", tmpStr);</span></span><br><span class="line">        ptr = strtok_r(tmpStr, <span class="string">","</span>, &amp;tmpStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before strtok: str=ab,cd,ef</span><br><span class="line">begin:</span><br><span class="line">str=ab</span><br><span class="line">ptr=ab</span><br><span class="line">str=ab</span><br><span class="line">ptr=cd</span><br><span class="line">str=ab</span><br><span class="line">ptr=ef</span><br></pre></td></tr></table></figure><h4 id="用STL进行字符串的分割"><a href="#用STL进行字符串的分割" class="headerlink" title="用STL进行字符串的分割"></a>用STL进行字符串的分割</h4><blockquote><p>参考来源：<a href="https://www.cnblogs.com/MikeZhang/archive/2012/03/24/MySplitFunCPP.html" target="_blank" rel="noopener">https://www.cnblogs.com/MikeZhang/archive/2012/03/24/MySplitFunCPP.html</a></p></blockquote><p>上面提到的是对C风格数组字符串的分割函数，这里的是C++中string的分割函数；涉及到string类的两个函数find和substr：<br>1、find函数<br>原型：<code>size_t find ( const string&amp; str, size_t pos = 0 ) const;</code><br>功能：查找子字符串第一次出现的位置。<br>参数说明：str为子字符串，pos为初始查找位置。<br>返回值：找到的话返回第一次出现的位置，否则返回string::npos </p><p>2、substr函数<br>原型：<code>string substr ( size_t pos = 0, size_t n = npos ) const;</code><br>功能：获得子字符串。<br>参数说明：pos为起始位置（默认为0），n为结束位置（默认为npos）<br>返回值：子字符串 </p><p>例子（多个分隔符版本）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split(<span class="built_in">string</span> str, <span class="built_in">string</span> pattern)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> patSize = pattern.size();</span><br><span class="line">    <span class="keyword">auto</span> strSize = str.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splits;</span><br><span class="line">    <span class="keyword">size_t</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; strSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = pattern.find(str[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; patSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前是分隔符</span></span><br><span class="line">            splits.push_back(str.substr(start, i - start));</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理最后一个</span></span><br><span class="line">    splits.push_back(str.substr(start, strSize));</span><br><span class="line">    <span class="keyword">return</span> splits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">" jai sdis sa,,dj  fia ,"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splits = split(str, <span class="string">" ,"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">string</span> s : splits)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">jai</span><br><span class="line">sdis</span><br><span class="line">sa</span><br><span class="line"></span><br><span class="line">dj</span><br><span class="line"></span><br><span class="line">fia</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-输入输出&quot;&gt;&lt;a href=&quot;#C-输入输出&quot; class=&quot;headerlink&quot; title=&quot;C++输入输出&quot;&gt;&lt;/a&gt;C++输入输出&lt;/h1&gt;&lt;h2 id=&quot;重定向&quot;&gt;&lt;a href=&quot;#重定向&quot; class=&quot;headerlink&quot; title=&quot;重
      
    
    </summary>
    
      <category term="C++" scheme="http://QQ876684433.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://QQ876684433.github.io/tags/C/"/>
    
      <category term="输入输出" scheme="http://QQ876684433.github.io/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据库-函数依赖和范式</title>
    <link href="http://QQ876684433.github.io/2019/12/04/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%92%8C%E8%8C%83%E5%BC%8F/"/>
    <id>http://QQ876684433.github.io/2019/12/04/数据库-函数依赖和范式/</id>
    <published>2019-12-04T14:26:41.000Z</published>
    <updated>2019-12-04T14:29:04.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库-函数依赖和范式"><a href="#数据库-函数依赖和范式" class="headerlink" title="数据库-函数依赖和范式"></a>数据库-函数依赖和范式</h1><blockquote><p>链接：<a href="https://www.nowcoder.com/questionTerminal/1acb9fc7610a4781b87363204f83609b?toCommentId=229287" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/1acb9fc7610a4781b87363204f83609b?toCommentId=229287</a></p><p>来源：牛客网</p></blockquote><p>​    数据库表中<strong>不存在非关键字段</strong>对任一<a href="http://baike.baidu.com/view/549695.htm" target="_blank" rel="noopener">候选关键字</a>段的        <strong><a href="http://baike.baidu.com/view/4807244.htm" target="_blank" rel="noopener">部分函数依赖</a></strong>（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。  </p><p>​<br>​      </p><p>​    第3范式：  </p><p>​    在第二范式的基础上，数据表中如果<strong>不存在非关键字段</strong>对任一候选关键字段的        <strong><a href="http://baike.baidu.com/view/550979.htm" target="_blank" rel="noopener">传递函数依赖</a></strong>则符合第三范式。所谓传递函数依赖，指的是如果存在”A → B      → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：  </p><p>​            关键字段 → 非关键字段x → 非关键字段y  </p><p>​<br>​      </p><p>​    BCNF（ 鲍依斯-科得范式 ）：  </p><p>​    在第三范式的基础上，数据库表中如果<strong>不存在任何字段</strong>对任一候选关键字段的        <strong><a href="http://baike.baidu.com/view/550979.htm" target="_blank" rel="noopener">传递函数依赖</a></strong>则符合BCNF。<br>​<br> 依赖关系：<br>​    1.数据依赖<br> 数据依赖指的是通过一个关系中属性间的相等与否体现出来的数据间的相互关系，其中最重要的是函数依赖和多值依赖。<br>​<br> 2.函数依赖<br> 设X,Y是关系R的两个属性集合，当任何时刻R中的任意两个元组中的X属性值相同时，则它们的Y属性值也相同，则称X函数决定Y，或Y函数依赖于X。<br>​<br> 3.平凡函数依赖<br> 当关系中属性集合Y是属性集合X的子集时(Y?X)，存在函数依赖X→Y，即一组属性函数决定它的所有子集，这种函数依赖称为平凡函数依赖。<br>​<br> 4.非平凡函数依赖<br> 当关系中属性集合Y不是属性集合X的子集时，存在函数依赖X→Y，则称这种函数依赖为非平凡函数依赖。<br>​<br> 5.完全函数依赖<br> 设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。<br>​<br> 6.部分函数依赖<br> 设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。<br>​<br> 7.传递函数依赖<br> 设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库-函数依赖和范式&quot;&gt;&lt;a href=&quot;#数据库-函数依赖和范式&quot; class=&quot;headerlink&quot; title=&quot;数据库-函数依赖和范式&quot;&gt;&lt;/a&gt;数据库-函数依赖和范式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://w
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="转载" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="函数依赖" scheme="http://QQ876684433.github.io/tags/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/"/>
    
      <category term="范式" scheme="http://QQ876684433.github.io/tags/%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CPP操作符重载</title>
    <link href="http://QQ876684433.github.io/2019/12/03/CPP%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://QQ876684433.github.io/2019/12/03/CPP操作符重载/</id>
    <published>2019-12-03T08:12:10.000Z</published>
    <updated>2019-12-17T01:53:05.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-操作符重载"><a href="#C-操作符重载" class="headerlink" title="C++操作符重载"></a>C++操作符重载</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>重载的运算符是具有特殊名字的函数：函数的名字由关键字operator和其后要定义的运算符号共同组成</p></li><li><p>重载运算符函数的参数数量与该运算符作用的运算对象的数量一样多</p></li><li><p>除了重载的函数调用运算符operator()之外，其他的重载运算符不能含有默认实参</p></li><li><p>当一个重载的运算符是成员函数时，this对象指针绑定到左侧运算对象（即运算符重载函数的第一个参数）</p></li><li><p>不能重载内置类型的运算符</p></li><li><p>我们只能重载已有的运算符</p></li><li><p>对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符一致</p><p>即<code>x == (y + z)</code>永远等价于<code>x == (y + z)</code></p></li></ul><p>其中<code>::</code>、<code>.*</code>、<code>.</code>和<code>?:</code>不能被重载：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/03/hTq6WVGOiKXpnft.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>运算符重载函数是可以像普通函数一样被显式调用的</p><ul><li><p>非成员函数运算符重载函数的等价调用</p><p><img src="https://i.loli.net/2019/12/03/PzaKcW3mkhQ7jMU.png" alt></p></li><li><p>成员函数运算符重载函数的等价调用</p><p><img src="https://i.loli.net/2019/12/03/cmJEn5YrWvPfaMj.png" alt></p></li></ul></li></ul><h3 id="某些运算符不应该被重载"><a href="#某些运算符不应该被重载" class="headerlink" title="某些运算符不应该被重载"></a>某些运算符不应该被重载</h3><p>某些运算符指定了运算对象的求值顺序，使用重载的运算符本质上是一次函数调用，所以这些关于<strong>运算符对象求值顺序的规则</strong>无法应用到重载的运算符上：逻辑与运算符（&amp;&amp;）、逻辑或运算符（||）和逗号运算符的运算对象求值顺序规则无法保留下来；此外逻辑与运算符（&amp;&amp;）、逻辑或运算符（||）的<strong>短路求值属性</strong>也无法保留，两个运算对象总是会被求值</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/16/DY4N2BxTgMSlyRr.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="使用与内置类型一致的含义"><a href="#使用与内置类型一致的含义" class="headerlink" title="使用与内置类型一致的含义"></a>使用与内置类型一致的含义</h3><p>重载运算符的<strong>返回类型</strong>通常情况下应该<strong>与其内置版本的返回类型兼容</strong>：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回<u><em>左侧运算对象</em></u>的一个引用</p><h3 id="选择作为成员或者非成员"><a href="#选择作为成员或者非成员" class="headerlink" title="选择作为成员或者非成员"></a>选择作为成员或者非成员</h3><ul><li><p>作为成员</p><p>（或者说，单目运算符多是作为成员？）</p><ul><li><strong>赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）运算符</strong>必须是成员</li><li>复合赋值运算符（+=、-=、*=、/=、%=等）一般来说是成员</li><li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员</li></ul></li><li><p>作为普通的非成员</p><ul><li>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/16/Fg6t7Sh5xK2WQ8U.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="输入输出运算符"><a href="#输入输出运算符" class="headerlink" title="输入输出运算符"></a>输入输出运算符</h2><h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><ul><li>输出运算符的第一个形参是一个<strong>非常量</strong>ostream对象的<strong>引用</strong><ul><li>非常量：向流写入内容会改变其内容</li><li>引用：我们无法直接复制一个ostream对象</li></ul></li><li>第二个形参一般来说是一个<strong>常量</strong>的<strong>引用</strong><ul><li>常量：通常情况下打印对象不会改变对象的内容</li><li>引用：我们希望避免复制实参</li></ul></li><li>operator&lt;&lt; 一般要<strong>返回它的ostream形参</strong>（是一个引用）</li></ul><h4 id="输出运算符尽量减少格式化操作"><a href="#输出运算符尽量减少格式化操作" class="headerlink" title="输出运算符尽量减少格式化操作"></a>输出运算符尽量减少格式化操作</h4><p>输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符<strong>不应该打印换行符</strong></p><h4 id="输入输出运算符必须是非成员函数"><a href="#输入输出运算符必须是非成员函数" class="headerlink" title="输入输出运算符必须是非成员函数"></a>输入输出运算符必须是非成员函数</h4><p>如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数；由于通常要读取类的非公有数据成员，所以<strong>IO运算符一般被声明成友元</strong></p><h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><ul><li>输入运算符的第一个形参是运算符将要读取的流的引用</li><li>第二个形参是将要读入到<strong>（非常量）对象</strong>的<strong>引用</strong><ul><li>非常量（必须）：因为输入运算符本身的目的就是将数据读入到这个对象（修改其内部状态）</li></ul></li><li>运算符通常会返回某个给定流的引用</li></ul><p><u><em>输入运算符必须处理 输入可能失败的情况，而输出运算符不需要</em></u></p><h4 id="输入时的错误"><a href="#输入时的错误" class="headerlink" title="输入时的错误"></a>输入时的错误</h4><ul><li>当<strong>流含有错误类型的数据</strong>时读取操作可能失败，那么读取操作和后续对流的使用都将失败</li><li>当<strong>读取操作到达文件末尾或者遇到输入流的其他错误</strong>时也会失败</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/16/FVMQjZd35KwIubG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="标示错误"><a href="#标示错误" class="headerlink" title="标示错误"></a>标示错误</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/16/InHA5YWrR1tThzo.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><ul><li>通常将算术和关系运算符定义为<strong>非成员函数</strong>以<strong>允许对左侧或右侧的运算对象进行转换</strong></li><li>形参都是<strong>常量的引用</strong>，因为这些<strong>运算符通常不需要改变运算对象的状态</strong></li></ul><p>算术运算符通常会计算两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量内，操作完成后返回该局部变量的副本作为其结果</p><p>一般来说可以<strong>使用复合赋值符来定义算术运算符</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data</span><br><span class="line"><span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">Sales_data sum = lhs;</span><br><span class="line">sum += rhs;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/16/si3NSTIUp5QCmA7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>C++中的类通常通过定义一个相等运算符来检验两个对象是否相等：它会比较对象的每个数据成员，只有当所有对应的成员都相等时才认为两个对象相等</p><ul><li>相等运算符应该具有传递性：如果a==b和b==c都为真，那么应该有a==c为真</li><li>如果类定义了operator==，则这个类也应该定义operator!=</li><li>相等运算符和不相等运算符中的一个应该把工作委托给另一个</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;</span><br><span class="line">lhs.units_sold == units_sold &amp;&amp;</span><br><span class="line">lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>通常情况下关系运算符应该：</p><ul><li>定义顺序关系，令其与关联容器对关键字的要求一致</li><li>如果类同时也含有==运算符的话，则定义一种关系令其与==保持一致；特别是，如果两个对象是!=的，那么一个对象应该&lt;另一个</li></ul><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><h4 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h4><ul><li>倾向于把包括复合赋值在内的赋值运算都定义在类的内部</li><li>另一个参数通常是<strong>常量的引用</strong>，因为复合赋值运算符往往不会改变另一个参数的值，并且可以避免引起拷贝</li><li>为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要<strong>返回其左侧运算对象的引用</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data &amp;Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">units_sold += rhs.units_sold;</span><br><span class="line">revenue += rhs.revenue;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>下标运算符<strong>必须是成员函数</strong></p><ul><li><p>通常以<strong>所访问元素的引用</strong>作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端</p></li><li><p>我们最好同时定义下标运算符的常量版本和非常量版本，以便作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值</p><ul><li><p>一个返回普通引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span><br><span class="line">&#123; <span class="keyword">return</span> elements[n]; &#125;</span><br></pre></td></tr></table></figure></li><li><p>另一个是类的常量成员并且返回常量引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> elements[n]; &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>由于递增递减运算符改变的是所操作对象的状态，所以建议将其设定为成员函数</p><h3 id="定义前置递增-递减运算符"><a href="#定义前置递增-递减运算符" class="headerlink" title="定义前置递增/递减运算符"></a>定义前置递增/递减运算符</h3><p>为了与内置版本保持一致，前置运算符<strong>应该返回递增或递减后对象的引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="区分前置和后置运算符"><a href="#区分前置和后置运算符" class="headerlink" title="区分前置和后置运算符"></a>区分前置和后置运算符</h3><p>普通的重载版本无法区分这两种情况，它们使用的是同一个符号，意味着其重载版本所用的名字将是相同的，并且运算对象的数量和类型也相同</p><ul><li>为了解决这个问题，<strong>后置版本接受一个额外的（不被使用）int类型的形参</strong>；当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参</li><li>为了与内置版本保持一致，后置运算符应该<strong>返回对象的原值（递增或递减之前的值）</strong>，返回形式是<strong>一个值而非引用</strong></li><li>因此在递增对象之前需要<strong>首先记录对象的状态</strong></li><li>可以使用前置运算符来实现后置运算符（委托）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递增/递减对象的值但是返回原值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此处无须检查有效性，调用前置递增运算符时才需要检查</span></span><br><span class="line">        StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 向前移动一个元素，前置++需要检查递增的有效性</span></span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 返回之前记录的值</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">        --*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前置递增运算符首先检查递增/递减操作是否安全，根据检查的结果<strong>抛出一个异常</strong>或者<strong>执行递增/递减操作</strong></p><h3 id="显式调用前置-后置运算符"><a href="#显式调用前置-后置运算符" class="headerlink" title="显式调用前置/后置运算符"></a>显式调用前置/后置运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;</span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);<span class="comment">// 调用后置版本</span></span><br><span class="line">p.<span class="keyword">operator</span>++();<span class="comment">// 调用前置版本</span></span><br></pre></td></tr></table></figure><h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><blockquote><h4 id="重载要求："><a href="#重载要求：" class="headerlink" title="重载要求："></a>重载要求：</h4><p>  1、箭头运算符必须是类的成员函数。解引用运算符一般也应该声明为类的成员函数，但不是必须。</p><p>  2、箭头用算符<strong>返回值必须是一个指针</strong>，或者是一个<strong>重载了箭头运算符的对象</strong>。</p><p>​     a）如果返回的是一个指针将调用内置的箭头运算符。执行相当于<code>(*(p.operator-&gt;()).mem;</code>的操作。</p><p>​     b）如果返回是一个重载了箭头运算符的对象，则继续对该对象调用其重载了的箭头运算符，直到返回的是一个指针，将对该指针调用a)的操作。操作相当于<code>(*(p.operator-&gt;().operator-&gt;())).mem;</code></p><p>   总的来说<strong>重载的箭头运算符就是为了改变从哪个对象中获取成员</strong></p><p>——来源：<a href="https://my.oschina.net/flylxl/blog/603114" target="_blank" rel="noopener">https://my.oschina.net/flylxl/blog/603114</a></p></blockquote><p>在实际中可以通过解引用运算符（*）来实现箭头运算符（-&gt;）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">    &#125;</span><br><span class="line">    str::<span class="built_in">string</span>* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>箭头运算符必须是类的成员</li><li>解引用运算符通常是类的成员，但并非必须如此</li></ul><h3 id="对箭头运算符返回值的限定"><a href="#对箭头运算符返回值的限定" class="headerlink" title="对箭头运算符返回值的限定"></a>对箭头运算符返回值的限定</h3><ul><li><p>解引用运算符可以返回任意值，但是箭头运算符不是这样：它永远不能丢掉<strong>成员访问</strong>这个最基本的含义</p></li><li><p>当我们重载箭头时，<strong>可以改变的是从哪个对象中获取成员</strong>，而箭头获取成员这一事实则永远不变</p></li><li><p>对于形如<code>point-&gt;mem</code>表达式来说，point必须是<strong>指向类对象的指针</strong>或是一个<strong>重载了operator-&gt;的类的对象</strong>；也即是说，重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*point).mem;<span class="comment">// point是一个内置的指针类型</span></span><br><span class="line">point.<span class="keyword">operator</span>()-&gt;mem;<span class="comment">// point是类的一个对象</span></span><br></pre></td></tr></table></figure></li></ul><p><code>point-&gt;mem</code>的执行过程：</p><ol><li><p>如果point是指针，则我们应用内置的箭头运算符，表达式等价于<code>(*point).mem</code>；首先解引用该指针，然后从所得的对象中获取指定的成员</p></li><li><p>如果point是定义了operator-&gt;的类的一个对象，则我们使用<code>point.operator-&gt;()</code>的结果来获取mem</p><ul><li>如果该结果是一个指针，则重复第1步</li><li>如果该结果本身含有重载的<code>operator-&gt;()</code>，则重复调用步骤2</li></ul><p>最终当这一过程结束时，程序或者返回了所需的内容，或者返回一些表示程序错误的消息</p></li></ol><p>注意：如果重载的operator-&gt;返回值是对象自身，会导致无限递归，编译器报错；但是如果返回的是对象自身的指针（例如this指针），编译器不会报错</p><p>（因为如果返回值是类的指针，那么编译器会进行步骤1，直接在对应的对象内部查找成员；而如果返回值是对象自身的值，那么编译器会反复调用步骤2，造成无限递归）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/16/MaeSfgPIu7NRnL8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象；这样的类同时能够存储状态，所以比普通函数更加灵活</p><p><strong>函数调用运算符必须是成员函数</strong>；一个类可以定义多个不同版本的函数调用运算符，相互之间应该在参数数量或者类型上有区别</p><p>如果类定义了调用运算符，则该类的对象称作<strong>函数对象</strong>；函数对象通常作为泛型算法的实参</p><h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><p>（先跳过）</p><h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>（先跳过）</p><h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><p>C++中可调用对象的种类：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类</p><ul><li>lambda有它自己唯一的（未命名）类类型</li><li>函数及函数指针的类型则由其返回值类型和实参类型决定</li></ul><p>两个不同类型的可调用对象可能共享一种<strong>调用形式（call signature）</strong>：它指明了调用<strong>返回的类型</strong>以及<strong>传递给调用的实参类型</strong>；例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>是一个调用形式，接受两个int，返回一个int</p><h4 id="不同类型可能具有相同的调用形式"><a href="#不同类型可能具有相同的调用形式" class="headerlink" title="不同类型可能具有相同的调用形式"></a>不同类型可能具有相同的调用形式</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/fyW1Qhpu7Si4LvK.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>例如上面的三个函数类型具有相同的调用形式：<code>int(int, int)</code></p><p>但是具有相同的调用形式却不一定可以看作是相同的类型：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/lVL9w1cHvq3TR7W.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（《Primer C++ 5th》中说mod不是一个函数指针，不能添加到funcTable中，但是我在Linux g++下面是可以编译运行的，emmm）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/4ujQnv3BXtACMEf.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="标准库function类型"><a href="#标准库function类型" class="headerlink" title="标准库function类型"></a>标准库function类型</h4><p>标准类型function定义在头文件functional中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/D3qI6fjSTumyeLv.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在调用时在尖括号中提供调用形式即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; func;</span><br></pre></td></tr></table></figure><p>这里创建了一个function对象func，可接受的调用形式是<code>int(int,int)</code></p><p>这样的func可以接受的可调用对象包括函数指针、lambda或者函数对象等</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/NByJ3iCsPmFtHUv.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="重载的函数与function"><a href="#重载的函数与function" class="headerlink" title="重载的函数与function"></a>重载的函数与function</h4><p>不能直接将重载函数的名字存入function类型对象中，即使这个重载函数的调用形式不同：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/gYrFMBqdl9NUO5G.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>解决方法有两种：</p><ul><li>通过函数指针给重载函数的其中一个版本定义新名字</li><li>使用lambda包装要存储的重载版本</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/home/steve/.config/Typora/typora-user-images/1576547582277.png" alt="1576547582277" title>                </div>                <div class="image-caption">1576547582277</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-操作符重载&quot;&gt;&lt;a href=&quot;#C-操作符重载&quot; class=&quot;headerlink&quot; title=&quot;C++操作符重载&quot;&gt;&lt;/a&gt;C++操作符重载&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="C++" scheme="http://QQ876684433.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://QQ876684433.github.io/tags/C/"/>
    
      <category term="操作符重载" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>编译原理课堂笔记</title>
    <link href="http://QQ876684433.github.io/2019/11/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    <id>http://QQ876684433.github.io/2019/11/29/编译原理课堂笔记/</id>
    <published>2019-11-29T08:38:13.000Z</published>
    <updated>2019-12-20T07:54:57.917Z</updated>
    
    <content type="html"><![CDATA[<p>Method 4 电路状态转换图</p><p>奇偶问题</p><blockquote><p>电路状态转换法解题步骤：</p><ol><li>构造电路状态转换图<br>首先确定状态，如果有n个元素，则存在2^n个状态。<br>然后链接状态。<br>示例：三个元素下的所有状态转换：<br><img src="http://artimg.ishenping.com/20190909054639960_UOPSSE.jpg" alt="在这里插入图片描述"></li><li>确定开始状态和结束状态<br>开始状态和结束状态是相对的，视题目具体情况确定。<br>1）以全是0作为结束状态，以题目要求作为开始状态。<br>2）以题目要求作为结束状态，以全是0作为开始状态。<br>比如对于某种语言，以a或b开头，以c结尾，abc的数量皆是偶数，那么开始状态就不是唯一的，就不能用全是0作为开始状态。而结束状态是唯一的，所以可以拿全是0作为结束状态</li><li>命名各个状态<br>初始状态用S命名，其他状态用A、B、C…命名</li><li>写出相应的产生式<br>每条边上的变化都对应一条产生式<br>对结束状态要增加一条产生式：G-&gt;ε<br>严格来说，最后可以写出2^n (n+1) + 1条产生式。</li></ol><p>来源：<a href="http://www.ishenping.com/ArtInfo/3505373.html" target="_blank" rel="noopener">http://www.ishenping.com/ArtInfo/3505373.html</a></p></blockquote><p>Ω属于{a，b，c，d}，其中a、b个数是奇数，c个数是偶数</p><p>（1）画出电路转换图</p><p>（2）确定开始状态和结束状态</p><p>全是0的状态特殊考虑：</p><ul><li><p>000：作为终态</p><p>根据需求确定初态（那么初态是110，表示a、b个数是1奇数，c的个数是0偶数）</p><p>然后将“上帝之手”指向初态</p><p>（原因是，从$110-&gt;000$，无论在电路图上怎么走，最终a、b变化的都是奇数次，c是偶数次）</p></li><li><p>000：作为初态</p><p>根据需求确定终态</p></li><li><p>随机</p><p>例如开始状态是101，那么终态是$101+110=011$</p></li></ul><p>（3）命名每个状态</p><p>开始状态必是S，若其他7个状态表示为A-G</p><p>（4）写出相应的产生式（related production）</p><p>每条边对应一个产生式，例如AB之间有一条边A &lt;a&gt; B，那么A-&gt; aB</p><p>对于终态Z（两个圈表示），要有Z -&gt; ∅</p><p>所以最终的产生式：</p><ul><li>$S-&gt;aA|bC|cG|dS$</li><li>$A-&gt;aS|bB|cE|dA$</li><li>$B-&gt;aC|bA|cD|dB$</li><li>……</li></ul><p>所以最终生成式的个数：$2^n*(n+m)+1$，其中+1表示的是终态$Z-&gt;∅$</p><p>终态和初态可能是相同的，最后要检查最终的产生式的个数是否相同</p><p>Method 5 FA-based Method</p><p>子序列（subsequence）和子串（substring）的区别：子序列不要求在原串中连续</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/15/pAqFX2B5M97jOtE.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/15/afK3MUhHgSxqToY.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Method 6 Hybrid Method</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/15/bwYA1qXVzDrTBmU.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Section 4 文法的二义性</p><p>$E-&gt;E+E|E*E|i$</p><p>$i+i*i$有不止一个分析树</p><h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><p>写程序时，首先考虑程序<strong>外部特性</strong>：程序的输入、输出；然后再考虑<strong>内部特性</strong></p><p>词法分析程序：</p><ul><li><p>输入：源程序</p></li><li><p>输出：token</p><p>token（lexeme（actual word），catalog，inner_code）</p><p>标识符放在标识符表中（ID Table），但是同一个word可能有多个含义，因此需要使用inner_code来进行区分，例如可以使用ID Table中的行号作为inner_code</p><p>例如x=y+2，那么ID Table如下：</p><p>(“X”, ID, 1)</p><p>(“=”, ASSIGN_SYM, _)  // 因为赋值符号是单例的，即赋值符号没有其他的含义，那么就不需要inner_code来进行区分</p><p>(“Y”, ID, 2)</p><p>……</p></li></ul><h3 id="Section-2"><a href="#Section-2" class="headerlink" title="Section 2"></a>Section 2</h3><p>单词构造规则（word construction rule），如何描述<strong>单词构造规则</strong>：</p><ul><li>正规文法 Regular Grammar：不直观，如abc：S-&gt;aA, A-&gt;bB, B-&gt;c</li><li>正规表达式 Regular Expression，它给出了单词的一个模板template</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/20/Y5C8r9LksAnHoTc.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/20/Fr9JDSOXAdi4KTn.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如何通过RE来构造词法分析程序：FA（有限自动机）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/20/reB2io3j8gk5MLw.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>FA：</p><ul><li><p>DFA（Deterministic） - 机器能接受的</p><p>i状态下读入了a字符，它的后续状态是唯一的</p><p>RE很容易变成NFA，因为a*的0次方是{空}边</p></li><li><p>NFA（Non-deterministic）</p><p>i状态下读入了a字符，它的后续状态可能是j或者k，或者其他</p></li></ul><p>如何将NFA转换成DFA？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/20/quO1FvCcx84RKUB.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/home/steve/Desktop/IMG_20191120_154604.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>怎么将两种方法结合起来？<strong>表驱动</strong>，确定化（DFA）以后的表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/20/hry3jMD9sVI1CwA.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过RE来生成DFA</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/22/ANckXvdzM5tZW8P.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>NFA转成DFA时，DFA中包含原NFA中终态的状态作为DFA的终态</strong></p><h3 id="Optimization-of-a-DFA"><a href="#Optimization-of-a-DFA" class="headerlink" title="Optimization of a DFA"></a>Optimization of a DFA</h3><p>Idea：Reduce the number of states of DFA</p><p>How to reduce?  Equivalent Class Division（等价类划分法，ECD）</p><p>等价：自反、对称、传递</p><p>划分等价类的方法ECD：</p><ul><li><p>Clustering——Bottom-Up Combination</p><p>从单个元素开始，知道类中所有元素都是等价的，类外的元素都是不等价的</p></li><li><p>Classifying——Top-Down Division</p><ul><li><p>首先将所有的状态作为top</p></li><li><p>然后将所有的终态放到一起，所有的非终态放到另一起</p></li><li><p>接下来这两个类别要不要继续分解，要根据<strong>State Equivalence（状态等价）</strong>来决定</p><p>状态等价：</p><ul><li>两个状态发出的边数相同（如果不同，说明两个状态处理的符号数不同，即处理能力不同）</li><li>发出的边上标记相同</li><li>后续状态要相应等价</li></ul><p>状态等价转换成<strong>后续状态等价</strong>的问题</p><p>状态等价有两种：</p><ul><li><p>special case：same（strong  state equivalence，强等价）</p></li><li><p>special case：belong to same leaf of current division tree（weak state equivalence，弱等价）</p><p>即后续状态同属于当前分解树的叶子节点，而不要求所有的后续状态都相同</p></li></ul><p>我们希望的是第二种（弱等价），因为这样分解得到的状态相对少，达到了我们的目的</p><p><img src="https://i.loli.net/2019/11/22/AdpCLI19MkqjWZz.jpg" alt></p></li><li><p>选择代表时，如果包含初态和其他状态，那么只能选择初态作为代表</p><p><img src="https://i.loli.net/2019/11/22/kuDsnLWCZbhxBXY.jpg" alt></p></li></ul><p>Note：<strong>lookback problem</strong>（后续状态的分解会引起前面状态的分解的改变<strong>（即继续分解）</strong>）</p><ul><li>一步一回首：每当有状态分解，就回头检验一下（因为会存在震荡/抖动问题，效率低）</li><li>最后再回首：分解结束后再回来检验叶子节点（效率高，推荐）</li></ul></li></ul><p>$NFA=&gt;DFA=&gt;{DFA}^{0}=&gt;program$</p><p>program：</p><ul><li>hard code：将状态转换表写死在程序中</li><li>sofe code：table-driven，smart personalization configuration file（将控制转成数据，表驱动，$DFA’s;transition;table$）<ul><li>loop up table</li><li>terminate：如果查到空白，则看当前状态是不是终态，如果是则终止，否则出错</li></ul></li></ul><h3 id="Section-5"><a href="#Section-5" class="headerlink" title="Section 5"></a>Section 5</h3><p>如何将RE转成成NFA？</p><h4 id="Method-1-Top-Down-Stepwise-Refinement"><a href="#Method-1-Top-Down-Stepwise-Refinement" class="headerlink" title="Method 1 Top-Down Stepwise Refinement"></a>Method 1 Top-Down Stepwise Refinement</h4><p>top：初始状态=(RE)=&gt;终止状态</p><p>down：边上标记是<strong>单个符号</strong>或者<img src="https://i.loli.net/2019/11/22/jSguUX9w72heBrP.png" style="zoom:50%;">边</p><p>按照RE本身的结构进行分解（庖丁解牛）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/22/UIH2S5XPfGkdLNY.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>容易出错，适合人进行操作</p><h4 id="Method-2-Thompson-Algorithm-Bottom-Up-Combination"><a href="#Method-2-Thompson-Algorithm-Bottom-Up-Combination" class="headerlink" title="Method 2 Thompson Algorithm Bottom-Up Combination"></a>Method 2 Thompson Algorithm Bottom-Up Combination</h4><p>从计算机角度出发，适合计算机来实现，它引入了更多的<img src="https://i.loli.net/2019/11/22/jSguUX9w72heBrP.png" style="zoom:50%;">边</p><img src="https://i.loli.net/2019/11/22/5vGJTmQxIbhFqrc.jpg" style="zoom:80%;"><ul><li>将点·补上，然后将中缀转成后缀：</li></ul><p>$$<br>(a<em>b)</em>(a|b)(a|b)* =&gt; (a<em>·b)*·(a|b)·(a|b)</em> =&gt; a<em>b·</em>ab|·ab|*·<br>$$</p><ul><li><p>最后扫描后缀表达式，使用算法</p><p><img src="https://i.loli.net/2019/11/22/WsjRn9bzJkTNPVK.jpg" alt></p><ul><li><p>遇到字符：生成小的自动机</p></li><li><p>遇到点或者其他符号：进行连接</p></li></ul><p>引入了太多的<img src="https://i.loli.net/2019/11/22/jSguUX9w72heBrP.png" style="zoom:50%;">边，但是能够由计算机计算完成</p></li></ul><p>龙书第三章讲了：直接从RE=&gt;DFA</p><h3 id="Section-6"><a href="#Section-6" class="headerlink" title="Section 6"></a>Section 6</h3><p>如何从语言来构造正规表达式RE？</p><h4 id="Method-1-Stepwise-Refinement"><a href="#Method-1-Stepwise-Refinement" class="headerlink" title="Method 1 Stepwise Refinement"></a>Method 1 Stepwise Refinement</h4><p>看单词特征是不是可分解的</p><p>一般来说是从左向右开始的</p><p>例子：<br>$$<br>L={w|w\in(0,1,2,…,9)^{<em>},w;mod;5=0 }<br>$$<br>先从个位数开始，然后再考虑多位数<br>$$<br>0|5|(1|2|3|…|9)(1|2|3|…|9)^{</em>}(0|5)<br>$$<br>龙书习题：</p><p><strong>先把最简单的情况写出来，后面复杂的情况可以用到简单情况</strong></p><ul><li><p>没有重复数字的字符串{0, 1, 2}</p><p><img src="https://i.loli.net/2019/11/22/dL934kbhzXMQHCq.jpg" alt></p></li><li><p>只有一个重复数字的字符串{0, 1, 2}</p></li></ul><h4 id="Method-2-FA-based"><a href="#Method-2-FA-based" class="headerlink" title="Method 2 FA-based"></a>Method 2 FA-based</h4><p>将电路状态转换图中的<strong>中间状态消除，只留下初始状态和终止状态</strong></p><p>只要有一个终态，就会有正规表达式的一种情形，它是从初态到终态的路径的RE</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/GRo8IMebTgdiwkF.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/vRKfQUrwguLeXbA.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="2019-11-27"><a href="#2019-11-27" class="headerlink" title="2019-11-27"></a>2019-11-27</h3><p>如何从RG=&gt;NFA？</p><p>RG有两种：</p><ul><li><p>*右线性正规文法：从左向右看</p><p><img src="https://i.loli.net/2019/11/27/tus7oiDvdGLXTBJ.jpg" alt></p></li><li><p>左线性正规文法</p></li></ul><p>language=&gt;RE</p><ul><li><p>Method 1：stepwise refinement</p></li><li><p>Method 2：FA-based</p></li></ul><p>对特殊的语言，可以直接从language=&gt;NFA</p><p>NFA至少满足其中一个情形：</p><ul><li>有<img src="https://i.loli.net/2019/11/22/jSguUX9w72heBrP.png" style="zoom:50%;">边</li><li>从同一个边可以到达多个不唯一的后续状态</li></ul><p>RE、RG和FA之间的关系：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/hJkRmUdfxsELwZ7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="Section-8"><a href="#Section-8" class="headerlink" title="Section 8"></a>Section 8</h3><p>对每个语言都专门写一个词法分析程序很繁琐，可以对相似的程序进行抽象出一个框架</p><p>similar program：</p><ul><li>Framework - common</li><li>Parameter - special</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/bT6Uy8SpKLNaHXA.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/pVszXbn3yFNM5gk.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这个framework就是LEX</p><p><img src="https://i.loli.net/2019/11/27/Re4bN5g3yUqpOwS.jpg" alt></p><p>当有n个RE（每个RE对应一类单词）时，依然是使用同一个词法分析程序来识别所有的单词</p><p>多个RE分别生成NFA，然后再将多个NFA合并成一个大的NFA<br>$$<br>NFA_{i}=&gt;aNFA=&gt;DFA=&gt;DFA^{0}<br>$$<br>$DFA^{0}$可以用来编写词法分析程序</p><ul><li><p>初态两两合并，是为了保证每个状态最多发出两条边，方便后面设计数据结构</p></li><li><p>终态不能合并，因为每个终态对应的含义不同</p><ul><li>优化DFA时将终态放到一起，只是以为这里没有给每个终态赋予含义</li></ul></li></ul><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/29/qr9xQzsXUJChH2y.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="section-1"><a href="#section-1" class="headerlink" title="section 1"></a>section 1</h3><p>词法分析程序输出token 序列，语法分析程序的输入为token序列</p><ul><li><p>Derivation-based：From $S=&gt;\alpha,\alpha\in V_{T}^+$，是一种top-down的分析方法</p></li><li><p>Reduction-based：Bottom-Up方法，Method of Construction of Parse Tree</p><ul><li>从句子实例本身开始，一步步进行抽象</li></ul></li></ul><p>CFGG=&gt;parser</p><h3 id="section-2"><a href="#section-2" class="headerlink" title="section 2"></a>section 2</h3><p>（1）Recursive Descent Parsing（the simplest top-down method）</p><ul><li><p>好处：有文法就可以写语法分析程序</p></li><li><p>缺点：对文法有相应要求</p><ul><li>不能含有公共左因子，如$S=&gt;ABC|AD$，A就是公共左因子，这样会<strong>引起回溯</strong></li><li>不能出现左递归，如$A=&gt;Aa|b $：会<strong>导致无限递归</strong></li></ul></li></ul><p>每个非终结符对应一个子程序</p><p>每个终结符对应一个判定（decision）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/zmsKtNyRCl57UJM.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>会导致回溯（backtracking）问题：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/Ie2YrDFwVCTU3bJ.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>$A=&gt;Aa|b$是一种左递归：会引起无限递归的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">ch=getchar();</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">'b'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）预测分析法（Predictive Parsing Method）</p><p>要求和上面一样：</p><ul><li>不能含有公共左因子，如$S=&gt;ABC|AD$，A就是公共左因子，这样会引起回溯</li><li>不能出现左递归，如$A=&gt;Aa|b $：会导致无限递归</li></ul><p>为了避免回溯和无限递归，提出了预处理方案：</p><p>1）提取最大的公共左因子（extract maximum common left factors）</p><p>因为含有公共左因子时，需要进行试探，试探就会引起回溯</p><p>$A=&gt;\alpha\beta|\alpha\gamma, \alpha,\beta,\gamma\in(V_N,V_T)$</p><p>$A=&gt;\alpha A^{‘}$</p><p>$A^{`}=&gt;\beta|\gamma$</p><p>2）消除左递归</p><p>$左递归：A=&gt;A\alpha|\beta$</p><p>$右递归：A=&gt;\alpha A|\epsilon$</p><ul><li><p>Immediate/Direct left recursion</p><p>通过语言，将左递归变成右递归</p><p><img src="https://i.loli.net/2019/11/29/KF7c5NC1ewAJjyE.jpg" alt></p></li><li><p>Indirect left recursion</p><p>间接左递归：$(1) S → Qc|c (2)Q → Rb|b (3) R → Sa|a$</p><p>消除死锁（死循环）：给它们规定优先级，高优先级能够使用低优先级（以及自身）的资源</p><p><img src="https://i.loli.net/2019/11/29/4qW72ihuzRcf1KV.jpg" alt></p><p>变成直接左递归后，再使用消除直接左递归的方法</p><p>（约定：开始状态的优先级最高）</p></li><li><p>Hybrid left recursion（混合左递归）</p><p>既有直接左递归，也有间接左递归</p><p>$S=&gt;Sa|Ab|b$</p><p>$A=&gt;Ad|Se|f$</p><p><img src="https://i.loli.net/2019/11/29/YApbvtnHz4hdZGw.jpg" alt></p><p>采用前面两种方法无效，无穷无尽</p><p>混合左递归的特点：Loop in Loop，圈中套圈</p><p>方法：</p><ul><li>Inner =&gt; Outer（攘外必先安内）</li><li>Left =&gt; Right</li></ul><p>先消除内部的圈，然后再消除外部的圈（从左向右）</p><p><img src="https://i.loli.net/2019/11/29/ltvr4aVZXUz9Pjx.jpg" alt></p><p><img src="https://i.loli.net/2019/11/29/ph1fItWwOya5mjr.jpg" alt></p></li></ul><p>3）<strong>Construct the PredictIve Parsing Table（PPT，构造预测分析表）</strong></p><p>Table driven：软编码</p><p>对一个输入加入左哨兵$$_L$和右哨兵$$_R$</p><p>如：$i+i;=&gt;$_L;i+i;$_R$</p><p>推导时将右边替换左边（即将左边出栈），同时为了实现最左推到，因此右边应该从右往左入栈</p><p>如果栈顶是终结符，则比较该终结符和指针指向的符号是否相同，相同则继续，指针往后走；不同则报错</p><p>$\epsilon$不压栈，例如$T=&gt;\epsilon$相当于将栈顶的T出栈</p><p>如果指针指向了$$_R$，则只需判断栈中剩余的所有的非终结符能够推导出$\epsilon$</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/29/CwziMIBvphdUnmW.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>最后根据推导序列（Derivation Sequence，预测分析法的灵魂）就能够得出分析树</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/29/q8nuvSd6mWckwNb.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>First：起到预测的作用</p><p>$first(\alpha)={a|\alpha=&gt;a…,a\in V_T}$</p><p>如果一个推导有多个可用产生式，那么经过如下预测，可以知道选用first($\alpha$)=a更合适，能够让推导前进一步</p><p><img src="https://i.loli.net/2019/11/29/cdG1tJlEqNjwRPz.jpg" alt></p><p>如果只有一个可用产生式，就只能用这个，如果最终推导无法匹配，那么将报错</p><p><img src="https://i.loli.net/2019/11/29/UB9CpoSqHwuX2LN.jpg" alt></p><p>迭代法求解递归</p><ul><li>先进行最初始假设</li></ul><p><img src="https://i.loli.net/2019/11/29/6SkbsPRwufpYcWX.jpg" alt></p><p><img src="https://i.loli.net/2019/11/29/638XCMclOTwJnRA.jpg" alt></p><p>这个为了看什么情况下才能够使用$E=&gt;TE^{`}$，根据first(E)的结果知道+和(的情况才能使用，否则报错</p><p>How to solve the application of $A=&gt;\epsilon$？</p><ul><li><p>求$Follow(A)={a|S=&gt;…Aa…,a\in V_T}$，而且是对非终结符求Follow()</p></li><li><p>即栈中推导出的所有的终结符去掉A后，其余部分能够和表达式匹配，那么$A=&gt;\epsilon$将A出栈</p></li><li><p>怎么变成算法（即怎么求follow）？</p><p>观察相应产生式的右部，看哪些产生式的右部包含A</p><ul><li><p>$B=&gt;\alpha A\beta$</p><p>$S=&gt;…=&gt;…B…=&gt;…\alpha A\beta…$</p><p><img src="https://i.loli.net/2019/12/04/DhSObgvXnA3s1EI.jpg" alt></p></li><li><p>$B=&gt;\alpha A$</p></li></ul><p>约定：对于开始符，求follow时，一定要把$$_R$放进follow(开始符)</p></li></ul><p>例子：</p><p><img src="https://i.loli.net/2019/12/04/W69oYkHshAxSc8N.jpg" alt></p><p><img src="https://i.loli.net/2019/12/04/x6nhYRG18ftE5Bz.jpg" alt></p><p><img src="https://i.loli.net/2019/12/04/kInLWZ5AjwGS7Fa.jpg" alt></p><p><img src="https://i.loli.net/2019/12/04/vHlhZwsV9puAL3m.jpg" alt></p></li></ul><p>4）构造预测分析程序</p><p>soft code（table-driven）</p><p>预测分析器：</p><ul><li><p>PPT</p><p>空白格子报错</p></li><li><p>monitor</p><ul><li>Initialization（初始化）：栈初始化，将PPT放入内存（以二维表的方式）</li><li>lookup table：查PPT（需要两个参数，栈顶的非终结符和指针指向的终结符）</li><li>matching程序：栈顶终结符和指针指向的终结符相同则matched</li><li>success report：异常结束、成功结束（栈顶是$$_L$，指针指向$$_R $）</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/URHEohbIpD3KdQt.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>对文法G进行预处理（含有公共左因子和左递归的情况需要进行预处理）得到G’后，如果G’的PPT没有冲突，那么G’称为<strong>LL(1)文法</strong>：</p><ul><li>L：从左向右扫描（scan from Left to right）</li><li>L：最左推导（Left-most derivation）</li><li>1：看读头下的一个符号进行推导（watch the character under the reader）</li><li>LL（1）文法才能用预测分析法进行推导</li></ul><p>$G=&gt;G’=&gt;PPT$</p><p>PPT里的一个格子里如果有两个产生式，那么就会产生冲突</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/N7uKlaZOjpRvP5J.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/TYeHgVFwvW8tSjJ.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/W3nrQwJVsbYzP5D.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>解决二义文法？（例子：ppt4第35张）</p><p>$S → iEtSS<code>|a \\$$S</code> → eS | \epsilon \$<br>$E →b$</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/ZjLxtXGf7ERMQub.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>消除左递归也不能解决二义性文法：</p><ul><li><p>$E=&gt;E+E|E*E|i$</p><p><img src="https://i.loli.net/2019/12/04/wKi5rksR1JygH4I.jpg" alt></p><p><img src="https://i.loli.net/2019/12/04/VqYnGBZrH14Xbkg.jpg" alt></p></li></ul><p><strong>（3）LR分析法（LR parser）</strong></p><p>L: scan from Left to right</p><p>R: Leftmost Reduction</p><p>思想：分层有限自动机（using Layered Finite Automata）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/VtmYw2XEheNs6cd.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>CFGG: Hierarchical Structure </p><p>给个产生式构造小的自动机，然后将相关的小自动机用$\epsilon$边来连接起来</p><p>$S=&gt;\eta | \theta$</p><ul><li><p>引入0号产生式，构造最上层的小自动机（使得初始状态有且只有一个）</p><p><img src="https://i.loli.net/2019/12/04/bhvzaZXflYS5Dmj.jpg" alt></p></li></ul><p>$G+(0)S’=&gt;S=&gt;G’=&gt;Layered; FA（是NFA）=&gt;LR;DFA$</p><p><strong>给分层FA中的每个状态命名，使用LRitem</strong></p><p>LRitem（实际上是一种二维的命名方法）：</p><ul><li>layer: 产生式本身（产生式就代表了层次），即第几层</li><li>position: dot（点），即该层的哪个位置</li></ul><p>LRitem：</p><ul><li>Shift item </li><li>Reduction item</li></ul><p>对于$C=&gt;\epsilon$的小自动机（命名为$C=&gt;.$）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/evosuMngNI9Rb81.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>关键：分层有限自动机、LR项</strong></p><ul><li><p>start point：$S’=&gt;S$</p></li><li><p>$\epsilon$闭包（解决$\epsilon$边的问题）和子集构造法（解决后续状态不唯一的问题）结合使用</p><ul><li><p>$\epsilon$闭包：内部状态扩展（in-state extension）</p><p>直到右部的首字符是终结符或者点走到最后，否则将继续进行内部状态扩展</p></li><li><p>子集构造法：状态间扩展（between-state extension）</p><p>shift dot（将点往后移动一步）</p></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/QUxRPSJ4she6lAb.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>与第三章的DFA的区别：<strong>边上可以是非终结符</strong></p><p>PPT中的例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/qmYTDZcsCB6EznK.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/Uoiq6KZ9vxgbnFM.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>LR DFA =&gt; LR parsing table</strong></p><ul><li><p>ACTION子表处理终结符边</p><p>另一个参数是：读头下可以出现的符号</p></li><li><p>GOTO子表处理非终结符边</p><p>另一个参数是：非终结符</p></li></ul><p>从I0开始，观察每一个状态</p><ul><li><p>发出边（outer edges）</p><ul><li>非终止符$V_N$——GOTO子表</li><li>终止符$V_T$——ACTION子表</li></ul></li><li><p>Inner——可规约的LRitem（即点跑到最后的项，例如$S’=&gt;E.$）</p><p>开始求Follow（…），例如求Follow(E)</p><p>使用0号产生式做规约，相当于$r_0=accept$</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/06/zYCySflXhg1vV5a.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>两个栈</p><ul><li>状态栈state，栈底是0号状态$S’$</li><li>符号栈symbol，栈底是$$_L$</li></ul><p>$S_i$的作用是，将读头指向的符号压入符号栈并将读头往后移动一位，同时将i状态压入状态栈，</p><p>$r_i$的作用是，拿i号可规约串做规约，将可规约串右部的符号弹出符号栈（状态栈也要同步弹出），将可规约串左部压入符号栈，并将<strong>GOTO(状态栈栈顶状态，符号栈栈顶符号)</strong>压入状态栈</p><p>（可规约串实际上是将右部规约成左部）</p><p>将规约过程中用到的可规约串作为<strong>规约序列（reduction sequence）</strong>，然后根据这个规约序列可以反向构造出语法分析树</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/06/1LPqgRuGXieVf87.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>$G+(0)=&gt;G’=&gt;LR;DFA=&gt;LR;Parsing;Table;without;conflicts$</p><p>那么G is called SLR(1) grammar</p><ul><li><p>S: simple</p><p>SLR(1)不能够分析所有的非二义文法</p></li><li><p>L: scan from left to right</p></li><li><p>R: leftmost reduction</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/06/E5OuasytmHT3CdW.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>conflicts：</p><ul><li><p>S-R: shift-reduce-conflicts（移进-规约冲突，即同一个格子中同时有S和R）</p></li><li><p>R-R: reduce-reduce-conflicts（规约-规约冲突，即同一个格子中有两个及以上的R）</p></li><li><p>不存在S-S，因为我们是基于LR DFA的，对于一个符号，只会有一个后续状态</p><p><img src="https://i.loli.net/2019/12/06/m8kCJdpxhBTF7ty.jpg" alt></p></li></ul><p><strong>解决方案</strong></p><p>通过LR(1)item，实现SLR(1)===&gt;LR(1)</p><p>LR(1)item = LR item + predictive symbol（预测符号，the character after the reducible string）</p><ul><li><p>可归约项之后会出现的符号</p></li><li><p>符号栈顶已经形成了可规约串，预测符号决定是否要进行规约</p></li></ul><p>预测符号一定属于Follow(规约项左部)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/06/bFkumzfQX2Twlyd.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/06/TY983ZRlkjxHLCv.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/home/steve/.config/Typora/typora-user-images/1575619938033.png" alt="1575619938033" title>                </div>                <div class="image-caption">1575619938033</div>            </figure><p>LR(1)DFA=&gt;LR(1) parsing table</p><ul><li><p>观察每个状态</p><ul><li><p>outer edges</p><ul><li>$V_T$</li><li>$V_N $</li></ul></li><li><p>inner，要带上预测符</p><p>$(A=&gt;\alpha,a)$，那么在(A, a)下面填$r_{规约项}$</p><p>这样就不需要求Follow(A)，直接通过预测符a来填$r_{规约项}$</p></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/06/h5Km2skJEzloPgB.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>2019-12-11</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/11/uwgCcAJosTxYOLG.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/11/tBqEOSby9fHgL4w.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/11/YAO3ceM6ywRuTXq.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>LR(1)DFA的能力比LRDFA强，但是状态更多</p><p>LR(1) state的预测符拿掉后是LR(1)item的核心（core）</p><p>LR(1)DFA可以通过合并同核心状态得到LALR(1)DFA，其中LA是：LookAhead，然后就可以构造LALR(1)分析表</p><p>$SLR(1) \in LR(1)$</p><p>$LALR(1)\in LR(1)$</p><p>LRDFA和LALRDFA的状态数相同</p><p>LRDFA不一定能够通过合并同心项来得到LALRDFA，可能会产生新的冲突，见PPT4第96-99页</p><p>LRDFA的分析能力是最强的，能够分析非二义文法和二义文法</p><p>ambiguous grammar G ==&gt; LR(1) parsing table、SLR(1) parsing table with conflicts</p><p>二义文法的解决方案是：<strong>引入附加条件</strong></p><ul><li><p>表达式文法：$E=&gt;E+E|E*E|(E)|i$，那么引入的附加条件有：</p><ul><li><strong>优先级</strong>（precedence / priority）</li><li><strong>结合性</strong>（left associativity / right associativity）</li></ul><p>方法一（SLR(1)）：</p><ul><li><p>构造SLR(1)分析表，找出冲突</p></li><li><p>通过引入的附加条件解决冲突</p><ul><li><p>给出附加条件，例如*和/的优先级比+和-高，并且都是左结合性</p></li><li><p>解决冲突：</p><p>通过比较读头下的符号和符号栈顶的符号的优先级或者结合性（这是我们引入的附加条件）来决定选择哪个动作</p><p>（已经进栈的写在前面，未进栈的写在后面，然后比较前后的优先级和结合性；符号相同看结合性，符号不同则看优先级）</p></li><li><p>最后就可以将有冲突的分析表变成无冲突的分析表</p></li></ul></li></ul><p><img src="https://i.loli.net/2019/12/11/toB3F5yqn8ebXRf.jpg" alt></p><p>方法二（LR(1)）：</p><ul><li>构造LR(1)分析表来找出冲突</li><li>解决冲突（同方法一）</li></ul></li><li><p>if-else二义文法时，引入附加条件为：else-dangling</p><p>$(0)S’=&gt;S$</p><p>$S=&gt;iS|iSeS|a$</p><ul><li><p>首先构造LR(1)/SLR(1)：$SLR(1): G+(0)=&gt;G’=&gt;LR DFA / SLR(1) DFA$</p></li><li><p>构造SLR(1)分析表，找出冲突</p><p>$i;i;S;;eS$</p></li><li><p>引入附加条件假设</p><ul><li><p>farest: else和最远的if匹配</p><p>那么先规约，再移进</p></li><li><p>nearest: else和最近的if匹配</p><p>那么先移进，再规约</p></li></ul></li></ul></li><li><p>规约-规约冲突时引入的附加条件：位置优先法（position-precedence）</p></li></ul><p>  <img src="https://i.loli.net/2019/12/13/sak5IldM2O13Lof.jpg" alt></p><p>由程序从G生成LL(1)：Yacc（Yet another compiler-compiler）</p><p>关于龙书习题4.8.1：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/13/6Sh5fznKp8sUGCa.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>ch4补充练习</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/18/H3jIhFPZ1DT62eq.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/18/JpIPj3G6SoeA8KO.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><p>Correction：</p><ul><li>legal</li><li>rational —— semantic analyze（语义分析）</li></ul><p>semantic analyze：</p><ul><li><strong>static</strong>: at compiling time (type checking，类型检查)</li><li>dynamic: at running time(黑盒测试)</li></ul><p>how to do semantic analyze? —— syntax directed（语法制导），doing while parsing</p><p>Semantic of a symbol: properties（特征） &lt;= <strong>attributes</strong> of a symbol</p><ul><li>attributes：<ul><li>name（属性名，例如通过属性名的不同来区分不同的类）</li><li>value（属性值，区分同类符号中的不同个体）</li></ul></li></ul><p>parse tree symbols’ attributes</p><ul><li>adding attribute name（给分析树中的符号命名）</li><li>evaluate attributes value（进行属性值的计算）</li></ul><p>—— semantic rules（semantic action，语义规则/语义动作）</p><p><strong>Grammar（CFG）+ Semantic Rules</strong></p><p>how to combine?</p><ul><li><p><strong>Central（集中）—— SDD（syntax-directed definition）</strong></p><p>a production &lt;= semantic rules</p><p>—— related to LR parsing，using semantic rules while reducing</p><p><img src="https://i.loli.net/2019/12/18/4Ev6NLQuUbqJgRM.png" alt></p><p>lexval：词法分析程序送过来的值，$3+2=&gt;i+i$</p><p>$E.val=digit.lexval$是进行属性值的计算，将digit.lexval赋值给E.val</p></li><li><p>Decentral —— Translation Scheme</p><p>语义规则嵌入在产生式中</p><p>$A=&gt;{B.h=2}B{B.t=B.h}$</p><p>—— related to LL(1) parsing, using semantic rules while deriving</p></li></ul><h3 id="SDD"><a href="#SDD" class="headerlink" title="SDD"></a>SDD</h3><p>attributes:</p><ul><li><p>Synthesized——父节点综合了子节点的值<br>$E=&gt;E_1+E_2$</p></li><li><p>Inherited</p><p>$D=&gt;TL, {L.type=T.type}$，即T的值决定了L的值，或者L的值继承了T的值</p><p>$L=&gt;L_1B, {L_1.size=L.side}$，L1继承了L的值</p></li></ul><p>if a SDD has only synthesized attributes, the SDD is called <strong>s-attribute definition</strong></p><p>parse tree + attribute =&gt; Annotated parse tree（加标注的分析树）</p><p>Chapter5的核心：对于s，通过s-attributes definition来构造Annotated parse tree of s</p><p><strong>How to construct the APT?</strong></p><h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><p>Syntax-directed generating while reducing</p><h4 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h4><p>First construct the parse tree, then generate APT</p><p>龙书习题5.2.4</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/18/FHtOjXQrB7qZACg.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><p>Translation =&gt; 目标程序(.obj)</p><p>引入中间代码，是为了优化生成高效的目标代码：</p><p>$Translation =&gt; Intermediate Code =&gt; Optimized Code =&gt; .obj$</p><p>目标代码.obj：</p><ul><li>Independent-machine（机器无关/平台无关的二进制码，例如Java的字节码）</li><li>Dependent-machine</li></ul><p>$.c=&gt;.obj=&gt;_{linking}.exe/.elf$</p><p>选择合适的中间代码形式</p><ul><li>便于人阅读（以便进行优化）</li></ul><p>Graph-based</p><ul><li><p>Parse tree</p></li><li><p>Syntax tree</p><p><img src="https://i.loli.net/2019/12/18/4evHqVpu2wgPEWo.jpg" alt></p></li><li><p>DAG（有向无环图）</p><p>Hierarchical Structure Graph（具有层次结构的图）: Directed Acyclic Graph</p><p><img src="https://i.loli.net/2019/12/18/lRkQDTNoUnzf6qh.jpg" alt></p></li></ul><p>Expression-Based</p><ul><li><p>Infix</p><p>$z=x+y$</p><p>涉及了三个地址：operand1, operand2, result</p><p><strong>Three-Address Code(TAC, 三地址码)</strong></p><p><code>if(a[i]==x)goto L;</code>不是三地址码，含有四个地址</p><p>引入GOTO：</p><p>Conditional expression：Simple Conditional Expression<br>Simple：</p><ul><li><p>logical constant</p><p><code>if(1) goto L;</code></p></li><li><p>logical variable</p><p><code>if(x) goto L;</code></p></li><li><p>relative comparation expression（关系比较表达式，&gt;，&lt;，&gt;=，&lt;=等） with simple data object（简单数据对象）</p></li></ul><p><img src="https://i.loli.net/2019/12/18/tuB2FrQmLhiA67l.png" alt></p><p><img src="https://i.loli.net/2019/12/18/KAw24CabtM1XPVz.png" alt></p></li></ul><ul><li><p>Prefix</p><p>$+xy$</p><p>$mov;ax,;bx$</p><p>$OpCode;Operand1,;Operand2$</p><p><strong>四元组形式（Quadruple）</strong>：$(OpCode,;Operand1,;Operand2,;Result)$</p></li><li><p>Postfix</p></li></ul><p>Syntax-directed Translation into TAC</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/as2648fyrowLzWk.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/cpZevCwI7ljA4aV.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>二维数组转成三地址码（TAC）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/H5zYb4nBL6kXFA8.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>复杂的条件表达式转简单的条件表达式</p><p>—— 短路码（Short-circuit Code）</p><p>$(a&lt;&gt;b)&amp;&amp;(c&lt;&gt;d)$</p><p>=&gt;</p><p>$if(a&lt;&gt;b);goto;L_1$</p><p>$goto;L_2$</p><p>$L_1:if(c&lt;&gt;d);goto;L_3$</p><p>$goto;L_2$</p><p>$L_3:……$</p><p>$L_2:……$</p><p>$(x&lt;&gt;y)||(e&lt;&gt;f)$</p><p>=&gt;</p><p>$if(x&lt;&gt;y);goto;L_1$</p><p>$goto;L_2$</p><p>$L_2:if(e&lt;&gt;f);goto;L_1$</p><p>$goto;L_3$</p><p>$L_1:;…$</p><p>$L_3:;…$</p><h3 id="Backpatching（标号回填技术）"><a href="#Backpatching（标号回填技术）" class="headerlink" title="Backpatching（标号回填技术）"></a>Backpatching（标号回填技术）</h3><p>（有利于使用计算机来完成）</p><ul><li><p>引入记忆机制（Memory Mechanism）：记忆要回填的指令（remember the instructions backpatched）</p><p>对于未知的标号，使用0来占位（因为0不是任何一个指令的编号，编号从1开始）</p><p>$(5)goto;0$</p></li><li><p>使用指令的编号代替标号（replace label with Instruction No.）</p><p>assign  a number to each instruction</p></li><li><p>对每个简单情形的条件表达式，Merge the list with same destination</p></li><li><p>Backpatch by the related semantic rules</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/jIvVDCTa5c9XzMe.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/BqzTH4exK5yEPUX.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/MhaGWmOLwZ4uDgd.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>对于$a[i,j]=a[i,j]+1$，前后两个$a[i,j]$是互相独立的，不能后面的使用前面的相关中间量t</p><p>即：赋值号左右两边有相同的数组元素，那么两个都需要重新做翻译</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/RPboFL7DamvAJ8M.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/SLMR8W5brjYgDcX.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如何优化？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Method 4 电路状态转换图&lt;/p&gt;
&lt;p&gt;奇偶问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;电路状态转换法解题步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造电路状态转换图&lt;br&gt;首先确定状态，如果有n个元素，则存在2^n个状态。&lt;br&gt;然后链接状态。&lt;br&gt;示例：三个元素下的
      
    
    </summary>
    
      <category term="编译原理" scheme="http://QQ876684433.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="编译原理" scheme="http://QQ876684433.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象之继承</title>
    <link href="http://QQ876684433.github.io/2019/11/26/CPP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF/"/>
    <id>http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/</id>
    <published>2019-11-26T11:06:55.000Z</published>
    <updated>2019-11-29T02:02:20.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-面向对象之继承"><a href="#C-面向对象之继承" class="headerlink" title="C++面向对象之继承"></a>C++面向对象之继承</h1><blockquote><p>参考书籍：《Primer C++, 5th》</p></blockquote><h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><p>下面可能会用到的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUOTE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUOTE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Quote() = <span class="keyword">default</span>;</span><br><span class="line">    Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price) : bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><p>继承关系中，<strong>根节点的类通常会定义一个虚析构函数</strong>，即使该函数不执行任何实际操作也是如此</p><h4 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h4><p>基类中通常有两种成员函数：</p><ul><li><p>虚函数：基类希望其派生类进行覆盖的函数</p><ul><li><p>当使用<strong>指针或者引用</strong>调用虚函数时，该调用将被动态绑定；根据引用或指针所绑定的对象类型的不同，该调用可能执行基类的版本，也可能执行某个派生类的版本</p></li><li><p><strong>任何构造函数之外的非静态函数都可以是虚函数</strong></p></li><li><p>并且virtual只能出现在类内部的声明语句之前，而不能用在类外部的函数定义</p></li><li><p>如果基类把一个函数声明为虚函数，则该函数<strong>在派生类中隐式地也是虚函数</strong>（即使没有virtual关键字）</p></li></ul></li><li><p>普通函数：基类希望派生类直接继承而不要改变的函数</p><p>非虚成员函数的<strong>解析过程发生在编译时而非运行时</strong></p></li></ul><h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权限访问从基类继承而来的成员</p><p>（private、protected、public，过于简单，就不再赘述）</p><h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须通过使用类派生列表明确指出它从哪些基类继承而来，每个基类前面可以使用三种访问说明符中的一个：public、protected、private</p><p><strong>三种继承方式不影响子类对父类的访问权限，子类对父类只看父类的访问控制权；</strong>三种继承方式都能访问父类中的public和protected成员</p><p>简单来说：访问说明符的作用是控制派生类从基类继承而来的成员是否对<strong>派生类的用户</strong>可见</p><p>如果一个派生是共有的，则<strong>基类的共有成员也是派生类接口的组成部分</strong>，我们能将共有派生类型的对象绑定到基类的引用或指针上</p><h4 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h4><p>派生类经常（但不总是）覆盖它继承的虚函数；如果没有覆盖，则该虚函数的行为类似于其他普通成员，派生类<strong>会直接继承其在基类中的版本</strong></p><h4 id="派生类对象及派生类向基类的类型转换"><a href="#派生类对象及派生类向基类的类型转换" class="headerlink" title="派生类对象及派生类向基类的类型转换"></a>派生类对象及派生类向基类的类型转换</h4><p>派生类对象包含多个组成部分：</p><ul><li>派生类自己定义的（非静态）成员的子对象</li><li>与派生类继承的基类对应的子对象（如果基类有多个，那这样的子对象也有多个）</li></ul><p>正因为如此，我们能够</p><ul><li>把派生类的对象当成基类对象来使用</li><li>能将基类的指针或引用绑定到派生类对象的基类部分上</li><li>可以把派生类对象指针用在需要基类指针的地方</li><li>可以把派生类对象或者派生类对象的引用用到需要基类引用的地方</li></ul><p>继承的关键所在：派生类对象中含有与基类对应的组成部分</p><h4 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h4><p><strong>每个类控制它自己的成员的初始化过程</strong>：意味着派生类不能直接初始化继承的基类成员，需要通过基类的构造函数初始化它的基类部分</p><p>我们可以通过构造函数初始化列表将实参传递给基类构造函数，同时用这个方法指定我们要调用的基类的构造函数版本，否则派生类对象的基类对象会像数据成员一样执行默认初始化</p><p>首先初始化基类的部分，然后<strong>按照声明的顺序</strong>依次初始化派生类的成员</p><h4 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h4><p>派生类可以访问基类的共有成员和受保护成员；派生类对象的作用域嵌套在基类的作用域之内，因此派生类的一个成员使用派生类其他成员的方式与使用基类成员的方式没有什么不同（除了基类private成员）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/Xczqr6LGanyIQVN.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h4><p>如果基类定义了一个静态成员，那么整个继承体系中该静态成员只存在唯一的实例；静态成员遵循通用的访问控制规则， 如果某静态成员是可访问的，那么我们既能通过基类（及其对象）、也能通过派生类（及其对象）使用它</p><h4 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h4><p>派生类的声明<strong>包含类名但是不包含它的派生列表</strong>；派生类列表与定义的其他细节必须与类的主体一起出现</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/tUPW17aKvqQzmsh.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>一条声明语句的目的是<strong>令程序知晓某个名字的存在</strong>以及<strong>该名字表示一个什么样的实体</strong>（如一个类、函数或者变量）</p><h4 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h4><p>一个类必须已经定义而非仅仅声明才能被用作基类：</p><ul><li>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必然要知道基类中定义了哪些成员</li><li>言外之意：一个类不能派生它本身</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/hvtalZF6kLwuqX2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>每个类都会继承直接基类的所有成员；在整个继承体系中，<strong>最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象</strong></p><h4 id="防止继承发生"><a href="#防止继承发生" class="headerlink" title="防止继承发生"></a>防止继承发生</h4><p>C++11新标准：在<strong>类名后跟一个final</strong>，可以防止该类被继承</p><h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><h4 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h4><ul><li>静态类型：编译时就确定的，它是变量声明时的类型或表达式生成的类型</li><li>动态类型：变量或表达式表示的内存中的对象的类型</li></ul><p><u>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致</u></p><h4 id="不存在从基类向派生类的隐式类型转换"><a href="#不存在从基类向派生类的隐式类型转换" class="headerlink" title="不存在从基类向派生类的隐式类型转换"></a>不存在从基类向派生类的隐式类型转换</h4><p>有一种特别的情况：<u>即使一个基类指针或者引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换</u></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/e9NKbaIrXP6SoRm.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或者引用的静态类型来腿短该转换是否合法</p><ul><li><p>如果基类中含有一个或多个虚函数，我们可以使用dynamic_case请求一个类型转换，该<strong>转换的安全检查将在运行时执行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">Bulk_quote *bulkP = <span class="keyword">dynamic_cast</span>&lt;Bulk_quote *&gt;(itemP);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bulkP-&gt;isbn() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果我们已知某个基类向派生类的转换是安全的，则我们可以使用static_cast来<strong>强制覆盖掉编译器的检查工作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">Bulk_quote *bulkP = <span class="keyword">static_cast</span>&lt;Bulk_quote *&gt;(itemP);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bulkP-&gt;isbn() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="在对象之间不存在类型转换"><a href="#在对象之间不存在类型转换" class="headerlink" title="在对象之间不存在类型转换"></a>在对象之间不存在类型转换</h4><p>派生类向基类的自动类型转换只针对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换：</p><ul><li>初始化或赋值一个类类型对象时，实际上是在调用某个函数<ul><li>执行初始化时，调用的是构造函数</li><li>执行赋值操作时，调用的是赋值运算符</li></ul></li><li>这些成员函数通常都包含一个参数，该参数的类型是类类型的const版本的引用</li></ul><p>这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象，因为<strong>这些操作不是虚函数</strong>，因此：</p><ul><li>当我们给基类的构造函数传递一个派生类对象时，实际运行的<strong>构造函数是基类中定义的那个</strong>，显然该构造函数<strong>只能处理基类自己的成员</strong></li><li>当我们将一个派生类对象赋值给一个基类对象，则实际运行的<strong>赋值运算符也是基类中定义的那个</strong>，该运算符同样<strong>只能处理基类自己的成员</strong></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/MvnOP58KS6wRXji.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="引入知识点：对象切片"><a href="#引入知识点：对象切片" class="headerlink" title="引入知识点：对象切片"></a>引入知识点：对象切片</h5><blockquote><p>原文链接：<a href="https://blog.csdn.net/beckle_ye/article/details/4700612" target="_blank" rel="noopener">https://blog.csdn.net/beckle_ye/article/details/4700612</a></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/rJ1tRg8UufwXIzn.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>If you upcast to an object instead of a pointer or reference, something will happen that may surprise you: the object is “sliced” until all that remains is the subobject that corresponds to the destination type of your cast.<br>—— Thinking In C++</p></blockquote><p>这句话的意思也就是说：在函数传参处理多态性时，如果一个派生类对象在UpCasting时，<strong>用的是传值的方式</strong>，而不是指针和引用，那么，这个派生类对象在UpCasting以后，将会被slice（切分）成基类对象，也就是说，派生类中独有的成员变量和方法都被slice掉了，只剩下和基类相同的成员变量和属性。这个派生类对象被切成了一个基类对象<br>如下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> pname;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pet(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name) : pname(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pname; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">description</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is "</span> + pname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Pet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> favoriteActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;activity)</span><br><span class="line">        : Pet(name), favoriteActivity(activity) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">description</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Pet::name() + <span class="string">" likes to "</span> +</span><br><span class="line">               favoriteActivity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe</span><span class="params">(Pet p)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// Slices the object</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.description() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Pet <span class="title">p</span><span class="params">(<span class="string">"Alfred"</span>)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">d</span><span class="params">(<span class="string">"Fluffy"</span>, <span class="string">"sleep"</span>)</span></span>;</span><br><span class="line">    describe(p); <span class="comment">//正常调用基类函数</span></span><br><span class="line">    describe(d); <span class="comment">//对象切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is Alfred</span><br><span class="line">This is Fluffy</span><br></pre></td></tr></table></figure><p>发生对象切片前后的情况是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/lkCJV72QrxT9ApB.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>发生Object Slicing后，原先的虚函数Dog vptr表变成了Pet vptr，Dog的成员favoriteActivity也不存在了，其实这时候执行了一些步骤：</p><ul><li>在正常情况下，main函数中执行describe函数，在传递Dog对象d的时候，调用了Pet类的拷贝构造函数，相当于此时，在describe函数中的那个Pet类对象p是拷贝构造的结果，所以，跟Dog对象d已经没有了关系。所以，此时，p.description()执行的会是调用的基类也就是Pet类的description函数</li></ul><p>但是如果将description函数声明为纯虚函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> pname;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pet(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name) : pname(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pname; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">description</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>；</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Pet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> favoriteActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;activity)</span><br><span class="line">        : Pet(name), favoriteActivity(activity) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">description</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Pet::name() + <span class="string">" likes to "</span> +</span><br><span class="line">               favoriteActivity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe</span><span class="params">(Pet p)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// Slices the object</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.description() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Pet <span class="title">p</span><span class="params">(<span class="string">"Alfred"</span>)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">d</span><span class="params">(<span class="string">"Fluffy"</span>, <span class="string">"sleep"</span>)</span></span>;</span><br><span class="line">    describe(p); <span class="comment">//正常调用基类函数</span></span><br><span class="line">    describe(d); <span class="comment">//对象切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这时候Pet类型就不能被实例化，所以在全局的describe函数中不可能有者拷贝构造函数来实例化一个Pet类对象，此时编译器就会报错</p><p>这里就体现出了纯虚函数的一个重要意义：可以在编译期间<strong>避免对象切片</strong>，从而避免很多可能会出现的问题</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>使用基类的<strong>引用或指针调用</strong>一个虚成员函数时会执行动态绑定；如果我们通过一个<strong>具有普通类型的表达式</strong>调用虚函数时，在<strong>编译时</strong>就会将调用的版本确定下来</p><p>通常如果我们不使用某个函数，则无须为该函数提供定义；但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，否则会编译出错</p><h3 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h3><p>基类中的虚函数在派生类中隐含地也是一个虚函数</p><ul><li><p>当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配；</p></li><li><p>派生类中虚函数的返回类型也必须与基类函数匹配</p><ul><li><p>例外情况是，当类的虚函数返回类型是类本身的指针或引用时，该条规则失效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A&amp; <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="function">B&amp; <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即这样也是有效的</p></li></ul></li></ul><h3 id="final和override说明符"><a href="#final和override说明符" class="headerlink" title="final和override说明符"></a>final和override说明符</h3><ul><li><p>我们可以使用override显式指定派生类中的某个函数是覆盖基类对应的虚函数，如果override标记的派生类的函数是<strong>在基类中不存在</strong>，那么编译器将报错</p></li><li><p>如果我们把某个函数指定为final，则之后派生类中任何尝试覆盖该函数的操作将引发错误</p></li></ul><p>注意：final和override都<strong>只能用在虚函数上，</strong>而且也只能出现在形参列表（包括从const或引用修饰符）以及尾置返回类型之后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A &amp;<span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">B &amp;<span class="title">func</span><span class="params">()</span> override </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> final</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译器报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test01.cpp:<span class="number">18</span>:<span class="number">10</span>: error: ‘<span class="keyword">void</span> B::func2()’ marked ‘override’, but does <span class="keyword">not</span> override</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> override</span>;</span><br><span class="line">          ^~~~~</span><br><span class="line">Test01.cpp:<span class="number">19</span>:<span class="number">10</span>: error: ‘<span class="keyword">void</span> B::func3()’ marked ‘final’, but is <span class="keyword">not</span> <span class="keyword">virtual</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> final</span>;</span><br><span class="line">          ^~~~~</span><br></pre></td></tr></table></figure><h3 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h3><p>虚函数可以拥有默认实参，如果某次函数调用使用了默认实参，则该<strong>实参值由本次调用的静态类型决定</strong></p><p>如果通过基类的引用或者指针调用函数，则<strong>使用基类中定义的默认实参</strong>，即使实际运行的是派生类中的函数版本也是如此，因此传入派生类函数的将是基类函数定义的默认实参；如果派生类函数依赖不同的是实参，则程序结果将与我们的预期不同</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/GjEd7WuLAslzhyk.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h3><p>可以使用作用域运算符来使得虚函数的调用不要进行动态绑定，而是强迫执行虚函数的某个特定版本，这种调用将在编译时完成解析</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/HZ3sVWNPURl8dwp.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>一个纯虚函数无须给出定义，通过在函数体的位置（即声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数（=0只能出现在类内部的虚函数声明语句处）</p><p>当然我们也可以给纯虚函数提供定义，不过<strong>函数体必须定义在类的外部</strong>，也就是说，我们不能在类的内部为一个=0的函数提供函数体</p><h3 id="含有纯虚函数的类是抽象基类"><a href="#含有纯虚函数的类是抽象基类" class="headerlink" title="含有纯虚函数的类是抽象基类"></a>含有纯虚函数的类是抽象基类</h3><p>含有纯虚函数的类是抽象基类，抽象基类负责定义接口，后续的其他类可以覆盖该接口</p><p>我们不能创建一个抽象基类的对象</p><h2 id="访问控制与继承-1"><a href="#访问控制与继承-1" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><h3 id="受保护成员"><a href="#受保护成员" class="headerlink" title="受保护成员"></a>受保护成员</h3><p>受保护成员对于<strong>类的用户</strong>来说是不可访问的，派生类的成员或友元只能<strong>通过派生类对象</strong>来访问基类的受保护成员，派生类对于一个<u><strong>基类对象</strong>的受保护成员</u>没有任何访问特权</p><p>例子如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/aZWzN4d25eVxcgt.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>派生类B的成员函数无法通过基类对象来访问受保护成员</strong>，也就是说此时B是基类A的用户，用户代码B无法访问A的受保护成员，它只能通过this指针来访问</p><p>至于友元函数，则是书上的例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/MrZi38CY4RzgAB6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="公有、私有和受保护继承"><a href="#公有、私有和受保护继承" class="headerlink" title="公有、私有和受保护继承"></a>公有、私有和受保护继承</h3><ul><li><p>派生访问说明符对于派生类的成员及友元能否访问其直接基类的成员没什么影响，对基类成员的访问权限只与基类中的访问说明符有关</p></li><li><p>派生访问说明符的目的是控制<strong>派生类用户</strong>（<strong>包括派生类的派生类在内</strong>）对于基类成员的访问权限</p><ul><li><p>这是私有继承的例子：</p><p><img src="https://i.loli.net/2019/11/28/im3hwSZuBGONYLq.png" alt></p></li><li><p>受保护继承的例子：</p><p><img src="https://i.loli.net/2019/11/28/sxpgqBD3GS8CtFW.png" alt></p></li></ul></li></ul><p>（<em>按照我个人的理解是这样的：私有派生将基类的成员继承过来之后，这部分基类的成员*</em>对外<strong>的访问说明符变成了私有private，即基类的成员不会成为</strong>派生类对外的接口*<em>，而对于派生类内部没有任何影响</em>）</p><h3 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h3><p>有三种情况：</p><ul><li><p>D<strong>公有地继承</strong>B，<strong>用户代码</strong>才能使用派生类向基类的转换；受保护或私有继承不行</p><p><img src="https://i.loli.net/2019/11/28/tR9NWrv3Lg7e1zZ.png" alt></p></li><li><p>不论D如果继承B，D的<strong>成员函数和友元</strong>都能使用派生类向基类的转换</p><p><img src="https://i.loli.net/2019/11/28/pEBSe6ZRH4cGvfW.png" alt></p></li><li><p>如果D<strong>公有地或受保护地</strong>继承B，则<strong>D的派生类</strong>的成员和友元可以使用D向B的类型转换；如果D私有继承B，则不能使用</p><p><img src="https://i.loli.net/2019/11/28/irgp9ow8BfPvX7u.png" alt></p></li></ul><p>书中给出了一个助记的方法：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/SvA6Kz81Oaq4UHd.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="关键概念：类的设计与受保护的成员"><a href="#关键概念：类的设计与受保护的成员" class="headerlink" title="关键概念：类的设计与受保护的成员"></a>关键概念：类的设计与受保护的成员</h4><p>（讲的太好了，没必要自己整理，故全文截图如下）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/1ep5UxZjVhXbETn.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/nls2PwDjX9YAKzg.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h3><p>友元关系<strong>既不能传递，也不能继承</strong></p><p>每个类负责控制自己的成员的访问权限，即使<strong>对于派生类的基类部分也是如此</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/IM8KaB95T4n27Fw.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可以看到例子中，可以通过派生类B在基类A的友元类Test中访问基类A的私有成员，而直接使用B访问x则会报错，这是因为<strong>派生类B的基类子对象部分的访问控制依然是由基类来控制的</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/ktsLipHr4XJuM9q.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h3><p>可以通过using声明来改变派生类<strong>继承的某个名字</strong>的访问级别</p><p>通过在类内部使用using声明语句，我们可以将该类的直接或间接基类中的任何<strong>可访问成员</strong>（例如，非私有成员）标记出来：</p><ul><li>using语句出现在类的private部分：该名字只能被<strong>类的成员和友元</strong>访问</li><li>using语句出现在类的public部分：<strong>类的所有用户</strong>都能访问它</li><li>using语句出现在类的protected部分：该名字对于<strong>成员、友元和类的派生类</strong>是可访问的</li></ul><h3 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h3><p>默认情况下：</p><ul><li>class关键字定义的派生类是私有继承的</li><li>struct关键字定义的派生类是公有继承的</li></ul><p><em>ps：struct和class的唯一差别就是<strong>默认访问说明符和默认派生说明符</strong>；除此之外，再无其他不同之处</em></p><h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>每个类定义自己的作用域，当存在继承关系时，派生类的作用域嵌套在基类的作用域之内</p><p>如果一个名字在派生类的作用域内无法正确解析，则编译器将<strong>继续在外层的基类作用域</strong>中寻找该名字的定义</p><h3 id="在编译时进行名字查找"><a href="#在编译时进行名字查找" class="headerlink" title="在编译时进行名字查找"></a>在编译时进行名字查找</h3><p>一个对象、引用或指针的<strong>静态类型</strong>决定了该对象的哪些成员是可见的；即使静态类型和动态类型不一致，但是我们<strong>能够使用哪些成员依然是由静态类型决定</strong>的</p><p>（按我的个人理解，对象、引用或者指针的静态类型决定了当前作用域，其派生类的作用域对与当前的对象、引用或者指针是不可见的，如果存在继承链A -&gt; B -&gt; C，通过B调用时，查找将从B开始，然后再到A，而C的作用域对B是不可见的）</p><h3 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h3><p>定义在内层作用域（即派生类）中的名字将隐藏外层作用域（即基类）的名字</p><h3 id="通过作用域运算符来使用隐藏的成员"><a href="#通过作用域运算符来使用隐藏的成员" class="headerlink" title="通过作用域运算符来使用隐藏的成员"></a>通过作用域运算符来使用隐藏的成员</h3><p>作用域运算符<code>::</code>能<strong>覆盖掉原有的查找规则</strong>，并指示编译器从基类的作用域中开始查找名字</p><p><strong>名字查找的过程</strong>（以p-&gt;mem()或p.mem()为例）：</p><ul><li>首先确定p的静态类型</li><li>在p的静态类型对应的类中查找名字mem<ul><li>如果找不到，则依次在直接基类中不断查找直至到达继承链顶端；如果仍然找不到，编译器将报错</li><li>一旦找到名字mem，就进行常规的类型检查，以确认对于当前找到的名字mem，本次调用是否合法<ul><li>如果调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码<ul><li>如果mem是虚函数，且我们通过引用或指针进行调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型（即运行时的实际类型）</li><li>反之（mem不是虚函数或者我们是通过对象本身（而非引用或指针）进行调用），编译器将产生一个常规函数调用，并且这个调用是在编译期间就已经确定的</li></ul></li><li>如果调用非法，则编译器报错，并且<strong>不会再向上继续往基类中查找</strong></li></ul></li></ul></li></ul><h3 id="名字查找先于类型检查"><a href="#名字查找先于类型检查" class="headerlink" title="名字查找先于类型检查"></a>名字查找先于类型检查</h3><ul><li>声明在内层作用域的函数并不会重载声明在外层作用域的函数</li><li>因此，定义派生类中的函数也不会重载其基类的成员</li></ul><p>如果派生类（内层作用域）的成员与基类（外层作用域）的某个成员<strong>同名</strong>，则派生类的成员将隐藏其作用域内该基类成员，<strong>即使派生类成员与基类成员的形参列表不一样</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/gZbcrlsvqL9QioM.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="虚函数与作用域-amp-amp-通过基类调用隐藏的虚函数"><a href="#虚函数与作用域-amp-amp-通过基类调用隐藏的虚函数" class="headerlink" title="虚函数与作用域&amp;&amp;通过基类调用隐藏的虚函数"></a>虚函数与作用域&amp;&amp;通过基类调用隐藏的虚函数</h3><p>如果派生类定义的函数名和基类的虚函数一样，但是形参列表不同，那么派生类的函数只是隐藏了基类中的同名虚函数，并没有覆盖，因此运行时发生动态绑定时，依然运行的是基类的虚函数版本</p><p>如下例的<code>bp2-&gt;fcn();</code>调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fcn()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D1::fcn(int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D1::f2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::fcn(int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::fcn()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::f2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base bobj;</span><br><span class="line">    D1 d1obj;</span><br><span class="line">    D2 d2obj;</span><br><span class="line">    Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;</span><br><span class="line">    bp1-&gt;fcn();</span><br><span class="line">    bp2-&gt;fcn();<span class="comment">// 注意看这个调用，这是个虚调用，但是执行的是Base::fcn版本</span></span><br><span class="line">    bp3-&gt;fcn();</span><br><span class="line">    D1 *d1p = &amp;d1obj;</span><br><span class="line">    D2 *d2p = &amp;d2obj;</span><br><span class="line">    <span class="comment">// bp2-&gt;f2();</span></span><br><span class="line">    d1p-&gt;f2();</span><br><span class="line">    d2p-&gt;f2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="覆盖重载的函数"><a href="#覆盖重载的函数" class="headerlink" title="覆盖重载的函数"></a>覆盖重载的函数</h3><p>成员函数无论是否是虚函数都能被重载</p><p>如果派生类希望所有的重载版本对于它来说都是可见的，那么它就<strong>需要覆盖所有的版本，或者一个也不覆盖</strong>（因为如果只覆盖其中一个或几个，那么剩余的基类版本将被隐藏起来，不可访问）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/CoLEN8mxFh1KW5n.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>解决方案是：</p><ul><li><strong>为重载的成员提供一条using声明语句</strong>，它只需要指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以<strong>把该函数的所有重载版本实例添加到派生类作用域中</strong></li></ul><p>这样我们就无需覆盖基类中的每一个重载版本了，派生类只需要定义其特有的函数就可以了，而不用为继承而来的其他函数重新定义</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/29/2ZzSd4GhLKgOMqB.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>基类函数的每个实例在派生类中必须都是可访问的，如果有任意一个同名实例是private，则using声明语句将出错（protected是允许的，因为基类protected实例在派生类中可访问）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/29/2et6QdkF8JnuZI4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个<strong>虚析构函数</strong>；如果指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除的对象的动态类型不符的情况，因此我们可以通过在基类中将析构函数定义为虚函数以确保执行正确的析构函数版本</p><p><strong>析构函数的析构属性能够被继承</strong>，无论派生类的析构函数是自己定义的还是编译器合成的</p><blockquote><p>C++三法则：如果需要析构函数，则一定需要拷贝构造函数和赋值操作符</p><p>如何理解这句话，首先，从“如果需要析构函数”这里我们知道，类中必然<strong>出现了指针类型的成员</strong>（<strong>否则不需要我们写析构函数，默认的析构函数就可以用了</strong>），所以，我们需要自己写析构函数来释放给指针所分配的内存来防止内存泄露，那么为什么说“一定需要拷贝构造函数和赋值操作符”呢，原因还是这样：类中出现了指针类型的成员。有指针类型的成员，我们必须防止浅拷贝问题，所以，一定需要拷贝构造函数和赋值操作符，这两个函数是防止浅拷贝问题所必须的</p><p>来源：<a href="https://blog.csdn.net/u010025211/article/details/48028571" target="_blank" rel="noopener">https://blog.csdn.net/u010025211/article/details/48028571</a></p></blockquote><p>但是对于基类来说，它总是需要一个析构函数，并且<strong>定义为虚函数，函数体为空</strong>，因此我们无法确定基类是否还需要赋值运算符或者拷贝构造函数</p><h4 id="虚析构函数将阻止合成移动操作"><a href="#虚析构函数将阻止合成移动操作" class="headerlink" title="虚析构函数将阻止合成移动操作"></a>虚析构函数将阻止合成移动操作</h4><p>基类需要一个虚析构函数导致：</p><ul><li>如果一个类定义了析构函数，即使是=default合成的版本，编译器也不会为这个类合成移动操作</li></ul><h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><h2 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h2><p>多重继承的派生类继承了<strong>所有父类的属性</strong></p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul><li>关键字class对应的默认访问说明符是private，关键字struct对应的是public</li><li>多重继承的派生列表只能包含已经被定义过的类，而且这些类不能是final的</li><li>派生列表中，同一个基类只能出现一次</li></ul><h4 id="多重继承的派生类从每个基类中继承状态"><a href="#多重继承的派生类从每个基类中继承状态" class="headerlink" title="多重继承的派生类从每个基类中继承状态"></a>多重继承的派生类从每个基类中继承状态</h4><p>多重继承关系中，派生类的对象包含有每个基类的子对象，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span>:</span> <span class="keyword">public</span> ZooAnimal &#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span>:</span> <span class="keyword">public</span> Bear, <span class="keyword">public</span> Endangered &#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/GgkZVWIScfHp3xd.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="派生类构造函数初始化所有基类"><a href="#派生类构造函数初始化所有基类" class="headerlink" title="派生类构造函数初始化所有基类"></a>派生类构造函数初始化所有基类</h4><p>构造一个派生类的对象将同时构造并初始化它的所有基类子对象，多重继承的派生类的构造函数初始值只能初始化<strong>它的直接基类</strong>（例如Panda的直接基类是Bear和Endangered）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/hyInO1iSfWBeQxG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>基类的构造顺序与<strong>派生列表中基类的出现顺序</strong>保持一致，而与派生类构造函数初始值列表中的基类顺序无关</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/WQIKwVPa67NtE2v.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/vNV8IH3zrX4Jjla.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="继承的构造函数与多重继承"><a href="#继承的构造函数与多重继承" class="headerlink" title="继承的构造函数与多重继承"></a>继承的构造函数与多重继承</h4><p>C++11中允许派生类继承多个基类的构造函数，但是如果从多个基类中继承了相同的构造函数（形参列表完全相同），那么程序将报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base1() = <span class="keyword">default</span>;</span><br><span class="line">    Base1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);</span><br><span class="line">    Base1(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base2() = <span class="keyword">default</span>;</span><br><span class="line">    Base2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);</span><br><span class="line">    Base2(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tempCodeRunnerFile.cpp:20:18: error: ‘D1::D1(const string&amp;)’ inherited from ‘Base2’</span><br><span class="line">     using Base2::Base2;</span><br><span class="line">                  ^~~~~</span><br><span class="line">tempCodeRunnerFile.cpp:19:18: error: conflicts with version inherited from ‘Base1’</span><br><span class="line">     using Base1::Base1;</span><br></pre></td></tr></table></figure><p>此时必须在派生类中<strong>定义这个冲突构造函数的派生类自己的版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">    D1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)&#123;&#125;</span><br><span class="line">    D1() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：前面版本的D1之所以只对<code>D1::D1(const string&amp;)</code>报错，是因为D1中没有定义自己版本的构造函数，编译器为D1合成了默认的构造函数，<strong>覆盖了从Base1和Base2继承过来的冲突的默认版本的构造函数</strong>；但是现在这个版本定义了自己的<code>D1(const std::string &amp;){}</code>来解决冲突，导致编译器不会为D1合成默认构造函数，因此也需要为D1显式定义默认构造函数</p><h4 id="析构函数与多重继承"><a href="#析构函数与多重继承" class="headerlink" title="析构函数与多重继承"></a>析构函数与多重继承</h4><p>析构函数的调用顺序与构造函数相反：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure><h4 id="多重继承的派生类的拷贝与移动操作"><a href="#多重继承的派生类的拷贝与移动操作" class="headerlink" title="多重继承的派生类的拷贝与移动操作"></a>多重继承的派生类的拷贝与移动操作</h4><ul><li>多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或者赋值操作</li><li><strong>只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作</strong></li></ul><p>例如Panda调用合成版本的拷贝构造函数，首先调用Bear的拷贝构造函数拷贝Bear子对象部分，而Bear又会在执行之前调用呢ZooAnimal的拷贝构造函数拷贝ZooAnimal子对象部分，Bear子对象部分拷贝完成后，又会调用Endangered拷贝构造函数拷贝Endangered子对象部分，最后才调用Panda的合成构造函数拷贝Panda部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/gJ7axq3sVvUAQhj.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="类型转换与多个基类"><a href="#类型转换与多个基类" class="headerlink" title="类型转换与多个基类"></a>类型转换与多个基类</h3><p>派生类有多个基类时，如果存在多个以基类为参数的重载函数，那么编译器会报错，因为<strong>编译器不会在派生类向基类的几种转换中进行比较和选择</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Panda.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Bear.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Endangered.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ZooAnimal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Endangered &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Panda p;</span><br><span class="line">    func(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译报错，程序有二义性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Test01.cpp: In function ‘int main(int, const char**)’:</span><br><span class="line">Test01.cpp:<span class="number">15</span>:<span class="number">11</span>: error: call of overloaded ‘func(Panda&amp;)’ is ambiguous</span><br><span class="line">     func(p);</span><br><span class="line">           ^</span><br><span class="line">Test01.cpp:<span class="number">6</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br><span class="line">Test01.cpp:<span class="number">8</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Endangered &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br><span class="line">Test01.cpp:<span class="number">10</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br></pre></td></tr></table></figure><p>注意：这个只限于直接基类为参数的重载，比如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Panda.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Bear.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Endangered.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ZooAnimal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span> &lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void func(Endangered &amp;) &#123; cout &lt;&lt; "func(Endangered &amp;) &lt;&lt; endl;"; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Panda p;</span><br><span class="line">    func(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承关系是ZooAnimal -&gt; Bear -&gt; Panda，输出结果是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">func(Bear &amp;)</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure><p>即会调用继承链上最近的那个重载版本</p><h4 id="基于指针类型或引用类型的查找"><a href="#基于指针类型或引用类型的查找" class="headerlink" title="基于指针类型或引用类型的查找"></a>基于指针类型或引用类型的查找</h4><p>通过基类指针来引用派生类对象时，如果析构函数是非虚函数，那么delete时无法调用派生类对象的析构函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooAnimal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal(<span class="comment">/* args */</span>);</span><br><span class="line">    ~ZooAnimal();</span><br><span class="line">&#125;;</span><br><span class="line">... ...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Panda p;</span></span><br><span class="line">    ZooAnimal *z_ptr = <span class="keyword">new</span> Panda();</span><br><span class="line">    <span class="comment">// func(p);</span></span><br><span class="line">    <span class="keyword">delete</span> z_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~ZooAnimal()</span><br><span class="line">    </span><br><span class="line">====================================================================</span><br><span class="line">====================================================================</span><br><span class="line">    </span><br><span class="line">class ZooAnimal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal(<span class="comment">/* args */</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~ZooAnimal();</span><br><span class="line">&#125;;</span><br><span class="line">... ...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Panda p;</span></span><br><span class="line">    ZooAnimal *z_ptr = <span class="keyword">new</span> Panda();</span><br><span class="line">    <span class="comment">// func(p);</span></span><br><span class="line">    <span class="keyword">delete</span> z_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure><p>在基类和派生类的析构函数都是虚函数时，无论使用哪个基类的指针来引用派生类对象，调用析构函数时，<strong>都是按照调用派生类对象析构函数的顺序执行</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~MI() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~MI()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 *pb1 = <span class="keyword">new</span> MI;</span><br><span class="line">    Base2 *pb2 = <span class="keyword">new</span> MI;</span><br><span class="line">    D1 *pd1 = <span class="keyword">new</span> MI;</span><br><span class="line">    D2 *pd2 = <span class="keyword">new</span> MI;</span><br><span class="line">    <span class="keyword">delete</span> pb2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pd2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line"></span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line"></span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br></pre></td></tr></table></figure><h3 id="多重继承下的类作用域"><a href="#多重继承下的类作用域" class="headerlink" title="多重继承下的类作用域"></a>多重继承下的类作用域</h3><p>单继承与多继承时的不同：</p><ul><li>单继承时，派生类的作用域嵌套在直接基类和间接基类的作用域中，查找过程<strong>沿着继承体系自底向上</strong>进行，直到找到所需的<strong>名字</strong>；派生类的名字将隐藏基类的<strong>同名成员</strong></li><li>多继承时，相同的查找过程将<strong>在所有直接基类中同时进行</strong>，如果<strong>名字</strong>在多个基类中都被找到，则对该名字的使用将具有二义性</li></ul><p>注意一点是，上面强调的是<strong>名字</strong>，即使派生类继承的两个函数形参列表不同也可能产生错误，因为它是<strong>按名字查找</strong>，<strong>先查找名字后进行类型检查</strong>，当编译器在两个作用域中同时发现了同名成员将直接报告一个调用二义性的错误</p><p>对一个派生类来说，从多个基类中分别继承同名的成员是完全合法的，只不过<strong>在使用这个名字时必须明确指出它的版本（这个如下面代码所示）</strong>；也就是说，派生仅是产生了潜在的二义性，只要没有调用就不会产生二义性（可以通过编译）；要想避免潜在的二义性，最好的办法是<strong>在派生类中为该函数定义一个新版本</strong>，或者<strong>通过using来显式使用确定的基类版本</strong>（例如using ZooAnimal::max_weight，或者using Endangered::max_weight）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~MI() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~MI()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="comment">// using D1::func1;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 *pb1 = <span class="keyword">new</span> MI;</span><br><span class="line">    Base2 *pb2 = <span class="keyword">new</span> MI;</span><br><span class="line">    D1 *pd1 = <span class="keyword">new</span> MI;</span><br><span class="line">    D2 *pd2 = <span class="keyword">new</span> MI;</span><br><span class="line">    <span class="keyword">delete</span> pb2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pd2;</span><br><span class="line">    MI mi;</span><br><span class="line">    mi.D1::func1();<span class="comment">// 显式指定使用的名字的版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虽然派生列表中同一个基类只能出现一次，但是派生类可以多次继承同一个类；派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类</p><p>默认情况下，派生类中含有继承链上每个类对应的字部分，如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/SRzq3O6imcCPptu.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看到，B1(base)和B2(base)中包含的A(base)是两个不同子部分（从x值不同可以看出，并且A的构造函数也调用了两次）</p><p>有时候要实现多次出现的同一个基类的共享，可以使用<strong>虚继承</strong>：虚继承的目的是令某个类作出声明，承诺愿意共享它的基类（共享的基类子对象称为<strong>虚基类</strong>），这样不论虚基类在继承体系中出现了多少次，<strong>在派生类中都只包含唯一一个共享的虚基类子对象</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/MRUSntrFqzxQeLJ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从上图可以看出此时A基类子对象只有一个，A只调用了一次构造函数</p><p>虚基类的缺点：必须在虚派生的真实需求出现之前就已经完成了虚派生的操作；在实际编程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题，它不会影响派生类本身，只会影响从制定了虚基类的派生类章进一步派生出来的类：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/gxDu6ZH7o28FTmY.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>例如Bear声明ZooAnimal为虚继承不会对Bear自身造成影响，但会对Panda造成影响</p><h4 id="使用虚基类"><a href="#使用虚基类" class="headerlink" title="使用虚基类"></a>使用虚基类</h4><p>指定虚基类的方式是在派生列表中添加关键字virtual，其中virtual和访问修饰符如public的顺序随意</p><p>virtual说明符表明了一种愿望：<strong>在后续的派生类中共享虚基类的同一份实例</strong></p><h4 id="虚基类成员的可见性"><a href="#虚基类成员的可见性" class="headerlink" title="虚基类成员的可见性"></a>虚基类成员的可见性</h4><ul><li>在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并且不会产生二义性</li><li>如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员</li><li>如果成员被多于一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本</li></ul><p>例如有如下继承关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>如果在D的对象中使用x，则有三种可能性：</p><ul><li><p>D1、D2都没有x的定义，此时x被解析为<strong>B的成员</strong>，此时不存在二义性</p></li><li><p>D1和D2只有其中一个有x的定义，此时依然没有二义性，派生类（D1或者D2）的x比共享虚基类B的x优先级更高（如下代码所示）</p><p><img src="https://i.loli.net/2019/11/27/gKDkOyYmW6idbsT.png" alt></p></li><li><p>D1、D2中均有x的定义，直接访问x将产生二义性</p></li></ul><p>解决这种二义性的最好方法是<strong>在派生类中为成员自定义新的实例</strong></p><h3 id="构造函数与虚继承"><a href="#构造函数与虚继承" class="headerlink" title="构造函数与虚继承"></a>构造函数与虚继承</h3><p>在虚派生中，虚基类是由最底层的派生类初始化的</p><h4 id="虚继承的对象的构造方式"><a href="#虚继承的对象的构造方式" class="headerlink" title="虚继承的对象的构造方式"></a>虚继承的对象的构造方式</h4><p>含有虚基类的对象的构造顺序与一般的顺序稍有区别：</p><ul><li>首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分</li><li>接下来按照直接基类在派生列表中出现的次序依次对其进行初始化</li></ul><p>也就是说：<strong>虚基类总是先于非虚基类构造，与他们在继承体系中的次序和位置无关</strong>；如下代码所示，B处于派生列表的第一个，但是虚基类A先于B进行初始化：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/HWQES617izRGBba.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>但是如果有多个虚基类的时候，虚基类的构造顺序则与派生列表的顺序有关，如下面代码所示，派生列表中B1是第一个直接基类，B1虚继承了A2，因此A2先于A1执行初始化：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/LkzYxlKp8vyaVme.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="构造函数与虚构函数的次序"><a href="#构造函数与虚构函数的次序" class="headerlink" title="构造函数与虚构函数的次序"></a>构造函数与虚构函数的次序</h4><p>一个类可以有多个虚基类，这些虚的子对象按照它们在派生列表中出现的顺序依次从左向右构造：<strong>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类；如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类</strong></p><p>对于如下的继承体系：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/MWCjRQivtZoUBY6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>它们的构造顺序如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/cj6vYmDgnwN8fAr.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>合成的拷贝和移动构造函数按照上面完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值；和往常一样，<strong>对象的销毁顺序与构造顺序正好相反</strong>：首先销毁TeddyBear，最后销毁ZooAnimal部分</p><p>最后来一个例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/uKTDBqH8k71PjLv.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>因为Class不是虚基类，因此<code>new Final</code>对象中含有多份Class的子对象部分，当使用Class类型指针绑定到<code>new Final</code>对象时，会造成Class基类的二义性，即控制台报错的：<code>ex18_29.cpp:15:21: error: ‘Class’ is an ambiguous base of ‘Final’</code></p><p>接下来我们修改一下，将其中一个Class申明为虚继承，另一个依然为普通继承：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/IXnykHGUbo2MhDq.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可以看到，Class还是存在二义性：<code>ex18_29.cpp:15:21: error: ‘Class’ is an ambiguous base of ‘Final’</code></p><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-面向对象之继承&quot;&gt;&lt;a href=&quot;#C-面向对象之继承&quot; class=&quot;headerlink&quot; title=&quot;C++面向对象之继承&quot;&gt;&lt;/a&gt;C++面向对象之继承&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考书籍：《Primer C++, 5th》&lt;/p&gt;

      
    
    </summary>
    
      <category term="C++" scheme="http://QQ876684433.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://QQ876684433.github.io/tags/C/"/>
    
      <category term="继承" scheme="http://QQ876684433.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="面向对象" scheme="http://QQ876684433.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-进程管理</title>
    <link href="http://QQ876684433.github.io/2019/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://QQ876684433.github.io/2019/11/17/操作系统-进程管理/</id>
    <published>2019-11-17T03:18:33.000Z</published>
    <updated>2019-11-17T14:35:03.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li></ul></blockquote><h2 id="进程定义和属性"><a href="#进程定义和属性" class="headerlink" title="进程定义和属性"></a>进程定义和属性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>从原理角度看：进程是支持程序执行的一种系统机制，它对处理器上运行程序的活动规律进行抽象</li><li>从实现角度看：进程是一种数据结构，用来准确地刻画运行程序的状态和系统动态变化状况</li></ul><p>操作系统有两个重要的特性：<strong>程序的并发性</strong>和<strong>资源的共享性</strong>。进程的概念既能描述程序的并发执行，又能共享系统的资源</p><ul><li><p>程序的并发性</p><p><img src="https://i.loli.net/2019/11/17/ZKvWsaEm7UnCDlS.png" alt></p><p><img src="https://i.loli.net/2019/11/17/Nf6P3UL12ESwJdV.png" alt></p><p>正因为“程序”自身这种静态的概念无法刻画程序的并发性，因此需要引入“进程”来描述系统内部程序的并发执行，提高资源利用率</p></li><li><p>资源的共享性</p><ul><li>“可再入”程序：能够被多个程序同时调用的程序</li><li>“可再用”程序：在备用过程中可以有自身修改，在调用它的程序退出之前不允许其他程序来调用</li></ul><p>“可再入”程序是纯代码，在执行过程中不被修改，调用它的各应用程序提供工作区，因此它可以被多个应用程序调用</p></li></ul><p>进程是既能描述程序的并发执行，又能共享系统资源的一个基本单位，当然操作系统也要为引入进程而付出<strong>（进程占用的）空间</strong>和<strong>（调度进程的）时间</strong>代价</p><p><strong>进程的定义</strong>：<u>进程是具有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位</u></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/QZayghxfTnXqtsw.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/4P2OSBkyueYQmaR.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/KsPmo4Qn3SlJLCG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="进程的状态和转换"><a href="#进程的状态和转换" class="headerlink" title="进程的状态和转换"></a>进程的状态和转换</h3><h4 id="三态模型"><a href="#三态模型" class="headerlink" title="三态模型"></a>三态模型</h4><p>进程是活动的且有状态变化，状态及其转换体现进程的动态性，进程在执行过程中有三种状态：</p><ul><li><p><strong>运行态（running）</strong></p><p>进程占有处理器正在运行的状态</p></li><li><p><strong>就绪态（ready）</strong></p><p>进程具备运行条件，等待系统分配处理器以便运行的状态</p></li><li><p><strong>等待态（wait）</strong></p><p>阻塞态（blocked）或睡眠态（sleep），指进程不具备运行条件，正在等待某个时间完成的状态</p></li></ul><p>处于运行态的进程个数不能大于处理器的个数，处于就绪态和等待态的进程可能有多个（非运行态进程的划分的主要依据是<strong>不能运行的原因</strong>）</p><p><strong>CPU只会从就绪态队列选择进程来执行，因此等待态队列的进程是被暂时性剥夺了获得CPU的机会</strong></p><h6 id="三态模型的状态转换"><a href="#三态模型的状态转换" class="headerlink" title="三态模型的状态转换"></a>三态模型的状态转换</h6><ul><li>进程在创建后处于就绪态</li><li>运行态进程因出现等待事件或者等待信号而进入等待态</li><li>当等待事件发生或者等待信号到达后，等待态进程变成就绪态</li><li>处理器的调度会引起运行态和就绪态进程之间的切换</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/8OiGTFmI4pnJVME.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="七态模型"><a href="#七态模型" class="headerlink" title="七态模型"></a>七态模型</h4><ul><li><p><strong>新建态（new）</strong></p><p>新建态对应于进程被创建时的状态，尚未进入就绪队列（有时候根据系统性能要求或内存容量限制推迟新建态被调度执行）</p><p>创建进程要通过两个步骤：</p><ul><li>先为新进程分配所需资源和建立必要的管理信息</li><li>然后设置该进程为就绪态，并等待被调度执行</li></ul></li><li><p><strong>终止态（exit）</strong></p><p>进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态，<strong>处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失</strong></p><p>进程终止要通过两个步骤：</p><ul><li>先等待操作系统或相关进程进行善后处理（如抽取信息）</li><li>然后回收占用的资源并被系统删除</li></ul></li></ul><p>进程挂起的原因：（1）由于不断创建进程，当系统资源尤其是内存资源已经不能满足进程运行要求时，必须把某些进程<strong>挂起（suspend）</strong>，对换到磁盘对换区中，释放它占有的某些资源，<strong>暂时不参与低级调度</strong>，起到平滑系统负荷的目的；（2）也可能系统出现故障，需要暂时挂起一些进程，以便故障消除后再解除挂起并恢复进程运行；（3）用户调试程序过程中，可以请求挂起进程，以便进行某种检查和修改</p><ul><li><p><strong>挂起就绪态（ready suspend）</strong></p><p>进程具备运行条件，但目前在外存中，只有当它被对换到内存中才能被调度执行</p></li><li><p><strong>挂起等待态（blocked suspend）</strong></p><p>进程正在等待某一事件发生且进程在外存中</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/rq1eoyvYDEAOR78.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>挂起进程等同于不在内存中的进程，因此挂起进程不参与低级调度直到它们被对换进内存</p><p>挂起进程的特征：</p><ul><li>该进程不能被立即执行</li><li>该进程可能会等待事件或者等待信号，但是所等待的事件或者信号是独立于挂起条件的，事件结束并不能导致进程具备执行条件</li><li>该进程进入挂起状态是由于<strong>操作系统、父进程或者进程自身</strong>阻止它的运行</li><li>结束进程挂起状态的命令只能通过<strong>操作系统或父进程</strong>发出</li></ul><h2 id="进程描述和组成"><a href="#进程描述和组成" class="headerlink" title="进程描述和组成"></a>进程描述和组成</h2><h3 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h3><blockquote><p>参考资料：<a href="http://www.tldp.org/LDP/LG/issue23/flower/psimage.html" target="_blank" rel="noopener">http://www.tldp.org/LDP/LG/issue23/flower/psimage.html</a></p></blockquote><p>程序和数据是进程必需的组成部分，用来刻画静态特征；还需要一种称为<strong>进程控制块的数据结构</strong>来刻画进程的动态特征，描述进程状态、占用资源状况、记录调度信息等。由于进程状态不断发生变化，<strong>某时刻进程的内容及其状态集合称为进程映像（process image）</strong>，包括如下要素：</p><ul><li><p>进程控制块</p><p>每个进程捆绑一个，用来存储进程的标志信息、现场信息和控制信息。进程创建时建立进程控制块，进程撤销时回收进程控制块，它与进程一一对应</p></li><li><p>进程程序块</p><p>被进程执行的程序，规定进程一次运行所应完成的功能；这部分是可以被不同的进程共享的</p></li><li><p>进程核心栈</p><p>每个进程捆绑一个，进程<strong>在内核态工作时</strong>使用，用来保存中断/异常现场，保存函数调用的参数、局部变量和返回地址等</p><p><img src="https://i.loli.net/2019/11/17/tylHdTwJ7FGCs8X.png" alt></p><blockquote><p><strong>内核栈:</strong></p><p>系统栈（也叫核心栈、内核栈）是内存中属于操作系统空间的一块区域，其主要用途为：</p><pre><code>(1)保存中断现场，对于嵌套中断，被中断程序的现场信息依次压入系统栈，中断返回时逆序弹出；(2)保存操作系统子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。</code></pre><p>用户栈是用户进程空间中的一块区域，用于保存用户进程的子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。</p><p>那么为什么不直接用一个栈，何必浪费那么多的空间呢？？原因有二：</p><p>​      （1）如果只用系统栈。系统栈一般大小有限，如果中断有16个优先级，那么系统栈一般大小为15（只需保存15个低优先级的中断，另一个高优先级中断处理 程序处于运行），但用户程序子程序调用次数可能很多，那样15次子程序调用以后的子程序调用的参数、返回值、返回点以及子程序(函数)的局部变量就不能被 保存，用户程序也就无法正常运行了</p><p>​     （2）如果只用用户栈。我们知道系统程序需要在某种保护下运行，而用户栈在用户空间（即cpu处于用户态，而cpu处于核心态时是受保护的），不能提供相应的保护措施（或相当困难）</p><p>来源：<a href="https://www.cnblogs.com/yysblog/archive/2012/11/05/2755226.html" target="_blank" rel="noopener">https://www.cnblogs.com/yysblog/archive/2012/11/05/2755226.html</a></p></blockquote></li><li><p>进程数据块</p><p>进程的私有地址空间，存放各种私有数据，用户栈也在数据块中开辟，用于在函数调用时存放栈帧、局部变量和返回地址等参数</p><blockquote><p>May be distinguished as initialised variables including external global and static variables, uninitialised variables (known as a bss area on Unix derivative systems). Data blocks are not shared between processes by default.</p><p>可区分为初始化变量（包括外部全局变量和静态变量）和非初始化变量(在Unix派生系统中称为bss区域)；默认情况下，进程之间不共享数据块</p></blockquote></li></ul><h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>进程在系统中存在及活动除了本身映像外，还需要环境支撑，如硬件寄存器、程序状态字寄存器、支持动态地址转换的页表和相关的核心数据结构。在操作系统中，进程物理实体和支持进程运行的环境合称<strong>进程上下文（process context）</strong>，进程在其当前上下文运行，<strong>当系统调度新进程占有处理器时，新老进程随之发生上下文切换</strong>。进程上下文由三部分组成：</p><ul><li><p>用户级上下文（user level context）</p><p>由程序块（可执行的机器指令序列）、数据块（进程可访问的信息）、共享内存区（进程通信使用的内存区）、用户栈（存放函数调用过程中的信息）组成，它们占用进程的虚存空间。对换至磁盘的分段或页面仍然是用户级上下文的组成部分</p></li><li><p>寄存器上下文（register context）</p><p>由处理器状态寄存器（进程当前状态）、指令计数器（下一条该执行的指令地址）、栈指针（指向用户栈或核心栈当前地址）、通用寄存器等组成。当进程不处于运行态时，处理器状态信息保存在寄存器上下文中</p></li><li><p>系统级上下文（system level context）</p><p>由进程控制块（进程的状态）、内存管理信息（进程页表或段表）、核心栈（进程内核态运行时的工作区）等操作系统管理进程所需要的信息组成</p></li></ul><p>Linux系统的进程上下文：</p><ul><li>用户级上下文：text、data、shared memory和user stack等</li><li>寄存器上下文：general register、program counter、EFLAGS、ESP等</li><li>系统级上下文：task_struct、mm_struct、vm_area_struct、pgd、pmd、pte和kernel stack等</li></ul><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>每个进程有且仅有一个进程控制块（Process Control Block，PCB），或称进程控制符（process descriptor），它是<strong>进程存在的唯一标识</strong>，是操作系统用来记录和刻画进程状态及环境信息的数据结构，是进程动态特征的汇集，也是操作系统掌握进程的唯一资料结构和管理进程的主要依据；进程控制块包括进程执行时的情况，以及进程让出处理器之后所处的状态、断点等信息，一般来说PCB包含以下三类信息：</p><ul><li><p>标识信息</p><p>标识信息用于唯一地标识一个进程，分为<strong>用户使用的外部标识符</strong>和<strong>系统使用的内部标识符</strong>。系统中所有进程都被赋予唯一的、内部使用的数值型进程号（0~32768的正整数），操作系统内核函数可通过进程号来引用PCB。常用的标识信息包括<strong>进程标识ID、进程组标识ID、用户进程名、用户组名</strong>等</p></li><li><p>现场信息</p><p>现场信息用于保留进程在运行时存放在处理器现场中的各种信息，包括<strong>通用寄存器内容、控制寄存器内容、栈指针、程序状态字</strong>等。进程在让出处理器时，必须将此时的现场信息保存到它的PCB中，而当此进程恢复运行时也应恢复处理器现场</p></li><li><p>控制信息</p><p>控制信息用于管理和调度进程，包括进程调度的相关信息、进程组成信息、进程间的族系信息、进程间通信信息、进程段/页表和进程映像在外存中的地址、CPU的占用和使用信息、进程特权信息、资源清单、文件传输和I/O信息</p><p><img src="https://i.loli.net/2019/11/17/BwXHlipEeq8VdtI.png" alt></p></li></ul><h3 id="进程队列及其管理"><a href="#进程队列及其管理" class="headerlink" title="进程队列及其管理"></a>进程队列及其管理</h3><p>进程的主要特征主要由PCB来刻画，为了便于对进程进行管理和调度，常常将进程的PCB通过某种方式组织起来，<strong>一般来说，把处于同一状态的所有进程的PCB链接在一起的数据结构称为进程队列（process queue）</strong>，简称队列。有两种队列组织方式，链接方式和索引方式：</p><ul><li><p>链接方式</p><p>对同一状态进程的PCB，通过PCB中的链接指针将其链接成队列</p><p><img src="https://i.loli.net/2019/11/17/ayw9N1PrnbBsWCY.png" alt></p><p><img src="/home/steve/.config/Typora/typora-user-images/1573992590492.png" alt="1573992590492"></p><p>不同状态的进程可以排成不同队列，如：</p><ul><li><p>运行队列</p><p>通常只有一个进程</p></li><li><p>就绪队列</p><p>可按照优先级或者FCFS的原则排队，也可按照进程优先级的高低分成多个就绪队列</p></li><li><p>等待队列</p><p>通常有多个，对应不同的等待状态，如等待I/O操作完成、等待信号量等</p></li></ul><p>此外，还可以将空闲PCB结构链接成自由队列以便使用</p><p>当发生某个事件使进程状态发生转换时，此进程就要退出所在队列而排入另一个队列中去。处理器调度中<strong>负责进程入队和出队工作的功能模块称为队列管理模块</strong>，其任务是<strong>对进程的PCB重新排队并修改其状态和响应链接结构</strong></p></li><li><p>索引方式</p><p>索引方式利用索引表记录不同状态进程的PCB地址或在PCB表中的编号，系统建立若干索引表，如<strong>就绪索引表、等待索引表、空闲索引表</strong>等。状态相同进程的PCB组织在同一张索引表中，每个索引表的表目中存放PCB地址或在PCB表中的编号，<strong>各索引表在内存中的起始地址放在内核专用指针单元中</strong></p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/sqfQYLmhcWi8bzj.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="进程上下文切换与处理器状态转换"><a href="#进程上下文切换与处理器状态转换" class="headerlink" title="进程上下文切换与处理器状态转换"></a>进程上下文切换与处理器状态转换</h2><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>中断和异常是激活操作系统的仅有方法，它暂停当前运行进程的执行，把处理器转换至内核态，内核获得处理器控制权之后，如果需要就可以实现进程上下文切换，所以<strong>进程切换必定在内核态而非用户态发生</strong>。</p><p>内核在处理中断事件或系统调用过程中可能会导致被阻塞的高优先级进程变为就绪态（等待事件发生或在等待信号到达），或在<strong>处理时钟中断事件期间</strong>发现运行进程的时间片耗尽，或当前运行进程执行阻塞型I/O指令等，均有可能引发内核实施进程上下文切换。</p><p>执行上下文切换时，保存老进程的上下文并装入新进程的上下文，以便新进程运行。</p><p>实现进程上下文切换的步骤：</p><ul><li>保存被中断进程的<strong>处理器现场信息</strong></li><li>修改被中断进程<strong>PCB的有关信息</strong>，如进程状态等</li><li>把被中断进程的PCB加入相关队列</li><li>选择占用处理器运行的另一进程</li><li>修改被选中进程<strong>PCB的有关信息</strong>，如改为就绪态</li><li>设置被选中进程的<strong>地址空间</strong>，恢复<strong>存储管理信息</strong></li><li>根据被选中进程的上下文信息恢复<strong>处理器现场</strong></li></ul><h3 id="进程上下文切换时机"><a href="#进程上下文切换时机" class="headerlink" title="进程上下文切换时机"></a>进程上下文切换时机</h3><p><strong>进程调度和切换</strong>是操作系统内核程序，内核处理过程中发现满足调度条件便可请求重新调度</p><p>原则上，发生请求重新调度事件、执行调度程序和实施进程上下文切换工作应该连续发生，但是实际上由于种种原因不能连续完成，内核中不能立即进行调度和切换的情况有：</p><ul><li><p>内核正在处理中断的过程中</p><p><img src="https://i.loli.net/2019/11/17/nzVjeEgH9GFsLc5.png" alt></p></li><li><p>进程运行在内核临界区中</p><p><img src="https://i.loli.net/2019/11/17/1gqJG4L2RBe6ONl.png" alt></p></li><li><p>内核处在需要屏蔽中断的原子操作中</p></li></ul><p>在上述情况中产生引起调度条件而不能马上进行调度和切换，系统采用<strong>置请求调度标志</strong>延迟到敏感性操作完成后才进行。Linux在进程task_struct设计<strong>重调度标志need_resched</strong>，当需要进程重调度时先置调度标志位，在调度时机来临时判别标志位是否为1，以决定要否进行调度。<strong>Linux调度时机</strong>分为：</p><ul><li><p>主动调度</p><p>调用schedule()函数来释放CPU引起新一轮调度，通常发生在当前进程状态被改变，如执行了read()、write()、exit()等系统调用，导致进程终止、进程阻塞等</p></li><li><p>被动调度</p><p>发生了引起调度的条件，通常发生在新进程产生、某个进程优先级改变、进程被唤醒、进程时间片用完等。这时仅置进程TIF_NEED_RESCHED调度标志。调度标志设置有如下情况：</p><ul><li>时钟中断中调用函数scheduler_tick()，它负责查看当前进程（实时进程除外）的时间片是否耗尽，如果是，则设置重调度标志</li><li>函数try_to_wake_up()将阻塞的进程唤醒，把它加入运行队列中，如果其优先级比当前正在运行的进程优先级高，则设置重调度标志。此外，设置应用程序优先级参数nice值、创建新进程、SMP负载均衡时都有可能使高优先级进程进入就绪状态，也都可能设置重调度标志</li><li>执行sched_setscheduler()（设置调度策略）、sched_yield()（暂时让出处理器）、pause()（暂停）等系统调用时，均要设置重调度标志</li></ul><p>每当<strong>中断处理和系统调用处理结束返回</strong>时，在ret_from_sys_call代码段中会主动测试调度标志，若置位则调用schedule()函数</p></li></ul><h3 id="处理器状态转换"><a href="#处理器状态转换" class="headerlink" title="处理器状态转换"></a>处理器状态转换</h3><p>与进程上下文切换有关的是<strong>处理器状态转换（又称处理器模式转换），从用户态到内核态或从内核态到用户态是处理器的状态转换</strong>，此时仍在同一个进程中运行</p><p>当发生中断或系统调用时暂停当前正在运行的进程，把处理器状态从用户态转换到内核态，执行操作系统服务例程，这是一次<strong>状态转换</strong>，此时进程仍在自己的上下文中执行，仅处理器状态发生变化，<strong>内核在被中断进程的上下文中进行处理</strong></p><p>处理器状态转换步骤：</p><ul><li>保存被中断进程的处理器现场信息</li><li>处理器从用户态转换到内核态，以便执行系统服务例程或中断处理程序</li><li>如果处理中断，可根据所规定的中断级别设置中断屏蔽位</li><li>根据系统调用号或中断号，从<strong>系统调用表</strong>或<strong>中断入口地址表</strong>中找到系统服务例程或中断处理程序的地址</li></ul><p>处理器状态转换不同于进程上下文切换，在大多数情况下，状态转换不一定引起上下文切换，在完成系统调用服务或中断处理之后，可通过逆向处理器状态转换来恢复被中断进程运行</p><p>处理器执行进程在任何时刻必处于以下4个活动范围内：</p><ul><li>用户空间中，处于进程上下文，应用进程在用户态下运行，使用用户栈</li><li>内核空间中，处于进程上下文，内核代表进程在内核下运行，使用核心栈</li><li>内核空间中，处于中断上下文，与任何进程无关，中断服务例程在内核态下处理特定中断</li><li>内核空间中，内核线程（无用户地址空间的进程）运行于内核态</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/4QDebchVMPXakgE.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/vKOf8LkMIpWFmaZ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="Linux中进程上下文切换与处理器状态转换"><a href="#Linux中进程上下文切换与处理器状态转换" class="headerlink" title="Linux中进程上下文切换与处理器状态转换"></a>Linux中进程上下文切换与处理器状态转换</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/1YOJRzWAfsHgc6k.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="进程控制和管理"><a href="#进程控制和管理" class="headerlink" title="进程控制和管理"></a>进程控制和管理</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程管理" scheme="http://QQ876684433.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>linux下制作ext4文件系统镜像</title>
    <link href="http://QQ876684433.github.io/2019/11/07/linux%E4%B8%8B%E5%88%B6%E4%BD%9Cext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/"/>
    <id>http://QQ876684433.github.io/2019/11/07/linux下制作ext4文件系统镜像/</id>
    <published>2019-11-07T15:47:51.000Z</published>
    <updated>2019-11-07T15:52:13.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux下制作ext4文件系统镜像"><a href="#linux下制作ext4文件系统镜像" class="headerlink" title="linux下制作ext4文件系统镜像"></a>linux下制作ext4文件系统镜像</h1><blockquote><p>由于网上的资料基本上都是一样的，大家抄来抄去，找不到最初的原作者，所以也没法在这里给出原文作者，但是声明一下，以下内容是转载自网络的</p></blockquote><p><strong>步骤如下</strong>：</p><ol><li><p>生成一个空的2MiB文件</p><p><code>dd if=/dev/zero of=rootfs.ext4 bs=1024 count=2048</code> (指定每一块大小为1024字节，一共又2048块，那么就是2048 * 1024 B = 2MiB)</p></li><li><p>对生成的文件进行格式化</p><p><code>mkfs.ext4 rootfs.ext4</code></p></li><li><p>挂载此空镜像</p><p><code>mount -o loop rootfs.ext4 /mnt</code></p></li><li><p>向挂载好的文件系统中写入需要加入的文件</p><p><code>cp everyfile /mnt</code></p></li><li><p>卸载根文件系统(意味着镜像已经制作完成)</p><p><code>umount /mnt</code></p></li><li><p>将镜像写入sd卡的某个分区中</p><p><code>dd if=rootfs.ext4 of=/dev/mmcblk0p3</code></p></li><li><p>此时挂载一下sd卡的某分区即可在发现刚才复制进去的文件</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux下制作ext4文件系统镜像&quot;&gt;&lt;a href=&quot;#linux下制作ext4文件系统镜像&quot; class=&quot;headerlink&quot; title=&quot;linux下制作ext4文件系统镜像&quot;&gt;&lt;/a&gt;linux下制作ext4文件系统镜像&lt;/h1&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="linux" scheme="http://QQ876684433.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://QQ876684433.github.io/tags/linux/"/>
    
      <category term="ext4" scheme="http://QQ876684433.github.io/tags/ext4/"/>
    
  </entry>
  
  <entry>
    <title>NASM学习记录</title>
    <link href="http://QQ876684433.github.io/2019/11/07/NASM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://QQ876684433.github.io/2019/11/07/NASM学习记录/</id>
    <published>2019-11-07T06:34:04.000Z</published>
    <updated>2019-11-23T08:56:55.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NASM学习记录"><a href="#NASM学习记录" class="headerlink" title="NASM学习记录"></a>NASM学习记录</h1><h2 id="零散知识点"><a href="#零散知识点" class="headerlink" title="零散知识点"></a>零散知识点</h2><h3 id="NASM汇编程序中的宏定义"><a href="#NASM汇编程序中的宏定义" class="headerlink" title="NASM汇编程序中的宏定义"></a>NASM汇编程序中的宏定义</h3><p>NASM汇编程序中的宏定义的格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%macro 宏名 参数名列表 </span><br><span class="line">宏体</span><br><span class="line">%endmacro</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%macro Descriptor 3</span><br><span class="line">dw %2 &amp; 0FFFFh </span><br><span class="line">dw %1 &amp; 0FFFFh </span><br><span class="line">db (%1 &gt;&gt; 16) &amp; 0FFh </span><br><span class="line">dw ((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh) </span><br><span class="line">db (%1 &gt;&gt; 24) &amp; 0FFh </span><br><span class="line">%endmacro ; 共 8 字节</span><br></pre></td></tr></table></figure><p>这个宏定义了操作系统中描述符的格式，宏名为：Descriptor 。使用时只需定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Descriptor 参数1, 参数2, 参数3</span><br></pre></td></tr></table></figure><p>即可。其中宏定义中的%1代表参数1，%2代表参数2，%3代表参数3</p><h3 id="EQU指令"><a href="#EQU指令" class="headerlink" title="EQU指令"></a>EQU指令</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/liukun321/article/details/5549023" target="_blank" rel="noopener">https://blog.csdn.net/liukun321/article/details/5549023</a></p></blockquote><p>有时，一个表达式在程序中会多次出现，重复书写可能较为繁杂，易出错。另一方面。如果要对该表达式进行变动，那么必须在程序中找到每一个表达式，一一做出修改，稍有不慎，就会遗漏，引出麻烦。利用EQU伪指令，就可以避免这些问题的发生。</p><p>$$<br>格式：&lt;符号名&gt; EQU &lt;表达式&gt;<br>$$<br>　　该伪指令的含义是为EQU后面的&lt;表达式&gt;起一个叫做&lt;符号名&gt;的名字。这样一来，程序中凡是需要用到该表达式的地方，就都可以用这个名字代替了。这里，&lt;表达式&gt;可以是任何有效的数据，可以是能够算出值的表达式，也可以是有效的助记符等。</p><p>　　例 <code>COUNT EQU 256</code></p><p>　　表示赋予数256一个名字，叫做COUNT。</p><p>　　<code>VAR1 EQU COUNT-2</code></p><p>　　表示赋予表达式COUNT-2一个名字，叫做VAR1。如果有<code>COUNT EQU 256</code>在先，那么由于COUNT是数值256，所以VAR1就代表数值254。</p><p>　　<code>PH EQU PUSH</code></p><p>　　表示赋予PUSH一个名字PH。由于PUSH是汇编语言的一个助记符，因此，在程序中书写<code>PH AX</code>，就相当于 <code>PUSH AX</code>。</p><h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令="></a>伪指令=</h4><p>　　与EQU伪指令类似的是等号伪指令“=”。它们的区别是：由EQU伪指令定义后的符号名是不能重复再定义的，而“=”伪指令中定义的符号名可重复定义。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EMP=7</span><br><span class="line"></span><br><span class="line">┋</span><br><span class="line"></span><br><span class="line">EMP=EMP+2</span><br></pre></td></tr></table></figure><p>　　这表示，开始把符号名EMP定义为是数值7，后来把符号名EMP重新定义为代表数值9。但是不能写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EMP EQU 7</span><br><span class="line"></span><br><span class="line">┋</span><br><span class="line"></span><br><span class="line">EMP EQU EMP+2</span><br></pre></td></tr></table></figure><h3 id="LGDT指令"><a href="#LGDT指令" class="headerlink" title="LGDT指令"></a>LGDT指令</h3><blockquote><p>原文：<a href="http://www.hgy413.com/hgydocs/IA32/instruct32_hh/vc155.htm" target="_blank" rel="noopener">http://www.hgy413.com/hgydocs/IA32/instruct32_hh/vc155.htm</a></p></blockquote><p>LGDT/LIDT - 用于加载全局/中断描述符表格寄存器</p><table><thead><tr><th>操作码</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>0F 01 /2</td><td>LGDT <strong>m16&amp;32</strong></td><td>将 <strong>m</strong> 加载到 GDTR</td></tr><tr><td>0F 01 /3</td><td>LIDT <strong>m16&amp;32</strong></td><td>将 <strong>m</strong> 加载到 IDTR</td></tr></tbody></table><ul><li><p>将源操作数中的值加载到全局描述符表格寄存器 (GDTR) 或中断描述符表格寄存器 (IDTR)。源操作数指定 6 字节内存位置，它包含全局描述符表格 (GDT) 或中断描述符表格 (IDT) 的基址（线性地址）与限制（表格大小，以字节计）。如果操作数大小属性是 32 位，则将 16 位限制（6 字节数据操作数的 2 个低位字节）与 32 位基址（数据操作数的 4 个高位字节）加载到寄存器。如果操作数大小属性是 16 位，则加载 16 位限制（2 个低位字节）与 24 位基址（第三、四、五字节）。这里，不使用操作数的高位字节，GDTR 或 IDTR 中基址的高位字节用零填充。</p></li><li><p>LGDT 与 LIDT 指令仅用在操作系统软件中；它们不用在应用程序中。在保护模式中，它们是仅有的能够直接加载线性地址（即，不是段相对地址）与限制的指令。它们通常在实地址模式中执行，以便处理器在切换到保护模式之前进行初始化。</p></li></ul><h3 id="CLD指令"><a href="#CLD指令" class="headerlink" title="CLD指令"></a>CLD指令</h3><blockquote><p>来源：<a href="https://c9x.me/x86/html/file_module_x86_id_29.html" target="_blank" rel="noopener">https://c9x.me/x86/html/file_module_x86_id_29.html</a></p></blockquote><p>CLD指令主要是用来清除EFLAGS寄存器中的DF标志位，即DF = 0，对其他标志位无影响</p><h4 id="DF标志-DF-flag"><a href="#DF标志-DF-flag" class="headerlink" title="DF标志(DF flag)"></a>DF标志(DF flag)</h4><p>这个方向标志(位于EFLAGS寄存器的第10位)控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），<strong>清除该标志则使得串指令自动递增</strong>。STD以及CLD指令分别用于设置以及清除DF标志。</p><blockquote><p>When the DF flag is set to 0, string operations increment the index registers (ESI and/or EDI).</p></blockquote><p>即DF = 0时，字符串操作会自动递增索引寄存器ESI和/或EDI</p><h3 id="LODS指令"><a href="#LODS指令" class="headerlink" title="LODS指令"></a>LODS指令</h3><blockquote><p>来源：<a href="https://baike.baidu.com/item/LODS" target="_blank" rel="noopener">https://baike.baidu.com/item/LODS</a></p></blockquote><p>汇编语言串装入指令（load string），规定源操作数为(DS:SI)，目的操作数隐含为AL（字节）或AX（字）寄存器。三种指令都用于<strong>将目的操作数的内容取到AL或AX寄存器</strong>，字节还是字操作由寻址方式确定，并根据寻址方式自动修改SI的内容</p><ul><li>LODS SRC 语法格式： LODS SI ；DST隐含为AL（字节）或AX（字）</li><li>LODSB ；字节操作，DST隐含为AL，SRC隐含为SI</li><li>LODSW ；字操作， DST隐含为AX，SRC隐含为SI</li></ul><p>注意：不影响标志位，一般不带重复前缀</p><p>执行的操作：</p><ul><li><p>（AL）←（DS:SI），（SI）←（SI）±1(字节)</p></li><li><p>（AX）←（DS:SI），（SI）←（SI）±2(字)</p></li></ul><h3 id="控制寄存器cr0"><a href="#控制寄存器cr0" class="headerlink" title="控制寄存器cr0"></a>控制寄存器cr0</h3><blockquote><p>来源：</p><ul><li><a href="https://en.wikipedia.org/wiki/Control_register" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Control_register</a></li><li><a href="https://baike.baidu.com/item/控制寄存器" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8</a></li></ul></blockquote><p>控制寄存器（CR0～CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性。<strong>CR0中含有控制处理器操作模式和状态的系统控制标志</strong>；CR1保留不用；CR2含有导致页错误的线性地址；CR3中含有页目录表物理内存基地址，因此该寄存器也被称为页目录基地址寄存器PDBR（Page-Directory Base address Register）</p><blockquote><p>CR0 has various control flags that modify the basic operation of the processor.</p></blockquote><table><thead><tr><th align="center">Bit</th><th align="center">Name</th><th align="center">Full Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">PE</td><td align="center">Protected Mode Enable</td><td align="center">If 1, system is in <a href="https://en.wikipedia.org/wiki/Protected_mode" target="_blank" rel="noopener">protected mode</a>, else system is in <a href="https://en.wikipedia.org/wiki/Real_mode" target="_blank" rel="noopener">real mode</a></td></tr><tr><td align="center">1</td><td align="center">MP</td><td align="center">Monitor co-processor</td><td align="center">Controls interaction of WAIT/FWAIT instructions with TS flag in CR0</td></tr><tr><td align="center">2</td><td align="center">EM</td><td align="center">Emulation</td><td align="center">If set, no x87 <a href="https://en.wikipedia.org/wiki/Floating-point_unit" target="_blank" rel="noopener">floating-point unit</a> present, if clear, x87 FPU present</td></tr><tr><td align="center">3</td><td align="center">TS</td><td align="center">Task switched</td><td align="center">Allows saving x87 task context upon a task switch only after x87 instruction used</td></tr><tr><td align="center">4</td><td align="center">ET</td><td align="center">Extension type</td><td align="center">On the 386, it allowed to specify whether the external math coprocessor was an <a href="https://en.wikipedia.org/wiki/80287" target="_blank" rel="noopener">80287</a> or <a href="https://en.wikipedia.org/wiki/80387" target="_blank" rel="noopener">80387</a></td></tr><tr><td align="center">5</td><td align="center">NE</td><td align="center">Numeric error</td><td align="center">Enable internal <a href="https://en.wikipedia.org/wiki/X87" target="_blank" rel="noopener">x87</a> floating point error reporting when set, else enables PC style x87 error detection</td></tr><tr><td align="center">16</td><td align="center">WP</td><td align="center">Write protect</td><td align="center">When set, the CPU can’t write to read-only pages when privilege level is 0</td></tr><tr><td align="center">18</td><td align="center">AM</td><td align="center">Alignment mask</td><td align="center">Alignment check enabled if AM set, AC flag (in <a href="https://en.wikipedia.org/wiki/FLAGS_register" target="_blank" rel="noopener">EFLAGS</a> register) set, and privilege level is 3</td></tr><tr><td align="center">29</td><td align="center">NW</td><td align="center">Not-write through</td><td align="center">Globally enables/disable <a href="https://en.wikipedia.org/wiki/Write_through_cache" target="_blank" rel="noopener">write-through caching</a></td></tr><tr><td align="center">30</td><td align="center">CD</td><td align="center"><a href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank" rel="noopener">Cache</a> disable</td><td align="center">Globally enables/disable the memory cache</td></tr><tr><td align="center">31</td><td align="center">PG</td><td align="center">Paging</td><td align="center">If 1, enable <a href="https://en.wikipedia.org/wiki/Paging" target="_blank" rel="noopener">paging</a> and use the <a href="https://en.wikipedia.org/wiki/Control_register#CR3" target="_blank" rel="noopener">§ CR3</a> register, else disable paging.</td></tr></tbody></table><p>要注意的是其中的两个标志位：</p><ul><li><p>PE</p><p>CR0的位0是启用保护（Protection Enable）标志。<strong>当设置该位时即开启了保护模式；当复位时即进入实地址模式</strong>。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位</p></li><li><p>PG</p><p>CR0的位31是分页（Paging）标志。<strong>当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于物理地址</strong>。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位</p></li></ul><h3 id="retf指令"><a href="#retf指令" class="headerlink" title="retf指令"></a>retf指令</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/ZCMUCZX/article/details/80216145" target="_blank" rel="noopener">https://blog.csdn.net/ZCMUCZX/article/details/80216145</a></p></blockquote><p><strong>关于ret指令和retf指令</strong></p><p>ret指令是用栈中的数据，修改IP的内容，从而实现了近转移(就是只修改IP)<br>retf指令是用栈中的数据，修改CS和IP的内容，从而实现了远转移(就是修改了CS和IP)<br>当CPU执行指令ret的时候，会进行下面的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、(IP)= ((ss *16)+(sp))</span><br><span class="line">2、(sp)=(sp)+2</span><br></pre></td></tr></table></figure><p>当CPU执行指令retf的时候相当于进行了下面的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、(IP)= ((ss *16)+(sp))</span><br><span class="line">2、(sp)=(sp)+2</span><br><span class="line">3、(CS)=((ss *16)+(sp))</span><br><span class="line">4、(sp)=(sp)+2</span><br></pre></td></tr></table></figure><p>其实就相当于CPU在执行ret指令的时候就是在执行下面的汇编语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></table></figure><p>CPU在执行retf指令的时候其实就是在执行下面的汇编语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure><h3 id="stosb-stosw-stosd指令"><a href="#stosb-stosw-stosd指令" class="headerlink" title="stosb, stosw, stosd指令"></a>stosb, stosw, stosd指令</h3><p>stosb, stosw, stosd这三个指令把al/ax/eax的内容存储到edi指向的内存单元中，同时edi的值根据方向标志的值增加或者减少</p><h3 id="LTR指令"><a href="#LTR指令" class="headerlink" title="LTR指令"></a>LTR指令</h3><p>LTR - 加载任务寄存器：</p><ul><li>将源操作数加载到任务寄存器的段选择器字段。源操作数（通用寄存器或内存位置）包含指向<strong>任务状态段 (TSS)</strong> 的段选择器。段选择器加载到任务寄存器之后，处理器使用段选择器在全局描述符表格 (GDT) 中确定 TSS 的段描述符的位置。接着，它将 TSS 的段限制与基址从段描述符加载到任务寄存器。任务寄存器指向的任务标记为忙，但不发生任务切换</li><li>提供的 LTR 指令用于操作系统软件；不应该在应用程序中使用它。它只能在 CPL 为 0 时在保护模式中执行。它常用在初始化代码，建立要执行的第一个任务</li><li>操作数大小属性不影响此指令。</li></ul><h3 id="DIV指令"><a href="#DIV指令" class="headerlink" title="DIV指令"></a>DIV指令</h3><p>指令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DIV reg8/mem8</span><br><span class="line">DIV reg16/mem16</span><br><span class="line">DIV reg32/mem32</span><br></pre></td></tr></table></figure><p>div指令只有一个操作数，即除数，被除数保存在AX（或者DX:AX，EDX:EAX）中，计算的结果商保存在AL（或者AX，EAX），余数保存在AH（或者DX，EDX），如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/22/gNSh8V4yFOPjXUx.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="MUL指令"><a href="#MUL指令" class="headerlink" title="MUL指令"></a>MUL指令</h3><p>MUL: 无符号乘</p><p>影响 OF、CF 标志位<br>指令格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL r/m  参数是乘数</span><br></pre></td></tr></table></figure><ul><li>如果参数是 r8/m8,   将把  AL 做乘数, 结果放在 AX</li><li>如果参数是 r16/m16, 将把 AX 做乘数, 结果放在 EAX</li><li>如果参数是 r32/m32, 将把 EAX 做乘数, 结果放在 EDX:EAX</li></ul><h3 id="cmp和test的区别"><a href="#cmp和test的区别" class="headerlink" title="cmp和test的区别"></a>cmp和test的区别</h3><p>test逻辑与运算结果为零,就把ZF(零标志)置1;<br>cmp 算术减法运算结果为零,就把ZF(零标志)置1.</p><h3 id="in和out端口指令"><a href="#in和out端口指令" class="headerlink" title="in和out端口指令"></a>in和out端口指令</h3><ul><li>in：从端口读取数据</li><li>out：把数据写入端口</li></ul><p>0-255时，8位端口用al，16位端口用ax</p><p>256-65535时，用dx</p><p>传输的时候需要先进入地址端口，再传输数据；比如70h为地址端口，71h为数据端口，读取2号单元的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,2h</span><br><span class="line">out 70h,al</span><br><span class="line">in al,71h</span><br></pre></td></tr></table></figure><h3 id="rep预处理指令"><a href="#rep预处理指令" class="headerlink" title="%rep预处理指令"></a>%rep预处理指令</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%rep 128</span><br><span class="line">GateSelectorCode32, SpuriousHandler, 0, DA_386IGate</span><br><span class="line">%endrep</span><br></pre></td></tr></table></figure><p>指令的作用是让<code>Gate    SelectorCode32, SpuriousHandler, 0, DA_386IGate</code>重复执行128次</p><h3 id="MOVZX指令"><a href="#MOVZX指令" class="headerlink" title="MOVZX指令"></a>MOVZX指令</h3><p>movzx一般用于将较小值拷贝到较大值中</p><h3 id="SGDT-SIDT指令"><a href="#SGDT-SIDT指令" class="headerlink" title="SGDT/SIDT指令"></a>SGDT/SIDT指令</h3><p><strong>将全局描述符表格寄存器 (GDTR) 或中断描述符表格寄存器 (IDTR) 中的内容存储到目标操作数</strong>。目标操作数是指定 6 字节内存位置。如果操作数大小属性为 32 位，则寄存器的 16 位限制字段存储到内存位置的 2 个低位字节，32 位基址存储到 4 个高位字节。如果操作数大小属性为 16 位，则限制字段存储在 2 个低位字节，24 位基址存储在第三、四及五字节，第六字节使用 0 填充。</p><p>SGDT 与 SIDT 指令仅在操作系统软件中有用；不过它们也可以在应用程序中使用，而不会导致生成异常。</p><h3 id="hlt指令"><a href="#hlt指令" class="headerlink" title="hlt指令"></a>hlt指令</h3><ul><li><p>使程序停止运行，处理器进入暂停状态，不执行任何操作，不影响标志。当RESET线上有复位信号、CPU响应非屏蔽中断、CPU响应可屏蔽中断3种情况之一时，CPU脱离暂停状态，执行HLT的下一条指令</p><p> 如果hlt指令之前，做了cli，那可屏蔽中断不能唤醒cpu</p></li><li><p>hlt是“只能在实方式和ring0执行的指令”，要区别于“IO敏感指令”。通过设置IOPI或IO许可位图，可以让ring1乃至ring3执行“IO敏感指令”，但“只能在实方式和ring0执行的指令”是规定死的</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NASM学习记录&quot;&gt;&lt;a href=&quot;#NASM学习记录&quot; class=&quot;headerlink&quot; title=&quot;NASM学习记录&quot;&gt;&lt;/a&gt;NASM学习记录&lt;/h1&gt;&lt;h2 id=&quot;零散知识点&quot;&gt;&lt;a href=&quot;#零散知识点&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="汇编" scheme="http://QQ876684433.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="http://QQ876684433.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="NASM" scheme="http://QQ876684433.github.io/tags/NASM/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-11-05）</title>
    <link href="http://QQ876684433.github.io/2019/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-11-05%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/11/05/数据库课堂笔记（2019-11-05）/</id>
    <published>2019-11-05T06:00:53.000Z</published>
    <updated>2019-11-05T06:00:53.384Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-10-29）</title>
    <link href="http://QQ876684433.github.io/2019/10/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-10-29%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/29/数据库课堂笔记（2019-10-29）/</id>
    <published>2019-10-29T05:58:08.000Z</published>
    <updated>2019-10-29T05:58:51.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-10-29）"><a href="#数据库课堂笔记（2019-10-29）" class="headerlink" title="数据库课堂笔记（2019-10-29）"></a>数据库课堂笔记（2019-10-29）</h2><h3 id="Ch06-Database-Design"><a href="#Ch06-Database-Design" class="headerlink" title="Ch06 Database Design"></a>Ch06 Database Design</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>使用Oracle嵌入式SQL预处理器Pro*C过程记录</title>
    <link href="http://QQ876684433.github.io/2019/10/24/%E4%BD%BF%E7%94%A8Oracle%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8Pro-C%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <id>http://QQ876684433.github.io/2019/10/24/使用Oracle嵌入式SQL预处理器Pro-C过程记录/</id>
    <published>2019-10-24T08:23:28.000Z</published>
    <updated>2019-10-24T09:13:48.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Oracle嵌入式SQL预处理器Pro-C过程记录"><a href="#使用Oracle嵌入式SQL预处理器Pro-C过程记录" class="headerlink" title="使用Oracle嵌入式SQL预处理器Pro*C过程记录"></a>使用Oracle嵌入式SQL预处理器Pro*C过程记录</h1><p>这玩意儿坑还挺多的，主要还是资料比较少，废话少说，先上参考链接：</p><blockquote><p>参考：</p><ul><li><a href="https://www.cnblogs.com/uriel/p/4275423.html" target="_blank" rel="noopener">https://www.cnblogs.com/uriel/p/4275423.html</a></li><li><a href="https://blog.csdn.net/Leafage_M/article/details/72082011" target="_blank" rel="noopener">https://blog.csdn.net/Leafage_M/article/details/72082011</a></li></ul></blockquote><p>说明：这篇文章主要是记录摸索过程中的关键步骤，以便后面使用的时候有章可循，具体关于Oracle的ESQL以及Pro*C的进阶使用，后面有时间会专门开一系列博客来记录</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在数据库课程学习上，专门有一章是用来讲Oracle嵌入式SQL（ESQL）的，主要是结合C语言来讲解。但是由于课上只是在书面上讲，而且这玩意之前没有听说过，总感觉如果不上手玩一玩的话就不能更加深入理解这玩意儿，所以就决定上手体验一下，从此开启了踩坑之路。</p><p>编程环境：</p><ul><li>Oracle数据库使用的是阿里云的Docker镜像（registry.cn-hangzhou.aliyuncs.com/qida/oracle-xe-11g）</li><li>开发环境是Deepin Linux 15.11</li></ul><h2 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h2><p> Oracle的嵌入式SQL的预编译工具是Pro*C，它的编译过程是这样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pro*C源文件(*.pc) -&gt; C源文件(*.c) -&gt; 目标文件(*.o) -&gt; 可执行文件</span><br></pre></td></tr></table></figure><p>所以首先要安装这个预编译工具，这里可以直接从oracle官网下载：</p><p><a href="https://www.oracle.com/database/technologies/instant-client/precompiler-112010-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/database/technologies/instant-client/precompiler-112010-downloads.html</a></p><p>官网没有提供deb安装包，但是有rpm安装包，只需要通过alien命令来安装即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo alien -i xxxx.rpm</span><br></pre></td></tr></table></figure><p>安装完成后，可以通过命令<code>proc -help</code>查看是否安装成功，proc就是Pro*C预编译器入口命令</p><h2 id="Pro-C头文件和库文件"><a href="#Pro-C头文件和库文件" class="headerlink" title="Pro*C头文件和库文件"></a>Pro*C头文件和库文件</h2><p>原先我想的是直接将Pro<em>C安装到我的主机上，然后将预处理和编译过程都放在本机上完成，然后运行时直接访问docker中的oracle数据库。理论上应该是可行的，但后来我发现一个问题就是，我本机没有安装oracle数据库，自然在开发Pro\</em>.C源程序的时候会找不到相关的<strong>Pro*C头文件和库文件</strong>，就是下面这些：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/FeRg96XzYZMuQmC.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>而从原博客中可以看出，这些头文件和库文件是随着oracle的安装就被安装进去的，这时我想到了，这些头文件和库文件应该是躺在Docker中的oracle容器中的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@989eb62277c6:/u01/app/oracle/product/11.2.0/xe/precomp# tree .</span><br><span class="line">.</span><br><span class="line">|-- admin</span><br><span class="line">|   `-- ottcfg.cfg</span><br><span class="line">`-- lib</span><br><span class="line">    `-- ottclasses.zip</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br><span class="line">root@989eb62277c6:/u01/app/oracle/product/11.2.0/xe/precomp#</span><br></pre></td></tr></table></figure><p>然而实际上是没有的orz，官网的原文是这样说的：</p><blockquote><p>The <code>ORACLE_BASE\ORACLE_HOME\precomp\public</code> directory contains the Pro*C/C++ header files</p><p><a href="https://docs.oracle.com/cd/B19306_01/win.102/b14321/use.htm" target="_blank" rel="noopener">https://docs.oracle.com/cd/B19306_01/win.102/b14321/use.htm</a></p></blockquote><p>估计被精简掉了。。。</p><p>场面一度很焦灼，先摸索一会儿，找到解决方案后再更新orz。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Oracle嵌入式SQL预处理器Pro-C过程记录&quot;&gt;&lt;a href=&quot;#使用Oracle嵌入式SQL预处理器Pro-C过程记录&quot; class=&quot;headerlink&quot; title=&quot;使用Oracle嵌入式SQL预处理器Pro*C过程记录&quot;&gt;&lt;/a&gt;使用Ora
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Pro*C" scheme="http://QQ876684433.github.io/tags/Pro-C/"/>
    
      <category term="Oracle" scheme="http://QQ876684433.github.io/tags/Oracle/"/>
    
      <category term="嵌入式SQL" scheme="http://QQ876684433.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/"/>
    
      <category term="Embedded SQL" scheme="http://QQ876684433.github.io/tags/Embedded-SQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-10-24）</title>
    <link href="http://QQ876684433.github.io/2019/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-10-24%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/24/数据库课堂笔记（2019-10-24）/</id>
    <published>2019-10-24T05:51:33.000Z</published>
    <updated>2019-10-24T05:53:08.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-10-24）"><a href="#数据库课堂笔记（2019-10-24）" class="headerlink" title="数据库课堂笔记（2019-10-24）"></a>数据库课堂笔记（2019-10-24）</h2><h3 id="Ch05-Programs-to-Access-a-Database"><a href="#Ch05-Programs-to-Access-a-Database" class="headerlink" title="Ch05 Programs to Access a Database"></a>Ch05 Programs to Access a Database</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>new/delete vs malloc/free</title>
    <link href="http://QQ876684433.github.io/2019/10/24/new_delete%20vs%20malloc_free/"/>
    <id>http://QQ876684433.github.io/2019/10/24/new_delete vs malloc_free/</id>
    <published>2019-10-24T04:08:04.000Z</published>
    <updated>2019-10-24T04:10:25.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new-delete-vs-malloc-free"><a href="#new-delete-vs-malloc-free" class="headerlink" title="new/delete vs malloc/free"></a>new/delete vs malloc/free</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;new-delete-vs-malloc-free&quot;&gt;&lt;a href=&quot;#new-delete-vs-malloc-free&quot; class=&quot;headerlink&quot; title=&quot;new/delete vs malloc/free&quot;&gt;&lt;/a&gt;new/delete 
      
    
    </summary>
    
      <category term="C++" scheme="http://QQ876684433.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://QQ876684433.github.io/tags/C/"/>
    
      <category term="new" scheme="http://QQ876684433.github.io/tags/new/"/>
    
      <category term="delete" scheme="http://QQ876684433.github.io/tags/delete/"/>
    
      <category term="malloc" scheme="http://QQ876684433.github.io/tags/malloc/"/>
    
      <category term="free" scheme="http://QQ876684433.github.io/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-存储管理</title>
    <link href="http://QQ876684433.github.io/2019/10/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://QQ876684433.github.io/2019/10/23/操作系统-存储管理/</id>
    <published>2019-10-23T13:23:37.000Z</published>
    <updated>2019-10-25T02:03:19.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li></ul></blockquote><p>内存空间一般分为两部分：</p><ul><li>系统区：存放操作系统内核程序和数据结构等</li><li>用户区：存放应用程序和数据</li></ul><p>有效的存储管理也是多道程序设计技术的关键支撑，存储管理包含以下功能：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/4QPXOMmnc6V8RBg.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="存储器工作原理"><a href="#存储器工作原理" class="headerlink" title="存储器工作原理"></a>存储器工作原理</h2><h3 id="存储器层次"><a href="#存储器层次" class="headerlink" title="存储器层次"></a>存储器层次</h3><p>目前计算机均采用层次结构的存储子系统，自上至下依次为：寄存器、缓存、内存、磁盘、磁带5层。其中<strong>寄存器、缓存和内存是操作系统存储管理的管辖范畴</strong>；磁盘和磁带属于文件管理和设备管理的管辖对象。</p><h3 id="地址转换与存储保护"><a href="#地址转换与存储保护" class="headerlink" title="地址转换与存储保护"></a>地址转换与存储保护</h3><p>源程序在计算机上运行涉及的过程：</p><ul><li>编译程序或汇编程序处理源程序并生成目标代码（程序）</li><li>链接程序将目标代码链接为一个<strong>可重定位代码（程序）</strong>，此时程序处在<strong>逻辑地址空间</strong>中</li><li>装载程序将可执行代码装入物理地址空间，直到此时程序才能运行</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/jqZwMSNIoas5r3x.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h4><p>程序编译指的是编译程序（compiler）或汇编程序（assembly）的处理生成目标模块（目标代码）。一个程序可以由独立编写的且具有不同功能的多个源程序模块组成，由于模块包含外部引用，即指向<strong>其他模块中的数据或指令地址</strong>，或包含<strong>对库函数的引用</strong>，<strong>编译程序或汇编程序负责记录引用发生的位置</strong>，其处理结果将产生相应的多个目标模块，每个目标模块都附有<strong>供引用使用的内部符号表和外部符号表</strong>。符号表中依次给出<strong>各个符号名及在本目标模块中的名字地址</strong>，在模块<strong>被链接时</strong>进行转换</p><h4 id="程序链接"><a href="#程序链接" class="headerlink" title="程序链接"></a>程序链接</h4><p>链接程序（linker）的作用是<strong>根据目标模块之间的调用和依赖关系，将主模块、被调模块以及所用到的库函数装配和链接成一个完整的可装载执行模块</strong>。</p><p>根据程序链接发生的时刻和链接的方式，程序链接可以分成以下三种方式：</p><ul><li><p>静态链接</p><p>在程序装载到内存和运行之前，就已经将它的所有目标模块及所需要的库函数进行链接和装配成一个<strong>完整的可执行程序</strong>且此后不再拆分</p><blockquote><p>简单来说就是在链接阶段，将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件，该可执行文件可能会比较大</p><ul><li><p>这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行</p></li><li><p>缺点是：文件太大，一个全静态方式生成的简单print文件都有857K。而动态链接生成的一样的可执行文件却只要8.４Ｋ</p></li></ul><p>reference：<a href="https://blog.csdn.net/freestyle4568world/article/details/49817799" target="_blank" rel="noopener">https://blog.csdn.net/freestyle4568world/article/details/49817799</a></p></blockquote><p>可重定位目标程序：</p><p><img src="https://i.loli.net/2019/10/23/sSd2pJmYozEWDj5.png" alt></p></li><li><p>动态链接</p><p>程序在装入内存前并未事先进行程序各目标模块的链接，而是在程序装载时一边装载一遍链接，生成一个可执行程序。</p><ul><li>在装载目标模块时，若发生外部模块调用，将引发外部目标模块的搜索、装载和链接</li><li>同时若发现所需某部目标模块已在内存，可<strong>直接进行链接且无需再次装载，支持目标模块的共享</strong></li></ul></li><li><p>运行时链接</p><p>将某些目标模块或库函数的链接推迟到执行时才进行。在程序执行过程中，若发现被调用模块或库函数尚未链接，先在内存中进行搜索以查看其是否装入内存</p><ul><li>若已装入，则直接将其链接到调用者程序中</li><li>否则进行该模块在外存上的搜索，以及装入内存和进行链接，生成一个可执行程序</li></ul><p>运行时链接的好处：</p><ul><li>避免事先无法知道本次要运行哪些目标模块</li><li>避免程序执行过程中不被调用的某些目标模块在执行前进行链接和装载而引起的开销，提高系统资源利用率和系统效率</li></ul><p>采用运行时链接时，程序执行所需要的库函数所在的部分目标模块是伴随着其被调用才动态进行装载和链接。具体的做法是：<u>不必将程序所需的外部函数代码从系统库中提取出并链入目标模块中，而仅仅是在程序调用处登记调用信息，记录函数名及入口号，形成调用链接；一旦函数库调入内存后，就可以确定所调函数在内存的物理地址</u>。</p></li></ul><h4 id="程序装载"><a href="#程序装载" class="headerlink" title="程序装载"></a>程序装载</h4><p>装载程序（loader）把可执行程序装入内存的方式有三种：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/UlP8L6R12y3XbVC.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>磁盘中的装载模块使用的是逻辑地址，逻辑地址的集合称为进程的<strong>逻辑地址空间</strong>：</p><ul><li>逻辑地址空间可以是一维的，这时逻辑地址限制在从0开始顺序排序的地址空间内</li><li>逻辑地址空间也可以是二维的，这时整个程序被分为若干段，每段都有不同段号，<strong>段内地址从0开始顺序编址</strong></li></ul><p>物理内存从统一的基地址开始顺序编址的存储单元称为物理地址或绝对地址，物理地址的总体构成物理地址空间</p><p><strong>可执行程序逻辑地址转换（绑定）为物理地址的过程称为地址重定位、地址映射或地址转换</strong>，基于程序装入方式的不同，可以区分三种地址重定位：</p><ul><li><p>静态地址重定位</p><p><img src="https://i.loli.net/2019/10/23/yAb246iZNMTedSD.png" alt></p></li><li><p>动态地址重定位</p><p><img src="https://i.loli.net/2019/10/23/fL1H2gUhyRE9CMT.png" alt></p><p><img src="https://i.loli.net/2019/10/23/KgY5IQmcdjeyVsH.png" alt></p></li><li><p>运行时链接地址重定位</p><p><img src="https://i.loli.net/2019/10/23/eQkOVLR5i8HtPh9.png" alt></p></li></ul><p>为了允许程序因对换或空闲区收集而被移动（会导致正在执行的程序在不同时刻处于内存的不同位置），必须使用动态地址重定位。动态地址重定位要借助于<strong>硬件地址转换机制</strong>来实现，<strong>重定位寄存器的内容通常保护在进程控制块中</strong>，每当执行进程上下文切换时，当前运行进程的重定位寄存器中的内容与其他信息被一起保护起来，新进程的重定位寄存器的内容会被恢复，这样进程就在上次中断的位置恢复运行，所使用的是与上次在此位置的同样的内存基地址。</p><p>存储保护涉及防止地址越界和控制正确存取：</p><ul><li><strong>地址越界保护</strong>：无论采用何种地址重定位方式，通常进程运行时产生的所有内存访问地址都应进行检查，确保进程仅访问自己的内存区，以免破坏其他进程的内存区</li><li><strong>信息存取保护</strong>：进程在访问分配给自己的内存区时，要对访问权限进行检查，如允许读、写、执行等，从而确保数据的安全性和完整性，防止有意或无意的误操作而破坏内存信息</li></ul><h2 id="连续存储管理"><a href="#连续存储管理" class="headerlink" title="连续存储管理"></a>连续存储管理</h2><h3 id="固定分区存储管理"><a href="#固定分区存储管理" class="headerlink" title="固定分区存储管理"></a>固定分区存储管理</h3><p>固定分区又称为静态分区模式，基本思想是：内存空间被划分为<strong>数目固定不变的分区，各分区大小不等，每个分区只装入一个作业</strong>，若多个分区中都装有作业，则它们可以并发执行。</p><p>为了说明各分区分配和使用情况，需要设置一张内存分配表，记录内存中划分的分区及其使用情况。<strong>内存分配表指出各分区起始地址和长度</strong>，占用标志用来指示此分区是否被使用，当其值为0时，表明此分区尚未被占用。</p><p>固定分区管理的一项任务是何时及如何把内存空间划分成分区。这项工作通常由系统管理员和操作系统初始化模块协同完成。系统初次启动时，管理员根据当天作业情况把内存划分成大小不等但数目固定的分区。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/vj71eTxgNHQmV4u.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="排队策略"><a href="#排队策略" class="headerlink" title="排队策略"></a>排队策略</h4><p>作业进入固定分区的两种排队策略：</p><ul><li>一是每个分区有单独的作业等待队列，调度程序选中作业后，创建用户进程并将其排入一个<strong>能够装入它的最小分区的进程等待队列尾部</strong>，当此分区空闲时，就装入队首进程执行<ul><li>好处是可以使装入分区浪费的空间最小</li><li>但是如果等待处理的作业大小很不均匀，将导致分区有的空闲而有的忙碌</li></ul></li><li>二是<strong>所有等待处理的作业排成一个等待队列</strong>，每当有分区空闲时，就从队首依次搜索分区长度能够容纳的作业以便装入执行；为了防止小作业占用大分区，也可以搜索<strong>分区长度能够容纳的最大作业</strong>装入执行</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>实现简单，对于程序大小和出现频率已知的情形还是比较合适的</li><li>解决了单道程序运行在并发环境下不能与CPU速度匹配的问题</li><li>解决了单道程序运行时内存空间利用率低的问题</li></ul><p>缺点：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/7ctDUWL4kFdGoBe.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="可变分区存储管理"><a href="#可变分区存储管理" class="headerlink" title="可变分区存储管理"></a>可变分区存储管理</h3><h4 id="可变分区内存空间的分配和去配"><a href="#可变分区内存空间的分配和去配" class="headerlink" title="可变分区内存空间的分配和去配"></a>可变分区内存空间的分配和去配</h4><p>可变分区（variable partition）存储管理又称为动态分区模式，按照作业大小来划分分区，但划分的时间、大小、位置都是动态的。系统把作业装入内存时，根据其所需要的内存容量查看是否有足够的空间，若有则按需分割一个分区分配给此作业；若无则令此作业等待资源。</p><p>可变分区能够克服固定分区内存资源浪费的问题，有利于多道程序设计，提高内存资源利用率。</p><p>内存中分区数目和大小随着作业的执行而不断改变，为了方便内存空间的分配和去配，用于管理的数据结构可由两张表组成：<strong>已分配区表</strong>和<strong>未分配区表</strong>。</p><ul><li><p>当装入新作业时，从未分配区表中找出一个足够容纳它的空闲区，将此区分成两部分，一部分用来装入作业，成为已分配区；另一部分仍是空闲区（若有）。</p><p>这时应该从分配区表中找出一个空栏目登记新作业的起始地址、占用长度，同时修改未分配区表中空闲区的长度和起始地址</p></li><li><p>当作业撤离时，已分配区表中的相应状态改为空闲，而将收回的分区登记到未分配区表中，若<strong>有相邻空闲区再将其连接后登记</strong></p></li></ul><p>当一个作业X撤离时的四种情况：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/X1MqKhHCI2Pktmf.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>由于分区数目不定，而且分区表占用了较多的额外空间，采用链表是另一种较好的<strong>空闲区管理</strong>方法：</p><ul><li>通过指针把<strong>所有的空闲区</strong>链接起来，每个空闲区的开头单元存放<strong>本空闲区长度</strong>及<strong>下一个空闲区起始地址指针</strong>，系统设置<strong>指向空闲区链的头指针</strong></li><li>使用时，沿链查找并取一个长度能够满足要求的空闲分区分配给进程，再修改链表</li><li>归还时，把此空闲区链入空闲区链表的相应位置即可</li></ul><p>空闲区链表管理比空闲区表格管理复杂，但是优点是链表自身并不占用存储单元</p><h5 id="可变分区分配算法"><a href="#可变分区分配算法" class="headerlink" title="可变分区分配算法"></a>可变分区分配算法</h5><ul><li><p>最先适应（first fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/ysHQ2ujJPRqnGFA.png" alt></p></li><li><p>下次/邻近适应（next fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/OoZfarJ8cnb7jLz.png" alt></p></li><li><p>最优适应（best fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/X1UnbyGSFuCQwlp.png" alt></p></li><li><p>最坏适应（worst fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/SazlsLRt4kGqNi8.png" alt></p></li><li><p>快速适应（quick fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/9ND4cXHgiChMtjW.png" alt></p></li></ul><h4 id="地址转换和存储保护"><a href="#地址转换和存储保护" class="headerlink" title="地址转换和存储保护"></a>地址转换和存储保护</h4><ul><li><p>对固定分区采用静态地址重定位，进程运行时使用绝对地址，可由加载程序进行地址越界检查</p></li><li><p>对可变分区则采用动态地址重定位，进程的程序和数据的地址转换由硬件完成，硬件设置两个专用控制寄存器：</p><ul><li>基址寄存器：存放分配给进程使用的分区的起始地址</li><li>限长寄存器：存放分配给进程所占用的连续存储空间的长度</li></ul><p><img src="https://i.loli.net/2019/10/24/F1VD3ClEqyweZsn.png" alt></p><p>多道程序系统中，硬件只需要设置一对基址/限长寄存器：</p><ul><li>进程在执行过程中出现等待事件时，操作系统把基址/限长寄存器的内容随此进程的其他信息（如PSW、通用寄存器等）一起保护起来</li><li>另一个被选中执行的线程，则将其基址/限长值再送入基址/限长寄存器</li></ul><p>在有N个重定位寄存器的机器中，允许每个进程获得N个不同的内存段，并在运行时进行动态地址重定位：</p><ul><li><p>如果每个进程只能占用一个分区，则不允许各个进程之间有公共区域（因为有存取保护机制）</p></li><li><p>提供两对或者多对基址/限长寄存器的机器中，允许一个进程占用两个或者多个分区，这样可以通过规定某对基址/限长寄存器的区域是共享的来实现不同进程之间的共享区域，且进程共享部分取相同的基址/限长值：</p><p><img src="https://i.loli.net/2019/10/24/dUAWKD9CcVY3vtF.png" alt></p></li></ul></li></ul><h3 id="内存不足的存储管理技术"><a href="#内存不足的存储管理技术" class="headerlink" title="内存不足的存储管理技术"></a>内存不足的存储管理技术</h3><blockquote><p>补充：内部碎片和外部碎片</p><p>来源：<a href="https://www.cnblogs.com/zlcxbb/p/5759790.html" target="_blank" rel="noopener">https://www.cnblogs.com/zlcxbb/p/5759790.html</a></p><ul><li><p><strong>internal fragmentation:</strong>when memory allocated to a process is larger than requested memory, the difference between these two numbers is internal fragmentation.</p><p>在内存管理中，<strong>内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间</strong></p></li><li><p><strong>external fragmentation:</strong>External fragments exists when total memory space exists to satisfy a request, but it is not continous. storage is broken into little pieces. </p><p><strong>外部碎片</strong>是指<strong>还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块</strong>。</p></li></ul><p>一般情况下，<strong>固定分区存在内部碎片，可变式分区分配会存在外部碎片</strong>；</p><p><strong>页式虚拟存储系统</strong>存在内部碎片（为了有效的利用内存，使内存产生更少的碎片，要<strong>对内存分页</strong>，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片）</p><p><strong>段式虚拟存储系统</strong>存在外部碎片（为了共享要分段，在段的换入换出时形成外部碎片，比如5K的段换出后，有一个4k的段进来放到原来5k的地方，于是形成1k的外部碎片）</p></blockquote><h4 id="移动技术"><a href="#移动技术" class="headerlink" title="移动技术"></a>移动技术</h4><p>当在未分配分区表中找不到足够大的空闲区来装入新进程时，可采用移动技术把已在内存中的进程分区连接到一起，使分散的空闲区汇集成片，也叫内存紧凑（compact）</p><ul><li>第一种方式是把<strong>所有</strong>当前占用的分区内容移动到内存的一端</li><li>第二种方式是把占用分区内容移动到内存的一端，但是当<strong>产生足够大小的空闲区时就停止移动</strong></li></ul><p>内存中的进程在移动过程中，凡是涉及地址的信息都需要进行修改，例如基址寄存器、地址指针、内存分配表等。那么什么时候进行移动？</p><ul><li>一是进程撤销之后释放分区时，如果它不与空闲区邻接，立即实施移动，于是系统始终保持只有一个空闲区</li><li>二是进程装入分区时，若空闲区的总和够用，但是没有一个空闲区能容纳此进程时实施移动</li></ul><p>移动技术分配内存空间的算法：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/85L24gcDBvHqblZ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>移动操作也为进程运行过程中<strong>动态扩充内存空间</strong>提供了方便，当进程执行过程中要求增加内存空间时，只需要适当移动邻近的占用分区内容就可以增加其所占有的连续区的长度，<strong>移动后的基址值和经扩大的限长值都要相应修改</strong></p><h4 id="对换技术"><a href="#对换技术" class="headerlink" title="对换技术"></a>对换技术</h4><p>对换技术（swapping）广泛应用于分时系统调度中，以<strong>解决内存容量不足</strong>的问题。如果当前一个或者多个驻留进程都处于阻塞态，此时选择其中一个进程，将其暂时移出内存，腾出空间给其他进程使用，同时把磁盘中的某个进程换入内存，让其投入运行，这种互换称为对换。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/RotUY5bDaXBE94x.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>由于有硬件地址重定位寄存器的支持，对换进来的进程映像被复制到新分配的内存区域并重置定位寄存器的值。</p><p>为了有效实施对换，必须确定以下事情：</p><ul><li><p>首先选择哪个进程换出：通常系统把时间片耗尽或优先级较低的进程换出，因为短时间内它们不会投入运行</p></li><li><p>其次应决定把进程的哪些信息移出去</p><p><img src="https://i.loli.net/2019/10/24/GPdIu2sCtxfQ647.png" alt></p></li><li><p>最后需要确定对换时机</p><ul><li>批处理系统中，当进程要求动态扩充内存空间且得不到满足时可触发对换</li><li>分时系统中，每个时间片结束或执行I/O操作时实施，调度程度启动一个挪出的进程换入，这样轮到它执行时立即可以启动（需要解决对换过程中进程的地址重定位问题）</li></ul></li></ul><p>与移动不同，<strong>对换要访问磁盘</strong>，这是I/O集中型操作，但是系统可以让对换与计算型进程并行工作。换出的进程候选者当<strong>首选被阻塞的进程</strong>，否则就挑选就绪进程，同时需要考虑进程的属性，例如消耗CPU时间、在内存已逗留时间等</p><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>移动和对换技术解决因多个程序存在而导致内存区不足的问题，这种内存短缺是暂时的；如果程序长度超过物理内存总和，或超出固定分区大小，则出现内存永久性短缺，大进程无法运行，前两种方法无法解决，解决方案是使用覆盖（overlaying）技术。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/KaZGpMvTN5iIhOA.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>但是不足之处是，<strong>存储管理工作转给了程序员</strong>，他们必须根据物理内存空间来设计和编写程序。</p><h2 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h2><h3 id="分页存储管理的基本原理"><a href="#分页存储管理的基本原理" class="headerlink" title="分页存储管理的基本原理"></a>分页存储管理的基本原理</h3><p>采用分页存储管理允许程序存放到若干不相邻的空闲块中，既可免除移动信息工作，又可充分利用内存空间，消除动态分区法中的“碎片”问题，从而提高内存空间利用率</p><p>基本概念：</p><ul><li><p>页面：进程<strong>逻辑地址空间</strong>分成<strong>大小相等</strong>的区，每个区称为页面或页，页号从0开始依次编号</p></li><li><p>页框：页框又称为页帧，把<strong>内存物理地址空间</strong>分成<strong>大小相等</strong>的区，其大小与页面大小相等，每个区是一个页框（物理块），块号从0开始依次编号</p></li><li><p>逻辑地址：分页存储器的逻辑地址由<strong>页号</strong>和<strong>页内位移</strong>两部分组成</p><p><img src="https://i.loli.net/2019/10/25/zn2u17CGlWJvyN3.png" alt></p></li><li><p>内存页框表：该表长度取决于内存划分的物理块数，编号可与物理块号一致，页框表的表项给出物理块使用情况（0：空闲，1：占用），有的系统还会增加保护位</p></li><li><p>页表（如下一小节）</p></li></ul><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>在进行内存分配时以页框为单位，进程信息有多少页，那么把它装入内存时就分配多少页框，其中进程的逻辑地址是划分成编号连续的页面的，而装入内存的页框却未必相连。每个</p><p>（1）页面与被分配的页框如何建立联系？</p><p><strong>页表</strong>是操作系统为进程建立的，是程序页面和内存页框的对照表，页表中的每一栏指明程序中的一个页面和分得页框之间的对应关系。</p><p>为了减少系统开销，操作系统在内存中开辟存储区（软件）存放进程页表，另外设置页表寄存器（硬件）来存放当前运行进程的页表起始地址，以加快地址转换速度。</p><p>进程在内存中的每个页框内的地址是连续的，但是页框之间的地址可以不连续。</p><p>（2）逻辑地址（页面）如何转换成物理地址（页框）？</p><p>进程在运行前由系统把它的页表基地址送入页表基址寄存器，运行时借助硬件地址转换机制按页面进行动态地址重定位。</p><p>CPU获得逻辑地址后，由硬件自动按设定的页面尺寸分成<strong>页号p</strong>和<strong>页内位移d</strong>两部分，先从页表基址寄存器找到页表基地址，再用页号p作为索引查页表，得到对应的页框号</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/25/JRcqrm2G6uM7UWT.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>然后计算出要访问的内存单元地址（物理地址），实际上就是页框号和页内位移进行拼接得到物理地址</p><p>（3）如何保证程序正确运行？</p><p>虽然进程存放在若干不连续的页框中，但是在执行过程中总能<strong>按正确的物理地址进行存取</strong>。整个系统<strong>只有一个页表基址寄存器</strong>，只有占用CPU的进程才占有它；多道程序设计中，当某道程序让出处理器时，应同时让出此寄存器供其他进程使用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/25/zIWV6LArS1TgpcR.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="翻译块表（Translation-Look-aside-Buffer，TLB）"><a href="#翻译块表（Translation-Look-aside-Buffer，TLB）" class="headerlink" title="翻译块表（Translation Look-aside Buffer，TLB）"></a>翻译块表（Translation Look-aside Buffer，TLB）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;存储管理&quot;&gt;&lt;a href=&quot;#存储管理&quot; class=&quot;headerlink&quot; title=&quot;存储管理&quot;&gt;&lt;/a&gt;存储管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="存储管理" scheme="http://QQ876684433.github.io/tags/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-10-22）</title>
    <link href="http://QQ876684433.github.io/2019/10/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-10-22%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/22/数据库课堂笔记（2019-10-22）/</id>
    <published>2019-10-22T05:52:13.000Z</published>
    <updated>2019-10-23T07:12:45.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-10-22）"><a href="#数据库课堂笔记（2019-10-22）" class="headerlink" title="数据库课堂笔记（2019-10-22）"></a>数据库课堂笔记（2019-10-22）</h2><h3 id="Ch4-Object-Relational-SQL-Oracle"><a href="#Ch4-Object-Relational-SQL-Oracle" class="headerlink" title="Ch4. Object-Relational SQL (Oracle)"></a>Ch4. Object-Relational SQL (Oracle)</h3><h4 id="Object-Types（对象类型）"><a href="#Object-Types（对象类型）" class="headerlink" title="Object Types（对象类型）"></a>Object Types（对象类型）</h4><h5 id="类型的循环嵌套定义"><a href="#类型的循环嵌套定义" class="headerlink" title="类型的循环嵌套定义"></a>类型的循环嵌套定义</h5><p>对象类型(object type)不能嵌套定义， 但 REF 关系可以实现嵌套引用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">type</span> police_officer_t <span class="keyword">as</span> <span class="keyword">object</span></span><br><span class="line">(</span><br><span class="line">    pol_person person_t,</span><br><span class="line">    badge_number <span class="built_in">integer</span>,</span><br><span class="line">    partner <span class="keyword">ref</span> police_officer_t</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="REF-的其它约束"><a href="#REF-的其它约束" class="headerlink" title="REF 的其它约束"></a>REF 的其它约束</h5><ul><li><p>两张表之间的相互REF关系的定义</p><p><img src="https://i.loli.net/2019/10/22/3cR6MzrC4h9Fj2t.png" alt></p></li><li><p>两个具有相互REF关系的表/类型的删除</p><p><img src="https://i.loli.net/2019/10/22/f8vQaitUkF5hMVH.png" alt></p></li><li><p>REF属性数据的加载</p><p><img src="https://i.loli.net/2019/10/22/ojbT5m3XgcLidSN.png" alt></p><p><img src="https://i.loli.net/2019/10/22/5QTBnZmsLpKNqdV.png" alt></p></li></ul><h4 id="Collection-Types（集合类型）"><a href="#Collection-Types（集合类型）" class="headerlink" title="Collection Types（集合类型）"></a>Collection Types（集合类型）</h4><p>集合类型允许我们将多个值（即值的集合）存放到一行记录的某一列中，在Oracle中，集合类型有以下两种：</p><ul><li><p>表类型（Table Types，嵌套表）</p></li><li><p>数组类型（Array Types）</p><p>其中数组类型中存放的元素是具有相同的类型（the element type）的</p></li></ul><h5 id="表类型和嵌套表（Table-Types-and-Nested-Tables）"><a href="#表类型和嵌套表（Table-Types-and-Nested-Tables）" class="headerlink" title="表类型和嵌套表（Table Types and Nested Tables）"></a>表类型和嵌套表（Table Types and Nested Tables）</h5><p>创建一个<strong>表类型（table type）</strong>的方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> dependents_t <span class="keyword">AS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> person_t;</span><br></pre></td></tr></table></figure><p>这样就可以通过表类型（dependents_t）来定义新的表，而dependents_t则形成一个嵌套表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employees (</span><br><span class="line">    eid <span class="built_in">int</span>,</span><br><span class="line">    eperson person_t,</span><br><span class="line">    dependents dependents_t,</span><br><span class="line">    primary <span class="keyword">key</span> (eid)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如上，dependents属性的类型就是一个表类型（dependents_t），它是employees的嵌套表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/22/rXlRbBpLfgZJNEu.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="嵌套表的访问"><a href="#嵌套表的访问" class="headerlink" title="嵌套表的访问"></a>嵌套表的访问</h5><ul><li><p>对嵌套表进行访问时，如果需要对表类型属性进行子查询，那么需要使用<strong>转换函数：table(…)</strong>：</p><p><img src="https://i.loli.net/2019/10/22/ywjF8oRn42peHrc.png" alt></p></li><li><p>嵌套表属性不能直接使用统计函数，比如count(…)等，同样需要使用转换函数table(…)</p><p><img src="https://i.loli.net/2019/10/22/MUkJDqIZuyFw9Ng.png" alt></p></li><li><p>Oracle 数据库没有提供 nested table 的相等比较运算，但是提供了单个对象的相等比较功能</p><p><img src="https://i.loli.net/2019/10/22/VXsY1jQ8m4TPZdf.png" alt></p></li><li><p>Oracle是支持嵌套表与表自身的联接查询的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid, d.ssno</span><br><span class="line"><span class="keyword">from</span> employees e, <span class="keyword">table</span>(e.dependents) d</span><br></pre></td></tr></table></figure></li></ul><h5 id="Oracle的外联接（outer-join）"><a href="#Oracle的外联接（outer-join）" class="headerlink" title="Oracle的外联接（outer join）"></a>Oracle的外联接（outer join）</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/hehaiyang/p/4745897.html" target="_blank" rel="noopener">https://www.cnblogs.com/hehaiyang/p/4745897.html</a></p></blockquote><p>对于外连接， 也可以使用“(+) ”来表示。 关于使用（+）的一些注意事项：</p><ol><li><strong>（+）操作符只能出现在WHERE子句中</strong>，并且不能与OUTER JOIN语法同时使用。</li><li>当使用（+）操作符执行外连接时，如果在WHERE子句中包含有多个条件，则必须在所有条件中都包含（+）操作符。</li><li>（+）操作符只适用于列，而不能用在表达式上。</li><li>（+）操作符不能与OR和IN操作符一起使用。</li><li>（+）操作符只能用于实现左外连接和右外连接，而<strong>不能用于实现完全外连接</strong>。</li></ol><p>用（+）来实现， 这个+号可以这样来理解： <strong>+ 表示补充，即哪个表有加号，这个表就是匹配表</strong>。如果加号写在右表，左表就是全部显示，所以是<strong>左连接</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> t_A a,t_B b <span class="keyword">where</span> a.id=b.id(+);</span><br></pre></td></tr></table></figure><p>如果加号写在左表，右表就是全部显示，所以是<strong>右连接</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> t_A a,t_B b <span class="keyword">where</span> a.id(+)=b.id;</span><br></pre></td></tr></table></figure><p>而对于全外联接，左表和右表都不做限制，所有的记录都显示，两表不足的地方均为NULL。 <strong>全外连接不支持（+）写法</strong>。</p><h5 id="嵌套游标（Nested-Cursors）"><a href="#嵌套游标（Nested-Cursors）" class="headerlink" title="嵌套游标（Nested Cursors）"></a>嵌套游标（Nested Cursors）</h5><p>可以使用嵌套游标来实现对嵌套表的查询，例如对于普通的查询操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid, d.ssno <span class="keyword">as</span> dep_sso</span><br><span class="line"><span class="keyword">from</span> employees e, <span class="keyword">table</span>(e.dependents) d</span><br><span class="line"><span class="keyword">where</span> d.age &lt; <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>可以使用嵌套游标来实现相同的功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid,</span><br><span class="line">    <span class="keyword">cursor</span> ( <span class="keyword">select</span> d.ssno <span class="keyword">as</span> dep_ssno</span><br><span class="line">        <span class="keyword">from</span> <span class="keyword">table</span>(e.dependents) d</span><br><span class="line">        <span class="keyword">where</span> d.age &lt; <span class="number">16</span>) dep_tab</span><br><span class="line"><span class="keyword">from</span> employees e;</span><br></pre></td></tr></table></figure><p>另外，嵌套游标也可以用来实现对嵌套表属性的统计功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> eid,</span><br><span class="line">    <span class="keyword">cursor</span> ( <span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">table</span>(e.dependents) )</span><br><span class="line"><span class="keyword">from</span> employees e;</span><br></pre></td></tr></table></figure><p>但是似乎cursor是多余的，因为以下两种方式也可以对嵌套表属性进行统计：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/3COt2zYwkmI5XRL.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="Array-Types（数组类型）"><a href="#Array-Types（数组类型）" class="headerlink" title="Array Types（数组类型）"></a>Array Types（数组类型）</h4><p>嵌套表类型（Nested Table）和数组类型（VARRAY）的对比：</p><table><thead><tr><th align="center"></th><th align="center">Nested table</th><th align="center">VARRAY</th></tr></thead><tbody><tr><td align="center">成员的排列次序</td><td align="center">无序</td><td align="center">有序</td></tr><tr><td align="center">成员的最大数目</td><td align="center">没有限制</td><td align="center">确定的值</td></tr><tr><td align="center">成员的存储组织</td><td align="center">单独的存储表</td><td align="center">直接存储在原表中</td></tr></tbody></table><p>两者在访问模式上的区别：</p><ul><li>可以对嵌套表属性执行insert操作， 或通过update操作修改其成员的取值</li><li>但对于 VARRAY 属性则不能执行上述的插入或修改操作， 只能通过<strong>update语句修改整个 VARRAY 属性</strong>的取值</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Makefile学习笔记</title>
    <link href="http://QQ876684433.github.io/2019/10/21/Makefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://QQ876684433.github.io/2019/10/21/Makefile学习笔记/</id>
    <published>2019-10-21T02:08:59.000Z</published>
    <updated>2019-10-21T02:08:59.036Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统-中断技术</title>
    <link href="http://QQ876684433.github.io/2019/10/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E6%8A%80%E6%9C%AF/"/>
    <id>http://QQ876684433.github.io/2019/10/17/操作系统-中断技术/</id>
    <published>2019-10-17T12:57:02.000Z</published>
    <updated>2019-10-18T07:44:33.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中断技术"><a href="#中断技术" class="headerlink" title="中断技术"></a>中断技术</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li><li>Linux Kernel Teaching - <a href="https://linux-kernel-labs.github.io/master/lectures/interrupts.html" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/lectures/interrupts.html</a></li></ul></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​        每当应用程序执行系统调用要求获得操作系统服务、I/O设备报告传输情况，或者产生各种内部和外部事件时，都需要通过中断机制产生中断信号并启动操作系统内核工作，可以说，操作系统是由“<strong>中断驱动</strong>”的。最初中断技术仅作为设备向CPU报告I/O操作情况的一种手段，以免CPU因不断地轮训设备而耗费CPU时间，<strong>中断的出现解决了主机和设备的并行性问题</strong>。</p><p>​        <strong>中断（interrupt）</strong>指的是在程序执行过程中遇到急需处理的事件时，暂时终止现行程序在CPU上的运行，转而执行相应的事件处理程序，待处理完成后再<u>返回断点</u>或<u>调度其他程序执行</u>的过程。</p><p>​        不同的计算机系统中通常有不同的中断源和中断装置，但是它们都有一个共性：中断事件发生后，中断装置能改变处理器内操作的执行顺序。</p><h2 id="中断源分类"><a href="#中断源分类" class="headerlink" title="中断源分类"></a>中断源分类</h2><h3 id="硬中断"><a href="#硬中断" class="headerlink" title="硬中断"></a>硬中断</h3><p>由硬件发出或产生的中断称为硬中断，按照硬中断事件的来源和实现手段，可以将硬中断划分为外中断和内中断</p><h4 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h4><p>又称为<strong>中断</strong>或<strong>异步中断</strong>，是指<strong>来自处理器之外的中断信号</strong>，包括：时钟中断、键盘中断、它机中断、外部设备中断等。外中断又分为</p><ul><li><strong>可屏蔽中断</strong></li><li><strong>不可屏蔽中断</strong></li></ul><p>各个中断具有不同的中断优先级，表示事件的紧急程度，在处理高一级中断时，往往会部分或者全部屏蔽低级中断。</p><h4 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h4><p>又称为<strong>异常（exception）</strong>或<strong>同步中断</strong>，是指<strong>来自处理器内部的中断信号</strong>，通常是由于在程序执行过程中，发现与<strong>当前指令</strong>关联的、不正常的或错误的事件。内中断可被细分为：</p><ul><li>访管中断，由执行系统调用引起</li><li>硬件故障中断，如电源失效、奇偶校验错误、总线超时等</li><li>程序性异常，如非法操作、地址越界、页面故障、调试指令、除数为0和浮点数溢出等</li></ul><p>这些事件都由<strong>异常处理程序</strong>处理，并且通常依赖于执行程序的当前现场。<strong>内中断不能被屏蔽，一旦出现应立即予以响应并进行处理</strong>，而异常处理程序运行时是否屏蔽外部中断或屏蔽哪些中断，可根据异常处理的需要来设定</p><h4 id="中断和异常的区别"><a href="#中断和异常的区别" class="headerlink" title="中断和异常的区别"></a>中断和异常的区别</h4><ul><li><p>中断由与当前运行程序无关的中断信号触发的，系统不能确定中断事件的发生时间，故<strong>中断与CPU是异步的</strong>，CPU对中断的响应完全是被动的。<strong>中断的发生与CPU当前状态无关</strong>，既可以发生在用户态也可以发生在内核态，因为无论是用户态还是内核态，都需要处理外部设备发来的中断请求。一般来说，<strong>中断处理程序所提供的服务不是当前进程所需要的</strong>，如时钟中断、磁盘中断等</p><p>异常是由<strong>CPU控制单元</strong>产生的，源于<strong>现行程序执行指令过程中检测到的例外</strong>（exception）。<strong>异常与CPU是同步的</strong>，允许指令在执行过程期间响应异常，而且允许多次响应异常，大部分异常发生在用户态，而<strong>内核态唯一发生的异常是“缺页异常”</strong></p></li><li><p>“中断”应该被快速处理以便及时响应其他中断信号，所以<strong>中断处理程序处理过程中是不能阻塞的</strong></p><p>“异常”处于被打断的当前进程上下文中，所提供的服务是当前进程所需要的，所以<strong>异常处理程序处理过程中是可以阻塞的</strong></p></li><li><p>中断允许发生嵌套，但异常大多为一重；异常处理过程中可能会发生中断，但是中断处理过程中绝不会被异常打断</p></li></ul><blockquote><p>reference：<a href="https://stackoverflow.com/questions/7295936/what-is-the-difference-between-interrupt-and-exception-context" target="_blank" rel="noopener">https://stackoverflow.com/questions/7295936/what-is-the-difference-between-interrupt-and-exception-context</a></p><p>Interrupts and exceptions both alter the program flow. The difference between the two is that <strong>interrupts are used to handle external events (serial ports, keyboard)</strong> and <strong>exceptions are used to handle instruction faults, (division by zero, undefined opcode).</strong></p><p>Interrupts are handled by the processor after finishing the current instruction. If it finds a signal on its interrupt pin, it will look up the address of the interrupt handler in the interrupt table and pass that routine control. After returning from the interrupt handler routine, it will resume program execution at the instruction after the interrupted instruction.</p><p>Exceptions on the other hand are divided into three kinds. These are <strong>Faults, Traps and Aborts</strong>. Faults are detected and serviced by the processor before the faulting instructions. Traps are serviced after the instruction causing the trap. User defined interrupts go into this category and can be said to be traps; this includes the MS- DOS INT 21h software interrupt, for example. Aborts are used only to signal severe system problems, when operation is no longer possible.</p></blockquote><h3 id="中断和异常的响应及服务"><a href="#中断和异常的响应及服务" class="headerlink" title="中断和异常的响应及服务"></a>中断和异常的响应及服务</h3><p>产生处理器外部中断或者内部异常的时候，CPU都会在<strong>执行完当前指令后</strong>，根据中断源所提供的“中断向量”，在内核中找到响应中断服务例程并调度执行。</p><p>中断向量<strong>由硬件或操作系统预先分配和设置</strong>，系统调用所对应的向量则在访管指令中给出；各种异常向量<strong>在CPU的硬件结构中预先规定</strong>。这样不同情况就因中断向量的不同而区分开来。</p><p>操作系统如何转到中断处理程序和异常处理程序执行呢？</p><ul><li>对于中断，它主要由外部设备、时钟部件或其他计算机发出的（发现中断源并产生中断的硬件称为中断控制器，这些硬件包括中断逻辑线路和中断寄存器）<u>当前指令执行结束后，CPU会检查中断寄存器是否有中断事件发生</u>：<ul><li>若无中断信号或中断信号被屏蔽，则继续执行程序的后续指令</li><li>否则将暂停执行当前程序，转向内核的中断处理程序执行</li></ul></li><li>对于异常，它是在执行指令时，由于指令本身的原因发生的，指令的控制逻辑和实现线路一旦发现异常情况便转向内核的异常处理程序</li></ul><p>这个<u>由硬件对中断和异常事件做出反应的过程</u>称为<strong>中断响应</strong>。目前的计算机都采用软硬件结合（<strong>硬件中断控制器</strong>和<strong>软件中断/异常处理程序</strong>相结合）的方法实现中断/异常处理。中断/异常响应需要执行以下四个步骤：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/18/I7Eo5uDZ6jtdcCV.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="中断优先级和多重中断"><a href="#中断优先级和多重中断" class="headerlink" title="中断优先级和多重中断"></a>中断优先级和多重中断</h3><h4 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h4><p>中断装置所预设的中断响应顺序称为中断优先级。例如，同样是设备，可以设定高速设备优先级高，慢速设备优先级低，以提高高速设备的利用率。那么中断系统如何按照预先设定的优先顺序予以响应？可以使用硬件和软件方法</p><ul><li>硬件方法根据排定的优先级顺序做一个硬件链式排队器，当产生高一级中断事件时，应该<strong>屏蔽比它优先级低的所有中断源</strong></li><li>软件方法编写一个查询程序，依据优先级顺序<strong>从高到低进行查询</strong>，一旦发现有中断请求，便转入相应中断事件处理程序入口</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;中断技术&quot;&gt;&lt;a href=&quot;#中断技术&quot; class=&quot;headerlink&quot; title=&quot;中断技术&quot;&gt;&lt;/a&gt;中断技术&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="中断" scheme="http://QQ876684433.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux写时拷贝技术（copy-on-write）</title>
    <link href="http://QQ876684433.github.io/2019/10/17/Linux%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%EF%BC%88copy-on-write%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/17/Linux写时拷贝技术（copy-on-write）/</id>
    <published>2019-10-17T10:36:13.000Z</published>
    <updated>2019-10-17T12:55:08.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux写时拷贝技术（copy-on-write）"><a href="#Linux写时拷贝技术（copy-on-write）" class="headerlink" title="Linux写时拷贝技术（copy on write）"></a>Linux写时拷贝技术（copy on write）</h1><h2 id="fork-和-exec"><a href="#fork-和-exec" class="headerlink" title="fork() 和 exec()"></a>fork() 和 exec()</h2><blockquote><p>参考资料：</p><ul><li><a href="https://www.geeksforgeeks.org/difference-fork-exec/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/difference-fork-exec/</a></li><li><a href="https://stackoverflow.com/questions/1653340/differences-between-fork-and-exec" target="_blank" rel="noopener">https://stackoverflow.com/questions/1653340/differences-between-fork-and-exec</a></li></ul></blockquote><p>每一个应用程序都是通过进程来运行的，进程是一个程序运行的实例，fork()和exec()都可以创建新的进程</p><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br></pre></td></tr></table></figure><p><code>fork()</code>创建的新进程是原调用进程的的一个拷贝，新进程称为子进程，原进程是它的父进程，父子进程之间的差别在于：</p><ul><li><p>子进程有自己独立的进程ID（pid），而且pid与任意已经存在的<strong>进程组</strong>的ID都不同</p><p>（链接原文说的是“进程组”，目前没搞懂和直接说“进程”有什么不同，待考证）</p><blockquote><p>在兼容于<a href="https://zh.wikipedia.org/wiki/POSIX" target="_blank" rel="noopener">POSIX</a>标准的<a href="https://zh.wikipedia.org/wiki/作業系統" target="_blank" rel="noopener">操作系统</a>中，<strong>进程组</strong>（英语：Process group，又译<strong>过程组群</strong>）是指一个或多个<a href="https://zh.wikipedia.org/wiki/行程" target="_blank" rel="noopener">进程</a>的集合。进程组被使用于控制<a href="https://zh.wikipedia.org/wiki/信号_(计算机科学)" target="_blank" rel="noopener">信号</a>的分配。对于一个进程组发出的的信号，会被个别递送到这个组群下的每个进程成员中。</p><p>进程组本身，也可以被集合成一个组群来管理，称为<strong>会话组</strong>（sessions）。归属于某个特定会话组下的进程组，不能移动到别的会话组下；在某个进程组下的特定进程，在创造出新的进程时，这个进程也只能属于这个父进程所归属的相同会话组。</p><p>—— 来源 <a href="https://zh.wikipedia.org/wiki/行程群組" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E7%BE%A4%E7%B5%84</a></p></blockquote></li><li><p>The child’s parent process ID is the same as the parent’s process ID.（这个没必要翻译orz）</p></li><li><p>The child does not inherit its parent’s <strong>memory locks</strong> and <strong>semaphore adjustments</strong></p><p>子进程不会继承父进程的内存锁和信号量调整</p></li><li><p>The child does not inherit outstanding asynchronous I/O operations from its parent nor does it inherit any asynchronous I/O contexts from its parent</p><p>子进程不会从其父级继承未完成的异步I / O操作，也不会从其父级继承任何异步I / O上下文</p></li></ul><h4 id="fork-的返回值"><a href="#fork-的返回值" class="headerlink" title="fork()的返回值"></a>fork()的返回值</h4><ul><li>如果创建子进程成功，那么子进程的PID就会被返回到父进程中，即<code>pid_t pid = fork();</code>中的pid就是创建的子进程的PID，而对子进程而言<code>pid_t pid = fork();</code>中的pid的值是0；可以根据父进程和子进程返回值的不同来使得父进程和子进程接下来执行不同的任务</li><li>如果创建子进程失败，那么父进程中<code>pid_t pid = fork();</code>返回值是-1，然后不会有子进程被创建出来，并且错误码会被设置</li></ul><p><code>fork()</code>之后子进程是父进程的拷贝，父进程和子进程会从相同的指令处接着往下面继续执行，即父进程和子进程都会从<code>pid_t pid = fork();</code>下面一行开始执行</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><blockquote><p>there is a whole family of <code>exec</code> calls (<code>execl</code>, <code>execle</code>, <code>execve</code> and so on) but <code>exec</code> in context here means any of them</p></blockquote><p><code>exec()</code>是一系列函数的统称</p><p><code>exec()</code>使用新的进程映像替换当前的进程映像，即它将要运行的程序加载到当前的进程空间中，然后从新程序的入口点开始运行。一般可以结合<code>fork()</code>和<code>exec()</code>来使得当前进程能够启动一个新进程来运行新程序。下面是一个在bash中运行ls程序来获取目录文件列表的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+--------+</span><br><span class="line">| pid=7  |</span><br><span class="line">| ppid=4 |</span><br><span class="line">| bash   |</span><br><span class="line">+--------+</span><br><span class="line">    |</span><br><span class="line">    | calls fork</span><br><span class="line">    V</span><br><span class="line">+--------+             +--------+</span><br><span class="line">| pid=7  |    forks    | pid=22 |</span><br><span class="line">| ppid=4 | ----------&gt; | ppid=7 |</span><br><span class="line">| bash   |             | bash   |</span><br><span class="line">+--------+             +--------+</span><br><span class="line">    |                      |</span><br><span class="line">    | waits for pid 22     | calls exec to run ls</span><br><span class="line">    |                      V</span><br><span class="line">    |                  +--------+</span><br><span class="line">    |                  | pid=22 |</span><br><span class="line">    |                  | ppid=7 |</span><br><span class="line">    |                  | ls     |</span><br><span class="line">    V                  +--------+</span><br><span class="line">+--------+                 |</span><br><span class="line">| pid=7  |                 | exits</span><br><span class="line">| ppid=4 | &lt;---------------+</span><br><span class="line">| bash   |</span><br><span class="line">+--------+</span><br><span class="line">    |</span><br><span class="line">    | continues</span><br><span class="line">    V</span><br></pre></td></tr></table></figure><h3 id="fork-和exec-的区别"><a href="#fork-和exec-的区别" class="headerlink" title="fork()和exec()的区别"></a>fork()和exec()的区别</h3><ul><li>fork starts a new process which is a copy of the one that calls it, while exec replaces the current process image with another (different) one.</li><li>Both parent and child processes are executed simultaneously in case of fork() while Control never returns to the original program unless there is an exec() error.</li></ul><h2 id="Copy-On-Write"><a href="#Copy-On-Write" class="headerlink" title="Copy On Write"></a>Copy On Write</h2><blockquote><p>参考资料：<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="noopener">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html</a></p></blockquote><p>​        从上面的介绍中可以知道，<code>fork()</code>会创建一个和父进程完全相同的子进程，但是子进程接下来可能会执行<code>exec()</code>来加载新的程序，如果子进程一创建就调用<code>exec()</code>，那么系统开销是很大的，因为刚刚拷贝了一份父进程，就接着被新的进程替换掉，显然前面的备份是有点多余的。因此，为了提高效率，Linux中引入了copy on write（写时复制）技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p><ul><li>在fork之后、exec之前，父子进程用的是相同的物理空间（内存区），<strong>子进程的代码段、数据段、堆栈都是指向父进程的物理空间</strong>，即两者的虚拟空间不同，但其对应的物理空间是同一个</li><li>当父子进程中有<strong>更改相应段的行为发生</strong>时，再为子进程相应的段分配物理空间<ul><li>如果不是因为exec，内核会<strong>给子进程的数据段、堆栈段分配相应的物理空间</strong>（至此两者有各自的进程空间，互不影响），而<strong>代码段继续共享父进程的物理空间</strong>（两者的代码完全相同）</li><li>如果是因为exec，由于两者执行的代码不同，子进程的<strong>代码段也会分配单独的物理空间</strong></li></ul></li><li>fork之后内核会通过将子进程放在队列的前面，以让子进程先执行，以免父进程<strong>先运行导致写时复制，而后子进程才执行exec系统调用</strong>，这样可以避免无意义的复制而造成效率的下降</li></ul><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>​        对于一个父进程P1，它的虚拟地址空间上有：正文段，数据段，堆，栈这四个部分，相应地，内核要为这四个部分分配各自的物理块，即正文段块，数据段块，堆块，栈块</p><ol><li><p>现在P1用fork()函数为进程创建一个子进程P2</p><p>对于内核来说，它会执行如下的任务：</p><ul><li><p>复制P1的正文段，数据段，堆，栈这四个部分，并且它们内容相同</p></li><li><p>为这四个部分分配物理块，对于新的进程P2：</p><ul><li>正文段－＞P1的正文段的物理块，其实就是<strong>不为P2分配正文段块</strong>，让P2的正文段指向P1的正文段块</li><li>数据段－＞P2自己的数据段块（为其分配对应的块）</li><li>堆－＞P2自己的堆块</li><li>栈－＞P2自己的栈块</li></ul><p>如图所示：其中大箭头表示内容复制方向</p><p><img src="https://i.loli.net/2019/10/17/Vct5I6YNm7jHJSX.jpg" alt></p></li></ul></li><li><p>写时复制技术</p><p>内核<strong>只为新生成的子进程创建虚拟空间结构</strong>，它们来复制于父进程的虚拟空间结构，但是<strong>不为这些段分配物理内存</strong>，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间</p><p><img src="https://i.loli.net/2019/10/17/QKVqc6bECtrJn2X.jpg" alt></p></li><li><p>vfork()</p><p>内核连子进程的虚拟地址空间结构也不创建了，<strong>直接共享了父进程的虚拟空间</strong>，自然地子进程也共享了父进程的物理空间</p><p><img src="https://i.loli.net/2019/10/17/9SGa4vYgzFTHhIk.jpg" alt></p></li></ol><blockquote><p>传统的fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。Linux的fork()使用写时拷贝（copy-on-write）页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，<strong>资源的复制只有在需要写入的时候才进行</strong>，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候。<strong>在页根本不会被写入的情况下（<em>举例来说，fork()后立即调用exec()</em>）它们就无需复制了。fork()的实际开销就是复制父进程的页表以及给子进程创建惟一的进程描述符</strong>。在一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以<strong>避免拷贝大量根本就不会被使用的数据</strong>（地址空间里常常包含数十兆的数据）。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。这里补充一点：<strong>Linux COW与exec没有必然联系</strong></p></blockquote><p>（<em>原文中还提到C++中string的copy-on-write技术，因为这个与本主题无关，想要了解的话可以通过上面的参考链接查看</em>）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux写时拷贝技术（copy-on-write）&quot;&gt;&lt;a href=&quot;#Linux写时拷贝技术（copy-on-write）&quot; class=&quot;headerlink&quot; title=&quot;Linux写时拷贝技术（copy on write）&quot;&gt;&lt;/a&gt;Linux写时拷
      
    
    </summary>
    
      <category term="Linux" scheme="http://QQ876684433.github.io/categories/Linux/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://QQ876684433.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-程序接口与系统调用</title>
    <link href="http://QQ876684433.github.io/2019/10/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://QQ876684433.github.io/2019/10/16/操作系统-程序接口与系统调用/</id>
    <published>2019-10-16T00:03:25.000Z</published>
    <updated>2019-10-17T10:33:35.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序接口与系统调用"><a href="#程序接口与系统调用" class="headerlink" title="程序接口与系统调用"></a>程序接口与系统调用</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li><li>Linux Kernel Teaching - <a href="https://linux-kernel-labs.github.io/master/index.html" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/index.html</a></li></ul></blockquote><h2 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h2><p>操作系统通过“程序接口”和“操作接口”将其服务和功能提供给用户：</p><ul><li>程序接口是操作系统对外提供服务和功能的手段，它由一组系统调用组成，在应用程序中使用“系统调用”可<strong>获得操作系统的低层服务</strong>，访问或使用系统管理的<strong>各种软硬件资源</strong></li><li>操作接口由一组控制命令和（或）作业控制语言组成，是操作系统为用户提供的<strong>组织和控制其作业（应用程序）执行</strong>的手段</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/uS6gCQYp4I3mBRW.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="程序接口与系统调用-1"><a href="#程序接口与系统调用-1" class="headerlink" title="程序接口与系统调用"></a>程序接口与系统调用</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/UBGqYT2x7A3KvE8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>因此可以这样认为，<strong>内核的主体是系统调用的集合</strong></p><blockquote><p>At a high level system calls are “services” offered by the kernel to user applications and they resemble library APIs in that they are described as a function call with a name, parameters and return value.</p><p>在高层次上来看，系统调用是内核为用户应用程序提供的“服务”，它们类似于库API，因为它们被描述为<strong>具有名称，参数和返回值的函数调用</strong></p></blockquote><h4 id="为什么使用系统调用"><a href="#为什么使用系统调用" class="headerlink" title="为什么使用系统调用"></a>为什么使用系统调用</h4><ul><li>根本原因是<strong>为了对系统进行“保护”</strong></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/MkKoNrVWsL6afz2.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>系统调用是一种中介角色，<strong>把用户和硬件资源隔离开来</strong>，应用程序只有通过系统调用才能请求系统服务并使用系统资源</li></ul><h4 id="系统调用的作用"><a href="#系统调用的作用" class="headerlink" title="系统调用的作用"></a>系统调用的作用</h4><ul><li>内核可以基于权限和规则<strong>对资源访问进行裁决</strong>，保证系统的安全性</li><li>系统调用<strong>对资源进行抽象</strong>，提供一致性接口，避免用户在使用资源时发生错误，且使编程效率大大提高</li></ul><p><strong>系统调用是应用程序获得操作系统服务的唯一途径</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/m28cC6uSbAKaOlJ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="API、库函数和系统调用"><a href="#API、库函数和系统调用" class="headerlink" title="API、库函数和系统调用"></a>API、库函数和系统调用</h3><p>不同操作系统提供的系统调用功能虽然大同小异，但是实现细节不尽相同，因此如果应用程序直接使用系统调用，那么会存在问题：</p><ul><li>接口复杂，使用困难</li><li>应用程序跨平台可移植性受到很大限制</li></ul><h4 id="不同操作系统之间的可移植性"><a href="#不同操作系统之间的可移植性" class="headerlink" title="不同操作系统之间的可移植性"></a>不同操作系统之间的可移植性</h4><p>POSIX（Portable Operating System Interface）为不同平台下的应用程序提供相同的<strong>应用程序接口（API）</strong>，但是它并没有保证相同的API的内部实现是一致的。其中系统调用只是其中一种API</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/AuwnP7WCJk6LHfs.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/lPKFso3z5XwkBd6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="库函数和系统调用"><a href="#库函数和系统调用" class="headerlink" title="库函数和系统调用"></a>库函数和系统调用</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/ZRPfL1eghsjGz6S.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>库函数属于应用程序，在<strong>用户态运行</strong>（用户可以替换库函数）</li><li>系统调用对应的服务例程属于系统程序，在<strong>内核态运行</strong>（用户通常不能替换系统调用）</li></ul><h3 id="系统调用分类"><a href="#系统调用分类" class="headerlink" title="系统调用分类"></a>系统调用分类</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/tjFvOqmTol53EsP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="系统调用实现"><a href="#系统调用实现" class="headerlink" title="系统调用实现"></a>系统调用实现</h3><ul><li>操作系统实现系统调用功能的机制称为<strong>陷阱或异常处理机制</strong></li><li>由于系统调用引起处理器中断的机器指令称为<strong>访管指令、自陷指令或中断指令</strong></li></ul><p>其中访管指令为非特权指令，在目态下执行时会将CPU转换到内核态</p><p>每个系统调用都事先规定编号，称为功能号，发出访管指令、自陷指令或中断指令时，必须通过某种方式指明对应系统调用的功能号（另外还要附带传递给相应服务例程的参数）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/uXIv26L59FMnryR.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/WDl4MKQNdikSoHj.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/BYsGkhpDeNqu3RX.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>应用程序和系统调用之间传递参数所采用的方法：</p><ul><li>访管指令或自陷指令自带参数</li><li>通过CPU通用寄存器传递参数</li><li>在内存区中开辟专用堆栈区传递参数</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/blihXo7WxKufDLZ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="系统调用与函数调用的区别"><a href="#系统调用与函数调用的区别" class="headerlink" title="系统调用与函数调用的区别"></a>系统调用与函数调用的区别</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/iHQXv2lD6sajo1u.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="System-Calls-in-Linux-Kernel"><a href="#System-Calls-in-Linux-Kernel" class="headerlink" title="System Calls in Linux Kernel"></a>System Calls in Linux Kernel</h2><blockquote><p>reference：<a href="https://linux-kernel-labs.github.io/master/lectures/syscalls.html" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/lectures/syscalls.html</a></p><p>Linux System Call Table for x86-64（Linux x86-64系统调用表）：<a href="http://shell-storm.org/shellcode/files/syscalls.html" target="_blank" rel="noopener">http://shell-storm.org/shellcode/files/syscalls.html</a></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/NIOgQMqSlaHjkye.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在进行系统调用的时候，特定的汇编指令会做如下的工作：</p><ul><li>setup information to identify the system call and its parameters</li><li>trigger a kernel mode switch</li><li>retrieve the result of the system call</li></ul><p>在Linux中，系统调用是通过数字编号来标识的，系统调用的参数的大小是机器的字长（word，32或者64位）。系统调用的参数最多有6个，系统调用编号和参数都是保存在特定的寄存器中，例如在32bit的x86架构中：</p><ul><li>系统调用数字编号保存在EAX寄存器中</li><li>系统调用的参数保存在EBX、ECX、EDX、ESI、EDI、EBP寄存器中</li></ul><p>为了使得开发应用程序时进行系统调用更简便，一些系统函数库（例如libc）会提供函数来完成系统调用内部的实际实现</p><p>当发生用户态到内核态的转移的时候，当前程序的执行流被中断，然后跳转到内核的入口点，这类似于中断和异常处理的方式（事实上，在一些架构中用户态到内核态的转换是异常处理的结果）</p><blockquote><p>During the user - kernel mode transition the stack is also switched from ther user stack to the kernel stack.</p><p>在发生用户态向内核态转移的时候，当前的系统堆栈也会由用户栈切换到内核态</p></blockquote><p>在系统调用的入口点会将当前寄存器的值（这些寄存器包含的是用户空间的值，并且包括<strong>系统调用数字编号和系统调用参数</strong>）保存起来</p><h3 id="系统调用例子"><a href="#系统调用例子" class="headerlink" title="系统调用例子"></a>系统调用例子</h3><blockquote><p>更详细的系统调用过程（结合Linux源码解析），参考：<a href="http://zhongmingmao.me/2019/04/20/linux-system-call-process/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/04/20/linux-system-call-process/</a></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/17/8CD37Y9OcLZaHut.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>系统调用调度器（system call dispatcher）</strong>的功能是验证系统调用的数字编号，然后运行和系统调用相关的内核函数，如下代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handles int $0x80 */</span></span><br><span class="line"><span class="comment">/* 在进入内核之前，通过push和SAVE_ALL将当前用户态的寄存器，保存在pt_regs结构里面，然后调用do_int80_syscall_32 */</span></span><br><span class="line">__<span class="function">visible <span class="keyword">void</span> <span class="title">do_int80_syscall_32</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    enter_from_user_mode();</span><br><span class="line">    local_irq_enable();</span><br><span class="line">    do_syscall_32_irqs_on(regs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* simplified version of the Linux x86 32bit System Call Dispatcher */</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">do_syscall_32_irqs_on</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr = regs-&gt;orig_ax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 系统调用的数量由 NR_syscalls 宏给定，这个判断似乎是检查系统调用号是不是合法的，如果合法则进行接下来的实际内核函数的执行，并且把返回结果保存到ax中 */</span></span><br><span class="line">    <span class="comment">/* 似乎这里的 regs-&gt;ax 指的是eax（32bit）或者rax（64bit）的统称，而不是x86中16bit的ax寄存器 */</span></span><br><span class="line">    <span class="keyword">if</span> (nr &lt; IA32_NR_syscalls)</span><br><span class="line">        regs-&gt;ax = ia32_sys_call_table[nr](regs-&gt;bx, regs-&gt;cx,</span><br><span class="line">                                           regs-&gt;dx, regs-&gt;si,</span><br><span class="line">                                           regs-&gt;di, regs-&gt;bp);</span><br><span class="line">    syscall_return_slowpath(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面参考自：<a href="https://blog.csdn.net/hq815601489/article/details/80009791" target="_blank" rel="noopener">https://blog.csdn.net/hq815601489/article/details/80009791</a></p></blockquote><p>Linux提供了200多个系统调用，通过汇编指令 <code>int 0x80</code> 实现，用系统调用号来区分入口函数。</p><p><strong>Linux实现系统调用的基本过程</strong>是：</p><ul><li><p>应用程序准备参数，发出调用请求；</p></li><li><p>C库封装函数引导。该函数在Linux提供的标准C库，即 glibc 中。对应的封装函数由下列汇编指令实现（以读函数调用为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; NASM</span><br><span class="line">; read(int fd, void *buffer, size_t nbytes)</span><br><span class="line">mov eax, 3          ; read系统调用号为3</span><br><span class="line">mov ebx, fd</span><br><span class="line">mov ecx, buffer</span><br><span class="line">mov edx, nbytes</span><br><span class="line">int 0x80            ; 触发系统调用</span><br></pre></td></tr></table></figure></li><li><p>执行系统调用。前两步在用户态工作，陷入后在内核态工作。系统调用处理程序根据系统调用号，<strong>按系统调用表中的偏移地址跳转，调用对应的内核函数</strong>；</p></li><li><p>系统调用完成相应功能，将<strong>返回值存入 eax</strong> ，返回到中断处理函数；</p></li><li><p>系统调用返回。内核函数处理完毕后，库函数读寄存器（ eax ）返回值，并返回给应用程序。恢复现场。</p></li></ul><p><strong>应用程序调用系统调用的过程</strong>是：</p><ul><li><p>把系统调用号存入 eax ；</p></li><li><p>把函数参数存入其它通用寄存器（约定顺序为 ebx 、 ecx 、 edx 、 esi 、 edi ，<u>更多的参数（通常不会出现这种情况）使用堆栈传递</u>，也可以<u>通过寄存器存放指向参数在用户空间的地址指针来传递</u>）；</p></li><li><p>触发 0x80 号中断（ int 0x80 ）。</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; NASM</span><br><span class="line">; 向显示器输出hello, world</span><br><span class="line">; write(int fd, const void *buffer, size_t nbytes)</span><br><span class="line">; exit(int status)</span><br><span class="line">        global  _start</span><br><span class="line">        section .text</span><br><span class="line">_start:</span><br><span class="line">        mov     eax, 4              ; write系统调用号为4</span><br><span class="line">        mov     ebx, 1              ; 文件描述符1：标准输出stdout</span><br><span class="line">        mov     ecx, message        ; 要输出的信息</span><br><span class="line">        mov     edx, message.len    ; 要输出的长度</span><br><span class="line">        int     0x80</span><br><span class="line"></span><br><span class="line">        mov     eax, 1              ; exit系统调用号为1</span><br><span class="line">        mov     ebx, 0              ; 状态码0：正常退出</span><br><span class="line">        int     0x80</span><br><span class="line"></span><br><span class="line">        section .data</span><br><span class="line">message:</span><br><span class="line">        db      &quot;hello, world&quot;, 10</span><br><span class="line">.len    equ     $ - message</span><br></pre></td></tr></table></figure></li></ul><p><strong>Linux系统调用实现机制</strong>：</p><ul><li><p>系统调用初始化</p><p>系统调用处理程序 <code>system_call()</code> 的入口地址放在系统的<strong>中断表述符表IDT（Interrupt Descriptor Table）</strong>中，Linux系统初始化时，由 <code>trap_init()</code> 将其填写完整，其设置系统调用处理程序的语句为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_system_gate(<span class="number">0x80</span>, &amp;system_call)</span><br></pre></td></tr></table></figure><p>经过初始化以后，每当执行 <code>int 0x80</code> 指令时，产生一个异常<strong>使系统陷入内核空间并执行128号异常处理程序</strong>，即系统调用处理程序 <code>system_call()</code> </p></li><li><p>系统调用公共入口</p><p><code>system_call()</code> 是所有系统调用的公共入口，其功能是保护现场，<strong>进行正确性检查，根据系统调用号跳转到具体的内核函数</strong>。内核函数执行完毕时需调用<code>ret_from_sys_call()</code>，这时完成返回用户空间前的最后检查，用<code>RESTORE_ALL</code>宏恢复现场并执行<code>iret</code>指令返回用户断点</p></li><li><p>保护现场</p><ul><li>硬件（CPU）保护：<code>ss</code> 、 <code>esp</code> 、 <code>eflags</code> 、 <code>cs</code> 、 <code>eip</code> ，压入核心栈</li><li>软件（操作系统）保护<ul><li>使用 <code>SAVE_ALL</code> 宏将寄存器压入堆栈，加载内核的 <code>ds</code> 和 <code>es</code> ，往 <code>edx</code> 中放入 <code>$(_KERNEL_DS)</code> 以指明使用内核数据段，把内核数据段选择符装入 <code>ds</code> 和 <code>es</code> 。注意：该宏压入寄存器的顺序<strong>不是随意的</strong>，而是和系统调用的参数传递密切相关</li><li><code>es</code> 、 <code>ds</code> 、 <code>eax</code> 、 <code>ebp</code> 、 <code>edi</code> 、 <code>esi</code> 、 <code>edx</code> 、 <code>ecx</code> 、 <code>ebx</code> ，压入核心栈</li></ul></li></ul><p>系统调用处理时的核心栈内容：</p><table><thead><tr><th align="center"></th><th align="center">寄存器</th></tr></thead><tbody><tr><td align="center">硬件完成</td><td align="center">ss</td></tr><tr><td align="center">硬件完成</td><td align="center">esp</td></tr><tr><td align="center">硬件完成</td><td align="center">eflags</td></tr><tr><td align="center">硬件完成</td><td align="center">cs</td></tr><tr><td align="center">硬件完成</td><td align="center">eip</td></tr><tr><td align="center">软件完成</td><td align="center">es</td></tr><tr><td align="center">软件完成</td><td align="center">ds</td></tr><tr><td align="center">软件完成</td><td align="center">eax</td></tr><tr><td align="center">软件完成</td><td align="center">ebp</td></tr><tr><td align="center">软件完成</td><td align="center">edi</td></tr><tr><td align="center">软件完成</td><td align="center">esi</td></tr><tr><td align="center">软件完成</td><td align="center">edx</td></tr><tr><td align="center">软件完成</td><td align="center">ecx</td></tr><tr><td align="center">软件完成</td><td align="center">ebx</td></tr></tbody></table></li><li><p>返回值传递</p><p>当内核函数返回到 <code>system_call()</code> 时， <code>eax</code> 中存放着内核函数的返回值。要将这个返回值传递给应用程序，内核先将 <code>eax</code> 放入原先 <code>SAVE_ALL</code> 宏保存 <code>eax</code> 的位置，这样当 <code>system_call()</code> 调用 <code>RESTORE_ALL</code> 恢复寄存器时， <code>eax</code> 便被恢复成系统调用的返回值，完成了返回值从内核空间到用户空间的传递</p></li></ul><p><strong>系统调用号和系统调用表</strong></p><p>系统调用的数量由 <code>NR_syscalls</code> 宏给定，每个系统调用所对应的编号已预先在系统文件中定义，且都用一个宏表示，其定义有如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_exit 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_fork 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_read 3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Linux的系统调用号和内核函数映射关系的系统调用表也被预先定义在系统文件中，具有如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">ENTRY(sys_call_table)</span><br><span class="line">    .long SYMBOL_NAME(sys_ni_syscall)    /* 空项 */</span><br><span class="line">    .long SYMBOL_NAME(sys_exit)</span><br><span class="line">    .long SYMBOL_NAME(sys_fork)</span><br><span class="line">    .long SYMBOL_NAME(sys_read)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>内核函数入口地址为： <code>eax * 4 + sys_call_table</code></p><blockquote><p>上面参考自：<a href="https://blog.csdn.net/hq815601489/article/details/80009791" target="_blank" rel="noopener">https://blog.csdn.net/hq815601489/article/details/80009791</a></p></blockquote><p>概括来说，系统调用过程中会发生如下的事情：</p><ul><li>The application is setting up the system call number and parameters and it issues a trap instruction</li><li>The execution mode switches from user to kernel; the CPU switches to a kernel stack; the user stack and the return address to user space is saved on the kernel stack</li><li>The kernel entry point saves registers on the kernel stack</li><li><strong>The system call dispatcher</strong> identifies the system call function and runs it</li><li>The user space registers are restored and execution is switched back to user (e.g. calling IRET)</li><li>The user space application resumes</li></ul><h3 id="系统调用表"><a href="#系统调用表" class="headerlink" title="系统调用表"></a>系统调用表</h3><p>系统调用调度器通过系统调用表来将系统调用号映射到内核函数（系统调用服务例程）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_I386(nr, sym, qual) [nr] = sym,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">sys_call_ptr_t</span> ia32_sys_call_table[] = &#123;</span><br><span class="line">  [<span class="number">0</span> ... __NR_syscall_compat_max] = &amp;sys_ni_syscall,</span><br><span class="line">  #include &lt;<span class="keyword">asm</span>/syscalls_32.h&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__SYSCALL_I386(<span class="number">0</span>, sys_restart_syscall, )</span><br><span class="line">__SYSCALL_I386(<span class="number">1</span>, sys_exit, )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">__SYSCALL_I386(<span class="number">2</span>, sys_fork, )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">__SYSCALL_I386(<span class="number">2</span>, sys_fork, )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__SYSCALL_I386(<span class="number">3</span>, sys_read, )</span><br><span class="line">__SYSCALL_I386(<span class="number">4</span>, sys_write, )</span><br></pre></td></tr></table></figure><h3 id="系统调用参数处理"><a href="#系统调用参数处理" class="headerlink" title="系统调用参数处理"></a>系统调用参数处理</h3><p>因为系统调用的参数是由用户空间设置的，内核不能保证参数的正确性，因此必须每次都对参数进行验证。指针参数有以下特殊情况是必须要检验的：</p><ul><li>不允许指针指向内核空间</li><li>检测指针是否有效</li></ul><p>因为<strong>系统调用是在内核态执行的，它们有访问内核空间的权限</strong>，因此如果没有对指针进行合适的检测，那么就会使得用户应用程序拥有读或者写内核空间的权限（甚至不正确的写内核空间会破坏内核内存）。</p><p>类似的，如果用户程序传递的指针是无效的（例如一个写指针指向一个只读的内存区域），它也会导致内核崩溃。</p><p>有以下两种方法来解决以上问题：</p><ul><li>在使用指针之前，先对照用户地址空间检查指针</li><li>避免检查指针，依靠MMU来检测指针何时无效，并使用页错误处理程序确定指针无效</li></ul><p><em>（原文中还有些比较高级的内容，这里不再列出，毕竟涉及的知识比较高深，参见：<a href="https://linux-kernel-labs.github.io/master/lectures/syscalls.html）" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/lectures/syscalls.html）</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序接口与系统调用&quot;&gt;&lt;a href=&quot;#程序接口与系统调用&quot; class=&quot;headerlink&quot; title=&quot;程序接口与系统调用&quot;&gt;&lt;/a&gt;程序接口与系统调用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统调用" scheme="http://QQ876684433.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
</feed>
