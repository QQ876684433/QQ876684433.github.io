<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>至繁归于至简 - chph&#39;s blog</title>
  
  <subtitle>steve_chph personal website</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://QQ876684433.github.io/"/>
  <updated>2019-09-15T05:02:14.666Z</updated>
  <id>http://QQ876684433.github.io/</id>
  
  <author>
    <name>steve_chph</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://QQ876684433.github.io/2019/09/15/hello-world/"/>
    <id>http://QQ876684433.github.io/2019/09/15/hello-world/</id>
    <published>2019-09-15T05:02:14.666Z</published>
    <updated>2019-09-15T05:02:14.666Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-12）</title>
    <link href="http://QQ876684433.github.io/2019/09/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-12%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/12/数据库课堂笔记（2019-09-12）/</id>
    <published>2019-09-12T03:25:09.000Z</published>
    <updated>2019-09-17T14:25:57.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-12）"><a href="#数据库课堂笔记（2019-09-12）" class="headerlink" title="数据库课堂笔记（2019-09-12）"></a>数据库课堂笔记（2019-09-12）</h2><h3 id="Ch2-The-Relational-Model"><a href="#Ch2-The-Relational-Model" class="headerlink" title="Ch2. The Relational Model"></a>Ch2. The Relational Model</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>152.乘积最大子序列</title>
    <link href="http://QQ876684433.github.io/2019/09/10/152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://QQ876684433.github.io/2019/09/10/152-乘积最大子序列/</id>
    <published>2019-09-10T03:38:00.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-10）</title>
    <link href="http://QQ876684433.github.io/2019/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-10%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/10/数据库课堂笔记（2019-09-10）/</id>
    <published>2019-09-10T03:25:09.000Z</published>
    <updated>2019-09-17T14:22:52.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-10）"><a href="#数据库课堂笔记（2019-09-10）" class="headerlink" title="数据库课堂笔记（2019-09-10）"></a>数据库课堂笔记（2019-09-10）</h2><h3 id="Ch2-The-Relational-Model"><a href="#Ch2-The-Relational-Model" class="headerlink" title="Ch2. The Relational Model"></a>Ch2. The Relational Model</h3><h4 id="键、超键和空值（Keys，Superkeys，and-Null-Values）"><a href="#键、超键和空值（Keys，Superkeys，and-Null-Values）" class="headerlink" title="键、超键和空值（Keys，Superkeys，and Null Values）"></a>键、超键和空值（Keys，Superkeys，and Null Values）</h4><h5 id="键（Keys）"><a href="#键（Keys）" class="headerlink" title="键（Keys）"></a>键（Keys）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/oAfCMukbUgwaRxv.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>条件1说明了任意一行u在属性集K上的值是唯一的；<strong>表可能具有不止一个键</strong>；关系规则3保证了所有列的集合可以唯一区分任意两行，因此<strong>关系中至少存在一个键</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/meGc57MyshgdLJ9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/RzwquBxEKGfOMIn.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="超键（Superkeys）"><a href="#超键（Superkeys）" class="headerlink" title="超键（Superkeys）"></a>超键（Superkeys）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/S3cbnm4Kv1Q9qaG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>属性集是不是键或者超键，取决于“设计者的意图”，有时候某些属性集在特定时刻它满足条件1，但是可能随着时间的改变，很有可能不再满足该条件，这样的属性集不是键或者超键</p><p><strong>空集既不是超键也不是键</strong>，因为属性集为空集时无法唯一确定某一行，因为所有行在空集上的取值都是空集</p><h5 id="候选键和主键（Candidate-Key-amp-Primary-Key）"><a href="#候选键和主键（Candidate-Key-amp-Primary-Key）" class="headerlink" title="候选键和主键（Candidate Key &amp; Primary Key）"></a>候选键和主键（Candidate Key &amp; Primary Key）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/46FHld1hWT7RkrV.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>主键是数据库设计者从候选键中选择出来，用来唯一确定数据表某一行的键</p><p><img src="https://i.loli.net/2019/09/15/igh9kcW6peAYPBF.png" alt></p></li><li><p>它有可能被其他表用来作为<strong>对当前表特定行的引用</strong>来使用</p><p><img src="https://i.loli.net/2019/09/15/KgdHEksYv37O1fA.png" alt></p></li></ul><h5 id="空值（Null-Values）"><a href="#空值（Null-Values）" class="headerlink" title="空值（Null Values）"></a>空值（Null Values）</h5><ul><li><p>空值应该被解释为<strong>未知的或者尚未定义的</strong>，意思是当我们<strong>以后知道更多情况的时候会重新填写该值。</strong></p><blockquote><p>A null value is placed in a field of a table when a specific value is either <strong>unknown or inappropriate</strong>.</p></blockquote></li><li><p>要注意的是：<u>空值和数字0（对于数值属性）或者是空串（对于字符串属性）是不同的</u></p></li><li><p><strong>主键不能包含空值</strong>，因为表的主键是唯一区分表的单独行的，在还没确定主键的值之前，该行是不允许被存储到数据表中的</p><p><img src="https://i.loli.net/2019/09/15/jYNURDvFofVLiq6.png" alt></p><p>实体完整性规则与3NF等价</p></li><li><p><strong>空值无法与任何非空值进行比较</strong>，用属性的非空值作为条件进行查询，永远也无法查询到该属性为空值的所在行</p></li></ul><h4 id="关系代数（Relational-Algebra）"><a href="#关系代数（Relational-Algebra）" class="headerlink" title="关系代数（Relational Algebra）"></a>关系代数（Relational Algebra）</h4><p>关系代数可以看作根据查询结果来生成新表的方法的集合，这些方法称为<strong>关系代数运算</strong>。</p><p>关系代数的运算分为两种类型：</p><ul><li><p><strong>集合论运算</strong>：以行为元素单位进行的集合运算</p><p><img src="https://i.loli.net/2019/09/17/13qwasP9bMj8XuW.png" alt></p></li><li><p><strong>自然关系运算</strong>：基于行的结构的运算</p><p><img src="https://i.loli.net/2019/09/17/orM4PlgVREWiFK9.png" alt></p></li></ul><h5 id="相容表（兼容表）"><a href="#相容表（兼容表）" class="headerlink" title="相容表（兼容表）"></a><strong>相容表（兼容表）</strong></h5><p>当表R和S有相同的表头（表标题），那么表R和表S是相容表，即：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/JmI3rojPadZEAs6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>相同的表头的含义：相同数量的属性、属性对的域相同、属性对有相同的名字</p><p>ps：关系型数据库中，两列有相同的含义意思是<strong>他们有相同的列名（属性名）</strong>；同时<strong>属性集是无序</strong>的，因此两个数据表的表头中属性顺序不一致，并不影响它们是相容表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/KlgNfBErdzQ1oSk.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="交、并、差"><a href="#交、并、差" class="headerlink" title="交、并、差"></a><strong>交、并、差</strong></h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/3nQBH1dKpTbiy8f.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>并（UNION）和交（INTERACTION）是满足<strong>交换律</strong>和<strong>结合律</strong>的；差（DIFFERENCE）不满足<strong>交换律</strong></p><h5 id="赋值、别名"><a href="#赋值、别名" class="headerlink" title="赋值、别名"></a><strong>赋值、别名</strong></h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/i8kaOMNA1heVzu2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>S为表R的别名，简写为<code>S:=R</code>，通常用于：“关系自身的连接运算”、用来保存计算的“中间结果”。</p><h5 id="乘积运算（R×S）"><a href="#乘积运算（R×S）" class="headerlink" title="乘积运算（R×S）"></a><strong>乘积运算（R×S）</strong></h5><p>乘积运算是基于集合运算中的笛卡尔积的，它可以允许我们建立一个包含两个表中行之间所有可能的相互联系的新表。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/UbSqeLfFAyH1wxO.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/eLwW2dxrtYy5sKk.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我们可以使用相对较小的表来构造大表，例如1000行的表的积可以有100万行</p><p>当要计算表与自身的乘积时，会存在限定符名重复的问题，例如乘积R×R是不允许的，我们<strong>可以通过使用表的别名来避免</strong>，例如S:=R，那么R与自身的乘积可以表示为：R×S</p><h5 id="自然关系运算"><a href="#自然关系运算" class="headerlink" title="自然关系运算"></a>自然关系运算</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/E3XRvUaQdhzOAmi.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>用关系代数表达式回答用自然语言表达的对数据的查询要求，我们称这样的表达式为<strong>关系代数查询</strong>，简称为查询</p><ul><li><p><strong>投影运算（project）</strong></p><p><img src="https://i.loli.net/2019/09/17/u9waNYiOZhQ4ARj.png" alt></p><p><img src="https://i.loli.net/2019/09/17/COaoQDtgiY9Sb8e.png" alt></p><p>投影运算实际上是在表中选择列的运算，运算结果其实是新的表，因此它会<strong>将重复的行删除</strong>，以保证任意两行是不一样的</p></li><li><p><strong>选择运算（selection）</strong></p><p>从给定的表中选择出满足特定准则的行来构成新的表</p><p><img src="https://i.loli.net/2019/09/17/oyprhnLcR7Y2JtQ.png" alt></p><ul><li><p>C是比较表达式，比较符号有：<code>&lt;, &gt;, =, &lt;=, &gt;=, 和&lt;&gt;</code>，其中<code>&lt;&gt;</code>为不等符号，类似于<code>!=</code></p></li><li><p>如果比较的条件中有字符常量，那么要使用引号，例如<code>city=&#39;Dallas&#39;</code>，其中字符常量是按照字典顺序来比较的</p></li><li><p>比较条件可以是复合表达式，例如<code>C AND C&#39;</code>等</p><p><img src="https://i.loli.net/2019/09/17/k7g5TqnPr6dHlFs.png" alt></p></li></ul><p>进行选择运算时要避免<strong>内容依赖</strong>的问题：即对于某个特定时刻表的内容，两个查询结果相同还不足以保证这两个查询表达式是等价的，他们必须要求对于所有可能的表的内容都给出相同的结果</p></li><li><p>关系代数的优先级</p><p><img src="https://i.loli.net/2019/09/17/K2vSMUuGefiLXb6.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>软件系统设计02-质量属性策略</title>
    <link href="http://QQ876684433.github.io/2019/09/09/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A102-%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E7%AD%96%E7%95%A5/"/>
    <id>http://QQ876684433.github.io/2019/09/09/软件系统设计02-质量属性策略/</id>
    <published>2019-09-09T12:37:15.000Z</published>
    <updated>2019-09-16T06:53:19.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件系统设计02-质量属性策略"><a href="#软件系统设计02-质量属性策略" class="headerlink" title="软件系统设计02-质量属性策略"></a>软件系统设计02-质量属性策略</h1><h2 id="第四章-理解质量属性"><a href="#第四章-理解质量属性" class="headerlink" title="第四章 理解质量属性"></a>第四章 理解质量属性</h2><h3 id="质量属性定义"><a href="#质量属性定义" class="headerlink" title="质量属性定义"></a>质量属性定义</h3><p><strong>质量属性（Quality Attribute，QA）</strong>：它是一个系统可度量或者可测试的属性，用来指示系统在多大程度上满足了它的利益相关者的需求</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/Dmh8IoW5f4c2MF3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="架构和需求"><a href="#架构和需求" class="headerlink" title="架构和需求"></a>架构和需求</h3><h4 id="需求的分类"><a href="#需求的分类" class="headerlink" title="需求的分类"></a>需求的分类</h4><ul><li><strong>功能性需求（Functional Requirements）</strong>：描述了系统必须做的事情（必须实现的功能），以及在运行时接受外部刺激时系统应该表现出的行为或者反应</li><li><strong>质量属性需求（Quality Attribute Requirements）</strong>：它是功能性需求或者整个产品的质量或者限定条件——对于功能性需求来说，它描述了系统响应有多快或者在接受错误输入时必须具备多大的弹性等；对于整个系统来说，它描述了产品的部署需要的时间或者对运营成本的限制</li><li><strong>约束（Constraints）</strong>：约束条件是<strong>具有零自由度的设计决策</strong>，即是说它是一个已经做出的设计决策，不能再修改。例如系统使用的编程语言或者要依赖的指定模块等</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/jdH9W4NpQTciDoX.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="不同种类的需求在架构中的体现"><a href="#不同种类的需求在架构中的体现" class="headerlink" title="不同种类的需求在架构中的体现"></a>不同种类的需求在架构中的体现</h4><ul><li>功能性需求：通过整个设计中合适的职责分配来满足</li><li>质量属性需求：通过设计到架构中的各种结构以及填充这些结构的元素的行为和交互来满足</li><li>约束：通过接受设计决策并将其与其他受影响的设计决策进行协调来满足约束条件</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/sAGFdjfNtq1pyU5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h3><p>功能性需求<strong>不能决定架构</strong>。原因是对于一个给定的功能性需求集合，我们可以有很多不同的方法来将功能性需求划分到不同的架构模块中；事实上，即使我们不划分模块，甚至内部毫无架构结构可言，也依旧有可能将功能性需求实现。</p><p>我们进行架构设计是为了使得系统更加易于理解，以便支持各种各样的<strong>其他目的——即质量属性需求</strong>。</p><p>尽管功能性需求<strong>独立于特定的系统结构</strong>，但是它是通过将系统的职责分配到不同的架构元素中来实现的；虽然职责可以被任意分配到某一个模块中，但是当质量属性占很重要地位的时候，软件架构会约束系统职责的分配。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/1k7jC4bmetfMHdS.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="质量属性考量"><a href="#质量属性考量" class="headerlink" title="质量属性考量"></a>质量属性考量</h3><p>功能性需求和质量属性都不是自身独立的。</p><p>从架构师的角度，系统质量属性会有以下三个问题：</p><ul><li>某个质量属性的定义是不可测试的</li><li>对质量属性的讨论通常侧重于特定问题所属的质量，而且这个问题往往在不同的质量属性范围中有重叠</li><li>每个质量社区都发展出了自己的属性词汇</li></ul><p>前两个问题可以通过才用“质量属性场景”这个工具来区分不同的质量属性；第三个问题可以通过对每一个属性的多个社区词汇进行讨论，寻找出某个质量属性的不通社区词汇之间最本质最基础的概念</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/ARi5bKTxBnFCMLz.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/VNMErefpAtXSTcy.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="质量属性分类"><a href="#质量属性分类" class="headerlink" title="质量属性分类"></a>质量属性分类</h4><ul><li>系统运行时的属性：可用性（Availability）、性能（Performance）、易用性（Usability）等</li><li>系统开发时的属性：可修改性（Modifiability）、可测试性（Testability）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/zIuGqswZ8JO3tvi.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在复杂的系统中，质量属性相互之间不可能是独立开的，一个质量属性的实现对其他质量属性产生或积极或负面的影响，因此在架构设计时需要在这些设计决策之间作出合适的权衡。</p><h3 id="制定质量属性需求"><a href="#制定质量属性需求" class="headerlink" title="制定质量属性需求"></a>制定质量属性需求</h3><p>质量属性需求应当是<strong>明确的和可测试的</strong>。质量属性表达的常用形式包含这些部分：</p><ul><li><strong>刺激（Stimulus）</strong>：到达系统的事件，例如易用性中的用户操作，安全性中的外部攻击，可修改性中的修改需求，可测试性中的某个开发阶段的完成等</li><li><strong>刺激源（Stimulus source）</strong>：不同的刺激源，系统对待和处理的方式会不一样，例如受信任用户和不受信任用户经历的审查是不一样的</li><li><strong>响应（Response）</strong>：对于刺激，系统应当采取的措施，例如在可修改性的场景中，一个修改需求的到达要求开发者将这个修改需求实现、测试并部署所作出的修改</li><li><strong>响应度量（Response measure）</strong>：判断系统的响应是否满足需求，例如性能的度量可以是延迟或者吞吐量，可修改性的度量可以是工作量或者修改、测试和部署修改所需的时间等</li><li><strong>环境（Environment）</strong>：需求的环境是一系列场景发生情况的集合，它充当了刺激的限定词，例如对待代码冻结以发布前后发生的错误，处理的方式是不一样的</li><li><strong>工件（Artifact）</strong>：它是系统中需求适用的部分，不同的问题，它可能影响整个系统，也有可能只影响系统的某一个部分，例如数据库出错和元数据库出错的处理方式是不一样的，用户接口的修改需求和中间件的修改需求所需要的时间也是不一样的，等等</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/PYTGwBznM42QHN8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/NZ4BG2OqXTiDuzw.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>质量属性需求可以划分为六个场景，它们可能单独发生，也有可能伴随发生，特别是系统架构设计初期</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/Q8yB2pgMoIGvmDt.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="质量属性场景示例图"><a href="#质量属性场景示例图" class="headerlink" title="质量属性场景示例图"></a>质量属性场景示例图</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/xOyBMiYCUJd1jXz.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/YLOvhojfMnNRxpB.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="通过策略来实现质量属性需求"><a href="#通过策略来实现质量属性需求" class="headerlink" title="通过策略来实现质量属性需求"></a>通过策略来实现质量属性需求</h3><h4 id="架构策略（Architectural-Tactics）"><a href="#架构策略（Architectural-Tactics）" class="headerlink" title="架构策略（Architectural Tactics）"></a>架构策略（Architectural Tactics）</h4><p>架构策略是用来实现需要的质量属性的技术，它是一种设计决策，会影响质量属性响应的实现以及会直接影响系统对某些刺激的响应。<strong>策略赋予一种设计可移植性，将性能传递给另一种设计，并将可集成性传递给第三种设计</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/D9BrKmp7Fjqgwfb.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="指导设计决策"><a href="#指导设计决策" class="headerlink" title="指导设计决策"></a>指导设计决策</h3><p><strong>架构是应用设计决策集合的结果</strong>。设计决策可以分为七个类别，在设计架构的时候可以分别从某个设计决策的维度进行设计考量，降低架构设计的复杂度：</p><ul><li><p><strong>职责分配（Allocation of Responsibilities）</strong></p><p>涉及职责分配的决策包括：</p><ul><li>识别重要的职责（基础系统功能、架构基础设施、质量属性的满足）</li><li>决定如何将这些职责分配到运行时和非运行时元素</li></ul><p>制定如上决策的策略有：功能分解、对真实世界对象建模、基于操作的主要模式分组、基于相似的质量属性分组</p><p><img src="https://i.loli.net/2019/09/16/X47xSvL1yr589FV.png" alt></p></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件系统设计02-质量属性策略&quot;&gt;&lt;a href=&quot;#软件系统设计02-质量属性策略&quot; class=&quot;headerlink&quot; title=&quot;软件系统设计02-质量属性策略&quot;&gt;&lt;/a&gt;软件系统设计02-质量属性策略&lt;/h1&gt;&lt;h2 id=&quot;第四章-理解质量属性&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件系统设计" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="架构" scheme="http://QQ876684433.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>91.解码方法</title>
    <link href="http://QQ876684433.github.io/2019/09/06/91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>http://QQ876684433.github.io/2019/09/06/91-解码方法/</id>
    <published>2019-09-06T11:29:49.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a>91.解码方法</h1><p>原题目如下：</p><blockquote><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26</p><p>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p><p>示例 1:</p><p>输入: “12”</p><p>输出: 2</p><p>解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。</p><p>示例 2:</p><p>输入: “226”</p><p>输出: 3</p><p>解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/decode-ways著作权归领扣网络所有。" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-ways著作权归领扣网络所有。</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题刚开始做的时候思路是挺清晰的，就是动态规划，从左往右遍历一遍即可。对于一个长度为n的串s，由于编码只有一位数和两位数这两种可能，因此很容易得出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numDecodings(s[<span class="number">1</span>:n]) = numDecodings(s[<span class="number">1</span>:n<span class="number">-1</span>]) + numDecodings(s[<span class="number">1</span>:n<span class="number">-2</span>])</span><br></pre></td></tr></table></figure><p>当然不是直接相加那么简单，这要分情况讨论一下：</p><p>（1）如果s[i]非0（由题可知，0不是合法的编码），s[1:n]一定可以按照在s[1:n-1]的所有解码方式后面加上s[i]来解码</p><p>（2）如果s[i-1]s[i]是合法的编码（<strong>即10&lt;=int(s[i-1]s[i])&lt;=26，大于等于10的是因为01、02等待这种以0开头的两位数不是合法的编码</strong>），那么s[1:n]也一定可以按照在s[1:n-2]的所有解码方式后面加上s[i-1]s[i]来得到</p><p>（3）否则上面两种情况都不符合，那么s[1:n]无论如何也无法进行解码，比如出现连续两个0的情况</p><p>我当时做的时候，因为没有考虑编码串中出现0的情况，所以出现了偏差。另外，由于前面做题的惯性思维，动态规划问题老是想构造数组，后来细细想这道题才发现根本不需要那么大的空间开销，只需要记录dp[i-1]和dp[i-2]即可计算出dp[i]。最终的解决方案如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> s[<span class="number">0</span>]!=<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> prev = <span class="number">1</span>, target = s[<span class="number">0</span>]==<span class="string">'0'</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">'0'</span>) temp = target;</span><br><span class="line">            <span class="comment">// int val = (s[i-1]-'0')*10+(s[i]-'0');</span></span><br><span class="line">            <span class="comment">// if(val&gt;=10&amp;&amp;val&lt;=26) temp+=prev;</span></span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span>||s[i<span class="number">-1</span>]==<span class="string">'2'</span>&amp;&amp;(s[i]&lt;=<span class="string">'6'</span>))temp+=prev;</span><br><span class="line">            </span><br><span class="line">            prev = target;</span><br><span class="line">            target = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测评的结果如下，然后我看了一下最高分的解答，思路跟我的差不多，就没必要去优化了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/06/YuE7XgBWSrZz51w.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题解没什么比较新的角度，跟我的想法差不多，就不再赘述</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;91-解码方法&quot;&gt;&lt;a href=&quot;#91-解码方法&quot; class=&quot;headerlink&quot; title=&quot;91.解码方法&quot;&gt;&lt;/a&gt;91.解码方法&lt;/h1&gt;&lt;p&gt;原题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一条包含字母 A-Z 的消息通过以下方式进行了
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>63.不同路径II</title>
    <link href="http://QQ876684433.github.io/2019/09/04/63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>http://QQ876684433.github.io/2019/09/04/63-不同路径II/</id>
    <published>2019-09-04T13:20:26.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="63-不同路径II"><a href="#63-不同路径II" class="headerlink" title="63.不同路径II"></a>63.不同路径II</h1><p>原题目如下：</p><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:</p><p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]</p><p>输出: 2</p><p>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">&gt; 2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-ii</a><br>著作权归领扣网络所有。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题与<a href="https://chph.xyz/2019/09/04/62-不同路径/" target="_blank" rel="noopener">前一道题</a>的区别只在于输入的二维数组增加了障碍物这一限制条件，只要在之前的思路（详见前面的链接）上稍作修改即可，用m和n分别表示输入的数组的行和列，我自己当时的解题思路如下：</p><ul><li>采用自底向上的递推方式，还是采用一位数组来降低空间开销，将dp数组初始化为包含m个元素的数组，然后将最后一个元素设置为1，原因是从最底层走，不考虑障碍物的情况下，只有一条路径能够到达目的地（<em>后来发现出现的问题就是，如果目的地就是障碍物的话，这样是无法AC的，所以在开始推导的最开始直接排除了这种情况<code>if(obstacleGrid[m-1][n-1]==1) return 0;</code>，省事</em>）</li><li>推导的核心公式是<code>dp[j] = dp[j]+dp[j+1];</code>，所以存在边界的问题，因此限定<code>0 ≤ j ≤ m-2</code>，而<code>j = m-1</code>的情况（即最底层）单独判断：如果在点<code>obstacleGrid[m-1][i]</code>遇到障碍物，则将dp数组的最后一个元素设置为0，表示从最底层小于等于点i的开始走，必然无法走到目的地</li><li>如果不是在最底层遇到障碍物（设为点<code>obstacleGrid[j][i]</code>），则只需要将<code>dp[j]</code>设置为0，表示从该点开始走，无法走到目的地，对其他路径的贡献为0</li></ul><p>所以最终的解决方案如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.size(), n = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; dp(m<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        dp.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[m<span class="number">-1</span>][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[m<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[j][i]==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = dp[j]+dp[j+<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提交之后，虽然AC了，但是感觉有点不够优雅：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/04/3RYpKZCPfHU4bDE.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><u><em>ps：这里有个坑是大数组的输入，如果使用<code>vector&lt;int&gt;</code>会溢出，改用<code>vector&lt;long&gt;</code>就可以了，这个也是没办法的</em></u></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>学习了leetcode官方的题解后发现自己的思路局限在了自底向上的角度，实际上自顶向下和自底向上最终的 结果是一样的，但使用自顶向下似乎更有助于思考问题。</p><p>最关键的问题还是集中在遇到障碍物时采取的措施上，因为题目没有要求输入数据不能修改，可以直接使用obstacleGrid作为dp数组，达到最优化空间复杂度，这样dp递推方程就变成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>而当<code>obstacleGrid[i][j]</code>是障碍物时，可直接将其置0：</p><blockquote><p>如果这个点有障碍物，设值为 <code>0</code> ，这可以保证不会对后面的路径产生贡献。</p></blockquote><p>这个可以体现在上面的递推方程上。即使是这样，还是避免不了边界条件的处理，这里就不展开了。</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>归根结底，解法不优雅的根源是边界问题的处理，所以也可以通过在原有的数组行列上各添加一维全0的数据，这样就比较优雅了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;63-不同路径II&quot;&gt;&lt;a href=&quot;#63-不同路径II&quot; class=&quot;headerlink&quot; title=&quot;63.不同路径II&quot;&gt;&lt;/a&gt;63.不同路径II&lt;/h1&gt;&lt;p&gt;原题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>62.不同路径</title>
    <link href="http://QQ876684433.github.io/2019/09/04/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://QQ876684433.github.io/2019/09/04/62-不同路径/</id>
    <published>2019-09-04T11:37:53.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h1><p>原题目如下：</p><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:</p><p>输入: m = 3, n = 2</p><p>输出: 3</p><p>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 2:</p><p>输入: m = 7, n = 3</p><p>输出: 28</p><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题一看就是很典型的动态规划问题，一般来说都可以从填表入手，动态规划方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>所以可以从初始状态开始（即finish处开始）推导填表，最后得到的就是问题的解。举个简单的例子，m=7，n=3（其实m和n是可以互换的对结果没有影响）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/04/VC6Ub3IFT95xPNg.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这样就可以通过一个二维数组来解决问题。一般来说二维数组开销太大，而且往往都能够通过压缩成一维数组来解决，因为<code>dp[i][j]</code>计算出来之后，<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>的值就不再需要了，所以最终的解答如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">                dp[j] = dp[j]+dp[j<span class="number">-1</span>];</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一次AC，惊喜满满：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/04/BDZc7A9of1GuiNS.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题解给出的方案和我的差不多，这里就没必要展开了，但是里面提供了一个数学角度的解决方案：</p><blockquote><p>思路：排列组合</p><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p><p>比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。</p><p>所以有 C_{m+n-2}^{m-1}C<br>m+n−2<br>m−1</p><p>作者：powcai</p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/</a></p><p>来源：力扣（LeetCode）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;62-不同路径&quot;&gt;&lt;a href=&quot;#62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62.不同路径&quot;&gt;&lt;/a&gt;62.不同路径&lt;/h1&gt;&lt;p&gt;原题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-03）</title>
    <link href="http://QQ876684433.github.io/2019/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-03%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/03/数据库课堂笔记（2019-09-03）/</id>
    <published>2019-09-03T11:53:37.000Z</published>
    <updated>2019-09-15T05:02:14.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-03）"><a href="#数据库课堂笔记（2019-09-03）" class="headerlink" title="数据库课堂笔记（2019-09-03）"></a>数据库课堂笔记（2019-09-03）</h2><h3 id="Ch1-Introduction"><a href="#Ch1-Introduction" class="headerlink" title="Ch1. Introduction"></a>Ch1. Introduction</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li><p>数据库管理系统（DataBase Management System，DBMS）</p><p>Connolly and Begg define Database Management System (DBMS) as a “<strong>software system that enables users to define, create, maintain and control access to the database</strong>“. … <strong>The core functionality is the storage, retrieval and update of data</strong>.</p><blockquote><p>The <a href="https://en.wikipedia.org/wiki/Database#Database_management_system" target="_blank" rel="noopener">database management system</a> (DBMS) is the <a href="https://en.wikipedia.org/wiki/Software" target="_blank" rel="noopener">software</a> that interacts with <a href="https://en.wikipedia.org/wiki/End_user" target="_blank" rel="noopener">end users</a>, applications, and the database itself to capture and analyze the data.</p><p>—— from wikipedia</p></blockquote><p>简单理解就是，数据库管理系统是终端用户、应用程序同数据库本身交互的软件</p></li><li><p>数据库（Database）</p><blockquote><p>A <strong>database</strong> is an organized collection of <a href="https://en.wikipedia.org/wiki/Data_(computing)" target="_blank" rel="noopener">data</a>, generally stored and accessed electronically from a computer system. Where databases are more complex they are often developed using formal <a href="https://en.wikipedia.org/wiki/Database#Design_and_modeling" target="_blank" rel="noopener">design and modeling</a> techniques.</p><p>—— from wikipedia</p></blockquote><p>简单理解就是，数据库是一个有组织的数据集合</p></li><li><p>数据库用户（DataBase User）</p><ul><li><p>最终用户——交互式用户</p><ul><li>临时用户——用SQL访问DBMS的用户</li><li>初级用户——通过菜单访问DBMS的用户</li></ul></li><li><p>应用程序员——编写菜单程序的程序员</p></li><li><p>数据库管理员（Database Administrator，DBA）——管理DBMS的专家</p><p><img src="https://i.loli.net/2019/09/03/EOwYuHP6gxaQci4.png" alt></p></li></ul></li></ul><h3 id="数据库系统的架构"><a href="#数据库系统的架构" class="headerlink" title="数据库系统的架构"></a>数据库系统的架构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/03/LPcK7sEfn54vDgG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>主要有<strong>两层C/S架构</strong>和<strong>三层B/S架构</strong>两种：</p><ul><li><p>两层C/S架构：数据库和DBMS运行在数据库服务器，数据库应用程序运行在客户机中，两者之间通过局域网实现数据访问（<em>但是更多的时候， 数据库服务器及其应用程序可能分布在距</em><br><em>离遥远的不同地方，这是得使用三层B/S架构来解决</em>）</p><p><img src="https://i.loli.net/2019/09/03/mv7GcaV85YwBzZp.png" alt></p></li><li><p>三层B/S架构：数据库和DBMS运行在数据库服务器中，<br>数据库应用程序运行在应用服务器（也称“Web服务器”）<br>中， 用户客户端只需要安装常用的浏览器， 负责接收用户<br>输入和结果展示</p><p><img src="https://i.loli.net/2019/09/03/NUSipYC8havWjgk.png" alt></p></li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型（data model）是对现实世界数据特征的抽象，它是数据库系统的核心和基础。根据应用的不同目的可以划分为两大类：第一类是概念模型，第二类是逻辑模型和物理模型。</p><ul><li>概念模型：按用户的观点来对数据和信息进行建模，主要用于数据库设计</li><li>逻辑模型：按计算机系统的观点对数据建模，主要用于数据库管理系统的实现</li><li>物理模型：对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法</li></ul><h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><ul><li>实体（entity）：客观存在并可互相区别的事物</li><li>属性（attribute）：实体所具有的某一特性</li><li>码（key）：唯一标识实体的属性集</li><li>实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体</li><li>实体集（entity set）：同一类型实体的集合</li><li>联系（relationship）：实体之间的联系通常是指不同实体集之间的联系，具有一对一、一对多和多对多等多种类型</li></ul><p>概念模型的表示方法：实体-联系方法（Entity-Relationship approach），E-R方法也称为E-R模型</p><p>数据模型的组成要素：</p><ul><li>数据结构：数据库的组成对象以及对象之间的联系</li><li>数据操作：对数据库汇总各种对象的实例运行执行的操作的集合，包括操作以及有关的操作规则</li><li>数据的完整性约束条件：一组完整性规则</li></ul><h4 id="常见的数据模型"><a href="#常见的数据模型" class="headerlink" title="常见的数据模型"></a>常见的数据模型</h4><h5 id="层次数据模型（Hierarchical-Data-Model-）"><a href="#层次数据模型（Hierarchical-Data-Model-）" class="headerlink" title="层次数据模型（Hierarchical Data Model ）"></a>层次数据模型（Hierarchical Data Model ）</h5><p>满足两个条件：</p><ul><li>有且只有一个结点没有双亲结点，这个结点称为根结点</li><li>根以外的其他结点有且只有一个双亲结点</li></ul><p>层次模型中，每个结点表示一个记录类型，记录类型之间的联系用结点之间的有向边表示，这种联系是父子之间的一对多的联系，可以看做有向树结构</p><h5 id="网状数据模型（Network-Data-Model）"><a href="#网状数据模型（Network-Data-Model）" class="headerlink" title="网状数据模型（Network Data Model）"></a>网状数据模型（Network Data Model）</h5><p>满足两个条件：</p><ul><li>允许一个以上的结点无双亲</li><li>一个结点可以有多于一个的双亲</li></ul><p>层次模型中子女结点与双亲结点的关系是唯一的，在网状模型中，这种关系可以不唯一</p><h5 id="关系模型（Relational-Model）"><a href="#关系模型（Relational-Model）" class="headerlink" title="关系模型（Relational Model）"></a>关系模型（Relational Model）</h5><p>从用户的观点看，关系模型由一组关系组成，每个关系的数据结构都是一张规范化的二维表：</p><ul><li>关系：一个关系对应通常说的一张表</li><li>元组：表中的一行即为一个元组</li><li>属性：表中的一列即为一个属性</li><li>码：也称为码键，它是表中的某个属性组，可以唯一确定一个元组</li><li>域：域是一组具有相同数据类型的值集合，属性的取值范围来自某个域</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述，通常表示为<code>关系名(属性1，属性2，属性3，...，属性n)</code></li></ul><h5 id="面向对象模型（Object-Oriented-Model）"><a href="#面向对象模型（Object-Oriented-Model）" class="headerlink" title="面向对象模型（Object-Oriented Model）"></a>面向对象模型（Object-Oriented Model）</h5><h5 id="对象关系模型（Object-Relational-Model）"><a href="#对象关系模型（Object-Relational-Model）" class="headerlink" title="对象关系模型（Object-Relational Model）"></a>对象关系模型（Object-Relational Model）</h5><h3 id="Ch2-The-Relational-Model"><a href="#Ch2-The-Relational-Model" class="headerlink" title="Ch2. The Relational Model"></a>Ch2. The Relational Model</h3><h4 id="CAP数据库"><a href="#CAP数据库" class="headerlink" title="CAP数据库"></a>CAP数据库</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/iuv9bsDBzYrlxfH.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/iWSvPMBGA8Ugund.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/zhZUMOiyYNAvbCG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/HjTJYBkUtcneDRm.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h4><ul><li><p><strong>数据模型（Data Model）</strong>：也称为数据库模型</p><ul><li>它是一组描述如何用计算机化的信息表示现实世界中的数据的定义</li><li>也描述了<strong>访问</strong>和<strong>更新</strong>这些信息的操作类型</li></ul></li><li><p><strong>数据库（Database）</strong>：<strong>表（Table）</strong>，或者说<strong>关系（Relation）</strong>的集合</p></li><li><p><strong>表的标题（Table Heading）</strong>：表的<strong>列名（Column Name）</strong>集合，又称为<strong>模式（Scheme）</strong></p><p><img src="https://i.loli.net/2019/09/06/I9yhKi46BRAufOP.png" alt></p></li><li><p>表的<strong>行（Row）</strong>集合：也就是<strong>元组（Tuple）</strong>的集合，称为表的内容，表的行数称为表的基数</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/06/FP2NDfJ3zABGlWc.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="数据库各部分的命名"><a href="#数据库各部分的命名" class="headerlink" title="数据库各部分的命名"></a>数据库各部分的命名</h4><p>由于数据库的行是经常改变的，而列通常来说不会改变，一般推荐数据库用户使用列来进行数据库查询</p><h5 id="程序数据独立性（Program-Data-Independence-）"><a href="#程序数据独立性（Program-Data-Independence-）" class="headerlink" title="程序数据独立性（Program-Data Independence ）"></a>程序数据独立性（Program-Data Independence ）</h5><blockquote><p>when asked to make up a query to answer a<br>question, query must still answer the<br>question even if all the data changes.</p></blockquote><p>查询语句和表的数据无关，二者是相互独立的，即使数据库中的表数据改变了，原有的查询依然能够执行（但是查询结果可能发生了改变）</p><h5 id="域类型（Column-type，也称-Domain和-Datatype）"><a href="#域类型（Column-type，也称-Domain和-Datatype）" class="headerlink" title="域类型（Column type，也称 Domain和 Datatype）"></a>域类型（Column type，也称 Domain和 Datatype）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/06/4NQEAOFYoPzXt8a.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>大多数商业数据库系统都不支持有枚举集组成的类型（如city，month等），它体现了数据库的<strong>完整性约束（Integrity）</strong></p><blockquote><p><strong>域完整性（Domain Integrity）</strong><br>域完整性是指保证指定列的数据具有正确的数据类型、格式和有效的数据范围。</p></blockquote></li><li><p><strong>particular type</strong></p><p>例子：Domain(city in CUSTOMERS) vs<br>Domain(city in AGENTS) ?</p><p><img src="https://i.loli.net/2019/09/06/3IUhzBc2NtJkwag.png" alt></p><p><img src="https://i.loli.net/2019/09/06/2RnTzvfjHdbMVZA.png" alt></p></li></ul><h5 id="关系代数（Relational-Algebra-）"><a href="#关系代数（Relational-Algebra-）" class="headerlink" title="关系代数（Relational Algebra ）"></a>关系代数（Relational Algebra ）</h5><p>数据表中的列的域类似于大多数编程语言中的枚举类型</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/06/zF83mwJsyaNvYHM.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/06/xueCP3KHmVn4cIr.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h5><p>数学上的笛卡尔积定义：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/11/XHPZu8mCs9biJfL.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>但是数据表的关系——即行的集合并没有包含数据表所有列的笛卡尔积中的所有元素，一般来说有如下关系：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/11/O9k6jhLcb1sXWPz.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="关系规则"><a href="#关系规则" class="headerlink" title="关系规则"></a>关系规则</h4><p><strong>数据库范式（Database Normalization）</strong>：一张数据表的表结构所符合的某种设计标准的级别。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。</p><p>数据库三大范式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/11/ov6eLOjT4EaNVci.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="第一范式（1NF）：First-Normal-Form-Rule"><a href="#第一范式（1NF）：First-Normal-Form-Rule" class="headerlink" title="第一范式（1NF）：First Normal Form Rule"></a>第一范式（1NF）：First Normal Form Rule</h5><p>数据表的列不允许有多值属性（重复的域）或者属性具有内部结构，也就是说要求列属性是原子的。</p><blockquote><p>columns that have multi-valued attributes (repeating fields) or have any internal structure (record) are not permitted</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/11/DCoqxLYdlN8Wcmj.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>以这个数据表为例，<code>name</code>具有内部结构，<code>enrollment</code>是多值属性（重复的域）（<em>实际上enrollment也具有内部结构</em>）</p><p>它有两方面的含义：</p><ul><li><p>多值属性（重复的域）意思是某个属性的取值是某些元素的列表或者集合，例如第一行中的enrollment属性取值是((101, No), (108, Yes))，它是元素(cno, major)的列表或集合，解决方法有三种：</p><ul><li>将多值属性拆分成多个属性 -&gt;（<strong>浪费空间并使得查询变得困难</strong>）</li><li>将具有多值属性的行（元组），按照多值属性的值集合拆分成多个行（元组）来表示，新的元组不再包含多值属性，这些元组在该属性的取值的集合等于原多值属性取值 -&gt; （<strong>包含大量冗余数据，浪费空间</strong>）</li><li>将多值属性和其他属性分拆到两个不同的表中，通过表的join运算来获得原数据表 -&gt;（<strong>最常用的操作</strong>）</li></ul></li><li><p>内部结构意思是某个属性的取值不是原子的，或者是不是基本类型，例如name属性具有内部结构(name.Iname, name.fname)，解决方法是：</p><p><img src="https://i.loli.net/2019/09/11/IHocynCRgkUAuMe.png" alt></p></li></ul><p><em>ps：第一范式规则被对象-关系数据库系统的数据表打破，这些表是非第一范式（NFNF）。</em></p><h5 id="第二范式（2NF）：Access-Rows-by-Content-Only-Rule"><a href="#第二范式（2NF）：Access-Rows-by-Content-Only-Rule" class="headerlink" title="第二范式（2NF）：Access Rows by Content Only Rule"></a>第二范式（2NF）：Access Rows by Content Only Rule</h5><p>只能基于内容存取行的规则，说明我们只可以通过行的内容即每一行中所存在的属性值来检索列</p><blockquote><p>can only retrieve rows by their content, the attribute values that exist in each row.</p></blockquote><p>它暗示了：</p><ul><li><p>行是无序的：即使用行号来访问数据表中指定行是无意义的</p><p><img src="https://i.loli.net/2019/09/15/2YerOAFicub759g.png" alt></p></li><li><p><strong>列是无序的</strong>：2NF中没有指明需要根据一定的属性次序来访问指定行</p></li></ul><p><em>ps：大多数的关系型数据库产品打破了这条规则，允许用户通过RID-row ID来访问行；而且新的对象-关系数据库产品有<code>refs</code>语法允许某一行上列值指向另一行。</em></p><h5 id="第三范式（3NF）：The-Unique-Row-Rule"><a href="#第三范式（3NF）：The-Unique-Row-Rule" class="headerlink" title="第三范式（3NF）：The Unique Row Rule"></a>第三范式（3NF）：The Unique Row Rule</h5><p>行唯一性规则，它要求关系中任何两个元组的值在同一时刻不能是完全相同的，也就是说<strong>关系是元组的无序集合</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/njuJqea9ZcNTSfA.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/TbAfJF4jM5exQk6.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C-深入理解ConcurrentHashMap原理</title>
    <link href="http://QQ876684433.github.io/2019/08/09/J-U-C-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ConcurrentHashMap%E5%8E%9F%E7%90%86/"/>
    <id>http://QQ876684433.github.io/2019/08/09/J-U-C-深入理解ConcurrentHashMap原理/</id>
    <published>2019-08-09T04:21:56.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解红黑树</title>
    <link href="http://QQ876684433.github.io/2019/08/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://QQ876684433.github.io/2019/08/09/深入理解红黑树/</id>
    <published>2019-08-09T04:20:24.000Z</published>
    <updated>2019-09-15T05:02:14.666Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java NIO学习笔记</title>
    <link href="http://QQ876684433.github.io/2019/07/25/Java%20NIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://QQ876684433.github.io/2019/07/25/Java NIO学习笔记/</id>
    <published>2019-07-25T12:51:09.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO学习笔记"><a href="#Java-NIO学习笔记" class="headerlink" title="Java NIO学习笔记"></a>Java NIO学习笔记</h1><blockquote><p>参考资料：<a href="https://nio.hacktons.cn/java-nio-tutorial.html" target="_blank" rel="noopener">https://nio.hacktons.cn/java-nio-tutorial.html</a></p><p>本文是上述有关Java NIO资料的学习笔记</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-NIO学习笔记&quot;&gt;&lt;a href=&quot;#Java-NIO学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Java NIO学习笔记&quot;&gt;&lt;/a&gt;Java NIO学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="NIO" scheme="http://QQ876684433.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统基础</title>
    <link href="http://QQ876684433.github.io/2019/07/25/Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>http://QQ876684433.github.io/2019/07/25/Linux系统基础/</id>
    <published>2019-07-25T01:34:24.000Z</published>
    <updated>2019-09-15T05:02:14.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统基础"><a href="#Linux系统基础" class="headerlink" title="Linux系统基础"></a>Linux系统基础</h1><blockquote><p>此文章是根据南大软院曾老师的《Linux系统基础》课程ppt的学习笔记整理</p></blockquote><p><strong>推荐：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a> ，关于Linux命令大全的实用网站</strong></p><h2 id="认识Linux系统"><a href="#认识Linux系统" class="headerlink" title="认识Linux系统"></a>认识Linux系统</h2><h3 id="Linux系统的组成"><a href="#Linux系统的组成" class="headerlink" title="Linux系统的组成"></a>Linux系统的组成</h3><p>Linux系统一般有4个主要部分：内核、Shell、文件系统 和 应用程序</p><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>内核是操作系统的核心，Linux内核的主要模块包括：存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等几个部分</p><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p>Shell是系统的用户界面，提供了<strong>用户</strong>与<strong>内核</strong>进行交互操作的一种接口，它接收用户输入的命令并把它送入内核去执行</p><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>文件系统是文件存放在磁盘等存储设备上的组织方法，Linux系统能支持多种目前流行的文件系统，如ext3、 ext4、 FAT、 FAT32、VFAT和ISO9660等</p><h4 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h4><p>包括文本编辑器、编程语言、 X Window、办公软件、 Internet工具和数据库等的程序集</p><h3 id="Linux系统与Windows系统的比较"><a href="#Linux系统与Windows系统的比较" class="headerlink" title="Linux系统与Windows系统的比较"></a>Linux系统与Windows系统的比较</h3><h4 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h4><ul><li><p>多用户操作系统</p><blockquote><p>​    这里补充一点，摘录自<a href="https://blog.csdn.net/yangkuiwu/article/details/53224239" target="_blank" rel="noopener">https://blog.csdn.net/yangkuiwu/article/details/53224239</a></p><p>​    1.<strong>单用户、多用户</strong>。根据在同一时间使用计算机用户的多少，操作系统可分为单用户操作系统和多用户操作系统。单用户操作系统是指一台计算机在同一时间只能由一个用户使用，*<u>一个用户独自享用系统的全部硬件和软件资源</u>，*而如果在同一时间允许多个用户同时使用计算机，则称为多用户操作系统。</p><p>​    2.<strong>单任务、多任务</strong>。用户在同一时间可以运行多个应用程序（每个应用程序被称作一个任务），则这样的操作系统被称为多任务操作系统。如果一个用户在同一时间只能运行一个应用程序，则对应的操作系统称为单任务操作系统。</p><p>​    现代操作系统一般属于多用户、多任务的操作系统，也就是说，同一台机器可以为多个用户建立各自的账户，也允许拥有这些账户的用户同时登录这台计算机，每个账号可以同时运行多个程序。</p><p>​    多个用户能够同时访问和使用同一台计算机，其中的一个用户具有管理所有这些用户账户和整个计算机的资源的权限，在Windows上，这个具有管理其他用户和计算机资源的用户一般叫administrator，而在Linux上一般叫做root。</p><p>​    个人计算机操作系统早期一般都是单用户操作系统，其主要特点是在某一时间为单个用户服务。早期的DOS操作系统是单用户单任务操作系统，Windows XP则是单用户多任务操作系统。Linux、UNIX是多用户多任务操作系统。现在常用的Windows操作系统都是多用户、多任务的操作系统，使用最广泛的win7，win10都是多用户，多任务操作系统。</p></blockquote></li><li><p>支持多种文件系统</p></li><li><p>支持多种端口和设备</p></li><li><p>支持联网功能</p></li><li><p>服务</p></li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/25/5d390b6c0f41545469.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>总结一下，Linux独有的特点如下：</p><ul><li>定位于网络操作系统，Linux的系统配置文件和数据都以文本为基础</li><li>可选图形化界面</li><li>Linux系统不使用文件扩展名来识别文件的类型，而是使用文件的头内容来识别其类型</li><li>除了Linux内核，其他软件的安装、启动、停止和重新配置都不用重新引导系统（即不需要重启）</li><li>Linux系统下的命令、文件和口令等都区分大小写</li></ul><h3 id="Linux版本"><a href="#Linux版本" class="headerlink" title="Linux版本"></a>Linux版本</h3><p>Linux的版本号分为两部分，即<strong>内核版本</strong>与<strong>发行版本</strong></p><h4 id="Linux内核版本"><a href="#Linux内核版本" class="headerlink" title="Linux内核版本"></a>Linux内核版本</h4><p>内核版本号由3个数字组成： r.x.y</p><ul><li>r：目前发布的内核主版本。</li><li>x：偶数表示稳定版本；奇数表示开发版本。</li><li>y：错误修补的次数。</li></ul><h4 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a>Linux发行版本</h4><p>一些组织和厂家，将Linux系统的内核、应用软件和文档包装起来，并提供一些系统安装界面、系统配置设定管理工具，就构成了Linux发行版本最著名的便是<strong>Red Hat公司开发的Red Hat系列</strong>以及<strong>社区组织开发的Debian系列发行版本</strong></p><h2 id="Linux系统的安装与删除"><a href="#Linux系统的安装与删除" class="headerlink" title="Linux系统的安装与删除"></a>Linux系统的安装与删除</h2><h3 id="Linux系统下硬盘的基本知识"><a href="#Linux系统下硬盘的基本知识" class="headerlink" title="Linux系统下硬盘的基本知识"></a>Linux系统下硬盘的基本知识</h3><h4 id="分区命名方案"><a href="#分区命名方案" class="headerlink" title="分区命名方案"></a>分区命名方案</h4><p>Linux系统使用<strong>字母和数字的组合</strong>来指代硬盘分区，命名方案是<strong>基于文件</strong>的，文件名的格式为/dev/xxyN</p><ul><li>/dev/：这是Linux系统下<strong>所有设备文件</strong>所在的目录名。</li><li>xx：分区名的前两个字母表示分区所在设备的类型，通常是hd（ IDE硬盘）或sd（ SCSI硬盘）。</li><li>y：这个字母表示分区<strong>所在的设备</strong>。</li><li>N：最后的数字N代表分区。</li></ul><p>例如：/dev/sda1表示这个分区在sd类型的设备上，如果有多个sd类型设备，那么该分区是在编号为a的设备上的分区1中</p><h4 id="磁盘分区和挂载目录"><a href="#磁盘分区和挂载目录" class="headerlink" title="磁盘分区和挂载目录"></a>磁盘分区和挂载目录</h4><p>分区是Linux系统上一组文件和目录的存储区，它通过挂载来实现，<strong>挂载</strong>是<strong>将分区关联到某一目录的过程</strong>，挂载分区使起始于这个指定目录（通称为挂载目录）的存储区能够被使用</p><ul><li>/boot分区：用来存放与Linux系统启动有关的程序，比如启动引导装载程序等</li><li>/usr分区：用来存放Linux系统中的应用程序</li><li>/var分区：用来存放Linux系统中经常变化的数据以及日志文件</li><li>/分区： Linux系统的根目录，所有的目录都挂在这个目录下面</li><li>SWAP分区：实现虚拟内存</li><li>/home分区：存放普通用户的数据，是普通用户的宿主目录</li></ul><h2 id="Linux字符界面操作"><a href="#Linux字符界面操作" class="headerlink" title="Linux字符界面操作"></a>Linux字符界面操作</h2><p>命令行界面可以通过字符界面、图形界面下的终端以及虚拟控制台等多种方式进入</p><h3 id="字符界面"><a href="#字符界面" class="headerlink" title="字符界面"></a>字符界面</h3><p>很多Linux发行版系统启动默认进入的是图形化界面，可以通过如下指令修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf</span><br></pre></td></tr></table></figure><p>重启后生效，默认进入字符界面，进入字符界面后，超级用户登录后提示符是“ #”，而其他用户登录后提示符是“ $”</p><h3 id="虚拟控制台"><a href="#虚拟控制台" class="headerlink" title="虚拟控制台"></a>虚拟控制台</h3><p>Linux系统提供了虚拟控制台的访问方式使得允许多个用户同时登录，还允许用户进行多次登录</p><ul><li>在<strong>字符界面</strong>下，虚拟控制台的切换可以通过按下[Alt+ F1]~ [Alt+ F6]键来实现</li><li>在<strong>图形界面</strong>下，可以使用[Ctrl+Alt+F2]~[Ctrl+Alt+F6]键切换不同的字符虚拟控制台，再使用[Ctrl+Alt+F1]可以切换回图形界面</li></ul><h3 id="关闭和重启系统"><a href="#关闭和重启系统" class="headerlink" title="关闭和重启系统"></a>关闭和重启系统</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><blockquote><p>参考原文：<a href="https://blog.csdn.net/xmc281141947/article/details/61191212" target="_blank" rel="noopener">https://blog.csdn.net/xmc281141947/article/details/61191212</a> </p></blockquote><p>在Linux中可以用Shutdown命令实现自动定时关机的功能，它在Linux系统关闭之前给系统上的所有登录用户提示一条警告信息</p><p>命令语法：shutdown [选项] [时间] [警告信息]</p><ul><li>-h 关闭计算机</li><li>-r 重启计算机</li><li>-c 取消正在等待的shutdown命令</li></ul><p><strong>精确时间</strong>的格式是hh:mm，表示小时和分钟。<br><strong>时间段（延迟）</strong>由“+” 和“分钟数”表示。<br>系统执行该命令后会自动进行数据同步的工作。时间部分如果是<code>now</code>，则上述命令则立即执行，否则延迟默认60s或者设定的时间</p><p>具体例子：</p><p>1、Shutdown -r now 关机后重启</p><p>2、Shutdown -h now 关机后不重启</p><p>3、Shutdown -r +11 11分钟后重启</p><p>4、Shutdown -r 11:00 11点钟重启</p><p>5、Shutdown -h +11 11分钟后关机</p><p>6、Shutdown -h 11:00 11点钟关机</p><h4 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h4><p>“ halt” 命令就是调用“ shutdown<br>–h”命令执行关闭系统，它是立即执行</p><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><p>“reboot”命令就是调用“shutdown -r”命令来重启系统，它是立即执行</p><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p>“ init” 命令是所有进程的祖先，它的进程号始终为“ 1” ，所以发送“ TERM” 信号给“ init” 会终止所有的用户进程和守护进程等。“ shutdown” 命令就是使用这种机制。“init”定义了7个运行级别：</p><ul><li>0    Halt    Shuts down the system.</li><li>1    Single-user mode    Mode for administrative tasks.（注意这里，说明系统返回的shell有root权限）</li><li>2    Multi-user mode    Does not configure network interfaces and does not export networks services.</li><li>3    Multi-user mode with networking    Starts the system normally.</li><li><u>4    Not used/user-definable    For special purposes.</u></li><li>5    Start the system normally with appropriate display manager (with GUI)    Same as runlevel 3 + display manager.</li><li>6    Reboot    Reboots the system.</li></ul><h3 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h3><p>Linux系统的运行级别由列在/etc/rc.d/rc&lt;x&gt;.d目录中的服务来定义，其中&lt;x&gt;是代表运行级别的符号，七种运行级别的定义如下：</p><ul><li>0：停止运行，所有进程中止，关闭系统。</li><li>1：单用户模式，用于维护系统，只有少数进程运行。</li><li>2：多用户模式，除了NFS服务没有启动外，其他和运行级别3一样。</li><li><strong>3：完整的多用户模式，进入Linux系统的字符界面。</strong></li><li>4：没有使用（可由用户定义）。</li><li><strong>5：完整的多用户模式（带有基于X Window的图形界面）。</strong></li><li>6：重新引导计算机。</li></ul><p>可以在使用<code>runlevel</code>命令查看当前的运行级别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~$ runlevel </span><br><span class="line">N 5</span><br></pre></td></tr></table></figure><p>表示当前运行级别是5，N表示没有上一次运行级别</p><h3 id="其他一些常用命令"><a href="#其他一些常用命令" class="headerlink" title="其他一些常用命令"></a>其他一些常用命令</h3><h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p>获取shell命令的帮助手册，命令语法：man [选项] [命令名称]</p><h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><p>可以通过help来获取shell命令的用法，命令语法：[命令] ––help</p><h4 id="which-whereis-locate-find"><a href="#which-whereis-locate-find" class="headerlink" title="which, whereis, locate, find"></a>which, whereis, locate, find</h4><blockquote><p>来源：<a href="https://zhuanlan.zhihu.com/p/35727707" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35727707</a></p></blockquote><ul><li><strong>which</strong>：常用于查找<strong>可直接执行的命令</strong>。只能查找可执行文件，该命令基本<strong>只在$PATH路径中搜索</strong>，查找范围最小，查找速度快。<strong>默认只返回第一个匹配的文件路径</strong>，通过选项 <em>-a</em> 可以返回所有匹配结果。</li><li><strong>whereis</strong>：不只可以查找命令，其他文件类型都可以（man中说只能查命令、源文件和man文件，实际测试可以查大多数文件）。在$PATH路径基础上增加了一些系统目录的查找，查找范围比which稍大，查找速度快。<u>可以通过 <em>-b</em> 选项，限定只搜索二进制文件</u>。</li><li><strong>locate</strong>：超快速查找任意文件。它会<strong>从linux内置的索引数据库查找文件的路径</strong>，索引速度超快。刚刚新建的文件可能需要一定时间才能加入该索引数据库，可以通过执行updatedb命令来强制更新一次索引，这样确保不会遗漏文件。该命令通常会返回大量匹配项，可以<strong>使用 <em>-r</em> 选项通过正则表达式来精确匹配</strong>。</li><li><strong>find</strong>：直接搜索整个文件目录，<strong>默认直接从根目录开始搜索</strong>，建议在以上命令都无法解决问题时才用它，功能最强大但速度超慢。除非你指定一个很小的搜索范围。通过 <em>-name</em> 选项指定要查找的文件名，支持通配符。</li></ul><h3 id="Shell基础"><a href="#Shell基础" class="headerlink" title="Shell基础"></a>Shell基础</h3><p>通俗地讲，Shell就是位于内核和操作者之间的一层使用者界面。一个Shell命令可能含有一些可选项和参数，其一般格式为：[Shell命令] [可选项] [参数]。目前流行的Shell有sh， csh， ksh， tcsh<br>和bash等。</p><h4 id="开始使用bash"><a href="#开始使用bash" class="headerlink" title="开始使用bash"></a>开始使用bash</h4><p>Shell命令可分为如下两大类：</p><p>（1） bash内置的命令</p><p>（2）应用程序</p><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/25/5d39652fb49c266836.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="特殊字符和引号"><a href="#特殊字符和引号" class="headerlink" title="特殊字符和引号"></a>特殊字符和引号</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/25/5d3964b167a0847483.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="常用控制组合键"><a href="#常用控制组合键" class="headerlink" title="常用控制组合键"></a>常用控制组合键</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/25/5d39656a7607c78493.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>说明：</p><ul><li>&amp; 使命令在后台运行，不阻塞当前控制台</li><li>CTRL+Z停止进程并放入后台</li><li>jobs 显示当前暂停的进程</li><li>bg %N 使第N个任务在后台运行（%前有空格）（<u>好像也会阻塞控制台？不太懂，在Ubuntu17.10上测试就是，bg执行后，控制台也被占用，但可以使用Ctr+S和Ctr+Q来暂停和恢复屏幕输出</u>）</li><li>fg %N 使第N个任务在前台运行，阻塞当前控制台</li><li>默认bg，fg不带%N时表示对最后一个进程操作！</li><li>Ctr+U是清空当前输入的命令行</li></ul><p>补充：</p><ul><li>控制台可以使用Ctr+Shift+C/V来执行复制粘贴功能</li></ul><h3 id="Shell实用功能"><a href="#Shell实用功能" class="headerlink" title="Shell实用功能"></a>Shell实用功能</h3><h4 id="命令的排列"><a href="#命令的排列" class="headerlink" title="命令的排列"></a>命令的排列</h4><p>如果希望一次执行多个命令， Shell允许在不同的命令之间，放上特殊的排列字符</p><ul><li><p>使用“; ”</p><p>使用“; ”命令时先执行命令1，不管命令1是否出错，接下来就执行命令2。<strong>命令语法：命令1; 命令2</strong></p></li><li><p>使用“ &amp;&amp;”</p><p>使用“ &amp;&amp;”命令时<strong>只有当命令1正确运行完毕</strong>后，才能执行命令2。<strong>命令语法：命令1&amp;&amp;命令2</strong></p></li></ul><h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p>有两种方式：</p><ul><li>命令1 $(命令2)</li><li>命令1 `命令2`</li></ul><p>意思是将命令2的输出结果与命令1拼接成新的命令执行，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pidof less //查看less的进程号，假如为4163</span><br><span class="line">kill -9 4163</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $(pidof less)</span><br><span class="line">// 或者</span><br><span class="line">kill -9 `pidof less`</span><br></pre></td></tr></table></figure><h4 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h4><p>alias命令用来设置指令的别名。我们可以使用该命令可以将一些较长的命令进行简化。使用alias时，用户必须使用单引号<code>&#39;&#39;</code>将原来的命令引起来，防止特殊字符导致错误。命令语法：</p><p><strong>alias [别名]＝[需要定义别名的命令]</strong></p><p>alias命令的作用<strong>只局限于该次登入的操作</strong>。若要每次登入都能够使用这些命令别名，则可将相应的alias命令存放到bash的初始化文件<code>/etc/bashrc</code>中。</p><p>要删除一个别名，可以使用 <a href="http://man.linuxde.net/unalias" target="_blank" rel="noopener">unalias</a> 命令，如 unalias l。</p><h4 id="文件名匹配和输出重定向"><a href="#文件名匹配和输出重定向" class="headerlink" title="文件名匹配和输出重定向"></a>文件名匹配和输出重定向</h4><h5 id="文件名匹配"><a href="#文件名匹配" class="headerlink" title="文件名匹配"></a>文件名匹配</h5><ul><li>“*” 可匹配任意一个或多个字符</li><li>“?” 可以匹配任意一个字符</li></ul><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>管道可以将某个命令的输出信息当作某个命令的输入，由管道符号“|” 来标识，命令语法：</p><p><strong>[命令1]|[ 命令2]|[ 命令3]</strong></p><p>例如：<code>alias tr=&#39;cd / &amp;&amp; tree | more &amp;&amp; cd ~&#39;</code>，就是将tree的输出内容作为more的输入，more的作用是将输出内容分页显示</p><h5 id="重定向文件"><a href="#重定向文件" class="headerlink" title="重定向文件"></a>重定向文件</h5><p>重定向有5种方式，分别是：输出重定向、输入重定向、错误重定向、追加重定向以及同时实现输出和错误的重定向</p><ul><li><p>输出重定向</p><p>将command命令的输出保存到文件file中，如果存在相同的文件，则<strong>覆盖file文件中的内容</strong>。</p><p><strong>命令语法：command &gt; file</strong></p><p>可以实用echo和输出重定向来创建文本文件：<code>echo hello &gt; hello.txt</code>，即创建文件hello.txt并写入内容“hello”</p></li><li><p>输入重定向</p><p>将文件file的内容作为command命令的输入。</p><p><strong>命令语法：command &lt; file</strong></p></li><li><p>错误重定向</p><p>将command命令执行的出错信息输出到文件file中。</p><p><strong>命令语法：command 2&gt; file</strong></p></li><li><p>追加重定向</p><p>将command命令执行的输出添加到已存在的文件file中。</p><p><strong>命令语法：command &gt;&gt; file</strong></p><p>补充：错误重定向和追加重定向可以组合使用，command 2&gt;&gt; file表示command的错误信息追加到file末尾</p></li><li><p>同时实现输出和错误的重定向</p><p>可以同时实现输出重定向和错误重定向的功能。</p><p><strong>命令语法：command &amp;&gt; file</strong></p><p>补充：同理，该命令可以和追加重定向组合使用，command &amp;&gt;&gt; file表示command的输出和错误信息追加到file末尾</p></li></ul><h3 id="vi编辑器基本使用"><a href="#vi编辑器基本使用" class="headerlink" title="vi编辑器基本使用"></a>vi编辑器基本使用</h3><h4 id="vim和vi的区别"><a href="#vim和vi的区别" class="headerlink" title="vim和vi的区别"></a>vim和vi的区别</h4><blockquote><p>摘录自：<a href="https://blog.csdn.net/allenlinrui/article/details/7269481" target="_blank" rel="noopener">https://blog.csdn.net/allenlinrui/article/details/7269481</a> </p></blockquote><p>简单来说一下vi和vim的区别与联系</p><p>首先，它们都是多模式编辑器，但vim是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性。总的来说，vim比vi更具优势的地方在于：</p><ul><li><p>多级撤消</p><p>在vi的命令模式里，<strong>按 u只能撤消上次命令，而在vim里可以无限制的撤消</strong>，几乎等同于windows下的ctrl+z了</p></li><li><p>多操作系统支持</p><p>vi只能运行于unix中，而vim不仅可以运行于unix,还有windows ,mac等操作系统上</p></li><li><p>语法加亮</p><p>作为一名程序员，我觉得这个效果用处最大了- vim可以对代码进行多颜色的语法加亮</p></li><li><p>可视化操作</p><p>因为vim不仅可以在终端运行，也可以运行于x window、 mac os、 windows， 所以说他“可视化”</p></li><li><p>对vi的完全兼容</p><p>某些情况下，vim可以完全被当成vi来使用</p></li></ul><h4 id="vi的工作模式"><a href="#vi的工作模式" class="headerlink" title="vi的工作模式"></a>vi的工作模式</h4><p>vi编辑器有3种基本工作模式，分别是命令行模式、插入模式和末行模式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/26/5d3a5d5e57a2f97173.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>命令行模式：控制屏幕光标的移动，字符、字或行的删除，移动、复制某区域，该模式下是不能输入文本数据的</li><li>插入模式：只有在插入模式下，才可以做文字输入，按“ Esc” 键可回到命令行模式</li><li>末行模式：将文件保存或退出vi编辑器，也可以设置编辑环境，如寻找字符串、列出行号等</li></ul><h4 id="vi基本操作"><a href="#vi基本操作" class="headerlink" title="vi基本操作"></a>vi基本操作</h4><h5 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h5><ul><li>按“ i” ：从光标当前位置开始输入文件</li><li>按“ I” ：在光标所在行的行首插入</li><li>按“ a” ：从目前光标所在位置的下一个位置开始输入文字</li><li>按“ A” ：在光标所在行的行末插入</li><li>按“ o” ：在光标所在的行的下面插入一行，从行首开始输入文字</li><li>按“ O” ：在光标所在的行的上面插入一行</li><li>按“ s” ：删除光标位置的一个字符，然后进入插入模式</li><li>按“ S” ：删除光标所在的行，然后进入插入模式</li></ul><h5 id="从插入模式切换为命令行模式"><a href="#从插入模式切换为命令行模式" class="headerlink" title="从插入模式切换为命令行模式"></a>从插入模式切换为命令行模式</h5><p>从插入模式切换为命令行模式只需按“ Esc” 键</p><h5 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h5><p>可以使用键盘的方向键移动光标，也可以使用vi定义的移动命令：<strong>h、j、k、l分别表示←、↓、↑、→移动一格</strong>。如果需要翻页：</p><ul><li>按[Ctrl+b]：屏幕往前移动一页（back）</li><li>按[Ctrl+f]：屏幕往后移动一页（front）</li><li>按[Ctrl+u]：屏幕往前移动半页（up）</li><li>按[Ctrl+d]：屏幕往后移动半页（down）</li></ul><p>其他的：</p><ul><li>按“ G” ：移动到文本的最后一行</li><li>按“ $” ：移动到光标所在行的行尾（助记：正则表达式的$）</li><li>按“ ^” 或数字“ 0”：移动到光标所在行的行首（助记：正则表达式的^）</li><li>按“ w” ：光标跳到下个字的开头</li><li>按“ e” ：光标跳到下个字的字尾</li><li>按“ b” ：光标回到上个字的开头</li></ul><p>解释：”e”和”b”的“下个字”和“上个字”的含义是当前光标停在某个字上，即当前字；而“w”的“下个字”真的就是下一个字，不是当前光标停留的字。举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word----</span><br><span class="line">↑</span><br></pre></td></tr></table></figure><p>箭头指向的是当前光标位置，如果按”w”，那么结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">word----</span><br><span class="line">    ↑</span><br><span class="line">// 因为当前字是word，那么对"w"来说，下一个字就是"----"，因此光标指向"-"</span><br></pre></td></tr></table></figure><p>而如果按的是”e”，那么结果将是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">word----</span><br><span class="line">   ↑</span><br><span class="line">// 因为当前字是word，那么对"e"来说，下一个字就是"word"，因此光标指向"d"</span><br></pre></td></tr></table></figure><h5 id="删除文字"><a href="#删除文字" class="headerlink" title="删除文字"></a>删除文字</h5><ul><li>“ x” ：每按一次，删除光标所在位置的一个字符</li><li>“ nx” ：例如， “ 6x” 表示删除光标所在位置开始的6个字符<u>（包括当前位置的字符）</u></li><li>“ X” ：大写的X，每按一次，删除光标所在位置的前面一个字符</li><li>“ nX”：例如， “ 20X”表示删除光标所在位置前面20个字符<u>（不包括当前位置的字符）</u></li><li>“ dd” ：删除光标所在行</li><li>“ ndd”：从光标所在行开始删除n行。例如， “ 4dd” 表示删除从光标所在行开始的4行字符<u>（包括当前行）</u></li><li>”dG“：删除当前后之后的全部行<u>（包括当前行）</u></li></ul><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><ul><li>“ yw” ：将光标所在之处到字尾的字符复制到缓冲区中（复制的是一个字的内容）</li><li>“ nyw” ：复制n个字到缓冲区<u>（包括当前字）</u></li><li>“ yy” ：复制光标所在行到缓冲区</li><li>“nyy” ：例如， “6yy” 表示复制从光标所在行开始的6行字符</li><li>“p” ：将缓冲区内的内容写到光标所在的<strong>后一个位置</strong>（原ppt这里错了，这里写的才是正确的）</li><li>”P“：将缓冲区内的内容写到光标所在的前一个位置</li></ul><p><strong>解释：”p“后一个位置有两种含义，如果复制的是字，那么写在光标所在位置的后面；如果复制的是行内容，那么写在光标所在行的下一行</strong>；”P“同理，替换成上一个位置或者上一行</p><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><ul><li>“ r” ：替换光标所在处的字符</li><li>“ R” ：替换光标所到之处的字符，直到按下“ Esc” 键为止</li></ul><h5 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h5><ul><li>“ u” ：如果误执行一个命令，可以马上按下“ u” ，回到上一个操作。</li><li>按多次“ u” 可以执行多次撤销</li></ul><p>补充：vi兼容模式下，多次”u“并不能多次撤销，原因是后一次”u“会把上一次”u“当做操作来撤销，即撤销”撤销操作“，所以”uu“会恢复原样</p><h5 id="跳至指定行"><a href="#跳至指定行" class="headerlink" title="跳至指定行"></a>跳至指定行</h5><ul><li>[Ctrl+g]：列出光标所在行的行号</li><li>“nG” ：例如， “ 15G” ，表示移动光标至该文本的第15行行首</li></ul><h5 id="存盘退出"><a href="#存盘退出" class="headerlink" title="存盘退出"></a>存盘退出</h5><ul><li>“ZZ” ：存盘退出</li></ul><h5 id="不保存退出"><a href="#不保存退出" class="headerlink" title="不保存退出"></a>不保存退出</h5><ul><li>“ZQ” ：不存盘退出</li></ul><h4 id="末行模式操作"><a href="#末行模式操作" class="headerlink" title="末行模式操作"></a>末行模式操作</h4><p>在使用末行模式之前，先按“ Esc”键确定已经处于命令行模式后，再按冒号“:”<br>即可进入末行模式</p><h5 id="列出行号"><a href="#列出行号" class="headerlink" title="列出行号"></a>列出行号</h5><p>“set nu” ：在文件中的每一行前面列出行号</p><h5 id="取消列出行号"><a href="#取消列出行号" class="headerlink" title="取消列出行号"></a>取消列出行号</h5><p>“set nonu” ：取消文件中的每一行前面列出的行号</p><h5 id="跳到文件中的某一行"><a href="#跳到文件中的某一行" class="headerlink" title="跳到文件中的某一行"></a>跳到文件中的某一行</h5><p>“n”：输入行号n后回车，光标会跳转到文本的指定行——第n行的行首</p><h5 id="查找字符"><a href="#查找字符" class="headerlink" title="查找字符"></a>查找字符</h5><ul><li>“/关键字”：向后查找关键字，可以按n往后查找下一个匹配的关键字</li><li>“?关键字”：向前查找关键字，可以按n往前查找下一个匹配的关键字</li></ul><h5 id="运行Shell命令"><a href="#运行Shell命令" class="headerlink" title="运行Shell命令"></a>运行Shell命令</h5><p>“!命令” ：运行Shell命令</p><h5 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h5><ul><li>“s /a/b” ：将光标所在行第一个a替换为b</li><li>“s /a/b/g” ：将光标所在行所有的a替换为b</li></ul><h5 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h5><p>“w” ：在冒号后输入字母“w” 就可以将文件保存起来</p><h5 id="退出vi"><a href="#退出vi" class="headerlink" title="退出vi"></a>退出vi</h5><ul><li>“q” ：按“q” 即退出vi，如果无法离开vi，可以在“q” 后跟一个“!” 强制符离开vi</li><li>“wq” ：一般建议离开时，搭配“w” 一起使用，这样在退出的时候还可以保存文件</li></ul><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>Linux系统中<strong>以目录的形式挂载文件系统</strong>，其目录结构是一个<strong>分层的树形结构</strong>。链接是一种在共享文件和访问它的用户的若干目录项之间建立联系的方法， Linux系统中包括<strong>硬链接和软链接</strong>两种方式</p><h3 id="Linux文件"><a href="#Linux文件" class="headerlink" title="Linux文件"></a>Linux文件</h3><p>如果一个文件没有扩展名，或者与它的扩展名不相符时，可以使用file命令查看该文件的类型，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~$ file db.json </span><br><span class="line">db.json: UTF-8 Unicode text, with very long lines, with no line terminators</span><br><span class="line">steve@ubuntu-17-10:~$ file _config.yml </span><br><span class="line">_config.yml: UTF-8 Unicode text</span><br><span class="line">steve@ubuntu-17-10:~$ file package-lock.json </span><br><span class="line">package-lock.json: ASCII text</span><br></pre></td></tr></table></figure><h3 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h3><p>Linux文件类型常见的有：普通文件、目录文件、字符设备文件、块设备文件和符号链接文件等，可以用<code>ls -lh</code>命令查看某个文件的属性</p><ul><li><p>普通文件</p><p>类似“ -rw-r–r–”的属性符号，其<strong>属性第一个符号是“ -”</strong>，这样的文件在Linux系统中就是普通文件</p></li><li><p>目录文件（<strong>d</strong>irectory）</p><p>类似“ drwxr-xr-x”的属性符号，其<strong>属性第一个符号是“ d”</strong>，这样的文件在Linux系统中就是目录文件</p></li><li><p>设备文件</p><p>Linux系统下的/dev目录中有大量的设备文件</p><ul><li><p>块设备文件（<strong>b</strong>lock）</p><p>块设备的主要特点是可以随机读写，而最常见的块设备就是磁盘，如/dev/hda1、/dev/sda2等</p><p>类似“ brw-rw—-”的属性符号，其<strong>属性第一个符号是“ b”</strong>，这样的文件在Linux系统中就是块设备文件</p></li><li><p>字符设备文件（<strong>c</strong>haracter）</p><p>最常见的字符设备文件是打印机和终端，可以接收字符流。 /dev/null是一个非常有用的字符设备文件，送入这个设备的所有内容都被忽略</p><p>类似“ crw-r—–”的属性符号，其<strong>属性第一个符号是“ c”</strong>，这样的文件在Linux系统中就是字符设备文件</p></li></ul></li><li><p>管道文件（<strong>p</strong>ipe）</p><p>管道文件有时候也被叫做FIFO文件（ FIFO是先进先出的意思），管道文件就是从一头流入，从另一头流出</p><p>类似“ prw——-”的属性符号，其<strong>属性第一个符号是“ p”</strong>，这样的文件在Linux系统中就是管道文件</p></li><li><p>链接文件（<strong>l</strong>ink）</p><p>链接文件有点类似于Windows系统中的快捷方式，链接有两种方式：软链接和硬链接</p><ul><li><p>软链接文件</p><p>软链接（也叫符号链接），文件<strong>用户数据块中存放的内容是另一文件的路径名的指向</strong>。软链接就是一个普通文件，只是数据块内容有点特殊。<strong>软链接可对文件或目录创建</strong>。删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接就变成了死链接</p><p>类似“ lrwxrwxrwx”的属性符号，其<strong>属性第一个符号是“ l”</strong>，这样的文件在Linux系统中就是软链接文件</p></li><li><p>硬链接文件</p><p>硬链接就是同一个文件使用了多个别名（他们<strong>有共同的 inode</strong>）。由于<strong>硬链接是有着相同inode</strong><br><strong>号仅文件名不同的文件</strong>，因此，删除一个硬链接文件并不影响其他有相同 inode 号的文件。硬链接<strong>不能对目录进行创建，只可对文件创建</strong></p><p>用“ ls -l”命令查看某个文件的属性，可以看到<strong>第二列的文件硬链接数大于1</strong> ，这样的文件在Linux系统中就是硬链接文件</p></li></ul></li></ul><h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p>Linux系统都有根文件系统，它包含<strong>系统引导和使其他文件系统得以挂载所必要的文件</strong>，根文件系统需要有<strong>单用户状态所必须的足够的内容</strong>，还应该包括<strong>修复损坏系统、恢复备份等工具</strong>。</p><p>Linux系统的目录结构是分层的树形结构，都是挂载在根文件系统“ /” 下</p><h3 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h3><ul><li><p>pwd：显示当前用户所处的工作目录的绝对路径</p></li><li><p>cd：更改工作目录路径，工作目录路径可以使用绝对或相对路径名，绝对路径从/（根）开始，然后循序到所需的目录下；相对路径从当前目录开始</p><p><strong>命令语法：cd [目录名]</strong></p></li><li><p>ls：对于目录而言将列出其中的所有子目录与文件信息；对于文件而言将输出其文件名以及所要求的其他信息</p><p><strong>命令语法：ls [选项] [目录或是文件]</strong></p><p>ls命令显示的详细信息：</p><p><img src="https://i.loli.net/2019/07/26/5d3ab0c1d837547899.png" alt="ls命令显示的详细信息"></p></li><li><p>touch：创建空文件以及更改文件或目录的时间，其中时间格式为MMDDHHmm</p><p><strong>命令语法：touch [-acfm] [-d &lt;日期时间&gt;] [-r &lt;参考 文件或目录&gt;] [-t &lt;日期时间&gt;] [文件]</strong></p></li><li><p>mkdir：在Linux系统中创建目录，其默认权限为rwxr-xr-x（ 755）</p><p><strong>命令语法：mkdir [选项] [目录名]</strong></p><p>-m 可以在创建目录时设置其权限，例如mkdir -m 777 newdir，其权限是rwxrwxrwx（ 777）</p></li><li><p>rmdir：删除空目录</p><p><strong>命令语法：rmdir [选项] [目录名]</strong></p><p>-p或–parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除</p></li><li><p>cp：复制文件和目录到其他目录中</p><p><strong>命令语法：cp [选项] [源文件或目录] [目标文件或目录]</strong></p></li><li><p>mv：对<u>文件和目录更改名称</u>以及移动文件和目录的路径</p><p><strong>命令语法：mv [选项] [源文件或目录] [目标文件或目录]</strong></p></li><li><p>rm：删除系统中的文件或目录</p><p><strong>命令语法：rm [选项] [文件或目录]</strong></p><p>-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；-f：强制删除文件或目录；-i：在删除文件之前提示信息</p></li><li><p>wc：统计指定文件中的行数、单词数或字节数，并将统计结果显示输出到屏幕</p><p><strong>命令语法：wc [选项] [文件]</strong></p><p>选项部分可以有-lwc，即将行数、单词数和字节数都显示出来</p></li></ul><h3 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h3><p>在Linux系统中，内核为每一个新创建的文件分配一个inode（索引节点）号，文件属性保存在索引节点里，在访问文件时，索引节点被复制到内存里，从而实现文件的快速访问</p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>硬链接是一个指针，指向文件索引节点，系统并不为它重新分配inode，可以用ln命令来建立硬链接。硬链接节省空间，也是Linux系统整合文件系统的传统方式。硬链接文件有两个限制：</p><p>（ 1）不允许给目录创建硬链接</p><p>（ 2）只有在同一文件系统中的文件之间才能创建链接</p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>软链接又称为符号链接，这个文件包含了另一个文件的路径名</p><h4 id="硬链接和软链接的区别"><a href="#硬链接和软链接的区别" class="headerlink" title="硬链接和软链接的区别"></a>硬链接和软链接的区别</h4><p><strong>硬链接记录的是目标的inode</strong>，<strong>软链接记录的是目标的路径</strong>。<strong>软链接就像是快捷方式，而硬链接就像是备份</strong>。软链接可以做跨分区的链接，而硬链接由于inode的缘故，只能在本分区中做链接。所以，软链接的使用频率要高得多</p><h4 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h4><p>ln命令可以创建链接文件（包括软链接文件和硬链接文件）</p><p><strong>命令语法：ln [选项] [源文件名] [链接文件名]</strong>，默认创建的是硬链接，加上-s后创建的是软链接</p><p>使用rm删除源文件后，硬链接文件依然能打开，而软链接变成死链接</p><h2 id="Linux常用操作命令"><a href="#Linux常用操作命令" class="headerlink" title="Linux常用操作命令"></a>Linux常用操作命令</h2><p><em>这部分挺琐碎的，直接参考<a href="http://man.linuxde.net/即可" target="_blank" rel="noopener">http://man.linuxde.net/即可</a> ，关于Linux命令大全的实用网站</em></p><h3 id="文本显示和处理"><a href="#文本显示和处理" class="headerlink" title="文本显示和处理"></a>文本显示和处理</h3><p>cat，more，less，head，tail，sort，uniq，cut，comm以及diff等</p><h3 id="文件和命令查找"><a href="#文件和命令查找" class="headerlink" title="文件和命令查找"></a>文件和命令查找</h3><p>grep，find，locate，whereis，file，whatis以及which等</p><h3 id="系统信息显示"><a href="#系统信息显示" class="headerlink" title="系统信息显示"></a>系统信息显示</h3><p>uname， hostname， dmesg， cal以及date等</p><h3 id="信息交流"><a href="#信息交流" class="headerlink" title="信息交流"></a>信息交流</h3><p>echo， mesg， wall以及write等</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>clear， sync， uptime以及last等</p><h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h3><p>Shell程序由开头部分、注释部分以及语句执行部分组成</p><h4 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h4><p>Shell程序必须以下面的行开始（必须放在文件的第一行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br></pre></td></tr></table></figure><p>符号“ #!” 用来告诉系统它后面的参数是<strong>用来执行该文件的程序</strong>，在这个例子中使用/bin/bash来执行程序。当编辑好脚本时，如果要执行该脚本，还必须<strong>使其可执行</strong>（即赋予可执行权限）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x [文件名]</span><br></pre></td></tr></table></figure><p>如果不设置可执行权限的话，可以手动受用bash命令告诉系统它是一个可执行的脚本，这样也可以执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash file.sh</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>以“ #” 开头的句子表示注释，直到这一行的结束</p><h4 id="执行部分"><a href="#执行部分" class="headerlink" title="执行部分"></a>执行部分</h4><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">filename:welcome</span></span><br><span class="line">first()</span><br><span class="line">&#123;</span><br><span class="line">echo "=========================================="</span><br><span class="line">echo "Hello! Everyone! Welcome to the Linux world."</span><br><span class="line">echo "=========================================="</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">second()</span><br><span class="line">&#123;</span><br><span class="line">echo "******************************************"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first</span><br><span class="line">second</span><br><span class="line">second</span><br><span class="line">first</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">==========================================</span><br><span class="line">Hello! Everyone! Welcome to the Linux world.</span><br><span class="line">==========================================</span><br><span class="line">******************************************</span><br><span class="line">******************************************</span><br><span class="line">==========================================</span><br><span class="line">Hello! Everyone! Welcome to the Linux world.</span><br><span class="line">==========================================</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>对Shell来讲，<strong>所有变量的取值都是一个字符</strong>， Shell程序采用“ $var” 的形式来引用名为var的变量的值</p><h4 id="Shell定义的环境变量"><a href="#Shell定义的环境变量" class="headerlink" title="Shell定义的环境变量"></a>Shell定义的环境变量</h4><p>Shell在开始执行时就已经定义了一些与系统的工作环境有关的变量，用户还可以重新定义这些变量，常见的环境变量如下：</p><ul><li>HOME：用于保存用户宿主目录的完全路径名</li><li>PATH：默认命令搜索路径</li><li>TERM：终端的类型</li><li>UID：当前用户的识别号</li><li>PWD：当前工作目录的绝对路径名</li><li>PS1： 用户平时的提示符</li><li>PS2： 第一行没输完，等待第二行输入的提示符</li></ul><h4 id="用户定义的变量"><a href="#用户定义的变量" class="headerlink" title="用户定义的变量"></a>用户定义的变量</h4><p>语法规则：<code>变量名=变量值</code></p><p>在定义变量时，<strong>变量名前不应加符号“ $”</strong> ；在引用变量的内容时，则应<strong>在变量名前加符号“ $”或“ ${变量名}”</strong> 。在给变量<strong>赋值时，等号两边一定不能留空格</strong>，若<strong>变量中本身就包含了空格，则整个字符串都要用双引号括起来</strong>。在编写Shell程序时，为了使变量名和命令名相区别，<strong>建议所有的变量名都用大写字母来表示</strong>。</p><p>有时需要在说明一个变量并对它设置为一个特定值后就不再改变它的值时，可以用下面的命令来保证一个变量的只读性：<code>readonly 变量名</code>。</p><p>在任何时候创建的变量都<strong>只是当前Shell的局部变量</strong>，所以不能被Shell运行的其他命令或Shell程序所利用，而export命令可以将一个局部变量提供给Shell命令使用，其格式是：<code>export 变量名</code>。也可以在给变量赋值的同时使用export命令：<code>export 变量名=变量值</code>。</p><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>位置参数是一种在调用Shell程序的命令行中按照各自的位置决定的变量，<strong>是在程序名之后输入的参数</strong>。位置参数之间用空格分隔，Shell取第一个位置参数替换程序文件中的$1，第二个替换$2，依次类推。<strong>$0是一个特殊的变量，它的内容是当前这个Shell程序的文件名</strong>，所以， $0不是一个位置参数，在显示当前所有的位置参数时是不包括$0的</p><h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>预定义变量和环境变量相类似，也是在Shell一开始时就定义了的变量。所不同的是，用户只能根据Shell的定义来使用这些变量，所有预定义变量都是<strong>由符号“ $” 和另一个符号组成</strong>的。常见的预定义变量如下：</p><ul><li>$#：位置参数的数量</li><li>$*：所有位置参数的内容</li><li>$?：命令执行后返回的状态</li><li>$$：当前进程的进程号</li><li>$!：后台运行的最后一个进程号</li><li>$0：当前执行的进程名。</li></ul><h4 id="参数置换的变量"><a href="#参数置换的变量" class="headerlink" title="参数置换的变量"></a>参数置换的变量</h4><p>Shell提供了参数置换功能以便用户可以根据不同的条件来给变量赋不同的值，下面Variable是变量名， value代表一个具体的值：</p><ul><li>${variable:-value}: 如果变量variable存在，则返回variable的值，否则返回值value</li><li>${variable:=value}: 如果变量variable存在，则返回variable的值，否则，先将值value赋给变量variable，然后返回值value</li><li>${variable:+value}: 如果变量variable存在，则返回value的值，否则返回空值</li><li>${variable:?value}: 如果变量variable存在，则返回variable的值，否则将value送到标准错误输出显示并退出shell程序，这里value通常为一个错误提示消息</li><li>${variable:offset[:length]}:其中offset和length为整数数字，中括号代表可选部分。此引用方式表示返回从变量variable的第(offset+1)个字符开始的、长度为length的子串。如果中括号内的部分省略，则返回其后的所有子串</li></ul><h3 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h3><p>首先要注意的是，<strong>这些表达式符号前后都需要有空格</strong>，否则会出错</p><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>测试字符串是否相等，长度是否为零，字符串是否为NULL：</p><ul><li>=：比较两个字符串是否相同，相同则为“是” （结果显示0）</li><li>!=：比较两个字符串是否相同，不同则为“是”（结果显示0）</li><li>-n：比较字符串的长度是否大于0，如果大于0则为“是” （结果显示0）</li><li>-z：比较字符串的<strong>长度是否等于0</strong>，如果等于0则为“是” （结果显示0）</li></ul><p>补充：</p><ul><li><p>直接测试时，控制台是不会有输出结果的，需要使用<code>$?</code>来获取输出结果</p></li><li><p>如果变量字符串含有空格，需要使用双引号，否则会出错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ str1="ab cd"</span><br><span class="line">steve@ubuntu-17-10:~/$ test $str1 = ab</span><br><span class="line">bash: test: 参数太多</span><br><span class="line">steve@ubuntu-17-10:~/$ test "$str1" = ab</span><br><span class="line">steve@ubuntu-17-10:~/$ echo $?</span><br><span class="line">1</span><br><span class="line">steve@ubuntu-17-10:~/$ test "$str1" = ab cd</span><br><span class="line">bash: test: 参数太多</span><br><span class="line">steve@ubuntu-17-10:~/$ test "$str1" = "ab cd"</span><br><span class="line">steve@ubuntu-17-10:~/$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure></li></ul><h4 id="数字比较"><a href="#数字比较" class="headerlink" title="数字比较"></a>数字比较</h4><p>test语句不使用<code>&gt;?</code> 类似的符号来表达大小的比较，而是用参数来表示：</p><ul><li>-eq：相等</li><li>-ge：大于等于</li><li>-le：小于等于</li><li>-ne：不等于</li><li>-gt：大于</li><li>-lt：小于</li></ul><h4 id="逻辑测试"><a href="#逻辑测试" class="headerlink" title="逻辑测试"></a>逻辑测试</h4><ul><li>!：与一个逻辑值相反的逻辑值</li><li>-a与（ and）：两个逻辑值都为“是” 返回值才为“是” ，反之为“否”</li><li>-o或（ or）：两个逻辑值有一个为“是” ，返回值就为“是” </li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@PC-LINUX ~]# test -r empty -a -s empty</span><br><span class="line">[root@PC-LINUX ~]# echo $?</span><br><span class="line">1</span><br><span class="line">// 结果显示1表示文件empty存在且只读以及长度为非0是不对的</span><br></pre></td></tr></table></figure><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>文件测试表达式通常是为了测试文件的文件操作逻辑：</p><ul><li>-d：对象存在且为目录，则返回值为“是” </li><li>-f：对象存在且为文件，则返回值为“是” </li><li>-L：对象存在且为符号连接，则返回值为“是” </li><li>-r：对象存在且可读，则返回值为“ 是”</li><li>-s：对象存在且<strong>长度非0</strong>，则返回值为“是” </li><li>-w：对象存在且可写，则返回值为“是” </li><li>-x：对象存在且可执行，则返回值为“是” </li><li>!：测试条件的否定</li></ul><h3 id="Shell程序的执行和跟踪"><a href="#Shell程序的执行和跟踪" class="headerlink" title="Shell程序的执行和跟踪"></a>Shell程序的执行和跟踪</h3><h4 id="Shell程序的执行和调试"><a href="#Shell程序的执行和调试" class="headerlink" title="Shell程序的执行和调试"></a>Shell程序的执行和调试</h4><p>程序的第一行一般为<code>#!/bin/bash</code> ，其中“ #” 表示该行是注释，感叹号“ ！ ” 表示Shell运行感叹号之后的命令<strong>并用文档的其余部分作为输入</strong>，也就是运行/bin/bash并让/bin/bash去执行Shell程序的内容</p><h5 id="Shell程序的执行"><a href="#Shell程序的执行" class="headerlink" title="Shell程序的执行"></a>Shell程序的执行</h5><p>有如下三种方式运行shell程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ vim exe.sh</span><br><span class="line">steve@ubuntu-17-10:~/$ bash &lt; exe.sh </span><br><span class="line">hello world</span><br><span class="line">steve@ubuntu-17-10:~/$ bash exe.sh </span><br><span class="line">hello world</span><br><span class="line">steve@ubuntu-17-10:~/$ chmod u+x exe.sh </span><br><span class="line">steve@ubuntu-17-10:~/$ ./exe.sh </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p><u>发现一个问题：使用<code>bash &lt; exe.sh</code>运行程序时，read指令好像不生效，控制台不会等待标准输入，具体原因还不知道</u></p><h5 id="Shell程序的调试"><a href="#Shell程序的调试" class="headerlink" title="Shell程序的调试"></a>Shell程序的调试</h5><p>调用bash的形式是：<code>bash [选项] [Shell程序文件名]</code></p><ul><li>-v：当读入Shell输入行时，把它们显示出来（输出的命令是<strong>未经执行的源程序命令</strong>）</li><li>-x：执行命令时把命令和它们的参数显示出来（输出的命令是<strong>解释后实际执行的命令</strong>）</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ vim exe.sh ; cat exe.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "shell file name is $0"</span><br><span class="line">echo "hello world"</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br><span class="line">steve@ubuntu-17-10:~/$ bash -x exe.sh a b</span><br><span class="line">+ echo 'shell file name is exe.sh'</span><br><span class="line">shell file name is exe.sh</span><br><span class="line">+ echo 'hello world'</span><br><span class="line">hello world</span><br><span class="line">+ echo a</span><br><span class="line">a</span><br><span class="line">+ echo b</span><br><span class="line">b</span><br><span class="line">steve@ubuntu-17-10:~/$ bash -v exe.sh a b</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "shell file name is $0"</span><br><span class="line">shell file name is exe.sh</span><br><span class="line">echo "hello world"</span><br><span class="line">hello world</span><br><span class="line">echo $1</span><br><span class="line">a</span><br><span class="line">echo $2</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h3 id="Shell流程控制语句"><a href="#Shell流程控制语句" class="headerlink" title="Shell流程控制语句"></a>Shell流程控制语句</h3><p>与传统语言不同的是， Shell用于指定条件值的不是布尔运算式，而是命令和字符串</p><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><h5 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h5><blockquote><p>可以参考：<a href="https://blog.csdn.net/doiido/article/details/43966819" target="_blank" rel="noopener">https://blog.csdn.net/doiido/article/details/43966819</a></p></blockquote><p>Shell程序中的条件分支有如下两种方式：</p><ul><li><p>if-then语句</p><p>语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ 命令行1 ];then</span><br><span class="line">命令行2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>需要注意的是，在 <strong>‘[‘后面</strong> 和 <strong>‘]’前面</strong> 都必须要有空格，不然会出错，例如要<code>[ $a=a ]</code></p></li><li><p>if-then-else语句</p><p>语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ 命令行1 ]</span><br><span class="line">then</span><br><span class="line">命令行2</span><br><span class="line">else</span><br><span class="line">命令行3</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul><h5 id="case条件语句"><a href="#case条件语句" class="headerlink" title="case条件语句"></a>case条件语句</h5><p>Shell通过计算字符串string的值，将其结果依次与运算式exp-1和exp-2等进行比较，直到找到一个匹配的运算式为止。如果找到了匹配项，则执行它下面的命令直到遇到一对分号<code>;;</code>为止，语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case string in</span><br><span class="line">exp-1)</span><br><span class="line">若干个命令行1</span><br><span class="line">;;</span><br><span class="line">exp-2)</span><br><span class="line">若干个命令行2</span><br><span class="line">;;</span><br><span class="line">……</span><br><span class="line">*)</span><br><span class="line">其他命令行</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>在case运算式中也可以使用Shell的通配符（ <code>*</code> ， <code>?</code> ， <code>[]</code>）。通常用<code>*</code>作为case命令的最后运算式以便在前面找不到任何相应的匹配项时执行“其他命令行” 的命令，样例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ cat menu.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo _</span><br><span class="line">echo "1 Restore"</span><br><span class="line">echo "2 Backup"</span><br><span class="line">echo "3 Unload"</span><br><span class="line">echo </span><br><span class="line">echo -n "Enter Choice: "</span><br><span class="line">read CHOICE</span><br><span class="line">case "$CHOICE" in</span><br><span class="line">1) echo "Restore";;</span><br><span class="line">2) echo "Backup";;</span><br><span class="line">3) echo "Unload";;</span><br><span class="line">*) echo "Sorry $CHOICE is not a valid choice."</span><br><span class="line">exit 1</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><h5 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量名 [in数值列表]</span><br><span class="line">do</span><br><span class="line">若干个命令行</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>如果变量名是var，则在in之后给出的数值将顺序替换循环命令列表中的“ $var” </li><li>如果省略了in，则变量var的取值将是位置参数</li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ vim mm.sh ; cat mm.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">for ab in 1 2 3 4</span><br><span class="line">do</span><br><span class="line">echo $ab</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ bash mm.sh </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>求和示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ cat qqq.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">sum=0</span><br><span class="line">for INT in $*;do</span><br><span class="line">sum=`expr $sum + $INT`</span><br><span class="line">done </span><br><span class="line">echo $sum</span><br><span class="line">steve@ubuntu-17-10:~/$ bash qqq.sh 1 2 3 4 </span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>要注意，原ppt中expr指令使用的是单引号<code>&#39;&#39;</code>括起来的，这样不对，应该使用反单引号``才能执行后面的加法计算</p><h5 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h5><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while</span><br><span class="line">若干个命令行1</span><br><span class="line">do</span><br><span class="line">若干个命令行2</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>只要while的“若干个命令行1” 中<strong>最后一个命令的返回状态为真</strong>， while循环就继续执行“ do…done” 之间的“ 若干个命令行2”，示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/桌面$ cat zx.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">int=1</span><br><span class="line">while [ $int -le 5 ]; do</span><br><span class="line">sq=`expr $int \* $int`</span><br><span class="line">echo $sq</span><br><span class="line">int=`expr $int + 1`</span><br><span class="line">done</span><br><span class="line">echo "Job completed!"</span><br><span class="line">steve@ubuntu-17-10:~/桌面$ bash zx.sh </span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">Job completed!</span><br></pre></td></tr></table></figure><h5 id="until循环语句"><a href="#until循环语句" class="headerlink" title="until循环语句"></a>until循环语句</h5><p>语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">until</span><br><span class="line">若干个命令行1</span><br><span class="line">do</span><br><span class="line">若干个命令行2</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>until循环和while循环的区别在于：<strong>while循环在条件为真时继续执行循环，而until则是在条件为假时继续执行循环</strong>。Shell还提供了true和false两条命令用于创建无限循环结构，它们的返回状态分别是总为0或总为非0</p><h5 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h5><p>用法和传统C语言中的用法无异</p><h5 id="source语句"><a href="#source语句" class="headerlink" title="source语句"></a>source语句</h5><p>source命令用法：<code>source FileName</code></p><p>作用：在<strong>当前bash环境下</strong>读取并执行FileName中的命令。</p><p>注：该命令<strong>通常用命令“ .”来替代</strong>。如： source .bash_rc 与 . .bash_rc 是等效的。</p><p>source命令与shell scripts的区别是， <strong>source在当前bash环境下执行命令</strong>，而<strong>scripts是启动一个子shell来执行命令</strong>。这样如果把设置环境变量（或alias等等）的命令写进scripts中，就只会影响子shell,无法改变当前的BASH,所以<strong>通过文件设置环境变量时，要用source 命令。</strong></p><p>source命令(从 C Shell 而来)是bash shell的内置命令。点命令(从Bourne Shell而来) 是source的另一名称。 <strong>source(或点)命令通常用于重新执行刚修改的初始化文档</strong>，如 .bash_profile 和<br>.profile 等等。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>所有函数在使用前必须定义</strong>。函数的调用，只需要使用函数名就可以调用已经定义好的函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义：</span></span><br><span class="line">[function] 函数名()</span><br><span class="line">&#123;</span><br><span class="line">命令</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 引用：</span></span><br><span class="line">函数名 [ 参数1 参数2 ...参数n ]</span><br></pre></td></tr></table></figure><p>在函数中得到函数返回值可以使用以下两种方法：</p><ul><li>在函数末尾加return，从函数中返回，用最后的<strong>命令状态</strong>决定返回值（<code>$?</code>）</li><li>返回一个数值，如0或1。格式如： return 0或者return 1</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/桌面$ cat func.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">function func()&#123;</span><br><span class="line">echo "hello"</span><br><span class="line">echo "world"</span><br><span class="line">&#125;</span><br><span class="line">func</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/桌面$ bash func.sh </span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>说明获取的是<strong>命令状态</strong>而不是命令的输出值</p><h2 id="用户和组群账户管理"><a href="#用户和组群账户管理" class="headerlink" title="用户和组群账户管理"></a>用户和组群账户管理</h2><h3 id="用户账户管理"><a href="#用户账户管理" class="headerlink" title="用户账户管理"></a>用户账户管理</h3><h4 id="Linux用户账户概述"><a href="#Linux用户账户概述" class="headerlink" title="Linux用户账户概述"></a>Linux用户账户概述</h4><p>用户在Linux系统中是分角色的，用户的角色是通过UID（用户ID号）来标识的，每个用户的UID都是不同的。在Linux系统中主要有<strong>root用户、虚拟用户和普通用户</strong>这3类用户。</p><ul><li><p>root用户</p><p>root用户是Linux系统的内置用户，在系统中的权限最高，也被称之为超级管理用户。在系统中的每个文件、目录和进程都归属于某一个用户，没有用户许可，<strong>除root用户外</strong>的其它普通用户无法进行操作</p></li><li><p>虚拟用户</p><p>这类用户也被称为伪用户或假用户，<strong>这类用户不具有登录系统的能力</strong>，但却是系统运行不可缺少的用户，比如bin， daemon， adm，ftp以及mail等用户账户，这类用户都是Linux系统的<strong>内置用户</strong></p></li><li><p>普通用户</p><p>这类用户是由系统管理员创建，并且能登录Linux系统。只能操作自己目录内的文件，权限有限</p></li></ul><h4 id="Linux用户账户配置文件"><a href="#Linux用户账户配置文件" class="headerlink" title="Linux用户账户配置文件"></a>Linux用户账户配置文件</h4><p>用户管理主要是<strong>通过修改用户配置文件完成</strong>的，使用用户管理控制工具的最终目的也是为了修改用户配置文件。</p><h5 id="etc-passwd文件"><a href="#etc-passwd文件" class="headerlink" title="/etc/passwd文件"></a>/etc/passwd文件</h5><p>/etc/passwd是系统识别用户的一个文件，Linux系统中所有的用户都记录在该文件中。<strong>任何用户</strong>都可以读取该文件内容，在/etc/passwd文件中，<strong>每一行表示的是一个用户账户信息</strong>，<strong>一行有7个段位，每个段位用“:”分隔</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/29/5d3ea1207389631335.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>每个用户都对应一个唯一的UID，Linux的用户UID值是非负整数， root的UID是0，拥有系统最高权限。UID的唯一性关系到系统的安全，比如在/etc/passwd文件中把用户zhangsan的UID改为0后， zhangsan这个用户会被确认为root用户。</p><p><strong>UID是确认用户权限的标识，用户登录系统所处的角色是通过UID来实现的，而不是用户名</strong>。</p><h5 id="etc-shadow文件"><a href="#etc-shadow文件" class="headerlink" title="/etc/shadow文件"></a>/etc/shadow文件</h5><p>/etc/shadow文件是/etc/passwd文件的影子文件，这个文件并不是由/etc/passwd文件产生，这两个文件是<strong>对应互补</strong>的。/etc/shadow文件内容包括<strong>用户及被加密的口令</strong>及<strong>其他/etc/passwd不能包括的信息，比如用户账户的有效期限</strong>等。/etc/shadow文件的内容包括9个段位，每个段位之间用“ :”分隔：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/29/5d3ea44904bdc53896.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="字符界面下用户账户的设置"><a href="#字符界面下用户账户的设置" class="headerlink" title="字符界面下用户账户的设置"></a>字符界面下用户账户的设置</h4><h5 id="创建新账户"><a href="#创建新账户" class="headerlink" title="创建新账户"></a>创建新账户</h5><p>创建用户账户就是在系统中创建一个新账户，然后为新账户分配<u>用户UID、用户组群、主目录和登录Shell</u>等资源，新创建的用户账户<strong>默认是被锁定的，无法使用</strong>，需要<strong>使用passwd命令设置密码</strong>以后才能使用。使用useradd命令可以在Linux系统下创建用户账户。</p><h5 id="修改账户"><a href="#修改账户" class="headerlink" title="修改账户"></a>修改账户</h5><p>使用usermod命令能更改用户的Shell类型、所属的用户组群、用户口令的有效期，还能更改用户的登录名</p><h5 id="删除用户账户"><a href="#删除用户账户" class="headerlink" title="删除用户账户"></a>删除用户账户</h5><p>使用userdel命令可以在Linux系统下删除用户账户：<code>userdel [-r][用户名]</code>，其中-r是指在删除该用户的同时一起删除主目录</p><h3 id="组群账户管理"><a href="#组群账户管理" class="headerlink" title="组群账户管理"></a>组群账户管理</h3><h4 id="Linux组群账户配置文件"><a href="#Linux组群账户配置文件" class="headerlink" title="Linux组群账户配置文件"></a>Linux组群账户配置文件</h4><p>/etc/gshadow是/etc/group的加密信息文件</p><h5 id="etc-group文件"><a href="#etc-group文件" class="headerlink" title="/etc/group文件"></a>/etc/group文件</h5><p>/etc/group文件的内容包括用户组群名、用户组群口令、 GID及该用户组群所包含的用户，每个用户组群都有一条记录。一行有4个段位，每个段位用“:” 分隔。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/29/5d3eae591ea3b22405.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>组群GID和UID类似，是一个从0开始的非负整数， <strong>GID为0的组群是root组群</strong>。Fedora 17系统会预留1000个GID号给系统虚拟用户组群使用，创建的新组群GID是从1000开始的。</p><h5 id="etc-gshadow文件"><a href="#etc-gshadow文件" class="headerlink" title="/etc/gshadow文件"></a>/etc/gshadow文件</h5><p>/etc/gshadow文件是/etc/group的加密文件，比如<strong>用户组群管理口令</strong>就是存放在这个文件中。/etc/gshadow文件中每个用户组群都有一条记录。一行有4个段位，每个段位之间用“ :”分隔。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/29/5d3eb098a186369791.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="字符界面下组群账户的设置"><a href="#字符界面下组群账户的设置" class="headerlink" title="字符界面下组群账户的设置"></a>字符界面下组群账户的设置</h4><p>在Linux系统字符界面下创建、修改以及删除组群账户主要使用groupadd，groupmod<br>和groupdel这3个命令。</p><h5 id="创建组群账户"><a href="#创建组群账户" class="headerlink" title="创建组群账户"></a>创建组群账户</h5><p>命令语法：<code>groupadd [-g gid [-o]] [-f] [组群名]</code></p><p>默认创建的是用户群组，即默认分配的GID大于等于1000，可以通过-g指定GID；-r选项可以创建系统群组，即默认分配的GID小于1000</p><h5 id="修改组群账户"><a href="#修改组群账户" class="headerlink" title="修改组群账户"></a>修改组群账户</h5><p>命令语法：<code>groupmod [-g &lt;组群识别码&gt; &lt;-o&gt;][-n &lt;新组群名称&gt;] [组群名称]</code></p><h5 id="删除组群账户"><a href="#删除组群账户" class="headerlink" title="删除组群账户"></a>删除组群账户</h5><p>命令语法：<code>groupdel [组群名称]</code></p><h3 id="账户相关文件或目录"><a href="#账户相关文件或目录" class="headerlink" title="账户相关文件或目录"></a>账户相关文件或目录</h3><h4 id="etc-skel目录"><a href="#etc-skel目录" class="headerlink" title="/etc/skel目录"></a>/etc/skel目录</h4><p>/etc/skel目录是存放用户启动文件的目录，这个目录由root用户管理，当管理员创建新用户时，这个目录下的文件会自动复制到新创建的用户的主目录下。/etc/skel目录下的文件都是隐藏文件，也就是类似“ .file” 格式的，可以通过添加、修改和删除/etc/skel目录下的文件，来为用户提供一个统一、标准和默认的用户环境。</p><h4 id="etc-login-defs配置文件"><a href="#etc-login-defs配置文件" class="headerlink" title="/etc/login.defs配置文件"></a>/etc/login.defs配置文件</h4><p>/etc/login.defs文件规定了<strong>创建新用户时的一些默认设置</strong>，比如创建用户时是否需要主目录、 UID和GID的范围、用户账户口令的期限等，这个文件可以通过root用户来修改</p><h4 id="etc-default-useradd文件"><a href="#etc-default-useradd文件" class="headerlink" title="/etc/default/useradd文件"></a>/etc/default/useradd文件</h4><p>/etc/default/useradd文件是在使用useradd命令创建用户账户时的规则文件</p><h3 id="用户和组群维护命令"><a href="#用户和组群维护命令" class="headerlink" title="用户和组群维护命令"></a>用户和组群维护命令</h3><h4 id="账户维护命令"><a href="#账户维护命令" class="headerlink" title="账户维护命令"></a>账户维护命令</h4><h5 id="passwd命令"><a href="#passwd命令" class="headerlink" title="passwd命令"></a>passwd命令</h5><p>使用passwd命令可以设置或修改用户的口令，普通用户和超级权限用户都可以运行passwd。<strong>普通用户只能更改自己的用户口令</strong>，root用户可以设置或修改任何用户的口令。如果passwd命令后面<strong>不接任何选项或用户名，则表示修改当前用户的口令</strong>。</p><p>命令语法：<code>passwd [选项] [用户名]</code></p><p>可以使用-l选项来锁住某个用户的口令，这样该用户就无法登录，但是可以从其他用户中通过su切换到被锁定的用户，被锁定的用户口令前面有<code>!</code>标识（Ubuntu系统，其他系统可能会有差异，比如Fedora17系统上是双感叹号<code>!!</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test:!$6$N8tiFTQb$ViLVGgYXVKoOIdIcoXVfmug5tOfzwIVoeKia4uY6Wtw6n0sIEs1uTf9Ff6DI1.iOPX6/jzs.CDus8h.x6AonJ.:18106:0:99999:7:::</span><br></pre></td></tr></table></figure><p>可以使用-u选项来解锁某用户的口令；-d是直接删除某用户的口令，使其无法登录系统。</p><h5 id="gpasswd命令"><a href="#gpasswd命令" class="headerlink" title="gpasswd命令"></a>gpasswd命令</h5><p>使用gpasswd命令可以设置一个组群的组群密码，或是在组群中添加、删除用户。</p><p>命令语法：<code>gpasswd [-r|-R][组群名]</code> <code>gpasswd [选项][用户名][组群名]</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux系统基础&quot;&gt;&lt;a href=&quot;#Linux系统基础&quot; class=&quot;headerlink&quot; title=&quot;Linux系统基础&quot;&gt;&lt;/a&gt;Linux系统基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;此文章是根据南大软院曾老师的《Linux系统基础》课程pp
      
    
    </summary>
    
      <category term="linux" scheme="http://QQ876684433.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://QQ876684433.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Java分布式应用知识点</title>
    <link href="http://QQ876684433.github.io/2019/07/24/Java%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://QQ876684433.github.io/2019/07/24/Java分布式应用知识点/</id>
    <published>2019-07-24T15:10:12.000Z</published>
    <updated>2019-09-15T05:02:14.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java分布式应用知识点"><a href="#Java分布式应用知识点" class="headerlink" title="Java分布式应用知识点"></a>Java分布式应用知识点</h1><h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><blockquote><p>来源：问题<a href="https://www.zhihu.com/question/22764869下的回答" target="_blank" rel="noopener">https://www.zhihu.com/question/22764869下的回答</a></p><p>知乎用户——by <a href="https://www.zhihu.com/people/yongxinge" target="_blank" rel="noopener">用心阁</a> 软件工程师</p></blockquote><ul><li><p>网络通讯，网络是分布式的基础，对分布式的理解建立在对网络的理解上，包括：</p></li><li><ul><li>OSI模型的7层</li><li>TCP/IP，DNS，NAT</li><li>HTTP，SPDY/HTTP2</li><li>Telnet</li></ul></li><li><p>网络编程，是通过程序在多个主机之间通信。包括：</p></li><li><ul><li><p>Socket</p></li><li><p>多线程</p></li><li><p>非阻塞IO</p></li><li><p>网络框架</p></li><li><ul><li>Netty</li><li>Mina</li><li>ZeroMQ</li></ul></li></ul></li><li><p>操作系统的网络部分</p></li><li><p>RPC，Socket使用不是很方便，很多分布式应用是基于RPC的，包括：</p></li><li><ul><li><p>同步RPC</p></li><li><p>异步RPC</p></li><li><p>主要的一些RPC协议</p></li><li><ul><li>RMI</li><li>Rest API</li><li>Thrift</li></ul></li></ul></li><li><p>集群，分布式计算离不开集群。集群就是多台主机被当作一个系统</p></li><li><ul><li><p>集群类型</p></li><li><ul><li>高可用，如主机备机切换，冷备，热备，双活</li><li>伸缩性，如Web服务器集群，数据库服务器的Sharding</li><li>并行计算，如网格，大数据</li></ul></li><li><p>集群相关技术，包括：</p></li><li><ul><li><p>高可用性，保证服务一直能够被访问，延长MTBF，缩短MTTR</p></li><li><ul><li>冗余的设备</li><li>多副本，为了避免单点失效</li></ul></li><li><p>负载均衡，如何将大量工作负载分配到多个主机上，最大化吞吐量，最小化平均响应时间，最大化资源利用率。</p></li><li><p>伸缩性（横向），能够添加计算机和设备来应对增长的计算压力</p></li><li><p>分片（Sharding），把数据分成多个数据集，由多个服务器来分别处理。</p></li><li><ul><li>自动分片</li></ul></li><li><p>容错性，当硬件或软件发生故障，能够继续运转</p></li><li><p>故障检测，以及故障预测</p></li><li><ul><li>心跳包</li><li>告警</li><li>性能预警</li></ul></li><li><p>故障转移，当出现错误，如何解决，为了高可用性和容错性</p></li><li><p>分布式一致性，在分布式环境中如何维持状态的一致性，严格一致性，还是最终一致性</p></li><li><p>集群状态协调，如Zookeeper，etcd等。</p></li><li><ul><li>分布式锁，在分布式环境中如何进行加锁</li><li>选主，当Master宕机，如何选择出新的Master，协议如Raft</li></ul></li><li><p>一致性哈希，如何将数据分布到集群中的多个主机。</p></li><li><p>分布式事务，保证在多台服务器上完成的操作符合事务的ACID属性。</p></li></ul></li></ul></li><li><p>安全，网络通常需要保证安全。</p></li><li><ul><li><p>身份认证，如何验证人或机器是他们声明的身份</p></li><li><ul><li>基于用户名/口令</li><li>基于数字证书</li></ul></li><li><p>私密性，如何防止窃听和嗅探</p></li><li><ul><li>对称加密</li><li>非对称加密</li></ul></li><li><p>完整性，如何保证数据不被篡改</p></li><li><ul><li>安全散列</li><li>消息认证码（MAC）</li></ul></li><li><p>不可否认性</p></li><li><ul><li>基于数字证书的数字签名和验签</li><li>基于密钥的散列，如HMAC</li></ul></li></ul></li><li><p>互联网站的基本架构</p></li><li><ul><li>页面缓存</li><li>负载均衡器，如HAProxy,Nginx</li><li>分布式缓存，如Memcache，Redis</li><li>消息队列，如ActiveMQ，Kafka</li></ul></li><li><p>分布式框架</p></li><li><ul><li><p>关系型数据库（Sharding，主从同步）</p></li><li><p>NoSQL</p></li><li><ul><li>HBase，基于HDFS和Zookeeper的NoSQL</li><li>Cassandra，无主集群</li></ul></li><li><p>大数据</p></li><li><ul><li>HDFS，分布式文件系统</li><li>MapReduce，将数据处理任务拆分为多个工作，通过集群来完成。</li><li>Spark，提供分布式的数据集抽象</li></ul></li></ul></li></ul><h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><ul><li>大型分布式网站架构设计与实践</li><li>大型网站技术架构：核心原理与案例分析</li><li>大型网站系统与Java中间件实践</li><li>分布式Java应用：基础与实践</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java分布式应用知识点&quot;&gt;&lt;a href=&quot;#Java分布式应用知识点&quot; class=&quot;headerlink&quot; title=&quot;Java分布式应用知识点&quot;&gt;&lt;/a&gt;Java分布式应用知识点&lt;/h1&gt;&lt;h2 id=&quot;相关知识点&quot;&gt;&lt;a href=&quot;#相关知识点&quot; c
      
    
    </summary>
    
      <category term="分布式" scheme="http://QQ876684433.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="分布式" scheme="http://QQ876684433.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>精读Servlet源码-javax.servlet.ServletContext</title>
    <link href="http://QQ876684433.github.io/2019/07/19/%E7%B2%BE%E8%AF%BBServlet%E6%BA%90%E7%A0%81-javax-servlet-ServletContext/"/>
    <id>http://QQ876684433.github.io/2019/07/19/精读Servlet源码-javax-servlet-ServletContext/</id>
    <published>2019-07-19T02:27:59.000Z</published>
    <updated>2019-09-15T05:02:14.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精读Servlet源码-javax-servlet-ServletContext"><a href="#精读Servlet源码-javax-servlet-ServletContext" class="headerlink" title="精读Servlet源码-javax.servlet.ServletContext"></a>精读Servlet源码-javax.servlet.ServletContext</h1><blockquote><p>参考：</p><p><a href="https://www.cnblogs.com/smyhvae/p/4140877.html" target="_blank" rel="noopener">https://www.cnblogs.com/smyhvae/p/4140877.html</a></p><p><a href="https://blog.csdn.net/gavin_john/article/details/51399425" target="_blank" rel="noopener">https://blog.csdn.net/gavin_john/article/details/51399425</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;精读Servlet源码-javax-servlet-ServletContext&quot;&gt;&lt;a href=&quot;#精读Servlet源码-javax-servlet-ServletContext&quot; class=&quot;headerlink&quot; title=&quot;精读Servlet源码-
      
    
    </summary>
    
      <category term="源码" scheme="http://QQ876684433.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="servlet" scheme="http://QQ876684433.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>精读Servlet源码-javax.servlet.ServletConfig</title>
    <link href="http://QQ876684433.github.io/2019/07/19/%E7%B2%BE%E8%AF%BBServlet%E6%BA%90%E7%A0%81-javax-servlet-ServletConfig/"/>
    <id>http://QQ876684433.github.io/2019/07/19/精读Servlet源码-javax-servlet-ServletConfig/</id>
    <published>2019-07-19T01:43:08.000Z</published>
    <updated>2019-09-15T05:02:14.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精读Servlet源码-javax-servlet-ServletConfig"><a href="#精读Servlet源码-javax-servlet-ServletConfig" class="headerlink" title="精读Servlet源码-javax.servlet.ServletConfig"></a>精读Servlet源码-javax.servlet.ServletConfig</h1><blockquote><p>参考：<a href="https://www.cnblogs.com/smyhvae/p/4140877.html" target="_blank" rel="noopener">https://www.cnblogs.com/smyhvae/p/4140877.html</a></p></blockquote><p><code>ServletConfig</code>的实例是servlet容器在初始化一个servlet时传递到<code>init()</code>方法的对象，它携带了一个servlet的相关配置以及初始化参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A servlet configuration object used by a servlet container</span></span><br><span class="line"><span class="comment"> * to pass information to a servlet during initialization. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="各个接口方法的说明"><a href="#各个接口方法的说明" class="headerlink" title="各个接口方法的说明"></a>各个接口方法的说明</h2><h3 id="getServletName"><a href="#getServletName" class="headerlink" title="getServletName"></a>getServletName</h3><p>返回servlet实例的名称，它可能是在web服务器中由服务器管理者提供的，如果servlet没有被注册到服务中，那么它将返回servlet实例的类名。</p><h3 id="getServletContext"><a href="#getServletContext" class="headerlink" title="getServletContext"></a>getServletContext</h3><p><code>getServletContext</code>返回<code>ServletContext</code>实例的引用，WEB容器在启动时，它会为<strong>每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用</strong>，并且保存在<code>ServletConfig</code>实例中并传递给对应的servlet，通过它可以允许调用者与servlet容器进行交互。</p><h3 id="getInitParameter"><a href="#getInitParameter" class="headerlink" title="getInitParameter"></a>getInitParameter</h3><p>初始化参数在<code>ServletConfig</code>中是以键值对方式存储的，<code>getInitParameter()</code>可以通过给定的参数名字获取对应的参数值，键和值都是以字符串的形式存储；如果对应的参数名字不存在，则返回null。</p><h3 id="getInitParameterNames"><a href="#getInitParameterNames" class="headerlink" title="getInitParameterNames"></a>getInitParameterNames</h3><p>获取所有的初始化参数，以Enumeration类型返回；如果没有，则返回一个空的Enumeration。Enumeration类似于迭代器，Enumeration接口中定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素。</p><h2 id="追根溯源：ServletConfig-vs-ServletContext"><a href="#追根溯源：ServletConfig-vs-ServletContext" class="headerlink" title="追根溯源：ServletConfig vs ServletContext"></a>追根溯源：ServletConfig vs ServletContext</h2><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>从更本质上来看，<code>ServletConfig</code>实际上代表的是当前Servlet在web.xml中的配置信息，在Servlet的配置文件中，可以使用&lt;servlet&gt;标签下的一个或多个&lt;init-param&gt;标签为servlet配置一些初始化参数。&lt;init-param&gt;标签是<strong>为某一个单独的servlet加配置信息，这种配置信息在其他的Servlet中是无法访问到的</strong>。</p><p>当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，程序员通过ServletConfig对象就可以得到当前servlet的初始化参数信息。</p><p>这样做的好处是：如果将数据库信息、编码方式等配置信息放在web.xml中，如果以后数据库的用户名、密码改变了，则<strong>直接很方便地修改web.xml就行了，避免了直接修改源代码的麻烦</strong>。</p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>WEB容器在启动时，它会为<strong>每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用</strong>。</p><p>ServletConfig对象中维护了ServletContext对象的引用，它是由servlet容器提供的，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。</p><p>由于一个WEB应用中的<strong>所有Servlet共享同一个ServletContext对象</strong>，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为<strong>context域对象</strong>。</p><p><u><em>对ServletContext更深入的研究请移步：精读Servlet源码-javax.servlet.ServletContext</em></u></p><h2 id="ServletConfig实例"><a href="#ServletConfig实例" class="headerlink" title="ServletConfig实例"></a>ServletConfig实例</h2><h3 id="编写Servlet"><a href="#编写Servlet" class="headerlink" title="编写Servlet"></a>编写Servlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletConfigDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletConfig servletConfig = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        resp.setContentType(<span class="string">"text/plain"</span>);</span><br><span class="line"></span><br><span class="line">        String servletName = servletConfig.getServletName();</span><br><span class="line">        out.println(<span class="string">"Servlet name: "</span> + servletName);</span><br><span class="line"></span><br><span class="line">        String username = servletConfig.getInitParameter(<span class="string">"username"</span>);</span><br><span class="line">        String password = servletConfig.getInitParameter(<span class="string">"password"</span>);</span><br><span class="line">        out.println(<span class="string">"=================servletConfig.getInitParameter================"</span>);</span><br><span class="line">        out.println(<span class="string">"username: "</span> + username);</span><br><span class="line">        out.println(<span class="string">"password: "</span> + password);</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">"=================servletConfig.getInitParameterNames================"</span>);</span><br><span class="line">        Enumeration&lt;String&gt; params = servletConfig.getInitParameterNames();</span><br><span class="line">        <span class="keyword">while</span> (params.hasMoreElements()) &#123;</span><br><span class="line">            String name = params.nextElement();</span><br><span class="line">            out.println(name + <span class="string">": "</span> + servletConfig.getInitParameter(name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletConfigDemo-xxxx<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>servlet.ServletConfigDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>steve_chph<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>password<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>mypassword123456<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>value1<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name2<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>value2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletConfigDemo-xxxx<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/ServletConfigDemo<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/19/5d312f57b095347163.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;精读Servlet源码-javax-servlet-ServletConfig&quot;&gt;&lt;a href=&quot;#精读Servlet源码-javax-servlet-ServletConfig&quot; class=&quot;headerlink&quot; title=&quot;精读Servlet源码-ja
      
    
    </summary>
    
      <category term="源码" scheme="http://QQ876684433.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="servlet" scheme="http://QQ876684433.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>精读Servlet源码-javax.servlet.http.HttpServlet</title>
    <link href="http://QQ876684433.github.io/2019/07/18/%E7%B2%BE%E8%AF%BBServlet%E6%BA%90%E7%A0%81-javax-servlet-http-HttpServlet/"/>
    <id>http://QQ876684433.github.io/2019/07/18/精读Servlet源码-javax-servlet-http-HttpServlet/</id>
    <published>2019-07-18T11:57:50.000Z</published>
    <updated>2019-09-15T05:02:14.670Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="源码" scheme="http://QQ876684433.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="servlet" scheme="http://QQ876684433.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>精读Servlet源码-javax.servlet.GenericServlet</title>
    <link href="http://QQ876684433.github.io/2019/07/18/%E7%B2%BE%E8%AF%BBServlet%E6%BA%90%E7%A0%81-javax-servlet-GenericServlet/"/>
    <id>http://QQ876684433.github.io/2019/07/18/精读Servlet源码-javax-servlet-GenericServlet/</id>
    <published>2019-07-18T11:57:19.000Z</published>
    <updated>2019-09-15T05:02:14.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精读Servlet源码-javax-servlet-GenericServlet"><a href="#精读Servlet源码-javax-servlet-GenericServlet" class="headerlink" title="精读Servlet源码-javax.servlet.GenericServlet"></a>精读Servlet源码-javax.servlet.GenericServlet</h1><p><code>GenericServlet</code>定义了通用的、协议独立的servlet，HTTP协议版的servlet即<code>HttpServlet</code>直接继承了<code>GenericServlet</code>；<code>GenericServlet</code>实现了<code>Servlet</code>和<code>ServletConfig</code>接口，它提供了<code>Servlet</code>接口生命周期方法的简单实现版本（<code>init</code>和<code>destroy</code>），同时对<code>ServletConfig</code>的接口方法作进一步的封装。</p><p><code>ServletConfig</code>作为<code>GenericServlet</code>的私有属性保存，它是在servlet在初始化时<code>init()</code>方法中传递进来的，这样就能在servlet的各个生命周期方法中以及servlet容器中访问到servlet配置及初始化参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LSTRING_FILE = <span class="string">"javax.servlet.LocalStrings"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ResourceBundle lStrings =</span><br><span class="line">        ResourceBundle.getBundle(LSTRING_FILE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="各个方法的说明"><a href="#各个方法的说明" class="headerlink" title="各个方法的说明"></a>各个方法的说明</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>因为servlet的初始化工作是由<code>init()</code>完成的，所以在构造函数里什么也不做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericServlet</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="Servlet接口方法"><a href="#Servlet接口方法" class="headerlink" title="Servlet接口方法"></a>Servlet接口方法</h3><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p><code>GenericServlet</code>除了实现<code>Servlet</code>接口的<code>init()</code>方法外，还提供了一个无参的<code>init()</code>方法：</p><ul><li><code>void init(ServletConfig config)</code> 由servlet容器调用，它将<code>ServletConfig</code>实例传递进来，<code>init()</code>的工作是将<code>ServletConfig</code>保存起来以备后用，然后再调用无参的<code>init()</code>来完成开发者自定义的初始化过程</li><li><code>void init()</code> 提供给开发者重写<code>init()</code>的便利方式，开发者可以根据需要在<code>init()</code>中完成servlet的初始化工作</li></ul><p>理论上，在开发servlet时重写任何一个<code>init()</code>都是可行的，区别在于如果重写的是带参数的<code>init()</code>，需要手动调用<code>super(config);</code>以将参数<code>ServletConfig</code>保存在servlet内部；如果重写的是无参的<code>init()</code>，那么就没有必要手动调用父类中对应的方法，因为servlet容器始终调用的是带参数的<code>init()</code>，带参数的<code>init()</code>随后又会调用无参的<code>init()</code>，如果开发者重写了无参的<code>init()</code>，那么也能完成自定义的servlet初始化工作。</p><p>一般来说推荐重写无参的<code>init()</code>，这样可以避免由于忘记调用<code>super(config);</code>而带来的不必要的麻烦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>抽象方法，<code>GenericServlet</code>没有提供任何实现，意味着任何一个具体子类必须实现<code>service()</code>方法以完成相应的业务逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span><span class="keyword">throws</span> ServletException, IOException</span>;</span><br></pre></td></tr></table></figure><h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h4><p>实现了一个空方法，由servlet容器调用，开发者可以根据需要重写该方法来完成servlet卸载前的相关资源清理工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="getServletInfo"><a href="#getServletInfo" class="headerlink" title="getServletInfo"></a>getServletInfo</h4><p>这是留给开发者自定义的方法，它的作用是用来返回servlet的相关信息比如：作者、版本和版权信息等等；<code>GenericServlet</code>中默认是返回一个空的字符串，因为具体的返回值是由实际的开发者决定的，但是有一个约定是：返回值应该是普通文本而不是标记文本（例如HTML、XML等等）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">""</span>;   &#125;</span><br></pre></td></tr></table></figure><h4 id="getServletConfig"><a href="#getServletConfig" class="headerlink" title="getServletConfig"></a>getServletConfig</h4><p>返回servlet保存的<code>ServletConfig</code>引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> config;   &#125;</span><br></pre></td></tr></table></figure><h3 id="ServletConfig接口方法"><a href="#ServletConfig接口方法" class="headerlink" title="ServletConfig接口方法"></a>ServletConfig接口方法</h3><p>这些接口方法实际上只是对<code>ServletConfig</code>的接口方法作了进一步的封装，实际上的工作是由servlet容器传递到<code>init()</code>方法的<code>ServletConfig</code>实例完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    ServletConfig sc = getServletConfig();</span><br><span class="line">    <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sc.getInitParameter(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServletConfig sc = getServletConfig();</span><br><span class="line">    <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sc.getInitParameterNames();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServletConfig sc = getServletConfig();</span><br><span class="line">    <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sc.getServletContext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServletConfig sc = getServletConfig();</span><br><span class="line">    <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        lStrings.getString(<span class="string">"err.servlet_config_not_initialized"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sc.getServletName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><h4 id="log"><a href="#log" class="headerlink" title="log"></a>log</h4><p>这个方法是对<code>getServletContext().log(...)</code>方法的进一步封装，用来向<code>ServletContext</code>输出servlet运行时的日志信息：</p><ul><li><code>void log(String msg)</code> 正常运行的日志信息，以对应的servlet名称作为日志信息前缀</li><li><code>void log(String message, Throwable t)</code> 运行时异常的日志信息，信息内容还包含了异常的调用栈追踪信息，以对应的servlet名称作为日志信息前缀</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    getServletContext().log(getServletName() + <span class="string">": "</span>+ msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message, Throwable t)</span> </span>&#123;</span><br><span class="line">    getServletContext().log(getServletName() + <span class="string">": "</span> + message, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;精读Servlet源码-javax-servlet-GenericServlet&quot;&gt;&lt;a href=&quot;#精读Servlet源码-javax-servlet-GenericServlet&quot; class=&quot;headerlink&quot; title=&quot;精读Servlet源码-
      
    
    </summary>
    
      <category term="源码" scheme="http://QQ876684433.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="servlet" scheme="http://QQ876684433.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>精读Servlet源码-javax.servlet.Servlet</title>
    <link href="http://QQ876684433.github.io/2019/07/18/%E7%B2%BE%E8%AF%BBServlet%E6%BA%90%E7%A0%81-javax-servlet-Servlet/"/>
    <id>http://QQ876684433.github.io/2019/07/18/精读Servlet源码-javax-servlet-Servlet/</id>
    <published>2019-07-18T08:41:32.000Z</published>
    <updated>2019-09-15T05:02:14.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精读Servlet源码-javax-servlet-Servlet"><a href="#精读Servlet源码-javax-servlet-Servlet" class="headerlink" title="精读Servlet源码-javax.servlet.Servlet"></a>精读Servlet源码-javax.servlet.Servlet</h1><p>servlet是运行在Web服务器上面的Java应用程序，Servlet接口类是servlet最核心的一个类，它定义了所有的servlet应该实现的方法，即servlet的生命周期方法，这些声明周期方法是由Web容器比如tomcat来调用的；同时也定义了获取一个servlet配置参数或者信息的方法。</p><p>GenericServlet类实现了Servlet类，定义了一个通用的、协议无关的servlet；而HttpServlet类继承了GenericServlet类，定义了HTTP协议下的servlet，它是抽象类，开发者必须继承HttpServlet并实现所有的抽象方法来创建具体的http servlet应用，它们的依赖关系如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/18/5d30365eae30f77247.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="各个接口方法的说明"><a href="#各个接口方法的说明" class="headerlink" title="各个接口方法的说明"></a>各个接口方法的说明</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p><code>init()</code>方法是用来指示一个servlet将被加载到web服务器的服务中，这个方法是在servlet初始化完成之后立即调用的，只有<code>init()</code>被调用并成功返回后，这个servlet才能接受、处理并响应客户端的请求。</p><p>当<code>inti()</code>调用过程中发生以下情况时，servlet是不会被加载到服务里面的：</p><ul><li><code>init()</code>抛出<code>ServletException</code>异常</li><li><code>init()</code>方法在Web服务器设定的时间内没有返回，即执行超时</li></ul><p>一个servlet的<code>init()</code>方法只会在初始化时会且只会被调用一次，它接受<code>ServletConfig</code>类型的参数，<code>ServletConfig</code>包含了servlet的配置和初始化参数，这些参数可以作用域Servlet的整个生命周期，<code>init()</code>方法可以使用这些参数完成相关的初始化工作。</p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>只有当<code>init()</code>成功调用并将servlet加载进服务中时，<code>service()</code>才能被servlet容器调用用来处理客户端的请求。一般servlet应用都是运行在多线程的servlet容器中，可以并行处理多个客户端请求，servlet每当接收到一个请求时都会产生一个新的线程来处理和该请求，因此就会出现多个servlet 同时访问相同的共享资源（如文件、内存资源等）的情况，这时要注意处理好线程同步的问题。</p><p><code>service()</code>方法由容器调用，<code>service()</code> 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以开发者不用对 <code>service()</code> 方法做任何动作，只需要根据来自客户端的请求类型来重写 <code>doGet()</code> 或 <code>doPost()</code> 即可。</p><p>它接受两个参数：<code>ServletRequest</code>和<code>ServletResponse</code>，分别对应客户端的请求和servlet对该请求作出的响应。</p><h3 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h3><p>在servlet被从容器中卸载之前调用，它可以用来清除该servlet占用的资源（例如关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动等）。</p><p><code>destroy()</code>方法仅当该servlet所有的service方法都成功返回之后、或者执行时间超时才能调用，而且<code>destroy()</code>方法一旦调用完成，这个servlet的<code>service()</code>就放就不会被调用了，而且servlet 对象被标记为垃圾回收，会等待JVM回收。</p><h3 id="getServletConfig"><a href="#getServletConfig" class="headerlink" title="getServletConfig"></a>getServletConfig</h3><p>该方法返回一个<code>ServletConfig</code>对象，这个对象恰好是servlet容器初始化servlet时传入<code>init()</code>方法的<code>ServletConfig</code>对象，因此在实现Servlet接口的时候要求<code>init()</code>方法能够将参数<code>ServletConfig</code>对象保存在servlet实例内部，而这个功能已经在Servlet接口实现类<code>GenericServlet</code>中实现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getServletInfo"><a href="#getServletInfo" class="headerlink" title="getServletInfo"></a>getServletInfo</h3><p>这是留给开发者自定义的方法，它的作用是用来返回servlet的相关信息比如：作者、版本和版权信息等等；这个方法在Servlet接口实现类<code>GenericServlet</code>中默认是返回一个空的字符串，具体的返回值是由实际的开发者决定的，但是有一个约定是：返回值应该是普通文本而不是标记文本（例如HTML、XML等等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Servlet生命周期架构图"><a href="#Servlet生命周期架构图" class="headerlink" title="Servlet生命周期架构图"></a>Servlet生命周期架构图</h2><p>典型的 Servlet 生命周期方案：</p><ul><li>第一个到达服务器的 HTTP 请求被委派到 Servlet 容器</li><li>Servlet 容器在调用 service() 方法之前加载 Servlet</li><li>然后 Servlet 容器处理由多个线程产生的多个请求，<strong>每个线程执行一个单一的 Servlet 实例的 service() 方法</strong></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/18/5d305e348bdc550818.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;精读Servlet源码-javax-servlet-Servlet&quot;&gt;&lt;a href=&quot;#精读Servlet源码-javax-servlet-Servlet&quot; class=&quot;headerlink&quot; title=&quot;精读Servlet源码-javax.servlet.
      
    
    </summary>
    
      <category term="源码" scheme="http://QQ876684433.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="servlet" scheme="http://QQ876684433.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb敲门砖-servlet概览</title>
    <link href="http://QQ876684433.github.io/2019/07/18/JavaWeb%E6%95%B2%E9%97%A8%E7%A0%96-servlet%E6%A6%82%E8%A7%88/"/>
    <id>http://QQ876684433.github.io/2019/07/18/JavaWeb敲门砖-servlet概览/</id>
    <published>2019-07-18T07:50:49.000Z</published>
    <updated>2019-09-15T05:02:14.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaWeb敲门砖-Servlet概览"><a href="#JavaWeb敲门砖-Servlet概览" class="headerlink" title="JavaWeb敲门砖-Servlet概览"></a>JavaWeb敲门砖-Servlet概览</h1><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><blockquote><p>来源：<a href="https://www.runoob.com/servlet/servlet-life-cycle.html" target="_blank" rel="noopener">https://www.runoob.com/servlet/servlet-life-cycle.html</a></p></blockquote><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p><ul><li>Servlet 通过调用 <strong>init ()</strong> 方法进行初始化。</li><li>Servlet 调用 <strong>service()</strong> 方法来处理客户端的请求。</li><li>Servlet 通过调用 <strong>destroy()</strong> 方法终止（结束）。</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</li></ul><h2 id="Servlet实例"><a href="#Servlet实例" class="headerlink" title="Servlet实例"></a>Servlet实例</h2><h3 id="编写Servlet类"><a href="#编写Servlet类" class="headerlink" title="编写Servlet类"></a>编写Servlet类</h3><p>开发web应用时，通常是继承HttpServlet类来编写自己的Servlet应用，用以处理客户端的HTTP请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        message = <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        resp.setContentType(<span class="string">"text/html"</span>);</span><br><span class="line">        PrintWriter pw = resp.getWriter();</span><br><span class="line">        pw.println(<span class="string">"&lt;h1&gt;"</span>+message+<span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"end of servlet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译Servlet"><a href="#编译Servlet" class="headerlink" title="编译Servlet"></a>编译Servlet</h3><p>如果直接javac编译<code>.java</code>文件，会出现依赖问题，因为servlet默认不是标准jdk自带的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line">                    ^</span><br><span class="line">HelloWorld.java:<span class="number">4</span>: 错误: 程序包javax.servlet.http不存在</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line">                         ^</span><br><span class="line">HelloWorld.java:<span class="number">5</span>: 错误: 程序包javax.servlet.http不存在</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line">                         ^</span><br><span class="line">HelloWorld.java:<span class="number">6</span>: 错误: 程序包javax.servlet.http不存在</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line">                         ^</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>为了方便解决依赖问题，建议使用maven来编译整个项目，然后再在<code>target/classes</code>下面找到需要的class文件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/18/5d3079b72175b79338.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="部署Servlet"><a href="#部署Servlet" class="headerlink" title="部署Servlet"></a>部署Servlet</h3><p>进入在tomcat目录，在<code>webapps/</code>下面建立项目结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">webapps</span><br><span class="line">└── serv</span><br><span class="line">    ├── index.html*</span><br><span class="line">    └── WEB-INF</span><br><span class="line">        ├── classes</span><br><span class="line">        │   └── HelloWorld.class</span><br><span class="line">        └── web.xml</span><br></pre></td></tr></table></figure><p>其中index.html是可选的，在这里我们只是为了测试我们的servlet，因此可以不用建立这个文件。然后将我们之前编译好的HelloWorld.class复制到classes下，然后编写web.xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Welcome to my first jsp <span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">     Welcome to my jsp</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>   </span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/HelloWorld<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>保存后启动tomcat服务器<code>bin/startup.sh</code>，访问”<a href="http://localhost:8080/serv/HelloWorld&quot;就可以了。。。" target="_blank" rel="noopener">http://localhost:8080/serv/HelloWorld&quot;就可以了。。。</a></p><p>。。。。。。</p><p>wtf？为什么报错了？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/18/5d307bbf775da27042.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>别急，往下看</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果你细心的话可以发现，我们的HelloWorld类是在<code>servlet</code>包下面的，但是我们的classes结构和web.xml描述是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WEB-INF</span><br><span class="line">    ├── classes</span><br><span class="line">    │   └── HelloWorld.class <span class="comment">// 看这里</span></span><br><span class="line">    └── web.xml</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt; </span><br><span class="line">    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; </span><br><span class="line">    &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">HelloWorld</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt; // 看这里</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;   </span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">Hello</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">HelloWorld</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;  </span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是实际上HelloWorld这个类的完整类名是<code>servlet.HelloWorld</code>，很显然跟我们的配置不匹配，所以我们需要修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">webapps/serv/WEB-INF/</span><br><span class="line">├── classes</span><br><span class="line">│   └── servlet <span class="comment">// 看这里</span></span><br><span class="line">│       └── HelloWorld.class <span class="comment">// 看这里</span></span><br><span class="line">└── web.xml</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt; </span><br><span class="line">    &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; </span><br><span class="line">    &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">servlet</span>.<span class="title">HelloWorld</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt; // 看这里</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;   </span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">Hello</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">HelloWorld</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;  </span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>保存后重启tomcat，然后再次访问页面：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/18/5d307d724192099566.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这很舒服了！</p><h3 id="servlet配置"><a href="#servlet配置" class="headerlink" title="servlet配置"></a>servlet配置</h3><p>为了让Servlet能响应用户请求，还必须将Servlet配置在web应用中，配置Servlet需要修改web.xml文件。从Servlet3.0开始，配置Servlet有两种方式：</p><ul><li>在Servlet类中使用@WebServlet Annotation进行配置。</li><li>在web.xml文件中进行配置。</li></ul><p>这里面我们用的是web.xml配置的方式。这里只介绍一下最核心的部分，更详细的内容可以参考：<a href="https://blog.csdn.net/believejava/article/details/43229361" target="_blank" rel="noopener">https://blog.csdn.net/believejava/article/details/43229361</a></p><ul><li>&lt;servlet&gt;定义一个servlet，它必须含有&lt;servlet-name&gt;和&lt;servlet-class&gt;<ul><li>&lt;servlet-name&gt;：用来定义servlet的名称，该名称<strong>在整个应用中必须是惟一的</strong></li><li>&lt;servlet-class&gt;：用来指定servlet的完全限定的名称，例如我们定义的servlet全限定名为<code>servlet.HelloWorld</code></li></ul></li><li>&lt;servlet-mapping&gt;用来定义servlet与请求url的匹配规则，它含有&lt;servlet-name&gt;和&lt;url-pattern&gt;<ul><li>&lt;servlet-name&gt;：Servlet的名字，唯一性和一致性，与&lt;servlet&gt;元素中声明的名字一致</li><li>&lt;url-pattern&gt;：指定相对于Servlet的URL的路径。该路径<strong>相对于web应用程序上下文的根路径</strong>，例如我们上面定义了应用的根路径是<code>/serv</code>，那么最后我们访问该servlet的url就是：<code>http://localhost:8080/serv/&lt;url-pattern&gt;</code>。&lt;servlet-mapping&gt;将URL模式映射到某个Servlet，即该Servlet处理的URL</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaWeb敲门砖-Servlet概览&quot;&gt;&lt;a href=&quot;#JavaWeb敲门砖-Servlet概览&quot; class=&quot;headerlink&quot; title=&quot;JavaWeb敲门砖-Servlet概览&quot;&gt;&lt;/a&gt;JavaWeb敲门砖-Servlet概览&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="后端" scheme="http://QQ876684433.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="servlet" scheme="http://QQ876684433.github.io/tags/servlet/"/>
    
  </entry>
  
</feed>
