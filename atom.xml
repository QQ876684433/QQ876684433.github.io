<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>至繁归于至简 - chph&#39;s blog</title>
  
  <subtitle>steve_chph personal website</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://QQ876684433.github.io/"/>
  <updated>2019-11-27T03:06:46.459Z</updated>
  <id>http://QQ876684433.github.io/</id>
  
  <author>
    <name>steve_chph</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++面向对象之继承</title>
    <link href="http://QQ876684433.github.io/2019/11/26/CPP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF/"/>
    <id>http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/</id>
    <published>2019-11-26T11:06:55.000Z</published>
    <updated>2019-11-27T03:06:46.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-面向对象之继承"><a href="#C-面向对象之继承" class="headerlink" title="C++面向对象之继承"></a>C++面向对象之继承</h1><blockquote><p>参考书籍：《Primer C++, 5th》</p></blockquote><h2 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h2><p>多重继承的派生类继承了<strong>所有父类的属性</strong></p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul><li>关键字class对应的默认访问说明符是private，关键字struct对应的是public</li><li>多重继承的派生列表只能包含已经被定义过的类，而且这些类不能是final的</li><li>派生列表中，同一个基类只能出现一次</li></ul><h4 id="多重继承的派生类从每个基类中继承状态"><a href="#多重继承的派生类从每个基类中继承状态" class="headerlink" title="多重继承的派生类从每个基类中继承状态"></a>多重继承的派生类从每个基类中继承状态</h4><p>多重继承关系中，派生类的对象包含有每个基类的子对象，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span>:</span> <span class="keyword">public</span> ZooAnimal &#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span>:</span> <span class="keyword">public</span> Bear, <span class="keyword">public</span> Endangered &#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/GgkZVWIScfHp3xd.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="派生类构造函数初始化所有基类"><a href="#派生类构造函数初始化所有基类" class="headerlink" title="派生类构造函数初始化所有基类"></a>派生类构造函数初始化所有基类</h4><p>构造一个派生类的对象将同时构造并初始化它的所有基类子对象，多重继承的派生类的构造函数初始值只能初始化<strong>它的直接基类</strong>（例如Panda的直接基类是Bear和Endangered）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/hyInO1iSfWBeQxG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>基类的构造顺序与<strong>派生列表中基类的出现顺序</strong>保持一致，而与派生类构造函数初始值列表中的基类顺序无关</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/WQIKwVPa67NtE2v.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/vNV8IH3zrX4Jjla.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="继承的构造函数与多重继承"><a href="#继承的构造函数与多重继承" class="headerlink" title="继承的构造函数与多重继承"></a>继承的构造函数与多重继承</h4><p>C++11中允许派生类继承多个基类的构造函数，但是如果从多个基类中继承了相同的构造函数（形参列表完全相同），那么程序将报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base1() = <span class="keyword">default</span>;</span><br><span class="line">    Base1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);</span><br><span class="line">    Base1(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base2() = <span class="keyword">default</span>;</span><br><span class="line">    Base2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);</span><br><span class="line">    Base2(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tempCodeRunnerFile.cpp:20:18: error: ‘D1::D1(const string&amp;)’ inherited from ‘Base2’</span><br><span class="line">     using Base2::Base2;</span><br><span class="line">                  ^~~~~</span><br><span class="line">tempCodeRunnerFile.cpp:19:18: error: conflicts with version inherited from ‘Base1’</span><br><span class="line">     using Base1::Base1;</span><br></pre></td></tr></table></figure><p>此时必须在派生类中<strong>定义这个冲突构造函数的派生类自己的版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">    D1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)&#123;&#125;</span><br><span class="line">    D1() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：前面版本的D1之所以只对<code>D1::D1(const string&amp;)</code>报错，是因为D1中没有定义自己版本的构造函数，编译器为D1合成了默认的构造函数，<strong>覆盖了从Base1和Base2继承过来的冲突的默认版本的构造函数</strong>；但是现在这个版本定义了自己的<code>D1(const std::string &amp;){}</code>来解决冲突，导致编译器不会为D1合成默认构造函数，因此也需要为D1显式定义默认构造函数</p><h4 id="析构函数与多重继承"><a href="#析构函数与多重继承" class="headerlink" title="析构函数与多重继承"></a>析构函数与多重继承</h4><p>析构函数的调用顺序与构造函数相反：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure><h4 id="多重继承的派生类的拷贝与移动操作"><a href="#多重继承的派生类的拷贝与移动操作" class="headerlink" title="多重继承的派生类的拷贝与移动操作"></a>多重继承的派生类的拷贝与移动操作</h4><ul><li>多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或者赋值操作</li><li><strong>只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作</strong></li></ul><p>例如Panda调用合成版本的拷贝构造函数，首先调用Bear的拷贝构造函数拷贝Bear子对象部分，而Bear又会在执行之前调用呢ZooAnimal的拷贝构造函数拷贝ZooAnimal子对象部分，Bear子对象部分拷贝完成后，又会调用Endangered拷贝构造函数拷贝Endangered子对象部分，最后才调用Panda的合成构造函数拷贝Panda部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/gJ7axq3sVvUAQhj.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="类型转换与多个基类"><a href="#类型转换与多个基类" class="headerlink" title="类型转换与多个基类"></a>类型转换与多个基类</h3><p>派生类有多个基类时，如果存在多个以基类为参数的重载函数，那么编译器会报错，因为<strong>编译器不会在派生类向基类的几种转换中进行比较和选择</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Panda.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Bear.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Endangered.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ZooAnimal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Endangered &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Panda p;</span><br><span class="line">    func(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译报错，程序有二义性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Test01.cpp: In function ‘int main(int, const char**)’:</span><br><span class="line">Test01.cpp:<span class="number">15</span>:<span class="number">11</span>: error: call of overloaded ‘func(Panda&amp;)’ is ambiguous</span><br><span class="line">     func(p);</span><br><span class="line">           ^</span><br><span class="line">Test01.cpp:<span class="number">6</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br><span class="line">Test01.cpp:<span class="number">8</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Endangered &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br><span class="line">Test01.cpp:<span class="number">10</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br></pre></td></tr></table></figure><p>注意：这个只限于直接基类为参数的重载，比如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Panda.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Bear.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Endangered.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ZooAnimal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span> &lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void func(Endangered &amp;) &#123; cout &lt;&lt; "func(Endangered &amp;) &lt;&lt; endl;"; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Panda p;</span><br><span class="line">    func(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承关系是ZooAnimal -&gt; Bear -&gt; Panda，输出结果是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">func(Bear &amp;)</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure><p>即会调用继承链上最近的那个重载版本</p><h4 id="基于指针类型或引用类型的查找"><a href="#基于指针类型或引用类型的查找" class="headerlink" title="基于指针类型或引用类型的查找"></a>基于指针类型或引用类型的查找</h4><p>通过基类指针来引用派生类对象时，如果析构函数是非虚函数，那么delete时无法调用派生类对象的析构函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooAnimal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal(<span class="comment">/* args */</span>);</span><br><span class="line">    ~ZooAnimal();</span><br><span class="line">&#125;;</span><br><span class="line">... ...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Panda p;</span></span><br><span class="line">    ZooAnimal *z_ptr = <span class="keyword">new</span> Panda();</span><br><span class="line">    <span class="comment">// func(p);</span></span><br><span class="line">    <span class="keyword">delete</span> z_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~ZooAnimal()</span><br><span class="line">    </span><br><span class="line">====================================================================</span><br><span class="line">====================================================================</span><br><span class="line">    </span><br><span class="line">class ZooAnimal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal(<span class="comment">/* args */</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~ZooAnimal();</span><br><span class="line">&#125;;</span><br><span class="line">... ...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Panda p;</span></span><br><span class="line">    ZooAnimal *z_ptr = <span class="keyword">new</span> Panda();</span><br><span class="line">    <span class="comment">// func(p);</span></span><br><span class="line">    <span class="keyword">delete</span> z_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure><p>在基类和派生类的析构函数都是虚函数时，无论使用哪个基类的指针来引用派生类对象，调用析构函数时，<strong>都是按照调用派生类对象析构函数的顺序执行</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~MI() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~MI()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 *pb1 = <span class="keyword">new</span> MI;</span><br><span class="line">    Base2 *pb2 = <span class="keyword">new</span> MI;</span><br><span class="line">    D1 *pd1 = <span class="keyword">new</span> MI;</span><br><span class="line">    D2 *pd2 = <span class="keyword">new</span> MI;</span><br><span class="line">    <span class="keyword">delete</span> pb2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pd2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line"></span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line"></span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br></pre></td></tr></table></figure><h3 id="多重继承下的类作用域"><a href="#多重继承下的类作用域" class="headerlink" title="多重继承下的类作用域"></a>多重继承下的类作用域</h3><p>单继承与多继承时的不同：</p><ul><li>单继承时，派生类的作用域嵌套在直接基类和间接基类的作用域中，查找过程<strong>沿着继承体系自底向上</strong>进行，直到找到所需的<strong>名字</strong>；派生类的名字将隐藏基类的<strong>同名成员</strong></li><li>多继承时，相同的查找过程将<strong>在所有直接基类中同时进行</strong>，如果<strong>名字</strong>在多个基类中都被找到，则对该名字的使用将具有二义性</li></ul><p>注意一点是，上面强调的是<strong>名字</strong>，即使派生类继承的两个函数形参列表不同也可能产生错误，因为它是<strong>按名字查找</strong>，<strong>先查找名字后进行类型检查</strong>，当编译器在两个作用域中同时发现了同名成员将直接报告一个调用二义性的错误</p><p>对一个派生类来说，从多个基类中分别继承同名的成员是完全合法的，只不过<strong>在使用这个名字时必须明确指出它的版本（这个如下面代码所示）</strong>；也就是说，派生仅是产生了潜在的二义性，只要没有调用就不会产生二义性（可以通过编译）；要想避免潜在的二义性，最好的办法是<strong>在派生类中为该函数定义一个新版本</strong>，或者<strong>通过using来显式使用确定的基类版本</strong>（例如using ZooAnimal::max_weight，或者using Endangered::max_weight）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~MI() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~MI()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="comment">// using D1::func1;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 *pb1 = <span class="keyword">new</span> MI;</span><br><span class="line">    Base2 *pb2 = <span class="keyword">new</span> MI;</span><br><span class="line">    D1 *pd1 = <span class="keyword">new</span> MI;</span><br><span class="line">    D2 *pd2 = <span class="keyword">new</span> MI;</span><br><span class="line">    <span class="keyword">delete</span> pb2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pd2;</span><br><span class="line">    MI mi;</span><br><span class="line">    mi.D1::func1();<span class="comment">// 显式指定使用的名字的版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虽然派生列表中同一个基类只能出现一次，但是派生类可以多次继承同一个类；派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类</p><p>默认情况下，派生类中含有继承链上每个类对应的字部分，如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/SRzq3O6imcCPptu.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看到，B1(base)和B2(base)中包含的A(base)是两个不同子部分（从x值不同可以看出，并且A的构造函数也调用了两次）</p><p>有时候要实现多次出现的同一个基类的共享，可以使用<strong>虚继承</strong>：虚继承的目的是令某个类作出声明，承诺愿意共享它的基类（共享的基类子对象称为<strong>虚基类</strong>），这样不论虚基类在继承体系中出现了多少次，<strong>在派生类中都只包含唯一一个共享的虚基类子对象</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/MRUSntrFqzxQeLJ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从上图可以看出此时A基类子对象只有一个，A只调用了一次构造函数</p><p>虚基类的缺点：必须在虚派生的真实需求出现之前就已经完成了虚派生的操作；在实际编程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题，它不会影响派生类本身，只会影响从制定了虚基类的派生类章进一步派生出来的类：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/gxDu6ZH7o28FTmY.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>例如Bear声明ZooAnimal为虚继承不会对Bear自身造成影响，但会对Panda造成影响</p><h4 id="使用虚基类"><a href="#使用虚基类" class="headerlink" title="使用虚基类"></a>使用虚基类</h4><p>指定虚基类的方式是在派生列表中添加关键字virtual，其中virtual和访问修饰符如public的顺序随意</p><p>virtual说明符表明了一种愿望：<strong>在后续的派生类中共享虚基类的同一份实例</strong></p><h4 id="虚基类成员的可见性"><a href="#虚基类成员的可见性" class="headerlink" title="虚基类成员的可见性"></a>虚基类成员的可见性</h4><ul><li>在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并且不会产生二义性</li><li>如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员</li><li>如果成员被多于一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本</li></ul><p>例如有如下继承关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>如果在D的对象中使用x，则有三种可能性：</p><ul><li><p>D1、D2都没有x的定义，此时x被解析为<strong>B的成员</strong>，此时不存在二义性</p></li><li><p>D1和D2只有其中一个有x的定义，此时依然没有二义性，派生类（D1或者D2）的x比共享虚基类B的x优先级更高（如下代码所示）</p><p><img src="https://i.loli.net/2019/11/27/gKDkOyYmW6idbsT.png" alt></p></li><li><p>D1、D2中均有x的定义，直接访问x将产生二义性</p></li></ul><p>解决这种二义性的最好方法是<strong>在派生类中为成员自定义新的实例</strong></p><h3 id="构造函数与虚继承"><a href="#构造函数与虚继承" class="headerlink" title="构造函数与虚继承"></a>构造函数与虚继承</h3><p>在虚派生中，虚基类是由最底层的派生类初始化的</p><h4 id="虚继承的对象的构造方式"><a href="#虚继承的对象的构造方式" class="headerlink" title="虚继承的对象的构造方式"></a>虚继承的对象的构造方式</h4><p>含有虚基类的对象的构造顺序与一般的顺序稍有区别：</p><ul><li>首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分</li><li>接下来按照直接基类在派生列表中出现的次序依次对其进行初始化</li></ul><p>也就是说：<strong>虚基类总是先于非虚基类构造，与他们在继承体系中的次序和位置无关</strong>；如下代码所示，B处于派生列表的第一个，但是虚基类A先于B进行初始化：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/HWQES617izRGBba.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>但是如果有多个虚基类的时候，虚基类的构造顺序则与派生列表的顺序有关，如下面代码所示，派生列表中B1是第一个直接基类，B1虚继承了A2，因此A2先于A1执行初始化：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/LkzYxlKp8vyaVme.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="构造函数与虚构函数的次序"><a href="#构造函数与虚构函数的次序" class="headerlink" title="构造函数与虚构函数的次序"></a>构造函数与虚构函数的次序</h4><p>一个类可以有多个虚基类，这些虚的子对象按照它们在派生列表中出现的顺序依次从左向右构造：<strong>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类；如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类</strong></p><p>对于如下的继承体系：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/MWCjRQivtZoUBY6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>它们的构造顺序如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/cj6vYmDgnwN8fAr.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>合成的拷贝和移动构造函数按照上面完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值；和往常一样，<strong>对象的销毁顺序与构造顺序正好相反</strong>：首先销毁TeddyBear，最后销毁ZooAnimal部分</p><p>最后来一个例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/uKTDBqH8k71PjLv.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>因为Class不是虚基类，因此<code>new Final</code>对象中含有多份Class的子对象部分，当使用Class类型指针绑定到<code>new Final</code>对象时，会造成Class基类的二义性，即控制台报错的：<code>ex18_29.cpp:15:21: error: ‘Class’ is an ambiguous base of ‘Final’</code></p><p>接下来我们修改一下，将其中一个Class申明为虚继承，另一个依然为普通继承：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/IXnykHGUbo2MhDq.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可以看到，Class还是存在二义性：<code>ex18_29.cpp:15:21: error: ‘Class’ is an ambiguous base of ‘Final’</code></p><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-面向对象之继承&quot;&gt;&lt;a href=&quot;#C-面向对象之继承&quot; class=&quot;headerlink&quot; title=&quot;C++面向对象之继承&quot;&gt;&lt;/a&gt;C++面向对象之继承&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考书籍：《Primer C++, 5th》&lt;/p&gt;

      
    
    </summary>
    
      <category term="C++" scheme="http://QQ876684433.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://QQ876684433.github.io/tags/C/"/>
    
      <category term="继承" scheme="http://QQ876684433.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="面向对象" scheme="http://QQ876684433.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-进程管理</title>
    <link href="http://QQ876684433.github.io/2019/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://QQ876684433.github.io/2019/11/17/操作系统-进程管理/</id>
    <published>2019-11-17T03:18:33.000Z</published>
    <updated>2019-11-17T14:35:03.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li></ul></blockquote><h2 id="进程定义和属性"><a href="#进程定义和属性" class="headerlink" title="进程定义和属性"></a>进程定义和属性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>从原理角度看：进程是支持程序执行的一种系统机制，它对处理器上运行程序的活动规律进行抽象</li><li>从实现角度看：进程是一种数据结构，用来准确地刻画运行程序的状态和系统动态变化状况</li></ul><p>操作系统有两个重要的特性：<strong>程序的并发性</strong>和<strong>资源的共享性</strong>。进程的概念既能描述程序的并发执行，又能共享系统的资源</p><ul><li><p>程序的并发性</p><p><img src="https://i.loli.net/2019/11/17/ZKvWsaEm7UnCDlS.png" alt></p><p><img src="https://i.loli.net/2019/11/17/Nf6P3UL12ESwJdV.png" alt></p><p>正因为“程序”自身这种静态的概念无法刻画程序的并发性，因此需要引入“进程”来描述系统内部程序的并发执行，提高资源利用率</p></li><li><p>资源的共享性</p><ul><li>“可再入”程序：能够被多个程序同时调用的程序</li><li>“可再用”程序：在备用过程中可以有自身修改，在调用它的程序退出之前不允许其他程序来调用</li></ul><p>“可再入”程序是纯代码，在执行过程中不被修改，调用它的各应用程序提供工作区，因此它可以被多个应用程序调用</p></li></ul><p>进程是既能描述程序的并发执行，又能共享系统资源的一个基本单位，当然操作系统也要为引入进程而付出<strong>（进程占用的）空间</strong>和<strong>（调度进程的）时间</strong>代价</p><p><strong>进程的定义</strong>：<u>进程是具有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位</u></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/QZayghxfTnXqtsw.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/4P2OSBkyueYQmaR.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/KsPmo4Qn3SlJLCG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="进程的状态和转换"><a href="#进程的状态和转换" class="headerlink" title="进程的状态和转换"></a>进程的状态和转换</h3><h4 id="三态模型"><a href="#三态模型" class="headerlink" title="三态模型"></a>三态模型</h4><p>进程是活动的且有状态变化，状态及其转换体现进程的动态性，进程在执行过程中有三种状态：</p><ul><li><p><strong>运行态（running）</strong></p><p>进程占有处理器正在运行的状态</p></li><li><p><strong>就绪态（ready）</strong></p><p>进程具备运行条件，等待系统分配处理器以便运行的状态</p></li><li><p><strong>等待态（wait）</strong></p><p>阻塞态（blocked）或睡眠态（sleep），指进程不具备运行条件，正在等待某个时间完成的状态</p></li></ul><p>处于运行态的进程个数不能大于处理器的个数，处于就绪态和等待态的进程可能有多个（非运行态进程的划分的主要依据是<strong>不能运行的原因</strong>）</p><p><strong>CPU只会从就绪态队列选择进程来执行，因此等待态队列的进程是被暂时性剥夺了获得CPU的机会</strong></p><h6 id="三态模型的状态转换"><a href="#三态模型的状态转换" class="headerlink" title="三态模型的状态转换"></a>三态模型的状态转换</h6><ul><li>进程在创建后处于就绪态</li><li>运行态进程因出现等待事件或者等待信号而进入等待态</li><li>当等待事件发生或者等待信号到达后，等待态进程变成就绪态</li><li>处理器的调度会引起运行态和就绪态进程之间的切换</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/8OiGTFmI4pnJVME.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="七态模型"><a href="#七态模型" class="headerlink" title="七态模型"></a>七态模型</h4><ul><li><p><strong>新建态（new）</strong></p><p>新建态对应于进程被创建时的状态，尚未进入就绪队列（有时候根据系统性能要求或内存容量限制推迟新建态被调度执行）</p><p>创建进程要通过两个步骤：</p><ul><li>先为新进程分配所需资源和建立必要的管理信息</li><li>然后设置该进程为就绪态，并等待被调度执行</li></ul></li><li><p><strong>终止态（exit）</strong></p><p>进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态，<strong>处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失</strong></p><p>进程终止要通过两个步骤：</p><ul><li>先等待操作系统或相关进程进行善后处理（如抽取信息）</li><li>然后回收占用的资源并被系统删除</li></ul></li></ul><p>进程挂起的原因：（1）由于不断创建进程，当系统资源尤其是内存资源已经不能满足进程运行要求时，必须把某些进程<strong>挂起（suspend）</strong>，对换到磁盘对换区中，释放它占有的某些资源，<strong>暂时不参与低级调度</strong>，起到平滑系统负荷的目的；（2）也可能系统出现故障，需要暂时挂起一些进程，以便故障消除后再解除挂起并恢复进程运行；（3）用户调试程序过程中，可以请求挂起进程，以便进行某种检查和修改</p><ul><li><p><strong>挂起就绪态（ready suspend）</strong></p><p>进程具备运行条件，但目前在外存中，只有当它被对换到内存中才能被调度执行</p></li><li><p><strong>挂起等待态（blocked suspend）</strong></p><p>进程正在等待某一事件发生且进程在外存中</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/rq1eoyvYDEAOR78.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>挂起进程等同于不在内存中的进程，因此挂起进程不参与低级调度直到它们被对换进内存</p><p>挂起进程的特征：</p><ul><li>该进程不能被立即执行</li><li>该进程可能会等待事件或者等待信号，但是所等待的事件或者信号是独立于挂起条件的，事件结束并不能导致进程具备执行条件</li><li>该进程进入挂起状态是由于<strong>操作系统、父进程或者进程自身</strong>阻止它的运行</li><li>结束进程挂起状态的命令只能通过<strong>操作系统或父进程</strong>发出</li></ul><h2 id="进程描述和组成"><a href="#进程描述和组成" class="headerlink" title="进程描述和组成"></a>进程描述和组成</h2><h3 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h3><blockquote><p>参考资料：<a href="http://www.tldp.org/LDP/LG/issue23/flower/psimage.html" target="_blank" rel="noopener">http://www.tldp.org/LDP/LG/issue23/flower/psimage.html</a></p></blockquote><p>程序和数据是进程必需的组成部分，用来刻画静态特征；还需要一种称为<strong>进程控制块的数据结构</strong>来刻画进程的动态特征，描述进程状态、占用资源状况、记录调度信息等。由于进程状态不断发生变化，<strong>某时刻进程的内容及其状态集合称为进程映像（process image）</strong>，包括如下要素：</p><ul><li><p>进程控制块</p><p>每个进程捆绑一个，用来存储进程的标志信息、现场信息和控制信息。进程创建时建立进程控制块，进程撤销时回收进程控制块，它与进程一一对应</p></li><li><p>进程程序块</p><p>被进程执行的程序，规定进程一次运行所应完成的功能；这部分是可以被不同的进程共享的</p></li><li><p>进程核心栈</p><p>每个进程捆绑一个，进程<strong>在内核态工作时</strong>使用，用来保存中断/异常现场，保存函数调用的参数、局部变量和返回地址等</p><p><img src="https://i.loli.net/2019/11/17/tylHdTwJ7FGCs8X.png" alt></p><blockquote><p><strong>内核栈:</strong></p><p>系统栈（也叫核心栈、内核栈）是内存中属于操作系统空间的一块区域，其主要用途为：</p><pre><code>(1)保存中断现场，对于嵌套中断，被中断程序的现场信息依次压入系统栈，中断返回时逆序弹出；(2)保存操作系统子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。</code></pre><p>用户栈是用户进程空间中的一块区域，用于保存用户进程的子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。</p><p>那么为什么不直接用一个栈，何必浪费那么多的空间呢？？原因有二：</p><p>​      （1）如果只用系统栈。系统栈一般大小有限，如果中断有16个优先级，那么系统栈一般大小为15（只需保存15个低优先级的中断，另一个高优先级中断处理 程序处于运行），但用户程序子程序调用次数可能很多，那样15次子程序调用以后的子程序调用的参数、返回值、返回点以及子程序(函数)的局部变量就不能被 保存，用户程序也就无法正常运行了</p><p>​     （2）如果只用用户栈。我们知道系统程序需要在某种保护下运行，而用户栈在用户空间（即cpu处于用户态，而cpu处于核心态时是受保护的），不能提供相应的保护措施（或相当困难）</p><p>来源：<a href="https://www.cnblogs.com/yysblog/archive/2012/11/05/2755226.html" target="_blank" rel="noopener">https://www.cnblogs.com/yysblog/archive/2012/11/05/2755226.html</a></p></blockquote></li><li><p>进程数据块</p><p>进程的私有地址空间，存放各种私有数据，用户栈也在数据块中开辟，用于在函数调用时存放栈帧、局部变量和返回地址等参数</p><blockquote><p>May be distinguished as initialised variables including external global and static variables, uninitialised variables (known as a bss area on Unix derivative systems). Data blocks are not shared between processes by default.</p><p>可区分为初始化变量（包括外部全局变量和静态变量）和非初始化变量(在Unix派生系统中称为bss区域)；默认情况下，进程之间不共享数据块</p></blockquote></li></ul><h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>进程在系统中存在及活动除了本身映像外，还需要环境支撑，如硬件寄存器、程序状态字寄存器、支持动态地址转换的页表和相关的核心数据结构。在操作系统中，进程物理实体和支持进程运行的环境合称<strong>进程上下文（process context）</strong>，进程在其当前上下文运行，<strong>当系统调度新进程占有处理器时，新老进程随之发生上下文切换</strong>。进程上下文由三部分组成：</p><ul><li><p>用户级上下文（user level context）</p><p>由程序块（可执行的机器指令序列）、数据块（进程可访问的信息）、共享内存区（进程通信使用的内存区）、用户栈（存放函数调用过程中的信息）组成，它们占用进程的虚存空间。对换至磁盘的分段或页面仍然是用户级上下文的组成部分</p></li><li><p>寄存器上下文（register context）</p><p>由处理器状态寄存器（进程当前状态）、指令计数器（下一条该执行的指令地址）、栈指针（指向用户栈或核心栈当前地址）、通用寄存器等组成。当进程不处于运行态时，处理器状态信息保存在寄存器上下文中</p></li><li><p>系统级上下文（system level context）</p><p>由进程控制块（进程的状态）、内存管理信息（进程页表或段表）、核心栈（进程内核态运行时的工作区）等操作系统管理进程所需要的信息组成</p></li></ul><p>Linux系统的进程上下文：</p><ul><li>用户级上下文：text、data、shared memory和user stack等</li><li>寄存器上下文：general register、program counter、EFLAGS、ESP等</li><li>系统级上下文：task_struct、mm_struct、vm_area_struct、pgd、pmd、pte和kernel stack等</li></ul><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>每个进程有且仅有一个进程控制块（Process Control Block，PCB），或称进程控制符（process descriptor），它是<strong>进程存在的唯一标识</strong>，是操作系统用来记录和刻画进程状态及环境信息的数据结构，是进程动态特征的汇集，也是操作系统掌握进程的唯一资料结构和管理进程的主要依据；进程控制块包括进程执行时的情况，以及进程让出处理器之后所处的状态、断点等信息，一般来说PCB包含以下三类信息：</p><ul><li><p>标识信息</p><p>标识信息用于唯一地标识一个进程，分为<strong>用户使用的外部标识符</strong>和<strong>系统使用的内部标识符</strong>。系统中所有进程都被赋予唯一的、内部使用的数值型进程号（0~32768的正整数），操作系统内核函数可通过进程号来引用PCB。常用的标识信息包括<strong>进程标识ID、进程组标识ID、用户进程名、用户组名</strong>等</p></li><li><p>现场信息</p><p>现场信息用于保留进程在运行时存放在处理器现场中的各种信息，包括<strong>通用寄存器内容、控制寄存器内容、栈指针、程序状态字</strong>等。进程在让出处理器时，必须将此时的现场信息保存到它的PCB中，而当此进程恢复运行时也应恢复处理器现场</p></li><li><p>控制信息</p><p>控制信息用于管理和调度进程，包括进程调度的相关信息、进程组成信息、进程间的族系信息、进程间通信信息、进程段/页表和进程映像在外存中的地址、CPU的占用和使用信息、进程特权信息、资源清单、文件传输和I/O信息</p><p><img src="https://i.loli.net/2019/11/17/BwXHlipEeq8VdtI.png" alt></p></li></ul><h3 id="进程队列及其管理"><a href="#进程队列及其管理" class="headerlink" title="进程队列及其管理"></a>进程队列及其管理</h3><p>进程的主要特征主要由PCB来刻画，为了便于对进程进行管理和调度，常常将进程的PCB通过某种方式组织起来，<strong>一般来说，把处于同一状态的所有进程的PCB链接在一起的数据结构称为进程队列（process queue）</strong>，简称队列。有两种队列组织方式，链接方式和索引方式：</p><ul><li><p>链接方式</p><p>对同一状态进程的PCB，通过PCB中的链接指针将其链接成队列</p><p><img src="https://i.loli.net/2019/11/17/ayw9N1PrnbBsWCY.png" alt></p><p><img src="/home/steve/.config/Typora/typora-user-images/1573992590492.png" alt="1573992590492"></p><p>不同状态的进程可以排成不同队列，如：</p><ul><li><p>运行队列</p><p>通常只有一个进程</p></li><li><p>就绪队列</p><p>可按照优先级或者FCFS的原则排队，也可按照进程优先级的高低分成多个就绪队列</p></li><li><p>等待队列</p><p>通常有多个，对应不同的等待状态，如等待I/O操作完成、等待信号量等</p></li></ul><p>此外，还可以将空闲PCB结构链接成自由队列以便使用</p><p>当发生某个事件使进程状态发生转换时，此进程就要退出所在队列而排入另一个队列中去。处理器调度中<strong>负责进程入队和出队工作的功能模块称为队列管理模块</strong>，其任务是<strong>对进程的PCB重新排队并修改其状态和响应链接结构</strong></p></li><li><p>索引方式</p><p>索引方式利用索引表记录不同状态进程的PCB地址或在PCB表中的编号，系统建立若干索引表，如<strong>就绪索引表、等待索引表、空闲索引表</strong>等。状态相同进程的PCB组织在同一张索引表中，每个索引表的表目中存放PCB地址或在PCB表中的编号，<strong>各索引表在内存中的起始地址放在内核专用指针单元中</strong></p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/sqfQYLmhcWi8bzj.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="进程上下文切换与处理器状态转换"><a href="#进程上下文切换与处理器状态转换" class="headerlink" title="进程上下文切换与处理器状态转换"></a>进程上下文切换与处理器状态转换</h2><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>中断和异常是激活操作系统的仅有方法，它暂停当前运行进程的执行，把处理器转换至内核态，内核获得处理器控制权之后，如果需要就可以实现进程上下文切换，所以<strong>进程切换必定在内核态而非用户态发生</strong>。</p><p>内核在处理中断事件或系统调用过程中可能会导致被阻塞的高优先级进程变为就绪态（等待事件发生或在等待信号到达），或在<strong>处理时钟中断事件期间</strong>发现运行进程的时间片耗尽，或当前运行进程执行阻塞型I/O指令等，均有可能引发内核实施进程上下文切换。</p><p>执行上下文切换时，保存老进程的上下文并装入新进程的上下文，以便新进程运行。</p><p>实现进程上下文切换的步骤：</p><ul><li>保存被中断进程的<strong>处理器现场信息</strong></li><li>修改被中断进程<strong>PCB的有关信息</strong>，如进程状态等</li><li>把被中断进程的PCB加入相关队列</li><li>选择占用处理器运行的另一进程</li><li>修改被选中进程<strong>PCB的有关信息</strong>，如改为就绪态</li><li>设置被选中进程的<strong>地址空间</strong>，恢复<strong>存储管理信息</strong></li><li>根据被选中进程的上下文信息恢复<strong>处理器现场</strong></li></ul><h3 id="进程上下文切换时机"><a href="#进程上下文切换时机" class="headerlink" title="进程上下文切换时机"></a>进程上下文切换时机</h3><p><strong>进程调度和切换</strong>是操作系统内核程序，内核处理过程中发现满足调度条件便可请求重新调度</p><p>原则上，发生请求重新调度事件、执行调度程序和实施进程上下文切换工作应该连续发生，但是实际上由于种种原因不能连续完成，内核中不能立即进行调度和切换的情况有：</p><ul><li><p>内核正在处理中断的过程中</p><p><img src="https://i.loli.net/2019/11/17/nzVjeEgH9GFsLc5.png" alt></p></li><li><p>进程运行在内核临界区中</p><p><img src="https://i.loli.net/2019/11/17/1gqJG4L2RBe6ONl.png" alt></p></li><li><p>内核处在需要屏蔽中断的原子操作中</p></li></ul><p>在上述情况中产生引起调度条件而不能马上进行调度和切换，系统采用<strong>置请求调度标志</strong>延迟到敏感性操作完成后才进行。Linux在进程task_struct设计<strong>重调度标志need_resched</strong>，当需要进程重调度时先置调度标志位，在调度时机来临时判别标志位是否为1，以决定要否进行调度。<strong>Linux调度时机</strong>分为：</p><ul><li><p>主动调度</p><p>调用schedule()函数来释放CPU引起新一轮调度，通常发生在当前进程状态被改变，如执行了read()、write()、exit()等系统调用，导致进程终止、进程阻塞等</p></li><li><p>被动调度</p><p>发生了引起调度的条件，通常发生在新进程产生、某个进程优先级改变、进程被唤醒、进程时间片用完等。这时仅置进程TIF_NEED_RESCHED调度标志。调度标志设置有如下情况：</p><ul><li>时钟中断中调用函数scheduler_tick()，它负责查看当前进程（实时进程除外）的时间片是否耗尽，如果是，则设置重调度标志</li><li>函数try_to_wake_up()将阻塞的进程唤醒，把它加入运行队列中，如果其优先级比当前正在运行的进程优先级高，则设置重调度标志。此外，设置应用程序优先级参数nice值、创建新进程、SMP负载均衡时都有可能使高优先级进程进入就绪状态，也都可能设置重调度标志</li><li>执行sched_setscheduler()（设置调度策略）、sched_yield()（暂时让出处理器）、pause()（暂停）等系统调用时，均要设置重调度标志</li></ul><p>每当<strong>中断处理和系统调用处理结束返回</strong>时，在ret_from_sys_call代码段中会主动测试调度标志，若置位则调用schedule()函数</p></li></ul><h3 id="处理器状态转换"><a href="#处理器状态转换" class="headerlink" title="处理器状态转换"></a>处理器状态转换</h3><p>与进程上下文切换有关的是<strong>处理器状态转换（又称处理器模式转换），从用户态到内核态或从内核态到用户态是处理器的状态转换</strong>，此时仍在同一个进程中运行</p><p>当发生中断或系统调用时暂停当前正在运行的进程，把处理器状态从用户态转换到内核态，执行操作系统服务例程，这是一次<strong>状态转换</strong>，此时进程仍在自己的上下文中执行，仅处理器状态发生变化，<strong>内核在被中断进程的上下文中进行处理</strong></p><p>处理器状态转换步骤：</p><ul><li>保存被中断进程的处理器现场信息</li><li>处理器从用户态转换到内核态，以便执行系统服务例程或中断处理程序</li><li>如果处理中断，可根据所规定的中断级别设置中断屏蔽位</li><li>根据系统调用号或中断号，从<strong>系统调用表</strong>或<strong>中断入口地址表</strong>中找到系统服务例程或中断处理程序的地址</li></ul><p>处理器状态转换不同于进程上下文切换，在大多数情况下，状态转换不一定引起上下文切换，在完成系统调用服务或中断处理之后，可通过逆向处理器状态转换来恢复被中断进程运行</p><p>处理器执行进程在任何时刻必处于以下4个活动范围内：</p><ul><li>用户空间中，处于进程上下文，应用进程在用户态下运行，使用用户栈</li><li>内核空间中，处于进程上下文，内核代表进程在内核下运行，使用核心栈</li><li>内核空间中，处于中断上下文，与任何进程无关，中断服务例程在内核态下处理特定中断</li><li>内核空间中，内核线程（无用户地址空间的进程）运行于内核态</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/4QDebchVMPXakgE.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/vKOf8LkMIpWFmaZ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="Linux中进程上下文切换与处理器状态转换"><a href="#Linux中进程上下文切换与处理器状态转换" class="headerlink" title="Linux中进程上下文切换与处理器状态转换"></a>Linux中进程上下文切换与处理器状态转换</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/1YOJRzWAfsHgc6k.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="进程控制和管理"><a href="#进程控制和管理" class="headerlink" title="进程控制和管理"></a>进程控制和管理</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程管理" scheme="http://QQ876684433.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>linux下制作ext4文件系统镜像</title>
    <link href="http://QQ876684433.github.io/2019/11/07/linux%E4%B8%8B%E5%88%B6%E4%BD%9Cext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/"/>
    <id>http://QQ876684433.github.io/2019/11/07/linux下制作ext4文件系统镜像/</id>
    <published>2019-11-07T15:47:51.000Z</published>
    <updated>2019-11-07T15:52:13.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux下制作ext4文件系统镜像"><a href="#linux下制作ext4文件系统镜像" class="headerlink" title="linux下制作ext4文件系统镜像"></a>linux下制作ext4文件系统镜像</h1><blockquote><p>由于网上的资料基本上都是一样的，大家抄来抄去，找不到最初的原作者，所以也没法在这里给出原文作者，但是声明一下，以下内容是转载自网络的</p></blockquote><p><strong>步骤如下</strong>：</p><ol><li><p>生成一个空的2MiB文件</p><p><code>dd if=/dev/zero of=rootfs.ext4 bs=1024 count=2048</code> (指定每一块大小为1024字节，一共又2048块，那么就是2048 * 1024 B = 2MiB)</p></li><li><p>对生成的文件进行格式化</p><p><code>mkfs.ext4 rootfs.ext4</code></p></li><li><p>挂载此空镜像</p><p><code>mount -o loop rootfs.ext4 /mnt</code></p></li><li><p>向挂载好的文件系统中写入需要加入的文件</p><p><code>cp everyfile /mnt</code></p></li><li><p>卸载根文件系统(意味着镜像已经制作完成)</p><p><code>umount /mnt</code></p></li><li><p>将镜像写入sd卡的某个分区中</p><p><code>dd if=rootfs.ext4 of=/dev/mmcblk0p3</code></p></li><li><p>此时挂载一下sd卡的某分区即可在发现刚才复制进去的文件</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux下制作ext4文件系统镜像&quot;&gt;&lt;a href=&quot;#linux下制作ext4文件系统镜像&quot; class=&quot;headerlink&quot; title=&quot;linux下制作ext4文件系统镜像&quot;&gt;&lt;/a&gt;linux下制作ext4文件系统镜像&lt;/h1&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="linux" scheme="http://QQ876684433.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://QQ876684433.github.io/tags/linux/"/>
    
      <category term="ext4" scheme="http://QQ876684433.github.io/tags/ext4/"/>
    
  </entry>
  
  <entry>
    <title>NASM学习记录</title>
    <link href="http://QQ876684433.github.io/2019/11/07/NASM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://QQ876684433.github.io/2019/11/07/NASM学习记录/</id>
    <published>2019-11-07T06:34:04.000Z</published>
    <updated>2019-11-23T08:56:55.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NASM学习记录"><a href="#NASM学习记录" class="headerlink" title="NASM学习记录"></a>NASM学习记录</h1><h2 id="零散知识点"><a href="#零散知识点" class="headerlink" title="零散知识点"></a>零散知识点</h2><h3 id="NASM汇编程序中的宏定义"><a href="#NASM汇编程序中的宏定义" class="headerlink" title="NASM汇编程序中的宏定义"></a>NASM汇编程序中的宏定义</h3><p>NASM汇编程序中的宏定义的格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%macro 宏名 参数名列表 </span><br><span class="line">宏体</span><br><span class="line">%endmacro</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%macro Descriptor 3</span><br><span class="line">dw %2 &amp; 0FFFFh </span><br><span class="line">dw %1 &amp; 0FFFFh </span><br><span class="line">db (%1 &gt;&gt; 16) &amp; 0FFh </span><br><span class="line">dw ((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh) </span><br><span class="line">db (%1 &gt;&gt; 24) &amp; 0FFh </span><br><span class="line">%endmacro ; 共 8 字节</span><br></pre></td></tr></table></figure><p>这个宏定义了操作系统中描述符的格式，宏名为：Descriptor 。使用时只需定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Descriptor 参数1, 参数2, 参数3</span><br></pre></td></tr></table></figure><p>即可。其中宏定义中的%1代表参数1，%2代表参数2，%3代表参数3</p><h3 id="EQU指令"><a href="#EQU指令" class="headerlink" title="EQU指令"></a>EQU指令</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/liukun321/article/details/5549023" target="_blank" rel="noopener">https://blog.csdn.net/liukun321/article/details/5549023</a></p></blockquote><p>有时，一个表达式在程序中会多次出现，重复书写可能较为繁杂，易出错。另一方面。如果要对该表达式进行变动，那么必须在程序中找到每一个表达式，一一做出修改，稍有不慎，就会遗漏，引出麻烦。利用EQU伪指令，就可以避免这些问题的发生。</p><p>$$<br>格式：&lt;符号名&gt; EQU &lt;表达式&gt;<br>$$<br>　　该伪指令的含义是为EQU后面的&lt;表达式&gt;起一个叫做&lt;符号名&gt;的名字。这样一来，程序中凡是需要用到该表达式的地方，就都可以用这个名字代替了。这里，&lt;表达式&gt;可以是任何有效的数据，可以是能够算出值的表达式，也可以是有效的助记符等。</p><p>　　例 <code>COUNT EQU 256</code></p><p>　　表示赋予数256一个名字，叫做COUNT。</p><p>　　<code>VAR1 EQU COUNT-2</code></p><p>　　表示赋予表达式COUNT-2一个名字，叫做VAR1。如果有<code>COUNT EQU 256</code>在先，那么由于COUNT是数值256，所以VAR1就代表数值254。</p><p>　　<code>PH EQU PUSH</code></p><p>　　表示赋予PUSH一个名字PH。由于PUSH是汇编语言的一个助记符，因此，在程序中书写<code>PH AX</code>，就相当于 <code>PUSH AX</code>。</p><h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令="></a>伪指令=</h4><p>　　与EQU伪指令类似的是等号伪指令“=”。它们的区别是：由EQU伪指令定义后的符号名是不能重复再定义的，而“=”伪指令中定义的符号名可重复定义。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EMP=7</span><br><span class="line"></span><br><span class="line">┋</span><br><span class="line"></span><br><span class="line">EMP=EMP+2</span><br></pre></td></tr></table></figure><p>　　这表示，开始把符号名EMP定义为是数值7，后来把符号名EMP重新定义为代表数值9。但是不能写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EMP EQU 7</span><br><span class="line"></span><br><span class="line">┋</span><br><span class="line"></span><br><span class="line">EMP EQU EMP+2</span><br></pre></td></tr></table></figure><h3 id="LGDT指令"><a href="#LGDT指令" class="headerlink" title="LGDT指令"></a>LGDT指令</h3><blockquote><p>原文：<a href="http://www.hgy413.com/hgydocs/IA32/instruct32_hh/vc155.htm" target="_blank" rel="noopener">http://www.hgy413.com/hgydocs/IA32/instruct32_hh/vc155.htm</a></p></blockquote><p>LGDT/LIDT - 用于加载全局/中断描述符表格寄存器</p><table><thead><tr><th>操作码</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>0F 01 /2</td><td>LGDT <strong>m16&amp;32</strong></td><td>将 <strong>m</strong> 加载到 GDTR</td></tr><tr><td>0F 01 /3</td><td>LIDT <strong>m16&amp;32</strong></td><td>将 <strong>m</strong> 加载到 IDTR</td></tr></tbody></table><ul><li><p>将源操作数中的值加载到全局描述符表格寄存器 (GDTR) 或中断描述符表格寄存器 (IDTR)。源操作数指定 6 字节内存位置，它包含全局描述符表格 (GDT) 或中断描述符表格 (IDT) 的基址（线性地址）与限制（表格大小，以字节计）。如果操作数大小属性是 32 位，则将 16 位限制（6 字节数据操作数的 2 个低位字节）与 32 位基址（数据操作数的 4 个高位字节）加载到寄存器。如果操作数大小属性是 16 位，则加载 16 位限制（2 个低位字节）与 24 位基址（第三、四、五字节）。这里，不使用操作数的高位字节，GDTR 或 IDTR 中基址的高位字节用零填充。</p></li><li><p>LGDT 与 LIDT 指令仅用在操作系统软件中；它们不用在应用程序中。在保护模式中，它们是仅有的能够直接加载线性地址（即，不是段相对地址）与限制的指令。它们通常在实地址模式中执行，以便处理器在切换到保护模式之前进行初始化。</p></li></ul><h3 id="CLD指令"><a href="#CLD指令" class="headerlink" title="CLD指令"></a>CLD指令</h3><blockquote><p>来源：<a href="https://c9x.me/x86/html/file_module_x86_id_29.html" target="_blank" rel="noopener">https://c9x.me/x86/html/file_module_x86_id_29.html</a></p></blockquote><p>CLD指令主要是用来清除EFLAGS寄存器中的DF标志位，即DF = 0，对其他标志位无影响</p><h4 id="DF标志-DF-flag"><a href="#DF标志-DF-flag" class="headerlink" title="DF标志(DF flag)"></a>DF标志(DF flag)</h4><p>这个方向标志(位于EFLAGS寄存器的第10位)控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），<strong>清除该标志则使得串指令自动递增</strong>。STD以及CLD指令分别用于设置以及清除DF标志。</p><blockquote><p>When the DF flag is set to 0, string operations increment the index registers (ESI and/or EDI).</p></blockquote><p>即DF = 0时，字符串操作会自动递增索引寄存器ESI和/或EDI</p><h3 id="LODS指令"><a href="#LODS指令" class="headerlink" title="LODS指令"></a>LODS指令</h3><blockquote><p>来源：<a href="https://baike.baidu.com/item/LODS" target="_blank" rel="noopener">https://baike.baidu.com/item/LODS</a></p></blockquote><p>汇编语言串装入指令（load string），规定源操作数为(DS:SI)，目的操作数隐含为AL（字节）或AX（字）寄存器。三种指令都用于<strong>将目的操作数的内容取到AL或AX寄存器</strong>，字节还是字操作由寻址方式确定，并根据寻址方式自动修改SI的内容</p><ul><li>LODS SRC 语法格式： LODS SI ；DST隐含为AL（字节）或AX（字）</li><li>LODSB ；字节操作，DST隐含为AL，SRC隐含为SI</li><li>LODSW ；字操作， DST隐含为AX，SRC隐含为SI</li></ul><p>注意：不影响标志位，一般不带重复前缀</p><p>执行的操作：</p><ul><li><p>（AL）←（DS:SI），（SI）←（SI）±1(字节)</p></li><li><p>（AX）←（DS:SI），（SI）←（SI）±2(字)</p></li></ul><h3 id="控制寄存器cr0"><a href="#控制寄存器cr0" class="headerlink" title="控制寄存器cr0"></a>控制寄存器cr0</h3><blockquote><p>来源：</p><ul><li><a href="https://en.wikipedia.org/wiki/Control_register" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Control_register</a></li><li><a href="https://baike.baidu.com/item/控制寄存器" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8</a></li></ul></blockquote><p>控制寄存器（CR0～CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性。<strong>CR0中含有控制处理器操作模式和状态的系统控制标志</strong>；CR1保留不用；CR2含有导致页错误的线性地址；CR3中含有页目录表物理内存基地址，因此该寄存器也被称为页目录基地址寄存器PDBR（Page-Directory Base address Register）</p><blockquote><p>CR0 has various control flags that modify the basic operation of the processor.</p></blockquote><table><thead><tr><th align="center">Bit</th><th align="center">Name</th><th align="center">Full Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">PE</td><td align="center">Protected Mode Enable</td><td align="center">If 1, system is in <a href="https://en.wikipedia.org/wiki/Protected_mode" target="_blank" rel="noopener">protected mode</a>, else system is in <a href="https://en.wikipedia.org/wiki/Real_mode" target="_blank" rel="noopener">real mode</a></td></tr><tr><td align="center">1</td><td align="center">MP</td><td align="center">Monitor co-processor</td><td align="center">Controls interaction of WAIT/FWAIT instructions with TS flag in CR0</td></tr><tr><td align="center">2</td><td align="center">EM</td><td align="center">Emulation</td><td align="center">If set, no x87 <a href="https://en.wikipedia.org/wiki/Floating-point_unit" target="_blank" rel="noopener">floating-point unit</a> present, if clear, x87 FPU present</td></tr><tr><td align="center">3</td><td align="center">TS</td><td align="center">Task switched</td><td align="center">Allows saving x87 task context upon a task switch only after x87 instruction used</td></tr><tr><td align="center">4</td><td align="center">ET</td><td align="center">Extension type</td><td align="center">On the 386, it allowed to specify whether the external math coprocessor was an <a href="https://en.wikipedia.org/wiki/80287" target="_blank" rel="noopener">80287</a> or <a href="https://en.wikipedia.org/wiki/80387" target="_blank" rel="noopener">80387</a></td></tr><tr><td align="center">5</td><td align="center">NE</td><td align="center">Numeric error</td><td align="center">Enable internal <a href="https://en.wikipedia.org/wiki/X87" target="_blank" rel="noopener">x87</a> floating point error reporting when set, else enables PC style x87 error detection</td></tr><tr><td align="center">16</td><td align="center">WP</td><td align="center">Write protect</td><td align="center">When set, the CPU can’t write to read-only pages when privilege level is 0</td></tr><tr><td align="center">18</td><td align="center">AM</td><td align="center">Alignment mask</td><td align="center">Alignment check enabled if AM set, AC flag (in <a href="https://en.wikipedia.org/wiki/FLAGS_register" target="_blank" rel="noopener">EFLAGS</a> register) set, and privilege level is 3</td></tr><tr><td align="center">29</td><td align="center">NW</td><td align="center">Not-write through</td><td align="center">Globally enables/disable <a href="https://en.wikipedia.org/wiki/Write_through_cache" target="_blank" rel="noopener">write-through caching</a></td></tr><tr><td align="center">30</td><td align="center">CD</td><td align="center"><a href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank" rel="noopener">Cache</a> disable</td><td align="center">Globally enables/disable the memory cache</td></tr><tr><td align="center">31</td><td align="center">PG</td><td align="center">Paging</td><td align="center">If 1, enable <a href="https://en.wikipedia.org/wiki/Paging" target="_blank" rel="noopener">paging</a> and use the <a href="https://en.wikipedia.org/wiki/Control_register#CR3" target="_blank" rel="noopener">§ CR3</a> register, else disable paging.</td></tr></tbody></table><p>要注意的是其中的两个标志位：</p><ul><li><p>PE</p><p>CR0的位0是启用保护（Protection Enable）标志。<strong>当设置该位时即开启了保护模式；当复位时即进入实地址模式</strong>。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位</p></li><li><p>PG</p><p>CR0的位31是分页（Paging）标志。<strong>当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于物理地址</strong>。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位</p></li></ul><h3 id="retf指令"><a href="#retf指令" class="headerlink" title="retf指令"></a>retf指令</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/ZCMUCZX/article/details/80216145" target="_blank" rel="noopener">https://blog.csdn.net/ZCMUCZX/article/details/80216145</a></p></blockquote><p><strong>关于ret指令和retf指令</strong></p><p>ret指令是用栈中的数据，修改IP的内容，从而实现了近转移(就是只修改IP)<br>retf指令是用栈中的数据，修改CS和IP的内容，从而实现了远转移(就是修改了CS和IP)<br>当CPU执行指令ret的时候，会进行下面的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、(IP)= ((ss *16)+(sp))</span><br><span class="line">2、(sp)=(sp)+2</span><br></pre></td></tr></table></figure><p>当CPU执行指令retf的时候相当于进行了下面的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、(IP)= ((ss *16)+(sp))</span><br><span class="line">2、(sp)=(sp)+2</span><br><span class="line">3、(CS)=((ss *16)+(sp))</span><br><span class="line">4、(sp)=(sp)+2</span><br></pre></td></tr></table></figure><p>其实就相当于CPU在执行ret指令的时候就是在执行下面的汇编语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></table></figure><p>CPU在执行retf指令的时候其实就是在执行下面的汇编语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure><h3 id="stosb-stosw-stosd指令"><a href="#stosb-stosw-stosd指令" class="headerlink" title="stosb, stosw, stosd指令"></a>stosb, stosw, stosd指令</h3><p>stosb, stosw, stosd这三个指令把al/ax/eax的内容存储到edi指向的内存单元中，同时edi的值根据方向标志的值增加或者减少</p><h3 id="LTR指令"><a href="#LTR指令" class="headerlink" title="LTR指令"></a>LTR指令</h3><p>LTR - 加载任务寄存器：</p><ul><li>将源操作数加载到任务寄存器的段选择器字段。源操作数（通用寄存器或内存位置）包含指向<strong>任务状态段 (TSS)</strong> 的段选择器。段选择器加载到任务寄存器之后，处理器使用段选择器在全局描述符表格 (GDT) 中确定 TSS 的段描述符的位置。接着，它将 TSS 的段限制与基址从段描述符加载到任务寄存器。任务寄存器指向的任务标记为忙，但不发生任务切换</li><li>提供的 LTR 指令用于操作系统软件；不应该在应用程序中使用它。它只能在 CPL 为 0 时在保护模式中执行。它常用在初始化代码，建立要执行的第一个任务</li><li>操作数大小属性不影响此指令。</li></ul><h3 id="DIV指令"><a href="#DIV指令" class="headerlink" title="DIV指令"></a>DIV指令</h3><p>指令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DIV reg8/mem8</span><br><span class="line">DIV reg16/mem16</span><br><span class="line">DIV reg32/mem32</span><br></pre></td></tr></table></figure><p>div指令只有一个操作数，即除数，被除数保存在AX（或者DX:AX，EDX:EAX）中，计算的结果商保存在AL（或者AX，EAX），余数保存在AH（或者DX，EDX），如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/22/gNSh8V4yFOPjXUx.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="MUL指令"><a href="#MUL指令" class="headerlink" title="MUL指令"></a>MUL指令</h3><p>MUL: 无符号乘</p><p>影响 OF、CF 标志位<br>指令格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL r/m  参数是乘数</span><br></pre></td></tr></table></figure><ul><li>如果参数是 r8/m8,   将把  AL 做乘数, 结果放在 AX</li><li>如果参数是 r16/m16, 将把 AX 做乘数, 结果放在 EAX</li><li>如果参数是 r32/m32, 将把 EAX 做乘数, 结果放在 EDX:EAX</li></ul><h3 id="cmp和test的区别"><a href="#cmp和test的区别" class="headerlink" title="cmp和test的区别"></a>cmp和test的区别</h3><p>test逻辑与运算结果为零,就把ZF(零标志)置1;<br>cmp 算术减法运算结果为零,就把ZF(零标志)置1.</p><h3 id="in和out端口指令"><a href="#in和out端口指令" class="headerlink" title="in和out端口指令"></a>in和out端口指令</h3><ul><li>in：从端口读取数据</li><li>out：把数据写入端口</li></ul><p>0-255时，8位端口用al，16位端口用ax</p><p>256-65535时，用dx</p><p>传输的时候需要先进入地址端口，再传输数据；比如70h为地址端口，71h为数据端口，读取2号单元的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,2h</span><br><span class="line">out 70h,al</span><br><span class="line">in al,71h</span><br></pre></td></tr></table></figure><h3 id="rep预处理指令"><a href="#rep预处理指令" class="headerlink" title="%rep预处理指令"></a>%rep预处理指令</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%rep 128</span><br><span class="line">GateSelectorCode32, SpuriousHandler, 0, DA_386IGate</span><br><span class="line">%endrep</span><br></pre></td></tr></table></figure><p>指令的作用是让<code>Gate    SelectorCode32, SpuriousHandler, 0, DA_386IGate</code>重复执行128次</p><h3 id="MOVZX指令"><a href="#MOVZX指令" class="headerlink" title="MOVZX指令"></a>MOVZX指令</h3><p>movzx一般用于将较小值拷贝到较大值中</p><h3 id="SGDT-SIDT指令"><a href="#SGDT-SIDT指令" class="headerlink" title="SGDT/SIDT指令"></a>SGDT/SIDT指令</h3><p><strong>将全局描述符表格寄存器 (GDTR) 或中断描述符表格寄存器 (IDTR) 中的内容存储到目标操作数</strong>。目标操作数是指定 6 字节内存位置。如果操作数大小属性为 32 位，则寄存器的 16 位限制字段存储到内存位置的 2 个低位字节，32 位基址存储到 4 个高位字节。如果操作数大小属性为 16 位，则限制字段存储在 2 个低位字节，24 位基址存储在第三、四及五字节，第六字节使用 0 填充。</p><p>SGDT 与 SIDT 指令仅在操作系统软件中有用；不过它们也可以在应用程序中使用，而不会导致生成异常。</p><h3 id="hlt指令"><a href="#hlt指令" class="headerlink" title="hlt指令"></a>hlt指令</h3><ul><li><p>使程序停止运行，处理器进入暂停状态，不执行任何操作，不影响标志。当RESET线上有复位信号、CPU响应非屏蔽中断、CPU响应可屏蔽中断3种情况之一时，CPU脱离暂停状态，执行HLT的下一条指令</p><p> 如果hlt指令之前，做了cli，那可屏蔽中断不能唤醒cpu</p></li><li><p>hlt是“只能在实方式和ring0执行的指令”，要区别于“IO敏感指令”。通过设置IOPI或IO许可位图，可以让ring1乃至ring3执行“IO敏感指令”，但“只能在实方式和ring0执行的指令”是规定死的</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NASM学习记录&quot;&gt;&lt;a href=&quot;#NASM学习记录&quot; class=&quot;headerlink&quot; title=&quot;NASM学习记录&quot;&gt;&lt;/a&gt;NASM学习记录&lt;/h1&gt;&lt;h2 id=&quot;零散知识点&quot;&gt;&lt;a href=&quot;#零散知识点&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="汇编" scheme="http://QQ876684433.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="http://QQ876684433.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="NASM" scheme="http://QQ876684433.github.io/tags/NASM/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-11-05）</title>
    <link href="http://QQ876684433.github.io/2019/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-11-05%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/11/05/数据库课堂笔记（2019-11-05）/</id>
    <published>2019-11-05T06:00:53.000Z</published>
    <updated>2019-11-05T06:00:53.384Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-10-29）</title>
    <link href="http://QQ876684433.github.io/2019/10/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-10-29%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/29/数据库课堂笔记（2019-10-29）/</id>
    <published>2019-10-29T05:58:08.000Z</published>
    <updated>2019-10-29T05:58:51.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-10-29）"><a href="#数据库课堂笔记（2019-10-29）" class="headerlink" title="数据库课堂笔记（2019-10-29）"></a>数据库课堂笔记（2019-10-29）</h2><h3 id="Ch06-Database-Design"><a href="#Ch06-Database-Design" class="headerlink" title="Ch06 Database Design"></a>Ch06 Database Design</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>使用Oracle嵌入式SQL预处理器Pro*C过程记录</title>
    <link href="http://QQ876684433.github.io/2019/10/24/%E4%BD%BF%E7%94%A8Oracle%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8Pro-C%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <id>http://QQ876684433.github.io/2019/10/24/使用Oracle嵌入式SQL预处理器Pro-C过程记录/</id>
    <published>2019-10-24T08:23:28.000Z</published>
    <updated>2019-10-24T09:13:48.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Oracle嵌入式SQL预处理器Pro-C过程记录"><a href="#使用Oracle嵌入式SQL预处理器Pro-C过程记录" class="headerlink" title="使用Oracle嵌入式SQL预处理器Pro*C过程记录"></a>使用Oracle嵌入式SQL预处理器Pro*C过程记录</h1><p>这玩意儿坑还挺多的，主要还是资料比较少，废话少说，先上参考链接：</p><blockquote><p>参考：</p><ul><li><a href="https://www.cnblogs.com/uriel/p/4275423.html" target="_blank" rel="noopener">https://www.cnblogs.com/uriel/p/4275423.html</a></li><li><a href="https://blog.csdn.net/Leafage_M/article/details/72082011" target="_blank" rel="noopener">https://blog.csdn.net/Leafage_M/article/details/72082011</a></li></ul></blockquote><p>说明：这篇文章主要是记录摸索过程中的关键步骤，以便后面使用的时候有章可循，具体关于Oracle的ESQL以及Pro*C的进阶使用，后面有时间会专门开一系列博客来记录</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在数据库课程学习上，专门有一章是用来讲Oracle嵌入式SQL（ESQL）的，主要是结合C语言来讲解。但是由于课上只是在书面上讲，而且这玩意之前没有听说过，总感觉如果不上手玩一玩的话就不能更加深入理解这玩意儿，所以就决定上手体验一下，从此开启了踩坑之路。</p><p>编程环境：</p><ul><li>Oracle数据库使用的是阿里云的Docker镜像（registry.cn-hangzhou.aliyuncs.com/qida/oracle-xe-11g）</li><li>开发环境是Deepin Linux 15.11</li></ul><h2 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h2><p> Oracle的嵌入式SQL的预编译工具是Pro*C，它的编译过程是这样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pro*C源文件(*.pc) -&gt; C源文件(*.c) -&gt; 目标文件(*.o) -&gt; 可执行文件</span><br></pre></td></tr></table></figure><p>所以首先要安装这个预编译工具，这里可以直接从oracle官网下载：</p><p><a href="https://www.oracle.com/database/technologies/instant-client/precompiler-112010-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/database/technologies/instant-client/precompiler-112010-downloads.html</a></p><p>官网没有提供deb安装包，但是有rpm安装包，只需要通过alien命令来安装即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo alien -i xxxx.rpm</span><br></pre></td></tr></table></figure><p>安装完成后，可以通过命令<code>proc -help</code>查看是否安装成功，proc就是Pro*C预编译器入口命令</p><h2 id="Pro-C头文件和库文件"><a href="#Pro-C头文件和库文件" class="headerlink" title="Pro*C头文件和库文件"></a>Pro*C头文件和库文件</h2><p>原先我想的是直接将Pro<em>C安装到我的主机上，然后将预处理和编译过程都放在本机上完成，然后运行时直接访问docker中的oracle数据库。理论上应该是可行的，但后来我发现一个问题就是，我本机没有安装oracle数据库，自然在开发Pro\</em>.C源程序的时候会找不到相关的<strong>Pro*C头文件和库文件</strong>，就是下面这些：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/FeRg96XzYZMuQmC.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>而从原博客中可以看出，这些头文件和库文件是随着oracle的安装就被安装进去的，这时我想到了，这些头文件和库文件应该是躺在Docker中的oracle容器中的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@989eb62277c6:/u01/app/oracle/product/11.2.0/xe/precomp# tree .</span><br><span class="line">.</span><br><span class="line">|-- admin</span><br><span class="line">|   `-- ottcfg.cfg</span><br><span class="line">`-- lib</span><br><span class="line">    `-- ottclasses.zip</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br><span class="line">root@989eb62277c6:/u01/app/oracle/product/11.2.0/xe/precomp#</span><br></pre></td></tr></table></figure><p>然而实际上是没有的orz，官网的原文是这样说的：</p><blockquote><p>The <code>ORACLE_BASE\ORACLE_HOME\precomp\public</code> directory contains the Pro*C/C++ header files</p><p><a href="https://docs.oracle.com/cd/B19306_01/win.102/b14321/use.htm" target="_blank" rel="noopener">https://docs.oracle.com/cd/B19306_01/win.102/b14321/use.htm</a></p></blockquote><p>估计被精简掉了。。。</p><p>场面一度很焦灼，先摸索一会儿，找到解决方案后再更新orz。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Oracle嵌入式SQL预处理器Pro-C过程记录&quot;&gt;&lt;a href=&quot;#使用Oracle嵌入式SQL预处理器Pro-C过程记录&quot; class=&quot;headerlink&quot; title=&quot;使用Oracle嵌入式SQL预处理器Pro*C过程记录&quot;&gt;&lt;/a&gt;使用Ora
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Pro*C" scheme="http://QQ876684433.github.io/tags/Pro-C/"/>
    
      <category term="Oracle" scheme="http://QQ876684433.github.io/tags/Oracle/"/>
    
      <category term="嵌入式SQL" scheme="http://QQ876684433.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/"/>
    
      <category term="Embedded SQL" scheme="http://QQ876684433.github.io/tags/Embedded-SQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-10-24）</title>
    <link href="http://QQ876684433.github.io/2019/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-10-24%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/24/数据库课堂笔记（2019-10-24）/</id>
    <published>2019-10-24T05:51:33.000Z</published>
    <updated>2019-10-24T05:53:08.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-10-24）"><a href="#数据库课堂笔记（2019-10-24）" class="headerlink" title="数据库课堂笔记（2019-10-24）"></a>数据库课堂笔记（2019-10-24）</h2><h3 id="Ch05-Programs-to-Access-a-Database"><a href="#Ch05-Programs-to-Access-a-Database" class="headerlink" title="Ch05 Programs to Access a Database"></a>Ch05 Programs to Access a Database</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>new/delete vs malloc/free</title>
    <link href="http://QQ876684433.github.io/2019/10/24/new_delete%20vs%20malloc_free/"/>
    <id>http://QQ876684433.github.io/2019/10/24/new_delete vs malloc_free/</id>
    <published>2019-10-24T04:08:04.000Z</published>
    <updated>2019-10-24T04:10:25.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new-delete-vs-malloc-free"><a href="#new-delete-vs-malloc-free" class="headerlink" title="new/delete vs malloc/free"></a>new/delete vs malloc/free</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;new-delete-vs-malloc-free&quot;&gt;&lt;a href=&quot;#new-delete-vs-malloc-free&quot; class=&quot;headerlink&quot; title=&quot;new/delete vs malloc/free&quot;&gt;&lt;/a&gt;new/delete 
      
    
    </summary>
    
      <category term="C++" scheme="http://QQ876684433.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://QQ876684433.github.io/tags/C/"/>
    
      <category term="new" scheme="http://QQ876684433.github.io/tags/new/"/>
    
      <category term="delete" scheme="http://QQ876684433.github.io/tags/delete/"/>
    
      <category term="malloc" scheme="http://QQ876684433.github.io/tags/malloc/"/>
    
      <category term="free" scheme="http://QQ876684433.github.io/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-存储管理</title>
    <link href="http://QQ876684433.github.io/2019/10/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://QQ876684433.github.io/2019/10/23/操作系统-存储管理/</id>
    <published>2019-10-23T13:23:37.000Z</published>
    <updated>2019-10-25T02:03:19.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li></ul></blockquote><p>内存空间一般分为两部分：</p><ul><li>系统区：存放操作系统内核程序和数据结构等</li><li>用户区：存放应用程序和数据</li></ul><p>有效的存储管理也是多道程序设计技术的关键支撑，存储管理包含以下功能：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/4QPXOMmnc6V8RBg.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="存储器工作原理"><a href="#存储器工作原理" class="headerlink" title="存储器工作原理"></a>存储器工作原理</h2><h3 id="存储器层次"><a href="#存储器层次" class="headerlink" title="存储器层次"></a>存储器层次</h3><p>目前计算机均采用层次结构的存储子系统，自上至下依次为：寄存器、缓存、内存、磁盘、磁带5层。其中<strong>寄存器、缓存和内存是操作系统存储管理的管辖范畴</strong>；磁盘和磁带属于文件管理和设备管理的管辖对象。</p><h3 id="地址转换与存储保护"><a href="#地址转换与存储保护" class="headerlink" title="地址转换与存储保护"></a>地址转换与存储保护</h3><p>源程序在计算机上运行涉及的过程：</p><ul><li>编译程序或汇编程序处理源程序并生成目标代码（程序）</li><li>链接程序将目标代码链接为一个<strong>可重定位代码（程序）</strong>，此时程序处在<strong>逻辑地址空间</strong>中</li><li>装载程序将可执行代码装入物理地址空间，直到此时程序才能运行</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/jqZwMSNIoas5r3x.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h4><p>程序编译指的是编译程序（compiler）或汇编程序（assembly）的处理生成目标模块（目标代码）。一个程序可以由独立编写的且具有不同功能的多个源程序模块组成，由于模块包含外部引用，即指向<strong>其他模块中的数据或指令地址</strong>，或包含<strong>对库函数的引用</strong>，<strong>编译程序或汇编程序负责记录引用发生的位置</strong>，其处理结果将产生相应的多个目标模块，每个目标模块都附有<strong>供引用使用的内部符号表和外部符号表</strong>。符号表中依次给出<strong>各个符号名及在本目标模块中的名字地址</strong>，在模块<strong>被链接时</strong>进行转换</p><h4 id="程序链接"><a href="#程序链接" class="headerlink" title="程序链接"></a>程序链接</h4><p>链接程序（linker）的作用是<strong>根据目标模块之间的调用和依赖关系，将主模块、被调模块以及所用到的库函数装配和链接成一个完整的可装载执行模块</strong>。</p><p>根据程序链接发生的时刻和链接的方式，程序链接可以分成以下三种方式：</p><ul><li><p>静态链接</p><p>在程序装载到内存和运行之前，就已经将它的所有目标模块及所需要的库函数进行链接和装配成一个<strong>完整的可执行程序</strong>且此后不再拆分</p><blockquote><p>简单来说就是在链接阶段，将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件，该可执行文件可能会比较大</p><ul><li><p>这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行</p></li><li><p>缺点是：文件太大，一个全静态方式生成的简单print文件都有857K。而动态链接生成的一样的可执行文件却只要8.４Ｋ</p></li></ul><p>reference：<a href="https://blog.csdn.net/freestyle4568world/article/details/49817799" target="_blank" rel="noopener">https://blog.csdn.net/freestyle4568world/article/details/49817799</a></p></blockquote><p>可重定位目标程序：</p><p><img src="https://i.loli.net/2019/10/23/sSd2pJmYozEWDj5.png" alt></p></li><li><p>动态链接</p><p>程序在装入内存前并未事先进行程序各目标模块的链接，而是在程序装载时一边装载一遍链接，生成一个可执行程序。</p><ul><li>在装载目标模块时，若发生外部模块调用，将引发外部目标模块的搜索、装载和链接</li><li>同时若发现所需某部目标模块已在内存，可<strong>直接进行链接且无需再次装载，支持目标模块的共享</strong></li></ul></li><li><p>运行时链接</p><p>将某些目标模块或库函数的链接推迟到执行时才进行。在程序执行过程中，若发现被调用模块或库函数尚未链接，先在内存中进行搜索以查看其是否装入内存</p><ul><li>若已装入，则直接将其链接到调用者程序中</li><li>否则进行该模块在外存上的搜索，以及装入内存和进行链接，生成一个可执行程序</li></ul><p>运行时链接的好处：</p><ul><li>避免事先无法知道本次要运行哪些目标模块</li><li>避免程序执行过程中不被调用的某些目标模块在执行前进行链接和装载而引起的开销，提高系统资源利用率和系统效率</li></ul><p>采用运行时链接时，程序执行所需要的库函数所在的部分目标模块是伴随着其被调用才动态进行装载和链接。具体的做法是：<u>不必将程序所需的外部函数代码从系统库中提取出并链入目标模块中，而仅仅是在程序调用处登记调用信息，记录函数名及入口号，形成调用链接；一旦函数库调入内存后，就可以确定所调函数在内存的物理地址</u>。</p></li></ul><h4 id="程序装载"><a href="#程序装载" class="headerlink" title="程序装载"></a>程序装载</h4><p>装载程序（loader）把可执行程序装入内存的方式有三种：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/UlP8L6R12y3XbVC.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>磁盘中的装载模块使用的是逻辑地址，逻辑地址的集合称为进程的<strong>逻辑地址空间</strong>：</p><ul><li>逻辑地址空间可以是一维的，这时逻辑地址限制在从0开始顺序排序的地址空间内</li><li>逻辑地址空间也可以是二维的，这时整个程序被分为若干段，每段都有不同段号，<strong>段内地址从0开始顺序编址</strong></li></ul><p>物理内存从统一的基地址开始顺序编址的存储单元称为物理地址或绝对地址，物理地址的总体构成物理地址空间</p><p><strong>可执行程序逻辑地址转换（绑定）为物理地址的过程称为地址重定位、地址映射或地址转换</strong>，基于程序装入方式的不同，可以区分三种地址重定位：</p><ul><li><p>静态地址重定位</p><p><img src="https://i.loli.net/2019/10/23/yAb246iZNMTedSD.png" alt></p></li><li><p>动态地址重定位</p><p><img src="https://i.loli.net/2019/10/23/fL1H2gUhyRE9CMT.png" alt></p><p><img src="https://i.loli.net/2019/10/23/KgY5IQmcdjeyVsH.png" alt></p></li><li><p>运行时链接地址重定位</p><p><img src="https://i.loli.net/2019/10/23/eQkOVLR5i8HtPh9.png" alt></p></li></ul><p>为了允许程序因对换或空闲区收集而被移动（会导致正在执行的程序在不同时刻处于内存的不同位置），必须使用动态地址重定位。动态地址重定位要借助于<strong>硬件地址转换机制</strong>来实现，<strong>重定位寄存器的内容通常保护在进程控制块中</strong>，每当执行进程上下文切换时，当前运行进程的重定位寄存器中的内容与其他信息被一起保护起来，新进程的重定位寄存器的内容会被恢复，这样进程就在上次中断的位置恢复运行，所使用的是与上次在此位置的同样的内存基地址。</p><p>存储保护涉及防止地址越界和控制正确存取：</p><ul><li><strong>地址越界保护</strong>：无论采用何种地址重定位方式，通常进程运行时产生的所有内存访问地址都应进行检查，确保进程仅访问自己的内存区，以免破坏其他进程的内存区</li><li><strong>信息存取保护</strong>：进程在访问分配给自己的内存区时，要对访问权限进行检查，如允许读、写、执行等，从而确保数据的安全性和完整性，防止有意或无意的误操作而破坏内存信息</li></ul><h2 id="连续存储管理"><a href="#连续存储管理" class="headerlink" title="连续存储管理"></a>连续存储管理</h2><h3 id="固定分区存储管理"><a href="#固定分区存储管理" class="headerlink" title="固定分区存储管理"></a>固定分区存储管理</h3><p>固定分区又称为静态分区模式，基本思想是：内存空间被划分为<strong>数目固定不变的分区，各分区大小不等，每个分区只装入一个作业</strong>，若多个分区中都装有作业，则它们可以并发执行。</p><p>为了说明各分区分配和使用情况，需要设置一张内存分配表，记录内存中划分的分区及其使用情况。<strong>内存分配表指出各分区起始地址和长度</strong>，占用标志用来指示此分区是否被使用，当其值为0时，表明此分区尚未被占用。</p><p>固定分区管理的一项任务是何时及如何把内存空间划分成分区。这项工作通常由系统管理员和操作系统初始化模块协同完成。系统初次启动时，管理员根据当天作业情况把内存划分成大小不等但数目固定的分区。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/vj71eTxgNHQmV4u.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="排队策略"><a href="#排队策略" class="headerlink" title="排队策略"></a>排队策略</h4><p>作业进入固定分区的两种排队策略：</p><ul><li>一是每个分区有单独的作业等待队列，调度程序选中作业后，创建用户进程并将其排入一个<strong>能够装入它的最小分区的进程等待队列尾部</strong>，当此分区空闲时，就装入队首进程执行<ul><li>好处是可以使装入分区浪费的空间最小</li><li>但是如果等待处理的作业大小很不均匀，将导致分区有的空闲而有的忙碌</li></ul></li><li>二是<strong>所有等待处理的作业排成一个等待队列</strong>，每当有分区空闲时，就从队首依次搜索分区长度能够容纳的作业以便装入执行；为了防止小作业占用大分区，也可以搜索<strong>分区长度能够容纳的最大作业</strong>装入执行</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>实现简单，对于程序大小和出现频率已知的情形还是比较合适的</li><li>解决了单道程序运行在并发环境下不能与CPU速度匹配的问题</li><li>解决了单道程序运行时内存空间利用率低的问题</li></ul><p>缺点：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/7ctDUWL4kFdGoBe.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="可变分区存储管理"><a href="#可变分区存储管理" class="headerlink" title="可变分区存储管理"></a>可变分区存储管理</h3><h4 id="可变分区内存空间的分配和去配"><a href="#可变分区内存空间的分配和去配" class="headerlink" title="可变分区内存空间的分配和去配"></a>可变分区内存空间的分配和去配</h4><p>可变分区（variable partition）存储管理又称为动态分区模式，按照作业大小来划分分区，但划分的时间、大小、位置都是动态的。系统把作业装入内存时，根据其所需要的内存容量查看是否有足够的空间，若有则按需分割一个分区分配给此作业；若无则令此作业等待资源。</p><p>可变分区能够克服固定分区内存资源浪费的问题，有利于多道程序设计，提高内存资源利用率。</p><p>内存中分区数目和大小随着作业的执行而不断改变，为了方便内存空间的分配和去配，用于管理的数据结构可由两张表组成：<strong>已分配区表</strong>和<strong>未分配区表</strong>。</p><ul><li><p>当装入新作业时，从未分配区表中找出一个足够容纳它的空闲区，将此区分成两部分，一部分用来装入作业，成为已分配区；另一部分仍是空闲区（若有）。</p><p>这时应该从分配区表中找出一个空栏目登记新作业的起始地址、占用长度，同时修改未分配区表中空闲区的长度和起始地址</p></li><li><p>当作业撤离时，已分配区表中的相应状态改为空闲，而将收回的分区登记到未分配区表中，若<strong>有相邻空闲区再将其连接后登记</strong></p></li></ul><p>当一个作业X撤离时的四种情况：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/X1MqKhHCI2Pktmf.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>由于分区数目不定，而且分区表占用了较多的额外空间，采用链表是另一种较好的<strong>空闲区管理</strong>方法：</p><ul><li>通过指针把<strong>所有的空闲区</strong>链接起来，每个空闲区的开头单元存放<strong>本空闲区长度</strong>及<strong>下一个空闲区起始地址指针</strong>，系统设置<strong>指向空闲区链的头指针</strong></li><li>使用时，沿链查找并取一个长度能够满足要求的空闲分区分配给进程，再修改链表</li><li>归还时，把此空闲区链入空闲区链表的相应位置即可</li></ul><p>空闲区链表管理比空闲区表格管理复杂，但是优点是链表自身并不占用存储单元</p><h5 id="可变分区分配算法"><a href="#可变分区分配算法" class="headerlink" title="可变分区分配算法"></a>可变分区分配算法</h5><ul><li><p>最先适应（first fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/ysHQ2ujJPRqnGFA.png" alt></p></li><li><p>下次/邻近适应（next fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/OoZfarJ8cnb7jLz.png" alt></p></li><li><p>最优适应（best fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/X1UnbyGSFuCQwlp.png" alt></p></li><li><p>最坏适应（worst fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/SazlsLRt4kGqNi8.png" alt></p></li><li><p>快速适应（quick fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/9ND4cXHgiChMtjW.png" alt></p></li></ul><h4 id="地址转换和存储保护"><a href="#地址转换和存储保护" class="headerlink" title="地址转换和存储保护"></a>地址转换和存储保护</h4><ul><li><p>对固定分区采用静态地址重定位，进程运行时使用绝对地址，可由加载程序进行地址越界检查</p></li><li><p>对可变分区则采用动态地址重定位，进程的程序和数据的地址转换由硬件完成，硬件设置两个专用控制寄存器：</p><ul><li>基址寄存器：存放分配给进程使用的分区的起始地址</li><li>限长寄存器：存放分配给进程所占用的连续存储空间的长度</li></ul><p><img src="https://i.loli.net/2019/10/24/F1VD3ClEqyweZsn.png" alt></p><p>多道程序系统中，硬件只需要设置一对基址/限长寄存器：</p><ul><li>进程在执行过程中出现等待事件时，操作系统把基址/限长寄存器的内容随此进程的其他信息（如PSW、通用寄存器等）一起保护起来</li><li>另一个被选中执行的线程，则将其基址/限长值再送入基址/限长寄存器</li></ul><p>在有N个重定位寄存器的机器中，允许每个进程获得N个不同的内存段，并在运行时进行动态地址重定位：</p><ul><li><p>如果每个进程只能占用一个分区，则不允许各个进程之间有公共区域（因为有存取保护机制）</p></li><li><p>提供两对或者多对基址/限长寄存器的机器中，允许一个进程占用两个或者多个分区，这样可以通过规定某对基址/限长寄存器的区域是共享的来实现不同进程之间的共享区域，且进程共享部分取相同的基址/限长值：</p><p><img src="https://i.loli.net/2019/10/24/dUAWKD9CcVY3vtF.png" alt></p></li></ul></li></ul><h3 id="内存不足的存储管理技术"><a href="#内存不足的存储管理技术" class="headerlink" title="内存不足的存储管理技术"></a>内存不足的存储管理技术</h3><blockquote><p>补充：内部碎片和外部碎片</p><p>来源：<a href="https://www.cnblogs.com/zlcxbb/p/5759790.html" target="_blank" rel="noopener">https://www.cnblogs.com/zlcxbb/p/5759790.html</a></p><ul><li><p><strong>internal fragmentation:</strong>when memory allocated to a process is larger than requested memory, the difference between these two numbers is internal fragmentation.</p><p>在内存管理中，<strong>内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间</strong></p></li><li><p><strong>external fragmentation:</strong>External fragments exists when total memory space exists to satisfy a request, but it is not continous. storage is broken into little pieces. </p><p><strong>外部碎片</strong>是指<strong>还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块</strong>。</p></li></ul><p>一般情况下，<strong>固定分区存在内部碎片，可变式分区分配会存在外部碎片</strong>；</p><p><strong>页式虚拟存储系统</strong>存在内部碎片（为了有效的利用内存，使内存产生更少的碎片，要<strong>对内存分页</strong>，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片）</p><p><strong>段式虚拟存储系统</strong>存在外部碎片（为了共享要分段，在段的换入换出时形成外部碎片，比如5K的段换出后，有一个4k的段进来放到原来5k的地方，于是形成1k的外部碎片）</p></blockquote><h4 id="移动技术"><a href="#移动技术" class="headerlink" title="移动技术"></a>移动技术</h4><p>当在未分配分区表中找不到足够大的空闲区来装入新进程时，可采用移动技术把已在内存中的进程分区连接到一起，使分散的空闲区汇集成片，也叫内存紧凑（compact）</p><ul><li>第一种方式是把<strong>所有</strong>当前占用的分区内容移动到内存的一端</li><li>第二种方式是把占用分区内容移动到内存的一端，但是当<strong>产生足够大小的空闲区时就停止移动</strong></li></ul><p>内存中的进程在移动过程中，凡是涉及地址的信息都需要进行修改，例如基址寄存器、地址指针、内存分配表等。那么什么时候进行移动？</p><ul><li>一是进程撤销之后释放分区时，如果它不与空闲区邻接，立即实施移动，于是系统始终保持只有一个空闲区</li><li>二是进程装入分区时，若空闲区的总和够用，但是没有一个空闲区能容纳此进程时实施移动</li></ul><p>移动技术分配内存空间的算法：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/85L24gcDBvHqblZ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>移动操作也为进程运行过程中<strong>动态扩充内存空间</strong>提供了方便，当进程执行过程中要求增加内存空间时，只需要适当移动邻近的占用分区内容就可以增加其所占有的连续区的长度，<strong>移动后的基址值和经扩大的限长值都要相应修改</strong></p><h4 id="对换技术"><a href="#对换技术" class="headerlink" title="对换技术"></a>对换技术</h4><p>对换技术（swapping）广泛应用于分时系统调度中，以<strong>解决内存容量不足</strong>的问题。如果当前一个或者多个驻留进程都处于阻塞态，此时选择其中一个进程，将其暂时移出内存，腾出空间给其他进程使用，同时把磁盘中的某个进程换入内存，让其投入运行，这种互换称为对换。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/RotUY5bDaXBE94x.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>由于有硬件地址重定位寄存器的支持，对换进来的进程映像被复制到新分配的内存区域并重置定位寄存器的值。</p><p>为了有效实施对换，必须确定以下事情：</p><ul><li><p>首先选择哪个进程换出：通常系统把时间片耗尽或优先级较低的进程换出，因为短时间内它们不会投入运行</p></li><li><p>其次应决定把进程的哪些信息移出去</p><p><img src="https://i.loli.net/2019/10/24/GPdIu2sCtxfQ647.png" alt></p></li><li><p>最后需要确定对换时机</p><ul><li>批处理系统中，当进程要求动态扩充内存空间且得不到满足时可触发对换</li><li>分时系统中，每个时间片结束或执行I/O操作时实施，调度程度启动一个挪出的进程换入，这样轮到它执行时立即可以启动（需要解决对换过程中进程的地址重定位问题）</li></ul></li></ul><p>与移动不同，<strong>对换要访问磁盘</strong>，这是I/O集中型操作，但是系统可以让对换与计算型进程并行工作。换出的进程候选者当<strong>首选被阻塞的进程</strong>，否则就挑选就绪进程，同时需要考虑进程的属性，例如消耗CPU时间、在内存已逗留时间等</p><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>移动和对换技术解决因多个程序存在而导致内存区不足的问题，这种内存短缺是暂时的；如果程序长度超过物理内存总和，或超出固定分区大小，则出现内存永久性短缺，大进程无法运行，前两种方法无法解决，解决方案是使用覆盖（overlaying）技术。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/KaZGpMvTN5iIhOA.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>但是不足之处是，<strong>存储管理工作转给了程序员</strong>，他们必须根据物理内存空间来设计和编写程序。</p><h2 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h2><h3 id="分页存储管理的基本原理"><a href="#分页存储管理的基本原理" class="headerlink" title="分页存储管理的基本原理"></a>分页存储管理的基本原理</h3><p>采用分页存储管理允许程序存放到若干不相邻的空闲块中，既可免除移动信息工作，又可充分利用内存空间，消除动态分区法中的“碎片”问题，从而提高内存空间利用率</p><p>基本概念：</p><ul><li><p>页面：进程<strong>逻辑地址空间</strong>分成<strong>大小相等</strong>的区，每个区称为页面或页，页号从0开始依次编号</p></li><li><p>页框：页框又称为页帧，把<strong>内存物理地址空间</strong>分成<strong>大小相等</strong>的区，其大小与页面大小相等，每个区是一个页框（物理块），块号从0开始依次编号</p></li><li><p>逻辑地址：分页存储器的逻辑地址由<strong>页号</strong>和<strong>页内位移</strong>两部分组成</p><p><img src="https://i.loli.net/2019/10/25/zn2u17CGlWJvyN3.png" alt></p></li><li><p>内存页框表：该表长度取决于内存划分的物理块数，编号可与物理块号一致，页框表的表项给出物理块使用情况（0：空闲，1：占用），有的系统还会增加保护位</p></li><li><p>页表（如下一小节）</p></li></ul><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>在进行内存分配时以页框为单位，进程信息有多少页，那么把它装入内存时就分配多少页框，其中进程的逻辑地址是划分成编号连续的页面的，而装入内存的页框却未必相连。每个</p><p>（1）页面与被分配的页框如何建立联系？</p><p><strong>页表</strong>是操作系统为进程建立的，是程序页面和内存页框的对照表，页表中的每一栏指明程序中的一个页面和分得页框之间的对应关系。</p><p>为了减少系统开销，操作系统在内存中开辟存储区（软件）存放进程页表，另外设置页表寄存器（硬件）来存放当前运行进程的页表起始地址，以加快地址转换速度。</p><p>进程在内存中的每个页框内的地址是连续的，但是页框之间的地址可以不连续。</p><p>（2）逻辑地址（页面）如何转换成物理地址（页框）？</p><p>进程在运行前由系统把它的页表基地址送入页表基址寄存器，运行时借助硬件地址转换机制按页面进行动态地址重定位。</p><p>CPU获得逻辑地址后，由硬件自动按设定的页面尺寸分成<strong>页号p</strong>和<strong>页内位移d</strong>两部分，先从页表基址寄存器找到页表基地址，再用页号p作为索引查页表，得到对应的页框号</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/25/JRcqrm2G6uM7UWT.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>然后计算出要访问的内存单元地址（物理地址），实际上就是页框号和页内位移进行拼接得到物理地址</p><p>（3）如何保证程序正确运行？</p><p>虽然进程存放在若干不连续的页框中，但是在执行过程中总能<strong>按正确的物理地址进行存取</strong>。整个系统<strong>只有一个页表基址寄存器</strong>，只有占用CPU的进程才占有它；多道程序设计中，当某道程序让出处理器时，应同时让出此寄存器供其他进程使用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/25/zIWV6LArS1TgpcR.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="翻译块表（Translation-Look-aside-Buffer，TLB）"><a href="#翻译块表（Translation-Look-aside-Buffer，TLB）" class="headerlink" title="翻译块表（Translation Look-aside Buffer，TLB）"></a>翻译块表（Translation Look-aside Buffer，TLB）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;存储管理&quot;&gt;&lt;a href=&quot;#存储管理&quot; class=&quot;headerlink&quot; title=&quot;存储管理&quot;&gt;&lt;/a&gt;存储管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="存储管理" scheme="http://QQ876684433.github.io/tags/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-10-22）</title>
    <link href="http://QQ876684433.github.io/2019/10/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-10-22%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/22/数据库课堂笔记（2019-10-22）/</id>
    <published>2019-10-22T05:52:13.000Z</published>
    <updated>2019-10-23T07:12:45.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-10-22）"><a href="#数据库课堂笔记（2019-10-22）" class="headerlink" title="数据库课堂笔记（2019-10-22）"></a>数据库课堂笔记（2019-10-22）</h2><h3 id="Ch4-Object-Relational-SQL-Oracle"><a href="#Ch4-Object-Relational-SQL-Oracle" class="headerlink" title="Ch4. Object-Relational SQL (Oracle)"></a>Ch4. Object-Relational SQL (Oracle)</h3><h4 id="Object-Types（对象类型）"><a href="#Object-Types（对象类型）" class="headerlink" title="Object Types（对象类型）"></a>Object Types（对象类型）</h4><h5 id="类型的循环嵌套定义"><a href="#类型的循环嵌套定义" class="headerlink" title="类型的循环嵌套定义"></a>类型的循环嵌套定义</h5><p>对象类型(object type)不能嵌套定义， 但 REF 关系可以实现嵌套引用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">type</span> police_officer_t <span class="keyword">as</span> <span class="keyword">object</span></span><br><span class="line">(</span><br><span class="line">    pol_person person_t,</span><br><span class="line">    badge_number <span class="built_in">integer</span>,</span><br><span class="line">    partner <span class="keyword">ref</span> police_officer_t</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="REF-的其它约束"><a href="#REF-的其它约束" class="headerlink" title="REF 的其它约束"></a>REF 的其它约束</h5><ul><li><p>两张表之间的相互REF关系的定义</p><p><img src="https://i.loli.net/2019/10/22/3cR6MzrC4h9Fj2t.png" alt></p></li><li><p>两个具有相互REF关系的表/类型的删除</p><p><img src="https://i.loli.net/2019/10/22/f8vQaitUkF5hMVH.png" alt></p></li><li><p>REF属性数据的加载</p><p><img src="https://i.loli.net/2019/10/22/ojbT5m3XgcLidSN.png" alt></p><p><img src="https://i.loli.net/2019/10/22/5QTBnZmsLpKNqdV.png" alt></p></li></ul><h4 id="Collection-Types（集合类型）"><a href="#Collection-Types（集合类型）" class="headerlink" title="Collection Types（集合类型）"></a>Collection Types（集合类型）</h4><p>集合类型允许我们将多个值（即值的集合）存放到一行记录的某一列中，在Oracle中，集合类型有以下两种：</p><ul><li><p>表类型（Table Types，嵌套表）</p></li><li><p>数组类型（Array Types）</p><p>其中数组类型中存放的元素是具有相同的类型（the element type）的</p></li></ul><h5 id="表类型和嵌套表（Table-Types-and-Nested-Tables）"><a href="#表类型和嵌套表（Table-Types-and-Nested-Tables）" class="headerlink" title="表类型和嵌套表（Table Types and Nested Tables）"></a>表类型和嵌套表（Table Types and Nested Tables）</h5><p>创建一个<strong>表类型（table type）</strong>的方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> dependents_t <span class="keyword">AS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> person_t;</span><br></pre></td></tr></table></figure><p>这样就可以通过表类型（dependents_t）来定义新的表，而dependents_t则形成一个嵌套表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employees (</span><br><span class="line">    eid <span class="built_in">int</span>,</span><br><span class="line">    eperson person_t,</span><br><span class="line">    dependents dependents_t,</span><br><span class="line">    primary <span class="keyword">key</span> (eid)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如上，dependents属性的类型就是一个表类型（dependents_t），它是employees的嵌套表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/22/rXlRbBpLfgZJNEu.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="嵌套表的访问"><a href="#嵌套表的访问" class="headerlink" title="嵌套表的访问"></a>嵌套表的访问</h5><ul><li><p>对嵌套表进行访问时，如果需要对表类型属性进行子查询，那么需要使用<strong>转换函数：table(…)</strong>：</p><p><img src="https://i.loli.net/2019/10/22/ywjF8oRn42peHrc.png" alt></p></li><li><p>嵌套表属性不能直接使用统计函数，比如count(…)等，同样需要使用转换函数table(…)</p><p><img src="https://i.loli.net/2019/10/22/MUkJDqIZuyFw9Ng.png" alt></p></li><li><p>Oracle 数据库没有提供 nested table 的相等比较运算，但是提供了单个对象的相等比较功能</p><p><img src="https://i.loli.net/2019/10/22/VXsY1jQ8m4TPZdf.png" alt></p></li><li><p>Oracle是支持嵌套表与表自身的联接查询的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid, d.ssno</span><br><span class="line"><span class="keyword">from</span> employees e, <span class="keyword">table</span>(e.dependents) d</span><br></pre></td></tr></table></figure></li></ul><h5 id="Oracle的外联接（outer-join）"><a href="#Oracle的外联接（outer-join）" class="headerlink" title="Oracle的外联接（outer join）"></a>Oracle的外联接（outer join）</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/hehaiyang/p/4745897.html" target="_blank" rel="noopener">https://www.cnblogs.com/hehaiyang/p/4745897.html</a></p></blockquote><p>对于外连接， 也可以使用“(+) ”来表示。 关于使用（+）的一些注意事项：</p><ol><li><strong>（+）操作符只能出现在WHERE子句中</strong>，并且不能与OUTER JOIN语法同时使用。</li><li>当使用（+）操作符执行外连接时，如果在WHERE子句中包含有多个条件，则必须在所有条件中都包含（+）操作符。</li><li>（+）操作符只适用于列，而不能用在表达式上。</li><li>（+）操作符不能与OR和IN操作符一起使用。</li><li>（+）操作符只能用于实现左外连接和右外连接，而<strong>不能用于实现完全外连接</strong>。</li></ol><p>用（+）来实现， 这个+号可以这样来理解： <strong>+ 表示补充，即哪个表有加号，这个表就是匹配表</strong>。如果加号写在右表，左表就是全部显示，所以是<strong>左连接</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> t_A a,t_B b <span class="keyword">where</span> a.id=b.id(+);</span><br></pre></td></tr></table></figure><p>如果加号写在左表，右表就是全部显示，所以是<strong>右连接</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> t_A a,t_B b <span class="keyword">where</span> a.id(+)=b.id;</span><br></pre></td></tr></table></figure><p>而对于全外联接，左表和右表都不做限制，所有的记录都显示，两表不足的地方均为NULL。 <strong>全外连接不支持（+）写法</strong>。</p><h5 id="嵌套游标（Nested-Cursors）"><a href="#嵌套游标（Nested-Cursors）" class="headerlink" title="嵌套游标（Nested Cursors）"></a>嵌套游标（Nested Cursors）</h5><p>可以使用嵌套游标来实现对嵌套表的查询，例如对于普通的查询操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid, d.ssno <span class="keyword">as</span> dep_sso</span><br><span class="line"><span class="keyword">from</span> employees e, <span class="keyword">table</span>(e.dependents) d</span><br><span class="line"><span class="keyword">where</span> d.age &lt; <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>可以使用嵌套游标来实现相同的功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid,</span><br><span class="line">    <span class="keyword">cursor</span> ( <span class="keyword">select</span> d.ssno <span class="keyword">as</span> dep_ssno</span><br><span class="line">        <span class="keyword">from</span> <span class="keyword">table</span>(e.dependents) d</span><br><span class="line">        <span class="keyword">where</span> d.age &lt; <span class="number">16</span>) dep_tab</span><br><span class="line"><span class="keyword">from</span> employees e;</span><br></pre></td></tr></table></figure><p>另外，嵌套游标也可以用来实现对嵌套表属性的统计功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> eid,</span><br><span class="line">    <span class="keyword">cursor</span> ( <span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">table</span>(e.dependents) )</span><br><span class="line"><span class="keyword">from</span> employees e;</span><br></pre></td></tr></table></figure><p>但是似乎cursor是多余的，因为以下两种方式也可以对嵌套表属性进行统计：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/3COt2zYwkmI5XRL.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="Array-Types（数组类型）"><a href="#Array-Types（数组类型）" class="headerlink" title="Array Types（数组类型）"></a>Array Types（数组类型）</h4><p>嵌套表类型（Nested Table）和数组类型（VARRAY）的对比：</p><table><thead><tr><th align="center"></th><th align="center">Nested table</th><th align="center">VARRAY</th></tr></thead><tbody><tr><td align="center">成员的排列次序</td><td align="center">无序</td><td align="center">有序</td></tr><tr><td align="center">成员的最大数目</td><td align="center">没有限制</td><td align="center">确定的值</td></tr><tr><td align="center">成员的存储组织</td><td align="center">单独的存储表</td><td align="center">直接存储在原表中</td></tr></tbody></table><p>两者在访问模式上的区别：</p><ul><li>可以对嵌套表属性执行insert操作， 或通过update操作修改其成员的取值</li><li>但对于 VARRAY 属性则不能执行上述的插入或修改操作， 只能通过<strong>update语句修改整个 VARRAY 属性</strong>的取值</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Makefile学习笔记</title>
    <link href="http://QQ876684433.github.io/2019/10/21/Makefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://QQ876684433.github.io/2019/10/21/Makefile学习笔记/</id>
    <published>2019-10-21T02:08:59.000Z</published>
    <updated>2019-10-21T02:08:59.036Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统-中断技术</title>
    <link href="http://QQ876684433.github.io/2019/10/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E6%8A%80%E6%9C%AF/"/>
    <id>http://QQ876684433.github.io/2019/10/17/操作系统-中断技术/</id>
    <published>2019-10-17T12:57:02.000Z</published>
    <updated>2019-10-18T07:44:33.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中断技术"><a href="#中断技术" class="headerlink" title="中断技术"></a>中断技术</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li><li>Linux Kernel Teaching - <a href="https://linux-kernel-labs.github.io/master/lectures/interrupts.html" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/lectures/interrupts.html</a></li></ul></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​        每当应用程序执行系统调用要求获得操作系统服务、I/O设备报告传输情况，或者产生各种内部和外部事件时，都需要通过中断机制产生中断信号并启动操作系统内核工作，可以说，操作系统是由“<strong>中断驱动</strong>”的。最初中断技术仅作为设备向CPU报告I/O操作情况的一种手段，以免CPU因不断地轮训设备而耗费CPU时间，<strong>中断的出现解决了主机和设备的并行性问题</strong>。</p><p>​        <strong>中断（interrupt）</strong>指的是在程序执行过程中遇到急需处理的事件时，暂时终止现行程序在CPU上的运行，转而执行相应的事件处理程序，待处理完成后再<u>返回断点</u>或<u>调度其他程序执行</u>的过程。</p><p>​        不同的计算机系统中通常有不同的中断源和中断装置，但是它们都有一个共性：中断事件发生后，中断装置能改变处理器内操作的执行顺序。</p><h2 id="中断源分类"><a href="#中断源分类" class="headerlink" title="中断源分类"></a>中断源分类</h2><h3 id="硬中断"><a href="#硬中断" class="headerlink" title="硬中断"></a>硬中断</h3><p>由硬件发出或产生的中断称为硬中断，按照硬中断事件的来源和实现手段，可以将硬中断划分为外中断和内中断</p><h4 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h4><p>又称为<strong>中断</strong>或<strong>异步中断</strong>，是指<strong>来自处理器之外的中断信号</strong>，包括：时钟中断、键盘中断、它机中断、外部设备中断等。外中断又分为</p><ul><li><strong>可屏蔽中断</strong></li><li><strong>不可屏蔽中断</strong></li></ul><p>各个中断具有不同的中断优先级，表示事件的紧急程度，在处理高一级中断时，往往会部分或者全部屏蔽低级中断。</p><h4 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h4><p>又称为<strong>异常（exception）</strong>或<strong>同步中断</strong>，是指<strong>来自处理器内部的中断信号</strong>，通常是由于在程序执行过程中，发现与<strong>当前指令</strong>关联的、不正常的或错误的事件。内中断可被细分为：</p><ul><li>访管中断，由执行系统调用引起</li><li>硬件故障中断，如电源失效、奇偶校验错误、总线超时等</li><li>程序性异常，如非法操作、地址越界、页面故障、调试指令、除数为0和浮点数溢出等</li></ul><p>这些事件都由<strong>异常处理程序</strong>处理，并且通常依赖于执行程序的当前现场。<strong>内中断不能被屏蔽，一旦出现应立即予以响应并进行处理</strong>，而异常处理程序运行时是否屏蔽外部中断或屏蔽哪些中断，可根据异常处理的需要来设定</p><h4 id="中断和异常的区别"><a href="#中断和异常的区别" class="headerlink" title="中断和异常的区别"></a>中断和异常的区别</h4><ul><li><p>中断由与当前运行程序无关的中断信号触发的，系统不能确定中断事件的发生时间，故<strong>中断与CPU是异步的</strong>，CPU对中断的响应完全是被动的。<strong>中断的发生与CPU当前状态无关</strong>，既可以发生在用户态也可以发生在内核态，因为无论是用户态还是内核态，都需要处理外部设备发来的中断请求。一般来说，<strong>中断处理程序所提供的服务不是当前进程所需要的</strong>，如时钟中断、磁盘中断等</p><p>异常是由<strong>CPU控制单元</strong>产生的，源于<strong>现行程序执行指令过程中检测到的例外</strong>（exception）。<strong>异常与CPU是同步的</strong>，允许指令在执行过程期间响应异常，而且允许多次响应异常，大部分异常发生在用户态，而<strong>内核态唯一发生的异常是“缺页异常”</strong></p></li><li><p>“中断”应该被快速处理以便及时响应其他中断信号，所以<strong>中断处理程序处理过程中是不能阻塞的</strong></p><p>“异常”处于被打断的当前进程上下文中，所提供的服务是当前进程所需要的，所以<strong>异常处理程序处理过程中是可以阻塞的</strong></p></li><li><p>中断允许发生嵌套，但异常大多为一重；异常处理过程中可能会发生中断，但是中断处理过程中绝不会被异常打断</p></li></ul><blockquote><p>reference：<a href="https://stackoverflow.com/questions/7295936/what-is-the-difference-between-interrupt-and-exception-context" target="_blank" rel="noopener">https://stackoverflow.com/questions/7295936/what-is-the-difference-between-interrupt-and-exception-context</a></p><p>Interrupts and exceptions both alter the program flow. The difference between the two is that <strong>interrupts are used to handle external events (serial ports, keyboard)</strong> and <strong>exceptions are used to handle instruction faults, (division by zero, undefined opcode).</strong></p><p>Interrupts are handled by the processor after finishing the current instruction. If it finds a signal on its interrupt pin, it will look up the address of the interrupt handler in the interrupt table and pass that routine control. After returning from the interrupt handler routine, it will resume program execution at the instruction after the interrupted instruction.</p><p>Exceptions on the other hand are divided into three kinds. These are <strong>Faults, Traps and Aborts</strong>. Faults are detected and serviced by the processor before the faulting instructions. Traps are serviced after the instruction causing the trap. User defined interrupts go into this category and can be said to be traps; this includes the MS- DOS INT 21h software interrupt, for example. Aborts are used only to signal severe system problems, when operation is no longer possible.</p></blockquote><h3 id="中断和异常的响应及服务"><a href="#中断和异常的响应及服务" class="headerlink" title="中断和异常的响应及服务"></a>中断和异常的响应及服务</h3><p>产生处理器外部中断或者内部异常的时候，CPU都会在<strong>执行完当前指令后</strong>，根据中断源所提供的“中断向量”，在内核中找到响应中断服务例程并调度执行。</p><p>中断向量<strong>由硬件或操作系统预先分配和设置</strong>，系统调用所对应的向量则在访管指令中给出；各种异常向量<strong>在CPU的硬件结构中预先规定</strong>。这样不同情况就因中断向量的不同而区分开来。</p><p>操作系统如何转到中断处理程序和异常处理程序执行呢？</p><ul><li>对于中断，它主要由外部设备、时钟部件或其他计算机发出的（发现中断源并产生中断的硬件称为中断控制器，这些硬件包括中断逻辑线路和中断寄存器）<u>当前指令执行结束后，CPU会检查中断寄存器是否有中断事件发生</u>：<ul><li>若无中断信号或中断信号被屏蔽，则继续执行程序的后续指令</li><li>否则将暂停执行当前程序，转向内核的中断处理程序执行</li></ul></li><li>对于异常，它是在执行指令时，由于指令本身的原因发生的，指令的控制逻辑和实现线路一旦发现异常情况便转向内核的异常处理程序</li></ul><p>这个<u>由硬件对中断和异常事件做出反应的过程</u>称为<strong>中断响应</strong>。目前的计算机都采用软硬件结合（<strong>硬件中断控制器</strong>和<strong>软件中断/异常处理程序</strong>相结合）的方法实现中断/异常处理。中断/异常响应需要执行以下四个步骤：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/18/I7Eo5uDZ6jtdcCV.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="中断优先级和多重中断"><a href="#中断优先级和多重中断" class="headerlink" title="中断优先级和多重中断"></a>中断优先级和多重中断</h3><h4 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h4><p>中断装置所预设的中断响应顺序称为中断优先级。例如，同样是设备，可以设定高速设备优先级高，慢速设备优先级低，以提高高速设备的利用率。那么中断系统如何按照预先设定的优先顺序予以响应？可以使用硬件和软件方法</p><ul><li>硬件方法根据排定的优先级顺序做一个硬件链式排队器，当产生高一级中断事件时，应该<strong>屏蔽比它优先级低的所有中断源</strong></li><li>软件方法编写一个查询程序，依据优先级顺序<strong>从高到低进行查询</strong>，一旦发现有中断请求，便转入相应中断事件处理程序入口</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;中断技术&quot;&gt;&lt;a href=&quot;#中断技术&quot; class=&quot;headerlink&quot; title=&quot;中断技术&quot;&gt;&lt;/a&gt;中断技术&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="中断" scheme="http://QQ876684433.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux写时拷贝技术（copy-on-write）</title>
    <link href="http://QQ876684433.github.io/2019/10/17/Linux%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF%EF%BC%88copy-on-write%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/17/Linux写时拷贝技术（copy-on-write）/</id>
    <published>2019-10-17T10:36:13.000Z</published>
    <updated>2019-10-17T12:55:08.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux写时拷贝技术（copy-on-write）"><a href="#Linux写时拷贝技术（copy-on-write）" class="headerlink" title="Linux写时拷贝技术（copy on write）"></a>Linux写时拷贝技术（copy on write）</h1><h2 id="fork-和-exec"><a href="#fork-和-exec" class="headerlink" title="fork() 和 exec()"></a>fork() 和 exec()</h2><blockquote><p>参考资料：</p><ul><li><a href="https://www.geeksforgeeks.org/difference-fork-exec/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/difference-fork-exec/</a></li><li><a href="https://stackoverflow.com/questions/1653340/differences-between-fork-and-exec" target="_blank" rel="noopener">https://stackoverflow.com/questions/1653340/differences-between-fork-and-exec</a></li></ul></blockquote><p>每一个应用程序都是通过进程来运行的，进程是一个程序运行的实例，fork()和exec()都可以创建新的进程</p><h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br></pre></td></tr></table></figure><p><code>fork()</code>创建的新进程是原调用进程的的一个拷贝，新进程称为子进程，原进程是它的父进程，父子进程之间的差别在于：</p><ul><li><p>子进程有自己独立的进程ID（pid），而且pid与任意已经存在的<strong>进程组</strong>的ID都不同</p><p>（链接原文说的是“进程组”，目前没搞懂和直接说“进程”有什么不同，待考证）</p><blockquote><p>在兼容于<a href="https://zh.wikipedia.org/wiki/POSIX" target="_blank" rel="noopener">POSIX</a>标准的<a href="https://zh.wikipedia.org/wiki/作業系統" target="_blank" rel="noopener">操作系统</a>中，<strong>进程组</strong>（英语：Process group，又译<strong>过程组群</strong>）是指一个或多个<a href="https://zh.wikipedia.org/wiki/行程" target="_blank" rel="noopener">进程</a>的集合。进程组被使用于控制<a href="https://zh.wikipedia.org/wiki/信号_(计算机科学)" target="_blank" rel="noopener">信号</a>的分配。对于一个进程组发出的的信号，会被个别递送到这个组群下的每个进程成员中。</p><p>进程组本身，也可以被集合成一个组群来管理，称为<strong>会话组</strong>（sessions）。归属于某个特定会话组下的进程组，不能移动到别的会话组下；在某个进程组下的特定进程，在创造出新的进程时，这个进程也只能属于这个父进程所归属的相同会话组。</p><p>—— 来源 <a href="https://zh.wikipedia.org/wiki/行程群組" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E7%BE%A4%E7%B5%84</a></p></blockquote></li><li><p>The child’s parent process ID is the same as the parent’s process ID.（这个没必要翻译orz）</p></li><li><p>The child does not inherit its parent’s <strong>memory locks</strong> and <strong>semaphore adjustments</strong></p><p>子进程不会继承父进程的内存锁和信号量调整</p></li><li><p>The child does not inherit outstanding asynchronous I/O operations from its parent nor does it inherit any asynchronous I/O contexts from its parent</p><p>子进程不会从其父级继承未完成的异步I / O操作，也不会从其父级继承任何异步I / O上下文</p></li></ul><h4 id="fork-的返回值"><a href="#fork-的返回值" class="headerlink" title="fork()的返回值"></a>fork()的返回值</h4><ul><li>如果创建子进程成功，那么子进程的PID就会被返回到父进程中，即<code>pid_t pid = fork();</code>中的pid就是创建的子进程的PID，而对子进程而言<code>pid_t pid = fork();</code>中的pid的值是0；可以根据父进程和子进程返回值的不同来使得父进程和子进程接下来执行不同的任务</li><li>如果创建子进程失败，那么父进程中<code>pid_t pid = fork();</code>返回值是-1，然后不会有子进程被创建出来，并且错误码会被设置</li></ul><p><code>fork()</code>之后子进程是父进程的拷贝，父进程和子进程会从相同的指令处接着往下面继续执行，即父进程和子进程都会从<code>pid_t pid = fork();</code>下面一行开始执行</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><blockquote><p>there is a whole family of <code>exec</code> calls (<code>execl</code>, <code>execle</code>, <code>execve</code> and so on) but <code>exec</code> in context here means any of them</p></blockquote><p><code>exec()</code>是一系列函数的统称</p><p><code>exec()</code>使用新的进程映像替换当前的进程映像，即它将要运行的程序加载到当前的进程空间中，然后从新程序的入口点开始运行。一般可以结合<code>fork()</code>和<code>exec()</code>来使得当前进程能够启动一个新进程来运行新程序。下面是一个在bash中运行ls程序来获取目录文件列表的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+--------+</span><br><span class="line">| pid=7  |</span><br><span class="line">| ppid=4 |</span><br><span class="line">| bash   |</span><br><span class="line">+--------+</span><br><span class="line">    |</span><br><span class="line">    | calls fork</span><br><span class="line">    V</span><br><span class="line">+--------+             +--------+</span><br><span class="line">| pid=7  |    forks    | pid=22 |</span><br><span class="line">| ppid=4 | ----------&gt; | ppid=7 |</span><br><span class="line">| bash   |             | bash   |</span><br><span class="line">+--------+             +--------+</span><br><span class="line">    |                      |</span><br><span class="line">    | waits for pid 22     | calls exec to run ls</span><br><span class="line">    |                      V</span><br><span class="line">    |                  +--------+</span><br><span class="line">    |                  | pid=22 |</span><br><span class="line">    |                  | ppid=7 |</span><br><span class="line">    |                  | ls     |</span><br><span class="line">    V                  +--------+</span><br><span class="line">+--------+                 |</span><br><span class="line">| pid=7  |                 | exits</span><br><span class="line">| ppid=4 | &lt;---------------+</span><br><span class="line">| bash   |</span><br><span class="line">+--------+</span><br><span class="line">    |</span><br><span class="line">    | continues</span><br><span class="line">    V</span><br></pre></td></tr></table></figure><h3 id="fork-和exec-的区别"><a href="#fork-和exec-的区别" class="headerlink" title="fork()和exec()的区别"></a>fork()和exec()的区别</h3><ul><li>fork starts a new process which is a copy of the one that calls it, while exec replaces the current process image with another (different) one.</li><li>Both parent and child processes are executed simultaneously in case of fork() while Control never returns to the original program unless there is an exec() error.</li></ul><h2 id="Copy-On-Write"><a href="#Copy-On-Write" class="headerlink" title="Copy On Write"></a>Copy On Write</h2><blockquote><p>参考资料：<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="noopener">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html</a></p></blockquote><p>​        从上面的介绍中可以知道，<code>fork()</code>会创建一个和父进程完全相同的子进程，但是子进程接下来可能会执行<code>exec()</code>来加载新的程序，如果子进程一创建就调用<code>exec()</code>，那么系统开销是很大的，因为刚刚拷贝了一份父进程，就接着被新的进程替换掉，显然前面的备份是有点多余的。因此，为了提高效率，Linux中引入了copy on write（写时复制）技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p><ul><li>在fork之后、exec之前，父子进程用的是相同的物理空间（内存区），<strong>子进程的代码段、数据段、堆栈都是指向父进程的物理空间</strong>，即两者的虚拟空间不同，但其对应的物理空间是同一个</li><li>当父子进程中有<strong>更改相应段的行为发生</strong>时，再为子进程相应的段分配物理空间<ul><li>如果不是因为exec，内核会<strong>给子进程的数据段、堆栈段分配相应的物理空间</strong>（至此两者有各自的进程空间，互不影响），而<strong>代码段继续共享父进程的物理空间</strong>（两者的代码完全相同）</li><li>如果是因为exec，由于两者执行的代码不同，子进程的<strong>代码段也会分配单独的物理空间</strong></li></ul></li><li>fork之后内核会通过将子进程放在队列的前面，以让子进程先执行，以免父进程<strong>先运行导致写时复制，而后子进程才执行exec系统调用</strong>，这样可以避免无意义的复制而造成效率的下降</li></ul><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>​        对于一个父进程P1，它的虚拟地址空间上有：正文段，数据段，堆，栈这四个部分，相应地，内核要为这四个部分分配各自的物理块，即正文段块，数据段块，堆块，栈块</p><ol><li><p>现在P1用fork()函数为进程创建一个子进程P2</p><p>对于内核来说，它会执行如下的任务：</p><ul><li><p>复制P1的正文段，数据段，堆，栈这四个部分，并且它们内容相同</p></li><li><p>为这四个部分分配物理块，对于新的进程P2：</p><ul><li>正文段－＞P1的正文段的物理块，其实就是<strong>不为P2分配正文段块</strong>，让P2的正文段指向P1的正文段块</li><li>数据段－＞P2自己的数据段块（为其分配对应的块）</li><li>堆－＞P2自己的堆块</li><li>栈－＞P2自己的栈块</li></ul><p>如图所示：其中大箭头表示内容复制方向</p><p><img src="https://i.loli.net/2019/10/17/Vct5I6YNm7jHJSX.jpg" alt></p></li></ul></li><li><p>写时复制技术</p><p>内核<strong>只为新生成的子进程创建虚拟空间结构</strong>，它们来复制于父进程的虚拟空间结构，但是<strong>不为这些段分配物理内存</strong>，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间</p><p><img src="https://i.loli.net/2019/10/17/QKVqc6bECtrJn2X.jpg" alt></p></li><li><p>vfork()</p><p>内核连子进程的虚拟地址空间结构也不创建了，<strong>直接共享了父进程的虚拟空间</strong>，自然地子进程也共享了父进程的物理空间</p><p><img src="https://i.loli.net/2019/10/17/9SGa4vYgzFTHhIk.jpg" alt></p></li></ol><blockquote><p>传统的fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。Linux的fork()使用写时拷贝（copy-on-write）页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，<strong>资源的复制只有在需要写入的时候才进行</strong>，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候。<strong>在页根本不会被写入的情况下（<em>举例来说，fork()后立即调用exec()</em>）它们就无需复制了。fork()的实际开销就是复制父进程的页表以及给子进程创建惟一的进程描述符</strong>。在一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以<strong>避免拷贝大量根本就不会被使用的数据</strong>（地址空间里常常包含数十兆的数据）。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。这里补充一点：<strong>Linux COW与exec没有必然联系</strong></p></blockquote><p>（<em>原文中还提到C++中string的copy-on-write技术，因为这个与本主题无关，想要了解的话可以通过上面的参考链接查看</em>）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux写时拷贝技术（copy-on-write）&quot;&gt;&lt;a href=&quot;#Linux写时拷贝技术（copy-on-write）&quot; class=&quot;headerlink&quot; title=&quot;Linux写时拷贝技术（copy on write）&quot;&gt;&lt;/a&gt;Linux写时拷
      
    
    </summary>
    
      <category term="Linux" scheme="http://QQ876684433.github.io/categories/Linux/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://QQ876684433.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-程序接口与系统调用</title>
    <link href="http://QQ876684433.github.io/2019/10/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://QQ876684433.github.io/2019/10/16/操作系统-程序接口与系统调用/</id>
    <published>2019-10-16T00:03:25.000Z</published>
    <updated>2019-10-17T10:33:35.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="程序接口与系统调用"><a href="#程序接口与系统调用" class="headerlink" title="程序接口与系统调用"></a>程序接口与系统调用</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li><li>Linux Kernel Teaching - <a href="https://linux-kernel-labs.github.io/master/index.html" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/index.html</a></li></ul></blockquote><h2 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h2><p>操作系统通过“程序接口”和“操作接口”将其服务和功能提供给用户：</p><ul><li>程序接口是操作系统对外提供服务和功能的手段，它由一组系统调用组成，在应用程序中使用“系统调用”可<strong>获得操作系统的低层服务</strong>，访问或使用系统管理的<strong>各种软硬件资源</strong></li><li>操作接口由一组控制命令和（或）作业控制语言组成，是操作系统为用户提供的<strong>组织和控制其作业（应用程序）执行</strong>的手段</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/uS6gCQYp4I3mBRW.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="程序接口与系统调用-1"><a href="#程序接口与系统调用-1" class="headerlink" title="程序接口与系统调用"></a>程序接口与系统调用</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/UBGqYT2x7A3KvE8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>因此可以这样认为，<strong>内核的主体是系统调用的集合</strong></p><blockquote><p>At a high level system calls are “services” offered by the kernel to user applications and they resemble library APIs in that they are described as a function call with a name, parameters and return value.</p><p>在高层次上来看，系统调用是内核为用户应用程序提供的“服务”，它们类似于库API，因为它们被描述为<strong>具有名称，参数和返回值的函数调用</strong></p></blockquote><h4 id="为什么使用系统调用"><a href="#为什么使用系统调用" class="headerlink" title="为什么使用系统调用"></a>为什么使用系统调用</h4><ul><li>根本原因是<strong>为了对系统进行“保护”</strong></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/MkKoNrVWsL6afz2.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>系统调用是一种中介角色，<strong>把用户和硬件资源隔离开来</strong>，应用程序只有通过系统调用才能请求系统服务并使用系统资源</li></ul><h4 id="系统调用的作用"><a href="#系统调用的作用" class="headerlink" title="系统调用的作用"></a>系统调用的作用</h4><ul><li>内核可以基于权限和规则<strong>对资源访问进行裁决</strong>，保证系统的安全性</li><li>系统调用<strong>对资源进行抽象</strong>，提供一致性接口，避免用户在使用资源时发生错误，且使编程效率大大提高</li></ul><p><strong>系统调用是应用程序获得操作系统服务的唯一途径</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/m28cC6uSbAKaOlJ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="API、库函数和系统调用"><a href="#API、库函数和系统调用" class="headerlink" title="API、库函数和系统调用"></a>API、库函数和系统调用</h3><p>不同操作系统提供的系统调用功能虽然大同小异，但是实现细节不尽相同，因此如果应用程序直接使用系统调用，那么会存在问题：</p><ul><li>接口复杂，使用困难</li><li>应用程序跨平台可移植性受到很大限制</li></ul><h4 id="不同操作系统之间的可移植性"><a href="#不同操作系统之间的可移植性" class="headerlink" title="不同操作系统之间的可移植性"></a>不同操作系统之间的可移植性</h4><p>POSIX（Portable Operating System Interface）为不同平台下的应用程序提供相同的<strong>应用程序接口（API）</strong>，但是它并没有保证相同的API的内部实现是一致的。其中系统调用只是其中一种API</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/AuwnP7WCJk6LHfs.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/lPKFso3z5XwkBd6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="库函数和系统调用"><a href="#库函数和系统调用" class="headerlink" title="库函数和系统调用"></a>库函数和系统调用</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/ZRPfL1eghsjGz6S.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>库函数属于应用程序，在<strong>用户态运行</strong>（用户可以替换库函数）</li><li>系统调用对应的服务例程属于系统程序，在<strong>内核态运行</strong>（用户通常不能替换系统调用）</li></ul><h3 id="系统调用分类"><a href="#系统调用分类" class="headerlink" title="系统调用分类"></a>系统调用分类</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/tjFvOqmTol53EsP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="系统调用实现"><a href="#系统调用实现" class="headerlink" title="系统调用实现"></a>系统调用实现</h3><ul><li>操作系统实现系统调用功能的机制称为<strong>陷阱或异常处理机制</strong></li><li>由于系统调用引起处理器中断的机器指令称为<strong>访管指令、自陷指令或中断指令</strong></li></ul><p>其中访管指令为非特权指令，在目态下执行时会将CPU转换到内核态</p><p>每个系统调用都事先规定编号，称为功能号，发出访管指令、自陷指令或中断指令时，必须通过某种方式指明对应系统调用的功能号（另外还要附带传递给相应服务例程的参数）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/uXIv26L59FMnryR.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/WDl4MKQNdikSoHj.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/BYsGkhpDeNqu3RX.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>应用程序和系统调用之间传递参数所采用的方法：</p><ul><li>访管指令或自陷指令自带参数</li><li>通过CPU通用寄存器传递参数</li><li>在内存区中开辟专用堆栈区传递参数</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/blihXo7WxKufDLZ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="系统调用与函数调用的区别"><a href="#系统调用与函数调用的区别" class="headerlink" title="系统调用与函数调用的区别"></a>系统调用与函数调用的区别</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/iHQXv2lD6sajo1u.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="System-Calls-in-Linux-Kernel"><a href="#System-Calls-in-Linux-Kernel" class="headerlink" title="System Calls in Linux Kernel"></a>System Calls in Linux Kernel</h2><blockquote><p>reference：<a href="https://linux-kernel-labs.github.io/master/lectures/syscalls.html" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/lectures/syscalls.html</a></p><p>Linux System Call Table for x86-64（Linux x86-64系统调用表）：<a href="http://shell-storm.org/shellcode/files/syscalls.html" target="_blank" rel="noopener">http://shell-storm.org/shellcode/files/syscalls.html</a></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/16/NIOgQMqSlaHjkye.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在进行系统调用的时候，特定的汇编指令会做如下的工作：</p><ul><li>setup information to identify the system call and its parameters</li><li>trigger a kernel mode switch</li><li>retrieve the result of the system call</li></ul><p>在Linux中，系统调用是通过数字编号来标识的，系统调用的参数的大小是机器的字长（word，32或者64位）。系统调用的参数最多有6个，系统调用编号和参数都是保存在特定的寄存器中，例如在32bit的x86架构中：</p><ul><li>系统调用数字编号保存在EAX寄存器中</li><li>系统调用的参数保存在EBX、ECX、EDX、ESI、EDI、EBP寄存器中</li></ul><p>为了使得开发应用程序时进行系统调用更简便，一些系统函数库（例如libc）会提供函数来完成系统调用内部的实际实现</p><p>当发生用户态到内核态的转移的时候，当前程序的执行流被中断，然后跳转到内核的入口点，这类似于中断和异常处理的方式（事实上，在一些架构中用户态到内核态的转换是异常处理的结果）</p><blockquote><p>During the user - kernel mode transition the stack is also switched from ther user stack to the kernel stack.</p><p>在发生用户态向内核态转移的时候，当前的系统堆栈也会由用户栈切换到内核态</p></blockquote><p>在系统调用的入口点会将当前寄存器的值（这些寄存器包含的是用户空间的值，并且包括<strong>系统调用数字编号和系统调用参数</strong>）保存起来</p><h3 id="系统调用例子"><a href="#系统调用例子" class="headerlink" title="系统调用例子"></a>系统调用例子</h3><blockquote><p>更详细的系统调用过程（结合Linux源码解析），参考：<a href="http://zhongmingmao.me/2019/04/20/linux-system-call-process/" target="_blank" rel="noopener">http://zhongmingmao.me/2019/04/20/linux-system-call-process/</a></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/17/8CD37Y9OcLZaHut.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>系统调用调度器（system call dispatcher）</strong>的功能是验证系统调用的数字编号，然后运行和系统调用相关的内核函数，如下代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handles int $0x80 */</span></span><br><span class="line"><span class="comment">/* 在进入内核之前，通过push和SAVE_ALL将当前用户态的寄存器，保存在pt_regs结构里面，然后调用do_int80_syscall_32 */</span></span><br><span class="line">__<span class="function">visible <span class="keyword">void</span> <span class="title">do_int80_syscall_32</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    enter_from_user_mode();</span><br><span class="line">    local_irq_enable();</span><br><span class="line">    do_syscall_32_irqs_on(regs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* simplified version of the Linux x86 32bit System Call Dispatcher */</span></span><br><span class="line"><span class="keyword">static</span> __<span class="function">always_inline <span class="keyword">void</span> <span class="title">do_syscall_32_irqs_on</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr = regs-&gt;orig_ax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 系统调用的数量由 NR_syscalls 宏给定，这个判断似乎是检查系统调用号是不是合法的，如果合法则进行接下来的实际内核函数的执行，并且把返回结果保存到ax中 */</span></span><br><span class="line">    <span class="comment">/* 似乎这里的 regs-&gt;ax 指的是eax（32bit）或者rax（64bit）的统称，而不是x86中16bit的ax寄存器 */</span></span><br><span class="line">    <span class="keyword">if</span> (nr &lt; IA32_NR_syscalls)</span><br><span class="line">        regs-&gt;ax = ia32_sys_call_table[nr](regs-&gt;bx, regs-&gt;cx,</span><br><span class="line">                                           regs-&gt;dx, regs-&gt;si,</span><br><span class="line">                                           regs-&gt;di, regs-&gt;bp);</span><br><span class="line">    syscall_return_slowpath(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面参考自：<a href="https://blog.csdn.net/hq815601489/article/details/80009791" target="_blank" rel="noopener">https://blog.csdn.net/hq815601489/article/details/80009791</a></p></blockquote><p>Linux提供了200多个系统调用，通过汇编指令 <code>int 0x80</code> 实现，用系统调用号来区分入口函数。</p><p><strong>Linux实现系统调用的基本过程</strong>是：</p><ul><li><p>应用程序准备参数，发出调用请求；</p></li><li><p>C库封装函数引导。该函数在Linux提供的标准C库，即 glibc 中。对应的封装函数由下列汇编指令实现（以读函数调用为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; NASM</span><br><span class="line">; read(int fd, void *buffer, size_t nbytes)</span><br><span class="line">mov eax, 3          ; read系统调用号为3</span><br><span class="line">mov ebx, fd</span><br><span class="line">mov ecx, buffer</span><br><span class="line">mov edx, nbytes</span><br><span class="line">int 0x80            ; 触发系统调用</span><br></pre></td></tr></table></figure></li><li><p>执行系统调用。前两步在用户态工作，陷入后在内核态工作。系统调用处理程序根据系统调用号，<strong>按系统调用表中的偏移地址跳转，调用对应的内核函数</strong>；</p></li><li><p>系统调用完成相应功能，将<strong>返回值存入 eax</strong> ，返回到中断处理函数；</p></li><li><p>系统调用返回。内核函数处理完毕后，库函数读寄存器（ eax ）返回值，并返回给应用程序。恢复现场。</p></li></ul><p><strong>应用程序调用系统调用的过程</strong>是：</p><ul><li><p>把系统调用号存入 eax ；</p></li><li><p>把函数参数存入其它通用寄存器（约定顺序为 ebx 、 ecx 、 edx 、 esi 、 edi ，<u>更多的参数（通常不会出现这种情况）使用堆栈传递</u>，也可以<u>通过寄存器存放指向参数在用户空间的地址指针来传递</u>）；</p></li><li><p>触发 0x80 号中断（ int 0x80 ）。</p></li><li><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; NASM</span><br><span class="line">; 向显示器输出hello, world</span><br><span class="line">; write(int fd, const void *buffer, size_t nbytes)</span><br><span class="line">; exit(int status)</span><br><span class="line">        global  _start</span><br><span class="line">        section .text</span><br><span class="line">_start:</span><br><span class="line">        mov     eax, 4              ; write系统调用号为4</span><br><span class="line">        mov     ebx, 1              ; 文件描述符1：标准输出stdout</span><br><span class="line">        mov     ecx, message        ; 要输出的信息</span><br><span class="line">        mov     edx, message.len    ; 要输出的长度</span><br><span class="line">        int     0x80</span><br><span class="line"></span><br><span class="line">        mov     eax, 1              ; exit系统调用号为1</span><br><span class="line">        mov     ebx, 0              ; 状态码0：正常退出</span><br><span class="line">        int     0x80</span><br><span class="line"></span><br><span class="line">        section .data</span><br><span class="line">message:</span><br><span class="line">        db      &quot;hello, world&quot;, 10</span><br><span class="line">.len    equ     $ - message</span><br></pre></td></tr></table></figure></li></ul><p><strong>Linux系统调用实现机制</strong>：</p><ul><li><p>系统调用初始化</p><p>系统调用处理程序 <code>system_call()</code> 的入口地址放在系统的<strong>中断表述符表IDT（Interrupt Descriptor Table）</strong>中，Linux系统初始化时，由 <code>trap_init()</code> 将其填写完整，其设置系统调用处理程序的语句为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_system_gate(<span class="number">0x80</span>, &amp;system_call)</span><br></pre></td></tr></table></figure><p>经过初始化以后，每当执行 <code>int 0x80</code> 指令时，产生一个异常<strong>使系统陷入内核空间并执行128号异常处理程序</strong>，即系统调用处理程序 <code>system_call()</code> </p></li><li><p>系统调用公共入口</p><p><code>system_call()</code> 是所有系统调用的公共入口，其功能是保护现场，<strong>进行正确性检查，根据系统调用号跳转到具体的内核函数</strong>。内核函数执行完毕时需调用<code>ret_from_sys_call()</code>，这时完成返回用户空间前的最后检查，用<code>RESTORE_ALL</code>宏恢复现场并执行<code>iret</code>指令返回用户断点</p></li><li><p>保护现场</p><ul><li>硬件（CPU）保护：<code>ss</code> 、 <code>esp</code> 、 <code>eflags</code> 、 <code>cs</code> 、 <code>eip</code> ，压入核心栈</li><li>软件（操作系统）保护<ul><li>使用 <code>SAVE_ALL</code> 宏将寄存器压入堆栈，加载内核的 <code>ds</code> 和 <code>es</code> ，往 <code>edx</code> 中放入 <code>$(_KERNEL_DS)</code> 以指明使用内核数据段，把内核数据段选择符装入 <code>ds</code> 和 <code>es</code> 。注意：该宏压入寄存器的顺序<strong>不是随意的</strong>，而是和系统调用的参数传递密切相关</li><li><code>es</code> 、 <code>ds</code> 、 <code>eax</code> 、 <code>ebp</code> 、 <code>edi</code> 、 <code>esi</code> 、 <code>edx</code> 、 <code>ecx</code> 、 <code>ebx</code> ，压入核心栈</li></ul></li></ul><p>系统调用处理时的核心栈内容：</p><table><thead><tr><th align="center"></th><th align="center">寄存器</th></tr></thead><tbody><tr><td align="center">硬件完成</td><td align="center">ss</td></tr><tr><td align="center">硬件完成</td><td align="center">esp</td></tr><tr><td align="center">硬件完成</td><td align="center">eflags</td></tr><tr><td align="center">硬件完成</td><td align="center">cs</td></tr><tr><td align="center">硬件完成</td><td align="center">eip</td></tr><tr><td align="center">软件完成</td><td align="center">es</td></tr><tr><td align="center">软件完成</td><td align="center">ds</td></tr><tr><td align="center">软件完成</td><td align="center">eax</td></tr><tr><td align="center">软件完成</td><td align="center">ebp</td></tr><tr><td align="center">软件完成</td><td align="center">edi</td></tr><tr><td align="center">软件完成</td><td align="center">esi</td></tr><tr><td align="center">软件完成</td><td align="center">edx</td></tr><tr><td align="center">软件完成</td><td align="center">ecx</td></tr><tr><td align="center">软件完成</td><td align="center">ebx</td></tr></tbody></table></li><li><p>返回值传递</p><p>当内核函数返回到 <code>system_call()</code> 时， <code>eax</code> 中存放着内核函数的返回值。要将这个返回值传递给应用程序，内核先将 <code>eax</code> 放入原先 <code>SAVE_ALL</code> 宏保存 <code>eax</code> 的位置，这样当 <code>system_call()</code> 调用 <code>RESTORE_ALL</code> 恢复寄存器时， <code>eax</code> 便被恢复成系统调用的返回值，完成了返回值从内核空间到用户空间的传递</p></li></ul><p><strong>系统调用号和系统调用表</strong></p><p>系统调用的数量由 <code>NR_syscalls</code> 宏给定，每个系统调用所对应的编号已预先在系统文件中定义，且都用一个宏表示，其定义有如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_exit 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_fork 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_read 3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Linux的系统调用号和内核函数映射关系的系统调用表也被预先定义在系统文件中，具有如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">ENTRY(sys_call_table)</span><br><span class="line">    .long SYMBOL_NAME(sys_ni_syscall)    /* 空项 */</span><br><span class="line">    .long SYMBOL_NAME(sys_exit)</span><br><span class="line">    .long SYMBOL_NAME(sys_fork)</span><br><span class="line">    .long SYMBOL_NAME(sys_read)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>内核函数入口地址为： <code>eax * 4 + sys_call_table</code></p><blockquote><p>上面参考自：<a href="https://blog.csdn.net/hq815601489/article/details/80009791" target="_blank" rel="noopener">https://blog.csdn.net/hq815601489/article/details/80009791</a></p></blockquote><p>概括来说，系统调用过程中会发生如下的事情：</p><ul><li>The application is setting up the system call number and parameters and it issues a trap instruction</li><li>The execution mode switches from user to kernel; the CPU switches to a kernel stack; the user stack and the return address to user space is saved on the kernel stack</li><li>The kernel entry point saves registers on the kernel stack</li><li><strong>The system call dispatcher</strong> identifies the system call function and runs it</li><li>The user space registers are restored and execution is switched back to user (e.g. calling IRET)</li><li>The user space application resumes</li></ul><h3 id="系统调用表"><a href="#系统调用表" class="headerlink" title="系统调用表"></a>系统调用表</h3><p>系统调用调度器通过系统调用表来将系统调用号映射到内核函数（系统调用服务例程）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SYSCALL_I386(nr, sym, qual) [nr] = sym,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">sys_call_ptr_t</span> ia32_sys_call_table[] = &#123;</span><br><span class="line">  [<span class="number">0</span> ... __NR_syscall_compat_max] = &amp;sys_ni_syscall,</span><br><span class="line">  #include &lt;<span class="keyword">asm</span>/syscalls_32.h&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__SYSCALL_I386(<span class="number">0</span>, sys_restart_syscall, )</span><br><span class="line">__SYSCALL_I386(<span class="number">1</span>, sys_exit, )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">__SYSCALL_I386(<span class="number">2</span>, sys_fork, )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">__SYSCALL_I386(<span class="number">2</span>, sys_fork, )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__SYSCALL_I386(<span class="number">3</span>, sys_read, )</span><br><span class="line">__SYSCALL_I386(<span class="number">4</span>, sys_write, )</span><br></pre></td></tr></table></figure><h3 id="系统调用参数处理"><a href="#系统调用参数处理" class="headerlink" title="系统调用参数处理"></a>系统调用参数处理</h3><p>因为系统调用的参数是由用户空间设置的，内核不能保证参数的正确性，因此必须每次都对参数进行验证。指针参数有以下特殊情况是必须要检验的：</p><ul><li>不允许指针指向内核空间</li><li>检测指针是否有效</li></ul><p>因为<strong>系统调用是在内核态执行的，它们有访问内核空间的权限</strong>，因此如果没有对指针进行合适的检测，那么就会使得用户应用程序拥有读或者写内核空间的权限（甚至不正确的写内核空间会破坏内核内存）。</p><p>类似的，如果用户程序传递的指针是无效的（例如一个写指针指向一个只读的内存区域），它也会导致内核崩溃。</p><p>有以下两种方法来解决以上问题：</p><ul><li>在使用指针之前，先对照用户地址空间检查指针</li><li>避免检查指针，依靠MMU来检测指针何时无效，并使用页错误处理程序确定指针无效</li></ul><p><em>（原文中还有些比较高级的内容，这里不再列出，毕竟涉及的知识比较高深，参见：<a href="https://linux-kernel-labs.github.io/master/lectures/syscalls.html）" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/lectures/syscalls.html）</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;程序接口与系统调用&quot;&gt;&lt;a href=&quot;#程序接口与系统调用&quot; class=&quot;headerlink&quot; title=&quot;程序接口与系统调用&quot;&gt;&lt;/a&gt;程序接口与系统调用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="系统调用" scheme="http://QQ876684433.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-10-15）</title>
    <link href="http://QQ876684433.github.io/2019/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-10-15%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/15/数据库课堂笔记（2019-10-15）/</id>
    <published>2019-10-15T03:25:09.000Z</published>
    <updated>2019-10-22T06:15:38.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-10-15）"><a href="#数据库课堂笔记（2019-10-15）" class="headerlink" title="数据库课堂笔记（2019-10-15）"></a>数据库课堂笔记（2019-10-15）</h2><h3 id="Ch4-Object-Relational-SQL-Oracle"><a href="#Ch4-Object-Relational-SQL-Oracle" class="headerlink" title="Ch4. Object-Relational SQL (Oracle)"></a>Ch4. Object-Relational SQL (Oracle)</h3><p>对象关系型数据表相关例子如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/15/cVmO6Xky84isWf5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/15/ZhLsu87Y6iJI4Bn.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="Object-Types（对象类型）"><a href="#Object-Types（对象类型）" class="headerlink" title="Object Types（对象类型）"></a>Object Types（对象类型）</h4><h5 id="定义新的数据类型"><a href="#定义新的数据类型" class="headerlink" title="定义新的数据类型"></a>定义新的数据类型</h5><p>对象类型的创建和删除语法（CREATE TYPE … AS OBJECT）如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> typename <span class="keyword">AS</span> <span class="keyword">OBJECT</span></span><br><span class="line">(attrname datatype, ......);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TYPE</span> typename;</span><br></pre></td></tr></table></figure><blockquote><p>这些数据类型一经定义， 便以持久形式保存在数据库系统中， 用户可以<strong>像使用系统内置的数据类型</strong>一样使用这些复杂的数据类型， 以此来扩充系统的数据类型</p></blockquote><p>创建对象类型的语法跟创建表的语法差不多，只不过对象类型的定义中没有约束条件的定义（constraint define），创建一个person_t的类型如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> person_t <span class="keyword">AS</span> <span class="keyword">OBJECT</span></span><br><span class="line">(</span><br><span class="line">    ssno <span class="built_in">int</span>,</span><br><span class="line">    pname name_t,</span><br><span class="line">    age <span class="built_in">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="对象类型的使用"><a href="#对象类型的使用" class="headerlink" title="对象类型的使用"></a>对象类型的使用</h5><p>自定义的对象类型可以有以下用法：</p><ul><li><p>使用所创建的对象类型来创建新类型</p><p>用于定义<strong>新类型中的属性</strong> (类型的嵌套定义)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> person_t <span class="keyword">AS</span> <span class="keyword">OBJECT</span></span><br><span class="line">(</span><br><span class="line">    ssno <span class="built_in">int</span>,</span><br><span class="line">    pname name_t,</span><br><span class="line">    age <span class="built_in">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中name_t就是一个对象类型</p></li><li><p>使用所创建的对象类型来创建新的表<br>用于定义<strong>表中的属性</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> teachers (</span><br><span class="line">    tid <span class="built_in">int</span>,</span><br><span class="line">    tname name_t,</span><br><span class="line">    room <span class="built_in">int</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中name_t就是一个对象类型</p></li><li><p>使用对象数据类型来直接创建一张表</p><ul><li><p>新创建的‘表’ 的结构与对象类型的结构相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename <span class="keyword">OF</span> typename</span><br><span class="line">&#123; ( <span class="keyword">constraint</span>-<span class="keyword">define</span> ) &#125; ;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>可以在创建的‘表’ 中<strong>增加完整性约束定义</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> people <span class="keyword">OF</span> person_t</span><br><span class="line">(</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>( ssno )</span><br><span class="line">) ;</span><br></pre></td></tr></table></figure></li></ul><h5 id="对象值的创建、-查询与更新"><a href="#对象值的创建、-查询与更新" class="headerlink" title="对象值的创建、 查询与更新"></a>对象值的创建、 查询与更新</h5><p>两个重要的函数：</p><ul><li><p>对象构造函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typename ( argument, …… )</span><br></pre></td></tr></table></figure><p>例如：<code>name_t ( ‘Einstein’, ‘Albert’, ‘E’ )</code>，就跟普通关系型数据表的行的创建一样</p></li><li><p><strong>返回对象取值</strong>的函数</p><blockquote><p>Ø <strong>Even though the primary table is object table, still it displays the rows in general format.</strong></p><p>Ø <strong>To display the entire structure of the object, this will be used.</strong></p><p>reference：<a href="http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html" target="_blank" rel="noopener">http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html</a></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value ( … )</span><br></pre></td></tr></table></figure><p>尽管oracle是对象关系型数据库，但是在直接查询一个对象关系表的时候，<strong>表中数据的类型是不会被返回的</strong>，因此需要使用value(…)函数来将表中属性类型返回回来</p><blockquote><p>Even though the vendors table is object table it will not show the adt along with data, to see the data along with the adt</p><p><strong>SQL&gt;Select * from vendors;</strong></p><p>This will give the data without adt.</p><p><strong>SQL&gt;Select value(v) from vendors v;</strong></p><p>This will give the columns data along wih the type.</p><p>reference：<a href="http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html" target="_blank" rel="noopener">http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html</a></p></blockquote></li></ul><p>对象值的创建（使用对象构造函数）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/15/EPDKns1egr9OCTY.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>对象值的查询（使用连续的点运算符）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/15/fUepAr6OEWgXkFL.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>对象值的更新：</p><ul><li><p>修改整个对象值</p><p>可以用对象值直接给对象属性进行赋值（即直接使用对象构造函数构造的新对象值替换表中的对象属性值），例如：</p><p><img src="https://i.loli.net/2019/10/15/8JBQ6jSWw1ehUpH.png" alt></p><p>如果某张表是基于“对象类型”创建的，那么可以<strong>用“对象”值直接修改整个元组</strong></p><p><img src="https://i.loli.net/2019/10/15/zAnDOIjicFoG1wK.png" alt></p></li><li><p>修改对象中成员属性的值</p><p>使用点运算符修改对象类型的某个属性值，例如：</p><p><img src="https://i.loli.net/2019/10/15/JN4XUpO1E6GwadZ.png" alt></p></li></ul><h5 id="对象的引用类型"><a href="#对象的引用类型" class="headerlink" title="对象的引用类型"></a>对象的引用类型</h5><p>可以通过以下语句创建对象的引用类型：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REF &lt;object type&gt;</span><br></pre></td></tr></table></figure><ul><li>创建的是指向某个元组对象的指针类型</li><li>引用类型可以用来实现对象类型之间的嵌套引用</li></ul><p>在使用含有REF类型的对象类型(Object Type)来创建关系表时， <strong>必须使用Scope for子句来限制REF属性的取值范</strong>围。</p><p>定义<strong>类型之间的引用关系</strong>的基本方法：</p><p>​    假设当前已经定义了三个对象类型customer_t, agents_t, products_t，那么可以通过如下方式来定义<strong>类型之间的引用关系</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create type order_t as object (</span><br><span class="line">    ordno int,</span><br><span class="line">    month char(3),</span><br><span class="line">    cid char(4),</span><br><span class="line">    aid char(3),</span><br><span class="line">    pid char(3),</span><br><span class="line">    qty int,</span><br><span class="line">    dollars double precision,</span><br><span class="line">    ordcust ref customer_t,</span><br><span class="line">    ordagent ref agent_t,</span><br><span class="line">    ordprod ref product_t</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>最后三行新增三个REF属性， 分别引用（指向） 三个不同的元组对象（Row Object）</p><p>创建<strong>含有引用类型的关系表</strong>的基本方法：</p><ul><li><p>先使用基本对象类型创建相应的基本关系表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customers <span class="keyword">of</span> customer_t</span><br><span class="line">(primary <span class="keyword">key</span> (cid));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> products <span class="keyword">of</span> product_t</span><br><span class="line">(primary <span class="keyword">key</span> (pid));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> agents <span class="keyword">of</span> agent_t</span><br><span class="line">(primary <span class="keyword">key</span> (aid));</span><br></pre></td></tr></table></figure></li><li><p>再使用含有REF属性的引用类型创建对应的关系表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> orders <span class="keyword">of</span> order_t (</span><br><span class="line">    primary <span class="keyword">key</span> (ordno),</span><br><span class="line">    <span class="keyword">scope</span> <span class="keyword">for</span> (ordcust) <span class="keyword">is</span> customers,</span><br><span class="line">    <span class="keyword">scope</span> <span class="keyword">for</span> (ordagent) <span class="keyword">is</span> agents,</span><br><span class="line">    <span class="keyword">scope</span> <span class="keyword">for</span> (ordprod) <span class="keyword">is</span> products</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中<code>scope for</code>是用来限制REF属性的取值范围的，在创建关系表时如果表中含有引用类型，那么必须使用<code>scope for</code>来指定属性要引用的对象</p></li></ul><p>根据元组之间的REF引用关系进行查询和普通的查询是一样的，都可以使用点运算符，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> o.ordcust.cname,</span><br><span class="line">o.ordagent.aname</span><br><span class="line"><span class="keyword">from</span> orders o</span><br></pre></td></tr></table></figure><p>其中ordcust和ordagent都是引用类型</p><p>引用类型两个函数和两个谓词：</p><p>两个函数</p><ul><li><p>获取对象(元组)的引用指针: REF(……)</p><blockquote><p>Ø <strong>The ref function allows referencing of existing row objects.</strong></p><p>Ø <strong>Each of the row objects has an object id value assigned to it.</strong></p><p>Ø <strong>The object id assigned can be seen by using ref function.</strong></p><p>reference：<a href="http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html" target="_blank" rel="noopener">http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html</a></p></blockquote><p>从上面可以看出，ref实际返回的是引用对象的id，因此如果需要查询并查看引用对象的内容，需要使用下面要介绍的deref。可以用来判断一个引用类型的引用对象是不是给定的对象，例如：</p><p><img src="https://i.loli.net/2019/10/15/OPnxQpyh635CqWk.png" alt></p></li><li><p>返回引用指针所指向对象的值: DEREF(……)</p><blockquote><p>Ø <strong>The deref function performs opposite action.</strong></p><p>Ø <strong>It takes a reference value of object id and returns the value of the row objects.</strong></p><p>reference：<a href="http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html" target="_blank" rel="noopener">http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html</a></p></blockquote><p>它用来检索整个被引用对象， 而不是仅仅获得该对象的引用指针，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">value</span> ( p ), deref ( p.partner )</span><br><span class="line"><span class="keyword">from</span> police_officers p</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">type</span> police_officer_t <span class="keyword">as</span> <span class="keyword">object</span> (</span><br><span class="line">    pol_person person_t,</span><br><span class="line">    badge_number <span class="built_in">integer</span>,</span><br><span class="line">    partner <span class="keyword">ref</span> police_officer_t </span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>两个判定谓词：</p><ul><li><p>IS DANGLING</p><ul><li>用于判断所引用的元组对象是否存在</li><li>如果<strong>所引用的元组对象不存在， 那么该谓词返回逻辑真(TRUE)</strong>， 否则返回逻辑假(FALSE)</li><li>该谓词主要用于检查那些错误的对象引用指针</li></ul><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> o.cid <span class="keyword">from</span> orders o</span><br><span class="line"><span class="keyword">where</span> o.ordcust <span class="keyword">IS</span> DANGLING;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> o.cid <span class="keyword">from</span> orders o</span><br><span class="line"><span class="keyword">where</span> o.ordcust &lt;&gt;</span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">ref</span>(c) <span class="keyword">from</span> customers c</span><br><span class="line">    <span class="keyword">where</span> c.cid = o.cid)</span><br></pre></td></tr></table></figure><p>即可以用来检索cid和引用的对象是否一致</p></li><li><p>IS NULL</p><ul><li>可以使用 IS NULL 谓词来查找取值为空(NULL) 的 <strong>REF 属性</strong>，但是‘is dangling’不等于‘is null’</li><li>对象引用指针的使用规则<ul><li>A dangling REF is non-null but useless</li><li>If o.ordcust is null or dangling, then o.ordcust.cname is null</li></ul></li></ul></li></ul><blockquote><p>A null pointer just means the pointer isn’t pointing to anything, or in some languages means it is unknown what it is pointing at. But because it is a null pointer, you know this, the code knows this, so no problem. A dangling pointer is one that you think is pointing at something but in reality is no longer there, hence the pointer is actually inaccurate but doesn’t know it.</p><p>reference：<a href="https://stackoverflow.com/questions/12714199/null-pointer-vs-dangling-pointer" target="_blank" rel="noopener">https://stackoverflow.com/questions/12714199/null-pointer-vs-dangling-pointer</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>从头到尾彻底理解KMP/BM/Sunday算法</title>
    <link href="http://QQ876684433.github.io/2019/10/07/%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3KMP-BM-Sunday%E7%AE%97%E6%B3%95/"/>
    <id>http://QQ876684433.github.io/2019/10/07/从头到尾彻底理解KMP-BM-Sunday算法/</id>
    <published>2019-10-07T15:54:05.000Z</published>
    <updated>2019-10-08T03:43:51.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【转载】从头到尾彻底理解KMP-BM-Sunday算法"><a href="#【转载】从头到尾彻底理解KMP-BM-Sunday算法" class="headerlink" title="【转载】从头到尾彻底理解KMP/BM/Sunday算法"></a>【转载】从头到尾彻底理解KMP/BM/Sunday算法</h1><h2 id="暴力匹配算法"><a href="#暴力匹配算法" class="headerlink" title="暴力匹配算法"></a>暴力匹配算法</h2><pre><code>假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：</code></pre><p>如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；<br>如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。<br>    理清楚了暴力匹配算法的流程及内在的逻辑，咱们可以写出暴力匹配的代码，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ViolentMatch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == p[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++    </span></span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0    </span></span><br><span class="line">i = i - j + <span class="number">1</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匹配成功，返回模式串p在文本串s中的位置，否则返回-1</span></span><br><span class="line"><span class="keyword">if</span> (j == pLen)</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>举个例子，如果给定文本串S“BBC ABCDAB ABCDABCDABDE”，和模式串P“ABCDABD”，现在要拿模式串P去跟文本串S匹配，整个过程如下所示：1. S[0]为B，P[0]为A，不匹配，执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[1]跟P[0]匹配，相当于模式串要往右移动一位（i=1，j=0）   ![](https://img-blog.csdn.net/20140723224710203)    2. S[1]跟P[0]还是不匹配，继续执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[2]跟P[0]匹配（i=2，j=0），从而模式串不断的向右移动一位（不断的执行“令i = i - (j - 1)，j = 0”，i从2变到4，j一直为0）</code></pre><p> <img src="https://img-blog.csdn.net/20140726213551553" alt></p><pre><code>3. 直到S[4]跟P[0]匹配成功（i=4，j=0），此时按照上面的暴力匹配算法的思路，转而执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，可得S[i]为S[5]，P[j]为P[1]，即接下来S[5]跟P[1]匹配（i=5，j=1）</code></pre><p> <img src="https://img-blog.csdn.net/20140726213602848" alt></p><pre><code>4. S[5]跟P[1]匹配成功，继续执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，得到S[6]跟P[2]匹配（i=6，j=2），如此进行下去</code></pre><p> <img src="https://img-blog.csdn.net/20140726213343578" alt></p><pre><code>5. 直到S[10]为空格字符，P[6]为字符D（i=10，j=6），因为不匹配，重新执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，相当于S[5]跟P[0]匹配（i=5，j=0）</code></pre><p> <img src="https://img-blog.csdn.net/20140726213353687" alt></p><pre><code>6. 至此，我们可以看到，如果按照暴力匹配算法的思路，尽管之前文本串和模式串已经分别匹配到了S[9]、P[5]，但因为S[10]跟P[6]不匹配，所以文本串回溯到S[5]，模式串回溯到P[0]，从而让S[5]跟P[0]匹配。</code></pre><p> <img src="https://img-blog.csdn.net/20140726213631208" alt></p><pre><code>而S[5]肯定跟P[0]失配。为什么呢？因为在之前第4步匹配中，我们已经得知S[5] = P[1] = B，而P[0] = A，即P[1] != P[0]，故S[5]必定不等于P[0]，所以回溯过去必然会导致失配。那有没有一种算法，让i 不往回退，只需要移动j 即可呢？答案是肯定的。这种算法就是本文的主旨KMP算法，它利用之前已经部分匹配这个有效信息，保持i 不回溯，通过修改j 的位置，让模式串尽量地移动到有效的位置。</code></pre><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre><code>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。下面先直接给出KMP的算法流程（如果感到一点点不适，没关系，坚持下，稍后会有具体步骤及解释，越往后看越会柳暗花明☺）：</code></pre><ul><li><p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p><ul><li><p>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</p></li><li><p>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。</p><ul><li>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文的3.3.3节中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。</li></ul><p>很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀后缀。</p><p>此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。</p><p>转换成代码表示，则是：</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    </span></span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span></span><br><span class="line"><span class="comment">//next[j]即为j所对应的next值      </span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == pLen)</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>继续拿之前的例子来说，当S[10]跟P[6]匹配失败时，KMP不是跟暴力匹配那样简单的把模式串右移一位，而是执行第②条指令：“如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]”，即j 从6变到2（后面我们将求得P[6]，即字符D对应的next 值为2），所以相当于模式串向右移动的位数为j - next[j]（j - next[j] = 6-2 = 4）。</code></pre>{% image https://img-blog.csdn.net/20140726213353687 '' '' %} <pre><code>向右移动4位后，S[10]跟P[2]继续匹配。为什么要向右移动4位呢，因为移动4位后，模式串中又有个“AB”可以继续跟S[8]S[9]对应着，从而不用让i 回溯。相当于在除去字符D的模式串子串中寻找相同的前缀和后缀，然后根据前缀后缀求出next 数组，最后基于next 数组进行匹配（不关心next 数组是怎么求来的，只想看匹配过程是咋样的，可直接跳到下文3.3.4节）。</code></pre><p> <img src="https://img-blog.csdn.net/20140721223539765" alt></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li><p>①寻找前缀后缀最长公共元素长度</p><ul><li>对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示：</li></ul><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140819173639786" alt title>                </div>                <div class="image-caption"></div>            </figure><p>比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k + 1 = 2）。</p></blockquote></li><li><p>②求next数组</p><ul><li>next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示：</li></ul><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140819173649739" alt title>                </div>                <div class="image-caption"></div>            </figure><p>比如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1）。</p></blockquote></li><li><p>③根据next数组进行匹配</p><ul><li><p>匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀pj-k pj-k+1, …, pj-1 跟文本串si-k si-k+1, …, si-1匹配成功，但pj 跟si匹配失败时，因为next[j] = k，相当于在不包含pj的模式串中有最大长度为k 的相同前缀后缀，即p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令j = next[j]，从而让模式串右移j - next[j] 位，使得模式串的前缀p0 p1, …, pk-1对应着文本串 si-k si-k+1, …, si-1，而后让pk 跟si 继续匹配。如下图所示：</p><p><img src="https://img-blog.csdn.net/20140812223633281" alt></p><p>综上，KMP的next 数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。如模式串中在j 处的字符跟文本串在i 处的字符匹配失配时，下一步用next [j] 处的字符继续跟文本串i 处的字符匹配，相当于模式串向右移动 j - next[j] 位。</p><p>接下来，分别具体解释上述3个步骤。</p></li></ul></li></ul><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><h4 id="寻找最长前缀后缀"><a href="#寻找最长前缀后缀" class="headerlink" title="寻找最长前缀后缀"></a>寻找最长前缀后缀</h4><pre><code>如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：</code></pre>{% image https://img-blog.csdn.net/20140725231726921 '' '' %}<pre><code>也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（下简称《最大长度表》）：</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140721222801918" alt title>                </div>                <div class="image-caption"></div>            </figure> <h4 id="基于《最大长度表》匹配"><a href="#基于《最大长度表》匹配" class="headerlink" title="基于《最大长度表》匹配"></a>基于《最大长度表》匹配</h4><pre><code>因为模式串中首尾可能会有重复的字符，故可得出下述结论：</code></pre><blockquote><p>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</p></blockquote><p> 下面，咱们就结合之前的《最大长度表》和上述结论，进行字符串的匹配。如果给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示：</p><p> <img src="https://img-blog.csdn.net/20140723224710203" alt></p><ol><li><p>因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第5个字符A匹配成功：</p><p><img src="https://img-blog.csdn.net/20140721223809617" alt></p></li></ol><ol start="2"><li><p>继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为6个（ABCDAB），然后根据《最大长度表》可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论，可知需要向右移动6 - 2 = 4 位。</p><p><img src="https://img-blog.csdn.net/20140721223809617" alt></p></li></ol><ol start="3"><li><p>模式串向右移动4位后，发现C处再度失配，因为此时已经匹配了2个字符（AB），且上一位字符B对应的最大长度值为0，所以向右移动：2 - 0 =2 位。</p><p><img src="https://img-blog.csdn.net/20140721223539765" alt></p></li></ol><ol start="4"><li><p>A与空格失配，向右移动1 位。</p><p><img src="https://img-blog.csdn.net/20140721223823548" alt></p></li></ol><ol start="5"><li><p>继续比较，发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B对应的最大长度2，即向右移动6 - 2 = 4 位。</p><p><img src="https://img-blog.csdn.net/20140721223558140" alt></p></li></ol><ol start="6"><li><p>经历第5步后，发现匹配成功，过程结束。</p><p><img src="https://img-blog.csdn.net/20140721223611515" alt></p></li></ol><pre><code>通过上述匹配过程可以看出，问题的关键就是寻找模式串中最大长度的相同前缀和后缀，找到了模式串中每个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。而这个最大长度便正是next 数组要表达的含义。</code></pre><h4 id="根据《最大长度表》求next-数组"><a href="#根据《最大长度表》求next-数组" class="headerlink" title="根据《最大长度表》求next 数组"></a>根据《最大长度表》求next 数组</h4><pre><code>由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为：</code></pre><p> <img src="https://img-blog.csdn.net/20140721230517324" alt></p><pre><code>而且，根据这个表可以得出下述结论</code></pre><ul><li><p>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</p><p>  上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。</p><p>  给定字符串“ABCDABD”，可求得它的next 数组如下：</p><p><img src="https://img-blog.csdn.net/20140721230250468" alt></p><p>  把next 数组跟之前求得的最大长度表对比后，不难发现，next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。</p><p>  换言之，对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140728110939595" alt title>                </div>                <div class="image-caption"></div>            </figure></p><p>  根据最大长度表求出了next 数组后，从而有</p></li></ul><blockquote><p>失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</p></blockquote><p>​    而后，你会发现，无论是基于《最大长度表》的匹配，还是基于next 数组的匹配，两者得出来的向右移动的位数是一样的。为什么呢？因为：</p><ul><li><p>根据《最大长度表》，失配时，模式串向右移动的位数 = 已经匹配的字符数 - 失配字符的上一位字符的最大长度值</p></li><li><p>而根据《next 数组》，失配时，模式串向右移动的位数 = 失配字符的位置 - 失配字符对应的next 值</p><ul><li><p>其中，从0开始计数时，失配字符的位置 = 已经匹配的字符数（失配字符不计数），而失配字符对应的next 值 = 失配字符的上一位字符的最大长度值，两相比较，结果必然完全一致。</p><p>所以，你可以把《最大长度表》看做是next 数组的雏形，甚至就把它当做next 数组也是可以的，区别不过是怎么用的问题。</p></li></ul></li></ul><h4 id="通过代码递推计算next-数组"><a href="#通过代码递推计算next-数组" class="headerlink" title="通过代码递推计算next 数组"></a>通过代码递推计算next 数组</h4><pre><code>接下来，咱们来写代码求下next 数组。基于之前的理解，可知计算next 数组的方法可以采用递推：</code></pre><ol><li><p>如果对于值k，已有p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k。</p><ul><li>此意味着什么呢？究其本质，next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀。有了这个next 数组，在KMP匹配中，当模式串中j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动j - next[j] 位。</li></ul><blockquote><p>举个例子，如下图，根据模式串“ABCDABD”的next 数组可知失配位置的字符D对应的next 值为2，代表字符D前有长度为2的相同前缀和后缀（这个相同的前缀后缀即为“AB”），失配后，模式串需要向右移动j - next [j] = 6 - 2 =4位。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140721223809617" alt title>                </div>                <div class="image-caption"></div>            </figure><p>向右移动4位后，模式串中的字符C继续跟文本串匹配。</p></blockquote></li></ol><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140721223539765" alt title>                </div>                <div class="image-caption"></div>            </figure></blockquote><ol start="2"><li>下面的问题是：已知next [0, …, j]，如何求出next [j + 1]呢？<pre><code>对于P的前j+1个序列字符：</code></pre></li></ol><ul><li><p>若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1；</p></li><li><p>若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。 相当于在字符p[j+1]之前不存在长度为k+1的前缀”p0 p1, …, pk-1 pk”跟后缀“pj-k pj-k+1, …, pj-1 pj”相等，那么是否可能存在另一个值t+1 &lt; k+1，使得长度更小的前缀 “p0 p1, …, pt-1 pt” 等于长度更小的后缀 “pj-t pj-t+1, …, pj-1 pj” 呢？如果存在，那么这个t+1 便是next[ j+1]的值，此相当于利用已经求得的next 数组（next [0, …, k, …, j]）进行P串前缀跟P串后缀的匹配。</p><p> 一般的文章或教材可能就此一笔带过，但大部分的初学者可能还是不能很好的理解上述求解next 数组的原理，故接下来，我再来着重说明下。</p><p>  如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。</p></li></ul>{% image https://img-blog.csdn.net/20140729182154066 '' '' %}<pre><code>但如果pk != pj 呢？说明“p0 pk-1 pk”  ≠ “pj-k pj-1 pj”。换言之，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140729181940812" alt title>                </div>                <div class="image-caption"></div>            </figure><pre><code>结合上图来讲，若能在前缀“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk&apos;-1 pk&apos; = pj-k&apos; pj-1 pj，则最大相同的前缀后缀长度为k&apos; + 1，从而next [j + 1] = k’ + 1 = next [k&apos; ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] = 0。那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？这又归根到next数组的含义。我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。此过程相当于模式串的自我匹配，所以不断的递归k = next[k]，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。如下图所示：</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20150812214857858" alt title>                </div>                <div class="image-caption"></div>            </figure>    <blockquote><p>引用下一读者wudehua55555于本文评论下留言，以辅助大家从另一个角度理解：“ 一直以为博主在用递归求next数组时没讲清楚，为何要用k = next[k],仔细看了这个红黄蓝分区图才突然恍然大悟，就是找到p[k]对应的next[k]，根据对称性，只需再判断p[next[k]]与p[j]是否相等即可，于是令k = next[k],这里恰好就使用了递归的思路。其实我觉得不要一开始就陷入递归的方法中，换一种思路，直接从考虑对称性入手，可直接得出k = next[k]，而这正好是递归罢了。以上是一些个人看法，非常感谢博主提供的解析，非计算机的学生也能看懂，虽然从昨晚9点看到了现在。高兴。”</p></blockquote><pre><code>所以，因最终在前缀ABC中没有找到D，故E的next 值为0：</code></pre><blockquote><p>模式串的后缀：ABDE</p></blockquote><blockquote><p>模式串的前缀：ABC</p></blockquote><blockquote><p>前缀右移两位：     ABC</p></blockquote><pre><code>读到此，有的读者可能又有疑问了，那能否举一个能在前缀中找到字符D的例子呢？OK，咱们便来看一个能在前缀中找到字符D的例子，如下图所示：</code></pre><p> <img src="https://img-blog.csdn.net/20140809163257703" alt></p><pre><code>给定模式串DABCDABDE，我们很顺利的求得字符D之前的“DABCDAB”的各个子串的最长相同前缀后缀的长度分别为0 0 0 0 1 2 3，但当遍历到字符D，要求包括D在内的“DABCDABD”最长相同前缀后缀时，我们发现pj处的字符D跟pk处的字符C不一样，换言之，前缀DABC的最后一个字符C 跟后缀DABD的最后一个字符D不相同，所以不存在长度为4的相同前缀后缀。怎么办呢？既然没有长度为4的相同前缀后缀，咱们可以寻找长度短点的相同前缀后缀，最终，因在p0处发现也有个字符D，p0 = pj，所以p[j]对应的长度值为1，相当于E对应的next 值为1（即字符E之前的字符串“DABCDABD”中有长度为1的相同前缀和后缀）。综上，可以通过递推求得next 数组，代码如下所示：</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span>* p,<span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) </span><br><span class="line">&#123;</span><br><span class="line">++k;</span><br><span class="line">++j;</span><br><span class="line">next[j] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>用代码重新计算下“ABCDABD”的next 数组，以验证之前通过“最长相同前缀后缀长度值右移一位，然后初值赋为-1”得到的next 数组是否正确，计算结果如下表格所示：</code></pre>{% image https://img-blog.csdn.net/20140812004705968 '' '' %} <pre><code>从上述表格可以看出，无论是之前通过“最长相同前缀后缀长度值右移一位，然后初值赋为-1”得到的next 数组，还是之后通过代码递推计算求得的next 数组，结果是完全一致的。</code></pre><h4 id="基于《next-数组》匹配"><a href="#基于《next-数组》匹配" class="headerlink" title="基于《next 数组》匹配"></a>基于《next 数组》匹配</h4><pre><code>下面，我们来基于next 数组进行匹配。</code></pre>{% image https://img-blog.csdn.net/20140721231622000 '' '' %}<pre><code>还是给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示：</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140723224710203" alt title>                </div>                <div class="image-caption"></div>            </figure><pre><code>在正式匹配之前，让我们来再次回顾下上文2.1节所述的KMP算法的匹配流程：</code></pre><ul><li><p>“假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p><ul><li>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</li><li>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。<ul><li>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。”</li></ul></li></ul></li><li><p>最开始匹配时</p><ul><li><p>P[0]跟S[0]匹配失败</p><ul><li>所以执行“如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]”，所以j = -1，故转而执行“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++”，得到i = 1，j = 0，即P[0]继续跟S[1]匹配。</li></ul></li><li><p>P[0]跟S[1]又失配，j再次等于-1，i、j继续自增，从而P[0]跟S[2]匹配。</p></li><li><p>P[0]跟S[2]失配后，P[0]又跟S[3]匹配。</p></li><li><p>P[0]跟S[3]再失配，直到P[0]跟S[4]匹配成功，开始执行此条指令的后半段：“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++”。</p><p><img src="https://img-blog.csdn.net/20140726213602848" alt></p></li></ul></li><li><p>P[1]跟S[5]匹配成功，P[2]跟S[6]也匹配成功, …，直到当匹配到P[6]处的字符D时失配（即S[10] != P[6]），由于P[6]处的D对应的next 值为2，所以下一步用P[2]处的字符C继续跟S[10]匹配，相当于向右移动：j - next[j] = 6 - 2 =4 位。</p><p><img src="https://img-blog.csdn.net/20140721223809617" alt></p></li><li><p>向右移动4位后，P[2]处的C再次失配，由于C对应的next值为0，所以下一步用P[0]处的字符继续跟S[10]匹配，相当于向右移动：j - next[j] = 2 - 0 = 2 位。</p><p><img src="https://img-blog.csdn.net/20140721223539765" alt></p></li><li><p>移动两位之后，A 跟空格不匹配，模式串后移1 位。</p><p><img src="https://img-blog.csdn.net/20140721223823548" alt></p></li><li><p>P[6]处的D再次失配，因为P[6]对应的next值为2，故下一步用P[2]继续跟文本串匹配，相当于模式串向右移动 j - next[j] = 6 - 2 = 4 位。</p><p><img src="https://img-blog.csdn.net/20140721223558140" alt></p></li><li><p>匹配成功，过程结束。</p><p><img src="https://img-blog.csdn.net/20140721223611515" alt></p></li></ul><pre><code>匹配过程一模一样。也从侧面佐证了，next 数组确实是只要将各个最大前缀后缀的公共元素的长度值右移一位，且把初值赋为-1 即可。</code></pre><h4 id="基于《最大长度表》与基于《next-数组》等价"><a href="#基于《最大长度表》与基于《next-数组》等价" class="headerlink" title="基于《最大长度表》与基于《next 数组》等价"></a>基于《最大长度表》与基于《next 数组》等价</h4><pre><code>我们已经知道，利用next 数组进行匹配失配时，模式串向右移动 j - next [ j ] 位，等价于已匹配字符数 - 失配字符的上一位字符所对应的最大长度值。原因是：</code></pre><ol><li><p>j 从0开始计数，那么当数到失配字符时，j 的数值就是已匹配的字符数；</p></li><li><p>由于next 数组是由最大长度值表整体向右移动一位（且初值赋为-1）得到的，那么失配字符的上一位字符所对应的最大长度值，即为当前失配字符的next 值。</p><p> 但为何本文不直接利用next 数组进行匹配呢？因为next 数组不好求，而一个字符串的前缀后缀的公共元素的最大长度值很容易求。例如若给定模式串“ababa”，要你快速口算出其next 数组，乍一看，每次求对应字符的next值时，还得把该字符排除之外，然后看该字符之前的字符串中有最大长度为多大的相同前缀后缀，此过程不够直接。而如果让你求其前缀后缀公共元素的最大长度，则很容易直接得出结果：0 0 1 2 3，如下表格所示：</p><p><img src="https://img-blog.csdn.net/20140725232020608" alt></p><p> 然后这5个数字 全部整体右移一位，且初值赋为-1，即得到其next 数组：-1 0 0 1 2。</p></li></ol><h4 id="Next-数组与有限状态自动机"><a href="#Next-数组与有限状态自动机" class="headerlink" title="Next 数组与有限状态自动机"></a>Next 数组与有限状态自动机</h4><pre><code>next 负责把模式串向前移动，且当第j位不匹配的时候，用第next[j]位和主串匹配，就像打了张“表”。此外，next 也可以看作有限状态自动机的状态，在已经读了多少字符的情况下，失配后，前面读的若干个字符是有用的。</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140805003320486" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="Next-数组的优化"><a href="#Next-数组的优化" class="headerlink" title="Next 数组的优化"></a>Next 数组的优化</h4><p>   行文至此，咱们全面了解了暴力匹配的思路、KMP算法的原理、流程、流程之间的内在逻辑联系，以及next 数组的简单求解（《最大长度表》整体右移一位，然后初值赋为-1）和代码求解，最后基于《next 数组》的匹配，看似洋洋洒洒，清晰透彻，但以上忽略了一个小问题。</p><pre><code>比如，如果用之前的next 数组方法求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1（0 0 1 2整体右移一位，初值赋为-1），当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 =2位。</code></pre>{% image http://hi.csdn.net/attachment/201106/14/8394323_1308075859Zfue.jpg '' '' %}<pre><code>右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hi.csdn.net/attachment/201106/14/8394323_13080758591kyV.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><pre><code>问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。所以，咱们得修改下求next 数组的代码。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//优化过后的next 数组求法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNextval</span><span class="params">(<span class="keyword">char</span>* p, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])</span><br><span class="line">&#123;</span><br><span class="line">++j;</span><br><span class="line">++k;</span><br><span class="line"><span class="comment">//较之前next数组求法，改动在下面4行</span></span><br><span class="line"><span class="keyword">if</span> (p[j] != p[k])</span><br><span class="line">next[j] = k;   <span class="comment">//之前只有这一行</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]]</span></span><br><span class="line">next[j] = next[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>利用优化过后的next 数组求法，可知模式串“abab”的新next数组为：-1 0 -1 0。可能有些读者会问：原始next 数组是前缀后缀最长公共元素长度值右移一位， 然后初值赋为-1而得，那么优化后的next 数组如何快速心算出呢？实际上，只要求出了原始next 数组，便可以根据原始next 数组快速求出优化后的next 数组。还是以abab为例，如下表格所示：</code></pre>{% image https://img-blog.csdn.net/20140801160510832 '' '' %}<pre><code>只要出现了p[next[j]] = p[j]的情况，则把next[j]的值再次递归。例如在求模式串“abab”的第2个a的next值时，如果是未优化的next值的话，第2个a对应的next值为0，相当于第2个a失配时，下一步匹配模式串会用p[0]处的a再次跟文本串匹配，必然失配。所以求第2个a的next值时，需要再次递归：next[2] = next[ next[2] ] = next[0] = -1（此后，根据优化后的新next值可知，第2个a失配时，执行“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符”），同理，第2个b对应的next值为0。</code></pre><p>对于优化后的next数组可以发现一点：如果模式串的后缀跟前缀相同，那么它们的next值也是相同的，例如模式串abcabc，它的前缀后缀都是abc，其优化后的next数组为：-1 0 0 -1 0 0，前缀后缀abc的next值都为-1 0 0。</p><pre><code>然后引用下之前3.1节的KMP代码：</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    </span></span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span></span><br><span class="line"><span class="comment">//next[j]即为j所对应的next值      </span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == pLen)</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>接下来，咱们继续拿之前的例子说明，整个匹配过程如下：</code></pre><ol><li>S[3]与P[3]匹配失败。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hi.csdn.net/attachment/201106/14/8394323_130807585714lW.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure> <ol start="2"><li><p>S[3]保持不变，P的下一个匹配位置是P[next[3]]，而next[3]=0，所以P[next[3]]=P[0]与S[3]匹配。</p><p><img src="http://hi.csdn.net/attachment/201106/14/8394323_13080758571390.jpg" alt></p></li><li><p>由于上一步骤中P[0]与S[3]还是不匹配。此时i=3，j=next [0]=-1，由于满足条件j==-1，所以执行“++i, ++j”，即主串指针下移一个位置，P[0]与S[4]开始匹配。最后j==pLen，跳出循环，输出结果i - j = 4（即模式串第一次在文本串中出现的位置），匹配成功，算法结束。</p><p><img src="http://hi.csdn.net/attachment/201106/14/8394323_1308075857e40u.jpg" alt>   </p></li></ol><h2 id="KMP的时间复杂度分析"><a href="#KMP的时间复杂度分析" class="headerlink" title="KMP的时间复杂度分析"></a>KMP的时间复杂度分析</h2><pre><code>相信大部分读者读完上文之后，已经发觉其实理解KMP非常容易，无非是循序渐进把握好下面几点：</code></pre><ol><li><p>如果模式串中存在相同前缀和后缀，即pj-k pj-k+1, …, pj-1 = p0 p1, …, pk-1，那么在pj跟si失配后，让模式串的前缀p0 p1…pk-1对应着文本串si-k si-k+1…si-1，而后让pk跟si继续匹配。</p></li><li><p>之前本应是pj跟si匹配，结果失配了，失配后，令pk跟si匹配，相当于j 变成了k，模式串向右移动j - k位。</p></li><li><p>因为k 的值是可变的，所以我们用next[j]表示j处字符失配后，下一次匹配模式串应该跳到的位置。换言之，失配前是j，pj跟si失配时，用p[ next[j] ]继续跟si匹配，相当于j变成了next[j]，所以，j = next[j]，等价于把模式串向右移动j - next [j] 位。</p></li><li><p>而next[j]应该等于多少呢？next[j]的值由j 之前的模式串子串中有多大长度的相同前缀后缀所决定，如果j 之前的模式串子串中（不含j）有最大长度为k的相同前缀后缀，那么next [j] = k。</p><p> 如之前的图所示：</p></li></ol>{% image https://img-blog.csdn.net/20140812223633281 '' '' %}<pre><code>接下来，咱们来分析下KMP的时间复杂度。分析之前，先来回顾下KMP匹配算法的流程：</code></pre><p>“KMP的算法流程：</p><ul><li><p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p><ul><li><p>如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；</p></li><li><p>如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。”</p><p>我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是i++、j++；如果匹配失配，i 不变（即 i 不回溯），模式串会跳过匹配过的next [j]个字符。整个算法最坏的情况是，当模式串首字符位于i - j的位置时才匹配成功，算法结束。</p><p>所以，如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。</p></li></ul></li></ul><h2 id="扩展1：BM算法"><a href="#扩展1：BM算法" class="headerlink" title="扩展1：BM算法"></a>扩展1：BM算法</h2><pre><code>KMP的匹配是从模式串的开头开始匹配的，而1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了一种新的字符串匹配算法：Boyer-Moore算法，简称BM算法。该算法从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的时间复杂度。在实践中，比KMP算法的实际效能高。BM算法定义了两个规则：</code></pre><ul><li><p>坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果”坏字符”不包含在模式串之中，则最右出现位置为-1。</p></li><li><p>好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。</p><p>  下面举例说明BM算法。例如，给定文本串“HERE IS A SIMPLE EXAMPLE”，和模式串“EXAMPLE”，现要查找模式串是否在文本串中，如果存在，返回模式串在文本串中的位置。</p></li></ul><ol><li>首先，”文本串”与”模式串”头部对齐，从尾部开始比较。”S”与”E”不匹配。这时，”S”就被称为”坏字符”（bad character），即不匹配的字符，它对应着模式串的第6位。且”S”不包含在模式串”EXAMPLE”之中（相当于最右出现位置是-1），这意味着可以把模式串后移6-(-1)=7位，从而直接移到”S”的后一位。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140728192101322" alt title>                </div>                <div class="image-caption"></div>            </figure><ol start="2"><li><p>依然从尾部开始比较，发现”P”与”E”不匹配，所以”P”是”坏字符”。但是，”P”包含在模式串”EXAMPLE”之中。因为“P”这个“坏字符”对应着模式串的第6位（从0开始编号），且在模式串中的最右出现位置为4，所以，将模式串后移6-4=2位，两个”P”对齐。</p><p><img src="https://img-blog.csdn.net/20140728192109185" alt></p><p><img src="https://img-blog.csdn.net/20140728192118623" alt></p></li><li><p>依次比较，得到 “MPLE”匹配，称为”好后缀”（good suffix），即所有尾部匹配的字符串。注意，”MPLE”、”PLE”、”LE”、”E”都是好后缀。</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140728193254930" alt title>                </div>                <div class="image-caption"></div>            </figure><ol start="4"><li><p>发现“I”与“A”不匹配：“I”是坏字符。如果是根据坏字符规则，此时模式串应该后移2-(-1)=3位。问题是，有没有更优的移法？</p><p><img src="https://img-blog.csdn.net/20140728193420403" alt></p><p><img src="https://img-blog.csdn.net/20140728193428671" alt> </p></li><li><p>更优的移法是利用好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串中上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。</p><p>所有的“好后缀”（MPLE、PLE、LE、E）之中，只有“E”在“EXAMPLE”的头部出现，所以后移6-0=6位。</p><p>可以看出，“坏字符规则”只能移3位，“好后缀规则”可以移6位。每次后移这两个规则之中的较大值。这两个规则的移动位数，只与模式串有关，与原文本串无关。</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140728194226031" alt title>                </div>                <div class="image-caption"></div>            </figure>       <ol start="6"><li>继续从尾部开始比较，“P”与“E”不匹配，因此“P”是“坏字符”，根据“坏字符规则”，后移 6 - 4 = 2位。因为是最后一位就失配，尚未获得好后缀。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20140728194006343" alt title>                </div>                <div class="image-caption"></div>            </figure><pre><code>由上可知，BM算法不仅效率高，而且构思巧妙，容易理解。</code></pre><h2 id="扩展2：Sunday算法"><a href="#扩展2：Sunday算法" class="headerlink" title="扩展2：Sunday算法"></a>扩展2：Sunday算法</h2><pre><code>上文中，我们已经介绍了KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，本文最后再介绍一种比BM算法更快的查找算法即Sunday算法。Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似：</code></pre><ul><li><p>只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。</p><ul><li><p>如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1；</p></li><li><p>否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。</p><p>下面举个例子说明下Sunday算法。假定现在要在文本串”substring searching algorithm”中查找模式串”search”。</p></li></ul></li></ul><ol><li>刚开始时，把模式串与文本串左边对齐：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">substring searching algorithm</span><br><span class="line">search</span><br><span class="line">^</span><br></pre></td></tr></table></figure><ol start="2"><li>结果发现在第2个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">substring searching algorithm</span><br><span class="line">　　　 search</span><br><span class="line">　　　　^</span><br></pre></td></tr></table></figure><ol start="3"><li>结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">substring searching algorithm</span><br><span class="line">          search</span><br><span class="line">               ^</span><br></pre></td></tr></table></figure><ol start="4"><li><p>匹配成功。</p><p> 回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于Sunday算法每一步的移动量都比较大，效率很高。完。</p></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p>《算法导论》的第十二章：字符串匹配；</p></li><li><p>本文中模式串“ABCDABD”的部分图来自于此文：<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html；" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html；</a></p></li><li><p>本文3.3.7节中有限状态自动机的图由微博网友@龚陆安 绘制：<a href="http://d.pr/i/NEiz；" target="_blank" rel="noopener">http://d.pr/i/NEiz；</a></p></li><li><p>北京7月暑假班邹博半小时KMP视频：<a href="http://www.julyedu.com/video/play/id/5；" target="_blank" rel="noopener">http://www.julyedu.com/video/play/id/5；</a></p></li><li><p>北京7月暑假班邹博第二次课的PPT：<a href="http://yun.baidu.com/s/1mgFmw7u；" target="_blank" rel="noopener">http://yun.baidu.com/s/1mgFmw7u；</a></p></li><li><p>理解KMP 的9张PPT：<a href="http://weibo.com/1580904460/BeCCYrKz3#_rnd1405957424876；" target="_blank" rel="noopener">http://weibo.com/1580904460/BeCCYrKz3#_rnd1405957424876；</a></p></li><li><p>详解KMP算法（多图）：<a href="http://www.cnblogs.com/yjiyjige/p/3263858.html；" target="_blank" rel="noopener">http://www.cnblogs.com/yjiyjige/p/3263858.html；</a></p></li><li><p>本文第4部分的BM算法参考自此文：<a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html；" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html；</a></p></li><li><p><a href="http://youlvconglin.blog.163.com/blog/static/5232042010530101020857；" target="_blank" rel="noopener">http://youlvconglin.blog.163.com/blog/static/5232042010530101020857；</a></p></li><li><p>《数据结构 第二版》，严蔚敏 &amp; 吴伟民编著；</p></li><li><p><a href="http://blog.csdn.net/v_JULY_v/article/details/6545192；" target="_blank" rel="noopener">http://blog.csdn.net/v_JULY_v/article/details/6545192；</a></p></li><li><p><a href="http://blog.csdn.net/v_JULY_v/article/details/6111565；" target="_blank" rel="noopener">http://blog.csdn.net/v_JULY_v/article/details/6111565；</a></p></li><li><p>Sunday算法的原理与实现：<a href="http://blog.chinaunix.net/uid-22237530-id-1781825.html；" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-22237530-id-1781825.html；</a></p></li><li><p>模式匹配之Sunday算法：<a href="http://blog.csdn.net/sunnianzhong/article/details/8820123；" target="_blank" rel="noopener">http://blog.csdn.net/sunnianzhong/article/details/8820123；</a></p></li><li><p>一篇KMP的英文介绍：<a href="http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/kmpen.htm；" target="_blank" rel="noopener">http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/kmpen.htm；</a></p></li><li><p>我2014年9月3日在西安电子科大的面试&amp;算法讲座视频（第36分钟~第94分钟讲KMP）：<a href="http://www.julyedu.com/video/play/21；" target="_blank" rel="noopener">http://www.julyedu.com/video/play/21；</a></p></li><li><p>一幅图理解KMP next数组的求法：<a href="http://v.atob.site/kmp-next.html" target="_blank" rel="noopener">http://v.atob.site/kmp-next.html</a></p></li></ol><blockquote><p>版权声明：本文为CSDN博主「v_JULY_v」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【转载】从头到尾彻底理解KMP-BM-Sunday算法&quot;&gt;&lt;a href=&quot;#【转载】从头到尾彻底理解KMP-BM-Sunday算法&quot; class=&quot;headerlink&quot; title=&quot;【转载】从头到尾彻底理解KMP/BM/Sunday算法&quot;&gt;&lt;/a&gt;【转载】从
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="转载" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>股票问题通解-有限状态机</title>
    <link href="http://QQ876684433.github.io/2019/10/02/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E9%80%9A%E8%A7%A3-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://QQ876684433.github.io/2019/10/02/股票问题通解-有限状态机/</id>
    <published>2019-10-02T03:21:30.000Z</published>
    <updated>2019-10-07T11:36:52.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【转载】股票问题通解-有限状态机"><a href="#【转载】股票问题通解-有限状态机" class="headerlink" title="【转载】股票问题通解 - 有限状态机"></a>【转载】股票问题通解 - 有限状态机</h1><p>很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。</p><p>这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。</p><p>先随便抽出一道题，看看别人的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s1=-prices[<span class="number">0</span>],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();++i) &#123;            </span><br><span class="line">        s1 = max(s1, -prices[i]);</span><br><span class="line">        s2 = max(s2, s1+prices[i]);</span><br><span class="line">        s3 = max(s3, s2-prices[i]);</span><br><span class="line">        s4 = max(s4, s3+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">0</span>,s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。</p><p>本文就来告诉你这个框架，然后带着你一道一道秒杀。</p><p>这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。</p><p>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。</p><h2 id="一、穷举框架"><a href="#一、穷举框架" class="headerlink" title="一、穷举框架"></a>一、穷举框架</h2><p>首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。</p><p>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。</p><p>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp状态<span class="number">1</span>[...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><p>比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。</p><p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dpi[<span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n<span class="number">-1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line">n 为天数，大 K 为最多交易数</span><br><span class="line">此问题共 n × K × <span class="number">2</span> 种状态，全部穷举就能搞定。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">        <span class="keyword">for</span> s in &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">            dpi[s] = max(buy, sell, rest)</span><br></pre></td></tr></table></figure><p>而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p><p>我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p><p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p><h2 id="二、状态转移框架"><a href="#二、状态转移框架" class="headerlink" title="二、状态转移框架"></a>二、状态转移框架</h2><p>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.leetcode-cn.com/c4eb5f0aa4daf7bef4b3b8af95129bb7394ec58e1ba7b191d9104bbd8ff1ccb3-40198bf2f6894018328b250b772b4a17724a983f99ba359b798a289733bffcbc-file_1559885188422-1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">              max(   选择 rest  ,           选择 sell      )</span><br><span class="line"></span><br><span class="line">解释：今天我没有持有股票，有两种可能：</span><br><span class="line">要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span><br><span class="line">要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span><br><span class="line"></span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">              max(   选择 rest  ,           选择 buy         )</span><br><span class="line"></span><br><span class="line">解释：今天我持有着股票，有两种可能：</span><br><span class="line">要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span><br><span class="line">要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span><br></pre></td></tr></table></figure><p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。</p><p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">-1</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 i 是从 <span class="number">0</span> 开始的，所以 i = <span class="number">-1</span> 意味着还没有开始，这时候的利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 k 是从 <span class="number">1</span> 开始的，所以 k = <span class="number">0</span> 意味着根本不允许交易，这时候利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span><br></pre></td></tr></table></figure><p>把上面的状态转移方程总结一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">base <span class="keyword">case</span>：</span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">0</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。</p><h2 id="三、秒杀题目"><a href="#三、秒杀题目" class="headerlink" title="三、秒杀题目"></a>三、秒杀题目</h2><h3 id="第一题，k-1"><a href="#第一题，k-1" class="headerlink" title="第一题，k = 1"></a>第一题，k = 1</h3><p>直接套状态转移方程，根据 base case，可以做一些化简：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i]) </span><br><span class="line">            = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">解释：k = <span class="number">0</span> 的 base <span class="keyword">case</span>，所以 dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">现在发现 k 都是 <span class="number">1</span>，不会改变，即 k 对状态转移已经没有影响了。</span><br><span class="line">可以进行进一步化简去掉所有 k：</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i])</span><br></pre></td></tr></table></figure><p>直接写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = prices.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>显然<code>i = 0</code> 时 <code>dp[i-1]</code> 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 解释：</span></span><br><span class="line">        <span class="comment">//   dp[i][0] </span></span><br><span class="line">        <span class="comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span></span><br><span class="line">        <span class="comment">// = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">        <span class="comment">//解释：</span></span><br><span class="line">        <span class="comment">//   dp[i][1] </span></span><br><span class="line">        <span class="comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span></span><br><span class="line">        <span class="comment">// = max(-infinity, 0 - prices[i]) </span></span><br><span class="line">        <span class="comment">// = -prices[i]</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k == 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="comment">// base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span></span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        <span class="comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span></span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p><h3 id="第二题，k-infinity"><a href="#第二题，k-infinity" class="headerlink" title="第二题，k = +infinity"></a>第二题，k = +infinity</h3><p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">            = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k][<span class="number">0</span>] - prices[i])</span><br><span class="line"></span><br><span class="line">我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>直接翻译成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_inf</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三题，k-infinity-with-cooldown"><a href="#第三题，k-infinity-with-cooldown" class="headerlink" title="第三题，k = +infinity with cooldown"></a>第三题，k = +infinity with cooldown</h3><p>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-2</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">解释：第 i 天选择 buy 的时候，要从 i<span class="number">-2</span> 的状态转移，而不是 i<span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><p>翻译成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_cool</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp_pre_0 = <span class="number">0</span>; <span class="comment">// 代表 dp[i-2][0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);</span><br><span class="line">        dp_pre_0 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四题，k-infinity-with-fee"><a href="#第四题，k-infinity-with-fee" class="headerlink" title="第四题，k = +infinity with fee"></a>第四题，k = +infinity with fee</h3><p>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i] - fee)</span><br><span class="line">解释：相当于买入股票的价格升高了。</span><br><span class="line">在第一个式子里减也是一样的，相当于卖出股票的价格减小了。</span><br></pre></td></tr></table></figure><p>在第一个式子里减也是一样的，相当于卖出股票的价格减小了。<br>直接翻译成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_fee</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第五题，k-2"><a href="#第五题，k-2" class="headerlink" title="第五题，k = 2"></a>第五题，k = 2</h3><p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。</p><p>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始的动态转移方程，没有可化简的地方</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123; <span class="comment">/* 处理一下 base case*/</span> &#125;</span><br><span class="line">    dp[i][k][<span class="number">0</span>] = Math.max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][k][<span class="number">1</span>] = Math.max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][k][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>为什么错误？我这不是照着状态转移方程写的吗？</p><p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max_k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123; </span><br><span class="line">            <span class="comment">/* 处理 base case */</span></span><br><span class="line">            dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][k][<span class="number">1</span>] = -prices[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 穷举了 n × max_k × 2 个状态，正确。</span></span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。</p><p>这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">2</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">2</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxProfit_k_2(<span class="keyword">int</span>[] prices) &#123;</span><br><span class="line">    <span class="keyword">int</span> dp_i10 = <span class="number">0</span>, dp_i11 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp_i20 = <span class="number">0</span>, dp_i21 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">        dp_i20 = Math.max(dp_i20, dp_i21 + price);</span><br><span class="line">        dp_i21 = Math.max(dp_i21, dp_i10 - price);</span><br><span class="line">        dp_i10 = Math.max(dp_i10, dp_i11 + price);</span><br><span class="line">        dp_i11 = Math.max(dp_i11, -price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。</p><h3 id="第六题，k-any-integer"><a href="#第六题，k-any-integer" class="headerlink" title="第六题，k = any integer"></a>第六题，k = any integer</h3><p>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？</p><p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。</p><p>直接把之前的代码重用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_any</span><span class="params">(<span class="keyword">int</span> max_k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (max_k &gt; n / <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> maxProfit_k_inf(prices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123; <span class="comment">/* 处理 base case */</span> &#125;</span><br><span class="line">            dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);     </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，6 道题目通过一个状态转移方程全部解决。</p><h2 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h2><p>本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。</p><p>关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？</p><p>具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。</p><p>所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。</p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/" target="_blank" rel="noopener">买卖股票的最佳时机</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">买卖股票的最佳时机 III</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">买卖股票的最佳时机 IV</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">买卖股票的最佳时机含手续费</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a><strong>推荐阅读</strong></h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia" target="_blank" rel="noopener">动态规划设计方法：归纳思想</a></p><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/" target="_blank" rel="noopener">滑动窗口算法解决一类子串问题</a></p><p><a href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/" target="_blank" rel="noopener">腾讯面试题详解：编辑距离</a></p><blockquote><p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/</a><br>来源：力扣（LeetCode）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【转载】股票问题通解-有限状态机&quot;&gt;&lt;a href=&quot;#【转载】股票问题通解-有限状态机&quot; class=&quot;headerlink&quot; title=&quot;【转载】股票问题通解 - 有限状态机&quot;&gt;&lt;/a&gt;【转载】股票问题通解 - 有限状态机&lt;/h1&gt;&lt;p&gt;很多读者抱怨股票系列
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="转载" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-26）</title>
    <link href="http://QQ876684433.github.io/2019/09/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-26%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/26/数据库课堂笔记（2019-09-26）/</id>
    <published>2019-09-26T13:24:12.000Z</published>
    <updated>2019-10-20T15:02:04.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-26）"><a href="#数据库课堂笔记（2019-09-26）" class="headerlink" title="数据库课堂笔记（2019-09-26）"></a>数据库课堂笔记（2019-09-26）</h2><h3 id="Ch3-Basic-SQL-Query-Language"><a href="#Ch3-Basic-SQL-Query-Language" class="headerlink" title="Ch3. Basic SQL Query Language"></a>Ch3. Basic SQL Query Language</h3><h4 id="UNION和FOR-ALL条件"><a href="#UNION和FOR-ALL条件" class="headerlink" title="UNION和FOR ALL条件"></a>UNION和FOR ALL条件</h4><ul><li>Union：结果中没有重复行（会将重复行给剔除）</li><li>Union All：结果中可能会有重复行（即不会将重复行给剔除）</li></ul><p>例子：</p><ul><li>R1 := S1 <strong>UNION</strong> S2</li><li>R2 := S1 <strong>UNION ALL</strong> S2</li><li>R3 := ( S1 <strong>UNION ALL</strong> S2 ) <strong>UNION</strong> S3</li><li>R4 := S1 <strong>UNION ALL</strong> ( S2 <strong>UNION</strong> S3 )</li></ul><p>只要<strong>最后一个操作是UNION</strong>，那么结果就没有重复行；所以R1&amp;R3的结果中没有重复行</p><h4 id="INTERSECT和EXCEPT操作"><a href="#INTERSECT和EXCEPT操作" class="headerlink" title="INTERSECT和EXCEPT操作"></a>INTERSECT和EXCEPT操作</h4><ul><li><p>INTERSECT</p><p>The INTERSECT clause in SQL is used to combine two <a href="https://www.geeksforgeeks.org/sql-select-clause/" target="_blank" rel="noopener">SELECT</a> statements but the dataset returned by the INTERSECT statement will be the intersection of the data-sets of the two SELECT statements. In simple words, the INTERSECT statement will return only those rows which will be common to both of the SELECT statements.</p><p><img src="https://i.loli.net/2019/10/20/9wkabC6zJxj7UBD.png" alt></p><p>The INTERSECT statement will return only those rows present in the deep green shaded region. i.e. common to both of the data-sets.</p></li><li><p>EXCEPT</p><p>The SQL <strong>EXCEPT</strong> clause/operator is used to combine two SELECT statements and returns rows from the first SELECT statement that are not returned by the second SELECT statement. This means EXCEPT returns only rows, which are not available in the second SELECT statement.</p><p>Just as with the UNION operator, the same rules apply when using the EXCEPT operator. <strong>MySQL does not support the EXCEPT operator</strong>.</p></li></ul><h4 id="SQL中的DIVISION操作"><a href="#SQL中的DIVISION操作" class="headerlink" title="SQL中的DIVISION操作"></a>SQL中的DIVISION操作</h4><p>SQL中没有类似于关系代数中的÷（division）操作，但可以通过<strong>两个NOT EXIST</strong>来实现除法操作，例子如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Q: Find cids of customers who place orders <span class="keyword">with</span> <span class="keyword">ALL</span> agents based <span class="keyword">in</span> <span class="keyword">New</span> York.</span><br><span class="line"></span><br><span class="line">A: o[cid, aid] ÷ (a <span class="keyword">where</span> city=‘<span class="keyword">New</span> York’)[aid]</span><br></pre></td></tr></table></figure><ul><li><p>以上是关系代数运算，它的意思等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if row c in customers table is a customer of result <span class="keyword">set</span>, <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> a <span class="keyword">in</span> agents <span class="keyword">table</span> which <span class="keyword">is</span> based <span class="keyword">in</span> <span class="keyword">New</span> York</span><br><span class="line">        we can find a <span class="keyword">row</span> o <span class="keyword">in</span> orders <span class="keyword">table</span> which: o.cid = c.cid <span class="keyword">and</span> o.aid = a.aid</span><br></pre></td></tr></table></figure></li><li><p>-&gt;等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if row c in customers table is a customer of result <span class="keyword">set</span>, <span class="keyword">then</span></span><br><span class="line"><span class="keyword">no</span> <span class="keyword">row</span>(a) <span class="keyword">in</span> agents <span class="keyword">table</span> which</span><br><span class="line">        <span class="keyword">is</span> based <span class="keyword">in</span> <span class="keyword">New</span> York, <span class="keyword">and</span></span><br><span class="line">        <span class="string">"no row(o) in orders table which o.cid = c.cid and o.aid = a.aid"</span></span><br></pre></td></tr></table></figure><p>这样我们可以根据最后一句构造出第一个条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond1: NOT EXISTS ( <span class="keyword">select</span> * <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid=c.cid <span class="keyword">and</span> o.aid=a.aid )</span><br></pre></td></tr></table></figure></li><li><p>-&gt;等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if row c in customers table is a customer of result <span class="keyword">set</span>, <span class="keyword">then</span></span><br><span class="line"><span class="keyword">no</span> <span class="keyword">row</span>(a) <span class="keyword">in</span> agents <span class="keyword">table</span> which</span><br><span class="line"><span class="keyword">is</span> based <span class="keyword">in</span> <span class="keyword">New</span> York, <span class="keyword">and</span></span><br><span class="line">cond1</span><br></pre></td></tr></table></figure><p>然后使用cond1可以构造出第二个条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond2: NOT EXISTS ( <span class="keyword">select</span> * <span class="keyword">from</span> agents a <span class="keyword">where</span> city = ‘<span class="keyword">New</span> York’ <span class="keyword">and</span> cond1 )</span><br></pre></td></tr></table></figure></li><li><p>-&gt;等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if row c in customers table is a</span><br><span class="line">    customer of result <span class="keyword">set</span>, <span class="keyword">then</span></span><br><span class="line">    cond2</span><br></pre></td></tr></table></figure><p>最后我们可以使用cond2写出SQL查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.cid <span class="keyword">FROM</span> customers c <span class="keyword">WHERE</span> cond2 )</span><br></pre></td></tr></table></figure></li><li><p>完整的SQL查询语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.cid <span class="keyword">FROM</span> customers c</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> agents a</span><br><span class="line">    <span class="keyword">WHERE</span> a.city = ‘<span class="keyword">New</span> York’ <span class="keyword">and</span> <span class="keyword">NOT</span></span><br><span class="line">    <span class="keyword">EXISTS</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orders o</span><br><span class="line">        <span class="keyword">WHERE</span> o.cid=c.cid <span class="keyword">and</span> o.aid=a.aid ) )</span><br></pre></td></tr></table></figure></li></ul><p>按照我自己的理解的话，这个类似于”双重否定表肯定”的感觉，或者逆否命题</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/20/LGkiJveumwUMCYP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>搬一张图片：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/20/zfYtal5LXSxHVpA.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-24）</title>
    <link href="http://QQ876684433.github.io/2019/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-24%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/24/数据库课堂笔记（2019-09-24）/</id>
    <published>2019-09-24T03:25:09.000Z</published>
    <updated>2019-10-15T03:30:19.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-24）"><a href="#数据库课堂笔记（2019-09-24）" class="headerlink" title="数据库课堂笔记（2019-09-24）"></a>数据库课堂笔记（2019-09-24）</h2><h3 id="Ch3-Basic-SQL-Query-Language"><a href="#Ch3-Basic-SQL-Query-Language" class="headerlink" title="Ch3. Basic SQL Query Language"></a>Ch3. Basic SQL Query Language</h3><h4 id="建立数据库"><a href="#建立数据库" class="headerlink" title="建立数据库"></a>建立数据库</h4><h5 id="ANSI-SQL数据类型"><a href="#ANSI-SQL数据类型" class="headerlink" title="ANSI SQL数据类型"></a>ANSI SQL数据类型</h5><ul><li><p>字符数据类型（Character）</p><ul><li>固定长度字符串类型：CHARACTER(n)，CHAR(n)</li><li>可变长度字符串类型：CHARACTER VARYING(n)，CHAR VARYING(n)</li></ul></li><li><p>数字数据类型（Numeric）</p><p>(此处推荐阅读：<a href="https://academy.vertabelo.com/blog/understanding-numerical-data-types-sql/" target="_blank" rel="noopener">https://academy.vertabelo.com/blog/understanding-numerical-data-types-sql/</a>)</p><blockquote><p>precision(p)：数字的总位数</p><p>scale(s)：小数点右边的数字个数</p></blockquote><blockquote><p>Precision is an integer that represents the total number of digits allowed in this column. These digits are in a particular radix, or number base – i.e. binary (base-2) or decimal (base-10). They are usually defined with a <em>decimal</em> <em>point</em>.</p><p>The scale, also an integer value, represents the number of <em>decimal</em> <em>places</em> to the right (if positive) or left (if negative; this is rarely used) of the <em>decimal</em> <em>point</em>.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE account (</span><br><span class="line">&gt;     accountNo integer,</span><br><span class="line">&gt;     balance numeric(8,2)</span><br><span class="line">&gt; );</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://academy.vertabelo.com/blog/understanding-numerical-data-types-sql/numeric-data-types-1.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></blockquote><p><strong>Exact numeric data types</strong>(means the values are stored as a literal representation of the number’s value):</p><ul><li>NUMERIC(p, s), DECIMAL(p, s), DEC(p, s)</li><li>INTEGER, INT, SMALLINT</li></ul><p><strong>Approximate numeric data types</strong>(means they are not represented as exact numbers in the database):</p><ul><li>FLOAT(p)</li><li>REAL</li><li>DOUBLE PRECISION</li></ul></li></ul><p>Oracle数据库中NUMBER数据类型的例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/mv4Di5buqhlRPOf.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="创建数据表的语句"><a href="#创建数据表的语句" class="headerlink" title="创建数据表的语句"></a>创建数据表的语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename&#123;</span><br><span class="line">    colname datatype [<span class="keyword">NOT</span> <span class="literal">NULL</span>]</span><br><span class="line">    &#123; , colname datatype [<span class="keyword">NOT</span> <span class="literal">NULL</span>] ...&#125;</span><br><span class="line">    [ , PRIMARY <span class="keyword">KEY</span> (colname &#123; , colname ...&#125;)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(1) <strong>[ … ] -&gt; 表示可选，即出现0次或者1次    { … } -&gt; 表示出现0次或者多次</strong></p><p>(2) CREATE TABLE</p><p>(3) NOT NULL</p><p>(4) PRIMARY KEY</p><p>说明创建一个数据表时，必须<strong>至少包含一个属性</strong>，另外<strong>主键可以有0个、1个或者多个</strong></p><h4 id="简单的选择语句"><a href="#简单的选择语句" class="headerlink" title="简单的选择语句"></a>简单的选择语句</h4><h5 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ......</span><br><span class="line"><span class="keyword">FROM</span> …...</span><br><span class="line">[ <span class="keyword">WHERE</span> …… ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> …... [ <span class="keyword">HAVING</span> …… ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> …… ];</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * | colname &#123; , colname ... &#125;</span><br><span class="line"><span class="keyword">FROM</span> tablename &#123; , tablename ... &#125;</span><br><span class="line">[ <span class="keyword">WHERE</span> search_condition ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> colname &#123; , colname ... &#125;</span><br><span class="line">[ <span class="keyword">HAVING</span> search_condition ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> colname [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ]</span><br><span class="line">&#123; , colname [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ] ... &#125; ];</span><br></pre></td></tr></table></figure><p>可以看出HAVING语句是跟GROUP BY一起使用的，不能单独存在；另外可以根据多个属性对查询结果进行排序，并且可以分别为每一个属性指定按照升序或者降序排列</p><h5 id="关系代数和SQL查询"><a href="#关系代数和SQL查询" class="headerlink" title="关系代数和SQL查询"></a>关系代数和SQL查询</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/IWFsYj8klAbUeHn.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/T7dJ18FvyzZqspt.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/D6eKmEURinphOVo.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/gFRvoE57ndSHpBN.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="ALL-DISTINCT"><a href="#ALL-DISTINCT" class="headerlink" title="ALL|DISTINCT"></a>ALL|DISTINCT</h5><p>select语句中可以添加all或者distinct来指示查询结果是否剔除重复行，下面的查询结果中每一行都是唯一的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span> pid <span class="keyword">FROM</span> orders ;</span><br></pre></td></tr></table></figure><h5 id="表和列的别名"><a href="#表和列的别名" class="headerlink" title="表和列的别名"></a>表和列的别名</h5><ul><li><p>表别名</p><p><code>table_name as alias_name</code>或者<code>table_name alias_name</code>，即<code>as</code>是可以省略的。给表取别名可以用在表与表自身联接查询的情况：</p><p><img src="https://i.loli.net/2019/10/10/DKgy69otJiwqIba.png" alt></p><p>（这里有一个技巧是通过<code>c1.cid &lt; c2.cid</code>来将查询结果重复行和<strong>逆序行</strong>去掉）</p></li><li><p>列别名</p><p><code>expression as alias_name</code>，这个可以向表别名一样直接给列取别名（<code>as</code>同样是可选的），也可以给列表达式取别名，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ordno, dollars,</span><br><span class="line">o.qty*p.price*(<span class="number">1</span>-c.discnt*<span class="number">0.01</span>) <span class="keyword">as</span> mydollars</span><br><span class="line"><span class="keyword">FROM</span> ...</span><br></pre></td></tr></table></figure><p>表达式取别名的作用是在查询结果作为子查询的时候，能够方便的通过别名来访问使用了表达式的列</p></li></ul><p><strong>*贴一道诡异的题目</strong>（注释是我的个人理解，这样sql语句才能解释的通）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/eMYauO3iG1FAXk9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><h5 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr [NOT] IN ( subquery )</span><br></pre></td></tr></table></figure><blockquote><p><strong>相关子查询和独立子查询（非相关子查询）</strong></p><ul><li>非相关子查询的执行不依赖与外部的查询。<br> 执行过程：<br>（1）执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。<br>（2）执行外部查询，并显示整个结果。　</li><li>相关子查询的执行依赖于外部查询。多数情况下是<strong>子查询的WHERE子句中引用了外部查询的表</strong>。<br>执行过程：<br>（1）从外层查询中取出一个元组，将元组相关列的值传给内层查询。<br>（2）执行内层查询，得到子查询操作的值。<br>（3）外查询根据子查询返回的结果或结果集得到满足条件的行。<br>（4）然后<strong>外层查询取出下一个元组重复做步骤1-3</strong>，直到外层的元组全部处理完毕。 　</li></ul><p>参考资料：<a href="https://blog.csdn.net/shiyong1949/article/details/80923083" target="_blank" rel="noopener">https://blog.csdn.net/shiyong1949/article/details/80923083</a></p></blockquote><p>例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/kObM9JydzA6E2T7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/Im9Ks38rzeqa57d.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>另外要注意<strong>表名</strong>和<strong>列名</strong>作用域问题，IN语句中的表名和列名不能被语句外部使用：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/10/6a58ipwJFATRHqu.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="定量比较谓词"><a href="#定量比较谓词" class="headerlink" title="定量比较谓词"></a>定量比较谓词</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr  SOME|ANY|ALL ( subquery )</span><br></pre></td></tr></table></figure><p>定量谓词 vs <code>[NOT] IN</code></p><ul><li><code>IN</code>相当于<code>SOME</code></li><li><code>NOT IN</code>相当于<code>&lt;&gt; ALL</code></li></ul><p>ps：<strong>SOME 和 ANY是一样的</strong>（参考：<a href="https://stackoverflow.com/questions/1383988/tsql-some-any-why-are-they-same-with-different-names）" target="_blank" rel="noopener">https://stackoverflow.com/questions/1383988/tsql-some-any-why-are-they-same-with-different-names）</a></p><p>例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/home/steve/.config/Typora/typora-user-images/1571108972229.png" alt="1571108972229" title>                </div>                <div class="image-caption">1571108972229</div>            </figure><p>划线部分到底是ALL还是ANY/SOME？</p><p>翻译的意思是：比任何客户都小。因此使用ALL</p><h5 id="存在谓词"><a href="#存在谓词" class="headerlink" title="存在谓词"></a>存在谓词</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NOT] EXISTS ( subquery )</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/15/PRrpIBYuiv3maEG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><code>NOT EXISTS</code>可以用来实现差运算</p><h5 id="BETWEEN运算符"><a href="#BETWEEN运算符" class="headerlink" title="BETWEEN运算符"></a>BETWEEN运算符</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr [NOT] BETWEEN expr1 AND expr2</span><br></pre></td></tr></table></figure><ul><li><p>The BETWEEN operator selects values within a given range. The values can be <strong>numbers, text, or dates</strong>.</p></li><li><p>The BETWEEN operator is inclusive: <strong>begin and end values are included</strong>. </p></li></ul><p>expr1和expr2是计算两个边界值的表达式</p><h5 id="IS-NULL运算符"><a href="#IS-NULL运算符" class="headerlink" title="IS NULL运算符"></a>IS NULL运算符</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column IS [NOT] NULL</span><br></pre></td></tr></table></figure><p>null值字段不能和其他非null字段直接比较（&gt;、&lt;、=等），可以使用<code>IS NULL</code>来判断一个字段的值是不是NULL</p><h5 id="LIKE运算符"><a href="#LIKE运算符" class="headerlink" title="LIKE运算符"></a>LIKE运算符</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">column [NOT] LIKE val1 [ ESCAPE val2 ]</span><br></pre></td></tr></table></figure><p>val1是模板值（pattern），val2是转义指示字符</p><ul><li>Underscore ( _ ) : Wildcard for any single character，任何单个字符的通配符</li><li>Percent ( % ) : Wildcard for any sequence of zero or more characters，任何<strong>零个或多个</strong>字符的通配符，即%可以不匹配任何字符</li><li>Escape character : Precedes quoted literal character，转义字符</li><li>All other characters : Represent themselves，代表字符本身</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
