<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>至繁归于至简 - chph&#39;s blog</title>
  
  <subtitle>steve_chph personal website</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://QQ876684433.github.io/"/>
  <updated>2019-12-23T06:10:02.219Z</updated>
  <id>http://QQ876684433.github.io/</id>
  
  <author>
    <name>steve_chph</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件系统设计复习 - Part1</title>
    <link href="http://QQ876684433.github.io/2019/12/23/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%A4%8D%E4%B9%A0%20-%20Part1/"/>
    <id>http://QQ876684433.github.io/2019/12/23/软件系统设计复习 - Part1/</id>
    <published>2019-12-23T05:53:02.000Z</published>
    <updated>2019-12-23T06:10:02.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件系统设计复习-Part1"><a href="#软件系统设计复习-Part1" class="headerlink" title="软件系统设计复习 - Part1"></a>软件系统设计复习 - Part1</h1><p>简答，分析，设计</p><p>简答：基本概念（不考细枝末节，主要是理解）</p><p>分析题：原则（和设计模式的关系）、目的（角色的设置的目的，如果不是这样，后果怎样）、相似模式的比较、优缺点的分析</p><p>设计题：给出问题描述和约束条件，给出设计，UML图（要标准）有可能是模式的简单应用，更多是模式的变体（课上讲的）、联用（防止过度模式化、即不需要很多个模式一起使用，一般都是很明确的，模式可由可无时尽量就不要加上去，同一类模式的联用少见，一般是不同类的模式在多个角度上正交联用，审题很重要，看清楚核心）</p><p>设计题写代码：一般是写设计中不能体现的部分，能画类图的一般不需要写代码（很重要、但是设计中无法体现的部分）</p><h2 id="软件模式"><a href="#软件模式" class="headerlink" title="软件模式"></a>软件模式</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件系统设计复习-Part1&quot;&gt;&lt;a href=&quot;#软件系统设计复习-Part1&quot; class=&quot;headerlink&quot; title=&quot;软件系统设计复习 - Part1&quot;&gt;&lt;/a&gt;软件系统设计复习 - Part1&lt;/h1&gt;&lt;p&gt;简答，分析，设计&lt;/p&gt;
&lt;p&gt;简答
      
    
    </summary>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件系统设计" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="架构" scheme="http://QQ876684433.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据库-数据库设计</title>
    <link href="http://QQ876684433.github.io/2019/12/22/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>http://QQ876684433.github.io/2019/12/22/数据库-数据库设计/</id>
    <published>2019-12-22T11:18:08.000Z</published>
    <updated>2019-12-24T06:31:01.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库-数据库设计"><a href="#数据库-数据库设计" class="headerlink" title="数据库 - 数据库设计"></a>数据库 - 数据库设计</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li></ul></blockquote><p>候选键和主键的微小区别：</p><ul><li>候选键：区分当前表的不同行</li><li>主键：在其他表引用当前表时唯一标识表中的行的一个候选键</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/22/AdlFXq4rBOGjThf.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>表的键的正确性描述是由数据库系统维护的</p><h2 id="数据库设计前言"><a href="#数据库设计前言" class="headerlink" title="数据库设计前言"></a>数据库设计前言</h2><p>Logical Database Design<br>➢also known as</p><ul><li>Database Design</li><li>Database Modeling</li></ul><p>如何进行数据库设计？</p><ul><li>analyze an enterprise</li><li>list the data items for a database</li><li>decide how to place these data items columns in relational tables</li></ul><p>案例：学生课程数据库（student-course database）</p><p>学生属性：sno, sname, dept, sage</p><p>课程属性：cno, cname</p><p>学生&amp;课程属性：grade</p><p>把这些属性全部放进同一张表中：<code>R(sno, sname, dept, sage, cno, cname, grade)</code>，结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/22/yeHPordXahWzq69.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>存在的问题有哪些？</p><ol><li><p>redundency（数据冗余）</p><p>相同的数据重复存储，造成磁盘空间的浪费</p><p><img src="https://i.loli.net/2019/12/22/bPEFZCgrQe93yBk.png" alt></p></li><li><p>abnormity of update（修改异常）</p><p>对于冗余存储的数据，如果需要修改的话，则需要修改所有重复存储的版本</p><ul><li>浪费时间</li><li>用户很容易操作出错</li></ul></li><li><p>abnormity of delete（删除异常）</p><p>可能会丢失一些有用的信息</p><p><img src="https://s2.ax1x.com/2019/12/22/QzdJFx.png" alt="QzdJFx.png"></p><p><img src="https://s2.ax1x.com/2019/12/22/QzdtfK.png" alt="QzdtfK.png"></p></li></ol><ol start="4"><li><p>abnormity of insert（插入异常）</p><p>可能会插入失败，比如要添加新的学生信息，但是该学生目前尚未选任何课程，这时候就会出现插入异常</p></li></ol><p>因此一个比较好的设计方案是将SCG数据表拆分成多张表：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/22/QzwAje.png" alt="QzwAje.png" title>                </div>                <div class="image-caption">QzwAje.png</div>            </figure><h2 id="E-R概念介绍"><a href="#E-R概念介绍" class="headerlink" title="E-R概念介绍"></a>E-R概念介绍</h2><p><strong>ER模型（Entity-Relationship model，实体关系模型）</strong>是用来描述数据库的抽象方法</p><img src="https://s2.ax1x.com/2019/12/22/QzwyDJ.png" alt="QzwyDJ.png" style="zoom:80%;"><h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><p>三种基本的数据分类对象：</p><ul><li>实体</li><li>属性</li><li>关系</li></ul><h4 id="实体（entity）"><a href="#实体（entity）" class="headerlink" title="实体（entity）"></a>实体（entity）</h4><p>定义：实体是具有公共性质的可区分的现实世界对象的集合（An entity is a collection of distinguishable<br>real-world objects with common properties）</p><ul><li>通常一个实体会被映射成一张关系表，代表对象的集合</li><li>关系表中的每一行代表一个实体事件（entity occurrence）或者实体实例（entity instance），代表一个可区分的现实世界对象</li></ul><p>E-R图用<strong>矩形</strong>来代表实体</p><h4 id="属性（attribute）"><a href="#属性（attribute）" class="headerlink" title="属性（attribute）"></a>属性（attribute）</h4><p>定义：属性是描述<strong>实体</strong>或者<strong>关系</strong>的性质的数据项（An attribute is a data item that describes a<br>property of an entity or a relationship）；属于一个实体的所有实体实例具有共同的性质，这些性质就是属性</p><p><strong>复合属性</strong>：一组简单属性，用来共同描述一个性质</p><p><strong>多值属性</strong>：在<u><em>一个实体实例中</em></u>可以取多个值的属性</p><p><strong>标识符（identifier</strong>，类似于关系表中的候选键）：每个实体都有一个标识符，也就是一个属性或者一个属性集合，每个实体实例在这些属性上具有不同的值；实体的标识符可以包含复合属性</p><p><strong>主标识符（primary identifier</strong>，类似于关系表中的主键）：一个实体可以定义多个标识符，当数据库管理员选定一个单键属性作为整个数据库中实体实例的标识方法时，它就被称为实体的主标识符</p><p><strong>描述符（descriptor）</strong>：非标识符的属性是描述性属性，被称为描述符</p><p>E-R图的表示：</p><ul><li>简单单质属性用椭圆形表示，并用直线连接到实体</li><li>复合属性同样用椭圆形表示并连接到实体，同时组成复合属性的简单属性连接到复合属性上</li><li>多值属性用双线连接到它所描述的实体上（而不是单线）</li><li><strong>主标识符属性加下划线标识</strong></li></ul><p>具有实体和属性的E-R图例</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/22/QzD08P.png" alt="QzD08P.png" title>                </div>                <div class="image-caption">QzD08P.png</div>            </figure><h4 id="转换实体和属性到关系"><a href="#转换实体和属性到关系" class="headerlink" title="转换实体和属性到关系"></a>转换实体和属性到关系</h4><h5 id="转换规则1"><a href="#转换规则1" class="headerlink" title="转换规则1"></a>转换规则1</h5><ul><li>每个实体映射到关系数据库中的一个表，并用实体名来命名这个表</li><li>表的列代表了连接到实体的所有简单单值属性（对于<strong>复合属性，本身不变成表的列</strong>，而是将复合属性所对应的多个简单单值属性映射为表的多个列）</li><li>实体的标识符映射为该表的候选键</li><li>实体的主标识符映射为该表的主键（主标识符可以是一个复合属性，所以它将变成关系表中的一个属性集合），主键加下划线表示</li><li>实体实例映射为该表中的行</li></ul><h5 id="转换规则2"><a href="#转换规则2" class="headerlink" title="转换规则2"></a>转换规则2</h5><p>对于实体E，主标识符是p，如果一个多值属性a在E-R图中连接到R，那么<strong>a映射成自身的一张表</strong>，该表按复数形式的多值属性名命名；这个新表的列用p和a命名（p或a都有可能由几个属性组成），<strong>表的行对应（p，a）值对</strong>，表示与E的实体实例关联的a的属性值对；这个<strong>表的主键属性是p和a中列的集合</strong></p><p>但是这个转换规则在对象-关系型数据库中是不成立的</p><h4 id="实体间联系"><a href="#实体间联系" class="headerlink" title="实体间联系"></a>实体间联系</h4><p>联系：给定m个实体的有序列表：E1、E2、…、Em（列表中同一实体可以出现多于一次），一个联系R定义了这些实体实例之间的对应规则；特别地R代表了一个m元组，它是笛卡尔积E1×E2×…×Em的子集</p><ul><li><p>联系可以有附加属性，它是每个联系实例的值（例如下图中percent代表了一个员工实例在该项目上的工作时间百分比）</p></li><li><p>联系一个实体到这个实体自身的二元联系（Ei×Ei的子集）叫做环，有时也叫做递归联系（recursive relationship）</p></li><li><p>三元关系：三个不同实体上的联系（甚至有更多元的关系，因此联系不是只能存在与两个实体之间）</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/22/Qz7zbd.png" alt="Qz7zbd.png" title>                </div>                <div class="image-caption">Qz7zbd.png</div>            </figure><h2 id="E-R模型的细节"><a href="#E-R模型的细节" class="headerlink" title="E-R模型的细节"></a>E-R模型的细节</h2><h3 id="关系中实体参与的基数"><a href="#关系中实体参与的基数" class="headerlink" title="关系中实体参与的基数"></a>关系中实体参与的基数</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/22/QzbqXD.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>如果实体E中所有的点最多只有一条出边，那么：</p><p>$max-card(E, R) = 1$</p></li><li><p>如果实体E中的点有超过一条出边，那么：</p><p>$max-card(E,R) = N$</p></li><li><p>如果实体E中所有的点至少有一条出边，那么：</p><p>$min-card(E,R)=1$</p></li><li><p>如果实体E中有的点没有出边，那么：</p><p>$min-card(E,R)=0$</p></li><li><p>如果$min-card(E,R)=x$，$max-card(E,R)=y$，那么最小最大有序对是：$card(E,R)=(x,y)$</p></li></ul><p>例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/22/QzqZAs.png" alt="QzqZAs.png" title>                </div>                <div class="image-caption">QzqZAs.png</div>            </figure><p>即$card(E,R)=(0,N)$，$card(F,R)=(1,1)$</p><ul><li><p>如果$max-card(X,R)=1$，那么在关系R中X是<strong>单值参与（single-valued participation）</strong></p></li><li><p>如果$max-card(X,R)=N$，那么在关系R中X是<strong>多值参与（multi-valued participation）</strong></p></li><li><p>如果$min-card(X,R)=1$，那么在关系R中X是<strong>强制参与（mandatory participation）</strong></p></li><li><p>如果$min-card(X,R)=0$，那么在关系R中X是<strong>可选参与（optional participation）</strong></p></li></ul><h3 id="一对一、多对一、多对多关系"><a href="#一对一、多对一、多对多关系" class="headerlink" title="一对一、多对一、多对多关系"></a>一对一、多对一、多对多关系</h3><p>只是针对max-card概念而言的</p><ul><li>一对一：两个实体都是单值参与</li><li>多对一：一个实体是单值参与，另一个实体是多值参与</li><li>多对多：两个实体都是多值参与</li></ul><h3 id="将二元联系转化成关系"><a href="#将二元联系转化成关系" class="headerlink" title="将二元联系转化成关系"></a>将二元联系转化成关系</h3><h5 id="转换规则3-N-N联系"><a href="#转换规则3-N-N联系" class="headerlink" title="转换规则3 N-N联系"></a>转换规则3 N-N联系</h5><p>当两个实体E和F参与一个多对多的二元联系R时，在相关的关系数据库设计中，联系映射成一个表T</p><ul><li>表T包括从E和F转化而来的两个表的主键的所有属性，这些列构成了表T的主键</li><li>表T还包含了<strong>连结到联系的所有属性</strong>的列</li></ul><p>联系实例用表的行表示，相关联的实体实例可以通过这些行的主键值唯一地标识出来</p><img src="https://i.loli.net/2019/12/23/FoItMcQ5L2XJSN4.png" style="zoom:80%;"><h5 id="转换规则4-N-1联系"><a href="#转换规则4-N-1联系" class="headerlink" title="转换规则4 N-1联系"></a>转换规则4 N-1联系</h5><p>当两个实体E和F参与一个多对一的二元联系R时，这个联系在关系数据库设计中不能映射为自身的一张表；相反，如果我们假设实体F具有$max-card(F,R)=1$，并表示联系关系中的“多”方，那么从实体F转化成的关系表T中应当包括从实体E转换出来的关系表的主键属性列，这被称为<strong>T的外键</strong>。由于$max-card(F,R)=1$，T的每一行都通过一个外键值联系到实体E的一个实例，如果F在R中是强制参与的($min-card(F,R)=1$)，那么它必须恰恰与E的一个实例相联系，这意味着T的上述外键不能取空值；如果F在R中是可选参与的($min-card(F,R)=0$)，那么T中不与E的实例相联系的行在外键的所有列可以取空值</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/23/1STFUhnHRYAOzM9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>其中Course_sections是“多”方，因此在它转换出来的关系表中包含Instructors的主键insid作为外键</p><h5 id="转换规则5-1-1联系，可选参与"><a href="#转换规则5-1-1联系，可选参与" class="headerlink" title="转换规则5 1-1联系，可选参与"></a>转换规则5 1-1联系，可选参与</h5><p>给定两个实体E和F，他们参与一对一二元联系R，二者的参与都是可选的，首先按照转换规则1建立表S表示实体E、表T表示实体F，然后向表T中添加一组列（作为外键），这些列在表S构成主键；对于R的任何联系实例，都有唯一一个E的实例联系到唯一一个F的实例——在S和T的对应行中，外键列填写的值引用另一张表相应行，这一联系是R的实例确定的</p><h5 id="转换规则6-1-1联系，强制参与"><a href="#转换规则6-1-1联系，强制参与" class="headerlink" title="转换规则6 1-1联系，强制参与"></a>转换规则6 1-1联系，强制参与</h5><p>对于一个两方都是强制参与的一对一联系，最好将两个实体对应的两个表<strong>合并成一个表</strong>，这一可以<strong>避免使用外键</strong></p><p>对于N元联系（N&gt;2）的转换规则，通常将这些N元联系转换成自己对应的表；如果除去一个实体外其余参与联系的所有实体都带有$max-card=1$（类似于星状结构），那么可以在那个具有较大基数的参与实体对应的表中，加入N-1个外键来表示这个联系</p><h2 id="其他E-R概念"><a href="#其他E-R概念" class="headerlink" title="其他E-R概念"></a>其他E-R概念</h2><h3 id="属性的基数"><a href="#属性的基数" class="headerlink" title="属性的基数"></a>属性的基数</h3><p>$min-card/max-card$可以用来描述实体属性的基数</p><ul><li>$(0,?)$表示属性不需要声明为<code>not null</code>（可选的，optional）</li><li>$(1,?)$表示属性声明为<code>not null</code>（强制的，mandatory）</li><li>$(?,1)$表示单值属性</li><li>$(?,N)$表示多值属性</li></ul><img src="https://i.loli.net/2019/12/23/gNEvdq7a2eCfsno.png" style="zoom:80%;"><img src="https://i.loli.net/2019/12/23/PhU2OyNQHD1qs3I.png" style="zoom:80%;"><h3 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h3><p>定义：如果实体的所有实例都<strong>通过一个联系R</strong>依赖于另一个实体的实例而存在，那么这个实体就是<strong>弱实体</strong>，而另一个实体称为<strong>强实体</strong></p><blockquote><p><strong>Strong Entity:</strong><br>Strong entity is not dependent of any other entity in schema. Strong entity always has primary key. <a href="https://practice.geeksforgeeks.org/problems/what-is-the-difference-between-strong-and-weak-entity" target="_blank" rel="noopener">Strong entity</a> is represented by single rectangle. Two strong entity’s relationship is represented by single diamond.<br>Various strong entities together makes the strong entity set.</p><p><strong><a href="https://practice.geeksforgeeks.org/problems/explain-weak-entity-types" target="_blank" rel="noopener">Weak Entity</a>:</strong><br>Weak entity is depend on strong entity to ensure the existance of weak entity. Like strong entity weak entity does not have any primary key, It has partial discriminator key. Weak entity is represented by double rectangle.<br>The relation between one strong and one weak entity is represented by double diamond.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://media.geeksforgeeks.org/wp-content/uploads/20190520181337/Untitled-Diagram-231.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>Difference between Strong and Weak Entity:</strong></p><table><thead><tr><th align="center">S.NO</th><th align="center">STRONG ENTITY</th><th align="center">WEAK ENTITY</th></tr></thead><tbody><tr><td align="center">1.</td><td align="center">Strong entity always has primary key.</td><td align="center">While weak entity has partial discriminator key.</td></tr><tr><td align="center">2.</td><td align="center">Strong entity is not dependent of any other entity.</td><td align="center">Weak entity is depend on strong entity.</td></tr><tr><td align="center">3.</td><td align="center">Strong entity is represented by single rectangle.</td><td align="center">Weak entity is represented by double rectangle.</td></tr><tr><td align="center">4.</td><td align="center">Two strong entity’s relationship is represented by single diamond.</td><td align="center">While the relation between one strong and one weak entity is represented by double diamond.</td></tr><tr><td align="center">5.</td><td align="center">Strong entity have either total participation or not.</td><td align="center">While weak entity always has total participation.</td></tr></tbody></table><p>—— reference: <a href="https://www.geeksforgeeks.org/difference-between-strong-and-weak-entity/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/difference-between-strong-and-weak-entity/</a></p></blockquote><img src="https://i.loli.net/2019/12/23/6JjnoVqdNSGRzDs.png" style="zoom:80%;"><h3 id="泛化层次"><a href="#泛化层次" class="headerlink" title="泛化层次"></a>泛化层次</h3><p>泛化层次是对应于对象-关系继承特性的E-R概念，其思想是：多个有公共属性的实体可以泛化为一个更高层次的超类型实体（supertype entity），或者一个一般化实体可以分解成低层次的子类型实体（subtype entity）；目的是让属性隶属于适当的层次，以免使用一个每个实例需要使用大量空值的公共实体的属性</p><p>泛化层次的E-R图用箭头（不命名）从子类型实体指向超类型实体，这个箭头联系经常称为<strong>ISA联系</strong></p><img src="https://i.loli.net/2019/12/23/hHYJc4X28KZdg1a.png" style="zoom: 67%;"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/23/4Zb6xj182LUHNDn.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="案例学习"><a href="#案例学习" class="headerlink" title="案例学习"></a>案例学习</h2><p>解题思路：</p><ol><li>有哪些实体(Entity)？</li><li>有哪些联系(Relationship)？</li><li>联系上的函数对应关系（参与方式）？</li><li>有哪些属性？属性与实体/联系的依附关系？</li></ol><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><p>设有一个图书借阅管理数据库， 已知： 图书的属性有书号（具有唯一性） 、 书名； 读者的属性有借书证号（具有唯一性， 每个读者只能有一个借书证号） 、 姓名、 身份证号、 住址、 电话； 出版社的属性有出版社名称（具有唯一性） 、 地址、 联系电话。<br>其中： 每本图书只能有一个出版社出版发行；每个读者可以同时借阅多本图书， 也可以在不同时候借阅同一本图书； 系统需要记录每本图书被借阅的借阅日期和归还日期。<br>请用E-R模型表示该数据库系统的概念模型，并将其转换成等价的关系模式。</p><h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><img src="https://i.loli.net/2019/12/23/SfMCXBpuDUrdhKN.png" style="zoom:80%;"><p>注意点：</p><ul><li>借阅关系中的归还日期属性基数是：$(0,1)$，是因为一本书被借阅但是尚未归还时，归还日期是空值</li><li>读者实体和电话的关系：电话是多值属性$(0,N)$，或许应该使用双线连接？</li></ul><h4 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h4><ul><li>图书（<u>书号</u>，书名，<strong>出版社名称</strong>）</li><li>出版社（<u>出版社名称</u>，联系电话，地址）</li><li>读者（<u>借书证号</u>，姓名，身份证号，地址）</li><li>读者电话（<u>借书证号，电话</u>）</li><li>借阅 ( <u>借书证号, 书号</u>, 借阅日期, 归还日期 )</li></ul><p>注意点：</p><ul><li>因为<strong>“出版”关系是多对一联系</strong>，因此应该在“多”方（即图书实体）添加属性表示转换成的关系表中添加“一”方（即出版社实体）的外键“出版社名称”</li><li>由于<strong>电话是多值属性</strong>，因此应该单独映射成一张表，表中包含多值属性自身（即电话）和它连接的实体（即读者实体）的主键</li><li><strong>关系“借阅”是多对多联系</strong>，因此应该将其转换成一张表，并且表中包含关系两边的实体的主键（构成借阅关系表的主键），并且转换后的关系表还包含附在关系上的属性（借阅日期和归还日期）</li></ul><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><p>假设需要设计一个用于NBA篮球比赛的数据库系统，需要记录的信息有：</p><ul><li>每个球员的球衣号码、姓名、身高、体重和位置</li><li>每个球队的名称和主场使用的体育馆的名称</li><li>每场比赛的比赛日期和比分</li></ul><p>其中：</p><ul><li>每个球员只能效力于一个球队</li><li>比赛采用主客场多循环方式</li></ul><p>请用E-R模型表示该数据库系统的概念模型，并将其转换成等价的关系模式</p><h4 id="概念模型-1"><a href="#概念模型-1" class="headerlink" title="概念模型"></a>概念模型</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/23/XpsgFKuWlHoB4De.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="关系模式-1"><a href="#关系模式-1" class="headerlink" title="关系模式"></a>关系模式</h4><ul><li><p>球员（<u>姓名</u>, 球衣号码, 身高, 体重, 位置，<strong>球队名称</strong>）</p><p>“签约”联系向关系的转换（Rule 4）</p></li><li><p>球队（<u>名称</u>, 体育馆名称）</p></li><li><p>比赛（<u>主队名称, 客队名称</u>, 日期, 比分）</p><p>“比赛”联系向关系的转换（Rule 3）</p></li></ul><h3 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h3><p>假设需要设计一个用于网络论坛聊天信息管理的数据库系统，需要记录的信息有：</p><ul><li>注册用户的用户名，email，电话，联系地址</li><li>帖子的帖子ID，标题，内容</li><li>每份帖子的发帖用户，帖子之间的回复关系</li></ul><p>请用E-R模型表示该数据库系统的概念模型，并将其转换成等价的关系模式</p><h4 id="概念模型-2"><a href="#概念模型-2" class="headerlink" title="概念模型"></a>概念模型</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/23/IXQ3grM1nbEfh8y.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="关系模式-2"><a href="#关系模式-2" class="headerlink" title="关系模式"></a>关系模式</h4><p>方法一：</p><ul><li>用户(<u>用户名</u>, 电话, 地址, email)</li><li>帖子(<u>帖子ID</u>, 标题, 内容 , 用户名, 原帖ID )</li></ul><p>方法二：</p><ul><li>用户 ( <strong>用户名</strong>, 电话, 地址, email)</li><li>帖子 ( <strong>帖子ID</strong>, 标题, 内容, 用户名 )</li><li>回复 ( 原帖ID, <strong>回帖ID</strong> )</li></ul><p>注意点：</p><ul><li>这里比较特殊的是“回复”关系，它是一个递归联系（即实体到自身的联系）并且是多对一联系，有两种处理方案：<ul><li>将“回复”关系单独转换成一张表，那么这张表的主键就是“多”方（即回帖）的主键，即回帖ID</li><li>由于这个关系本质上还是多对一联系，因此还是可以直接在“多”方（即帖子实体）中添加“一”方（也还是帖子实体）的外关键字这一属性（即原贴ID），这个就对应了方法一那种解法</li></ul></li></ul><h3 id="案例四"><a href="#案例四" class="headerlink" title="案例四"></a>案例四</h3><p>有一个邮件管理数据库，其信息如下：</p><ul><li>联系人：用户名，email（关键字），电话，联系地址</li><li>邮件：邮件ID，邮件标题，邮件内容，收信人集合，抄送人集合</li><li>邮件之间的回复关系</li></ul><p>请用E-R模型表示该数据库系统的概念模型，并将其转换成等价的关系模式</p><h4 id="概念模型-3"><a href="#概念模型-3" class="headerlink" title="概念模型"></a>概念模型</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/23/GjELySZ4bBm16Rq.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="关系模式-3"><a href="#关系模式-3" class="headerlink" title="关系模式"></a>关系模式</h4><ul><li>联系人(<u>email</u>, 用户名, 电话, 地址)</li><li>邮件(<u>邮件ID</u>, 邮件标题, 邮件内容, 发件人email, 被回复邮件的ID )</li><li>接收 ( <u>邮件ID,  收信人email</u> )</li><li>抄送 ( <u>邮件ID,  抄送人email</u> )</li></ul><h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p>符合第一范式的表就是没有多值字段的表</p><h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><p>任何不符合第三范式的表都能够被分解为几个不同的表，并且具有以下性质：</p><ul><li>每一个分解出的表都是一个有效的第三范式表</li><li>所有分解出的表的联接恰恰包含原始表的信息</li></ul><p>从原始全局表分解出的3NF表集合被称为数据库的一个<strong>3NF无损分解</strong></p><h3 id="异常操作"><a href="#异常操作" class="headerlink" title="异常操作"></a>异常操作</h3><h4 id="更新异常（Update-Anomaly）"><a href="#更新异常（Update-Anomaly）" class="headerlink" title="更新异常（Update Anomaly）"></a>更新异常（Update Anomaly）</h4><p>如果更改表所对应的某个实体实例或关系实例的单个属性时，需要将多行更新，那么就说这个表存在更新异常</p><h4 id="删除异常（Delete-Anomaly）"><a href="#删除异常（Delete-Anomaly）" class="headerlink" title="删除异常（Delete Anomaly）"></a>删除异常（Delete Anomaly）</h4><p>如果删除表的某一行来反映某个实体实例或关系实例消失时，会导致另一个不同实体实例或关系实例的信息，而这是我们不希望丢失的，那么就说这个表存在删除异常</p><h4 id="插入异常（Insert-Anomaly）"><a href="#插入异常（Insert-Anomaly）" class="headerlink" title="插入异常（Insert Anomaly）"></a>插入异常（Insert Anomaly）</h4><p>我们无法在缺少另一个实体实例或关系实例信息的情况下，表示某个实体或实例的信息，那么就存在插入异常</p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>函数依赖（Functional Dependency，FD）：给定一个包含至少两个属性A和B的表T，我们说A→B（A函数决定B或者B函数依赖于A），当且仅当设计者希望对于表T的任何可能的内容（行集合），T中的两行不能在A上取相同值而在B上面取不同值</p><ul><li>即，给定T的两行$r_1$和$r_2$，如果$r_1(A)=r_2(A)$，那么$r_1(B)=r_2(B)$</li></ul><p><img src="https://i.loli.net/2019/12/23/MCuN3z87RBmYIrE.png" style="zoom: 50%;"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/23/3yD1P6FMk5A2lcm.png" alt title>                </div>                <div class="image-caption"></div>            </figure></p><img src="https://i.loli.net/2019/12/23/3yD1P6FMk5A2lcm.png" style="zoom: 50%;"><p>可以把函数依赖的定义扩展到完整的一般形式的以处理属性集的情况：</p><p>给定表T和两个属性集，分别为$X=A_1A_2…A_k$和$Y=B_1B_2…B_m$，X的一些属性可以和Y的一些属性重叠，我们说X→Y（X函数决定Y或者Y函数依赖于X），当且仅当T中两行不能在X的所有属性上相同，而同时在Y的任一属性取不同值，即：给定T的两行$r_1$和$r_2$，如果$r_1(A_i)=r_2(A_i)$对每一个X中的$A_i$成立，那么$r_1(B_j)=r_2(B_j)$对于Y中的每一个$B_j$成立</p><img src="https://i.loli.net/2019/12/23/p1V5dKHogAql93B.png" style="zoom: 50%;"><h3 id="函数依赖的逻辑蕴涵"><a href="#函数依赖的逻辑蕴涵" class="headerlink" title="函数依赖的逻辑蕴涵"></a>函数依赖的逻辑蕴涵</h3><h4 id="包含规则"><a href="#包含规则" class="headerlink" title="包含规则"></a>包含规则</h4><p>给定表T，其标题是$Head(T)$，如果X和Y是$Head(T)$中属性的集合，并且$Y\subset X$，那么$X→Y$</p><h4 id="平凡依赖"><a href="#平凡依赖" class="headerlink" title="平凡依赖"></a>平凡依赖</h4><p>表T中的一个平凡依赖是一个形如$X→Y$的函数依赖，其中$X\cap Y\subseteq Head(T)$，且对于表T的任何可能的内容都成立</p><p>给定表T的一个平凡依赖$X→Y$，必然有$Y\sub X$</p><h3 id="阿姆斯特朗公理"><a href="#阿姆斯特朗公理" class="headerlink" title="阿姆斯特朗公理"></a>阿姆斯特朗公理</h3><p>假设给定一个表T，以及$Head(T)$的子集X、Y、Z，那么我们有下面的蕴含规则：</p><ul><li><p>包含规则：如果$Y\sub X$，那么$X→Y$</p></li><li><p>传递规则：如果$X\sub Y$且$Y\sub Z$，那么$X\sub Z$</p></li><li><p>增广规则：如果$X→Y$，那么$XZ→YZ$</p></li></ul><p>其中两个顺序排列的顺序的集合表示一个并运算，即$XY=X\cup Y$</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/23/VSQbEHqY2cgeCFz.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>阿姆斯特朗公理的一些蕴含：</p><ul><li><p>合并规则：如果$X→Y$且$X→Z$，那么$X→YZ$</p></li><li><p>分解规则：如果$X→YZ$，那么$X→Y$且$X→Z$</p></li><li><p>伪传递规则：如果$X→Y$且$WY→Z$，$XW→Z$</p></li><li><p>集合累积规则：如果$X→YZ$且$Z→W$，那么$X→YZW$</p></li></ul><p>阿姆斯特朗公理是完全的</p><h3 id="函数依赖集的闭包"><a href="#函数依赖集的闭包" class="headerlink" title="函数依赖集的闭包"></a>函数依赖集的闭包</h3><p>给定一个函数依赖集F，它作用在表T的属性上，我们定义F的闭包为可以从F推导出的所有函数依赖的集合（包括平凡依赖），记为$F^+$</p><p>例子如下：</p><img src="https://i.loli.net/2019/12/23/O7LkaDWtBAMhYmo.png" style="zoom:80%;"><h3 id="函数依赖集的覆盖"><a href="#函数依赖集的覆盖" class="headerlink" title="函数依赖集的覆盖"></a>函数依赖集的覆盖</h3><p>表T上的两个函数依赖集合F和G，如果函数依赖集G可以从F用蕴含规则推导出来，或者换句话说，如果$G\sub F^+$，那么我们说F覆盖G。如果F覆盖G且G覆盖F，那么这两个函数依赖集称为等价的，写作$F\equiv G$</p><h3 id="属性集的闭包"><a href="#属性集的闭包" class="headerlink" title="属性集的闭包"></a>属性集的闭包</h3><p>给定表T的函数依赖集F和T中包含的属性集X，我们定义X的闭包$X^+$，作为由X函数决定的最大属性集合Y，则最大集合Y满足$X→Y$存在于$F^+$中；注意，根据包含规则，集合Y一定包含了X的所有属性，但可以不包含其他任何属性</p><p>求集合闭包的相关算法（一个技巧是，函数依赖集中的函数依赖使用一次之后，在后续的循环中就不再需要使用了，因为不会再产生新的作用）：</p><img src="https://i.loli.net/2019/12/23/ZBWcUq7ryfNC1da.png" style="zoom:67%;"><p>可以通过集合闭包来<strong>确定一个给定的函数依赖是否可以从函数依赖集F推导出来</strong>，例如：如果我们需要知道函数依赖$X→A$是否可以有函数依赖集F推导出来，我们只需简单地在F下使用集合闭包算法<strong>计算出$X^+$，然后看它是否包含A</strong>，如果包含，那么$X→A$在$F^+$中，即它可以由F推导出来</p><p>表的键恰恰是这个表中可以<strong>函数决定所有属性</strong>的最小属性集合，<strong>为判断X是否是一个键</strong>，我们只需要在该表的属性的函数依赖集F下计算$X^+$，看它是否包括了表中全部属性，然后确认没有X的某个子集也满足这一点</p><h3 id="最小覆盖"><a href="#最小覆盖" class="headerlink" title="最小覆盖"></a>最小覆盖</h3><p>能够覆盖给定的函数依赖的最小函数依赖集合</p><ul><li>没有冗余的函数依赖</li><li>每一个函数依赖的左边都没有多余的属性</li></ul><p>算法步骤：</p><ol><li><p>从函数依赖集F，我们<strong>使用分解规则</strong>创建函数依赖的一个等价集H，它的函数依赖的<strong>右边只有单个属性</strong></p><p><img src="https://i.loli.net/2019/12/23/MRpl72JcuG9Ntme.png" alt></p></li><li><p>从函数依赖集H，顺次去掉在H中非关键的单个函数依赖；一个函数依赖$X→Y$在一个函数依赖集H中是非关键的，是指如果$X→Y$从H中去掉，得到结果J，仍然有$H^+=J^+$，或者$H\equiv J$；就是说，从H中去掉这个函数依赖对于$H^+$没有任何影响</p><p><img src="https://i.loli.net/2019/12/23/DwKz5fdVSP2pvxG.png" alt></p><p>画蓝线的部分是求J的函数依赖集的闭包$X^+$，然后看$X^+$是否包含A，如果是的话，说明去掉该函数依赖之后，得到的函数依赖集依然是和之前的函数依赖集等价</p></li><li><p>从函数依赖集H，顺次用左边具有更少属性的函数依赖替换原来的函数依赖，只要不会导致$H^+$改变</p><p>要注意，<strong>如果在步骤3的计算过程中，函数依赖集发生了变化，那么需要返回到步骤2，消除冗余的函数依赖</strong></p><p><img src="https://s2.ax1x.com/2019/12/23/l91dtU.png" alt="l91dtU.png"></p><p><img src="https://s2.ax1x.com/2019/12/23/l91whF.png" alt="l91whF.png"></p></li><li><p>从剩下的函数依赖集中<strong>收集所有左边相同的函数依赖</strong>，使用联合规则创建一个等价函数依赖集M，它的所有函数依赖的<strong>左边是唯一的</strong></p><p><img src="https://s2.ax1x.com/2019/12/23/l91HBt.png" alt="l91HBt.png"></p></li></ol><p>注意，当你<strong>在函数依赖已经改变的地方开始新的一个步骤时，重写函数依赖集很重要</strong>，保证后续的所有操作都是基于最新的函数依赖集上进行的</p><h2 id="无损分解"><a href="#无损分解" class="headerlink" title="无损分解"></a>无损分解</h2><p>规范化过程：将一个表分解成两个或者更多较小的表；这种方法中，我们可以把分解出的表连接起来重新获得到原始表的详细信息</p><p>projecting onto two or more subsets of columns that cover all columns and <strong>have some columns in common</strong></p><p>but it doesn’t always work when join back that keep all information of original table;  Always get ALL rows back, but might get MORE</p><h3 id="无损分解-1"><a href="#无损分解-1" class="headerlink" title="无损分解"></a>无损分解</h3><p>对于任何表T以及它的一个函数依赖集F，T的一个分解是一个表的集合${T_1,T_2,…,T_k}$，该集合具有两个性质：</p><ul><li>对于这个集合中的每一个表$T_i$，$Head(T_i)$是$Head(T)$一个子集</li><li>$Head(T)=Head(T_1)\cup Head(T_2)\cup …Head(T_k)$</li></ul><p>给定表T的特定内容，即T的行被投影到每个$T_i$的列上作为分解的结果；如果对表T的任何内容，F中的函数依赖都保证如下关系成立则称表T的一个分解相对于函数依赖集F是一个无损分解：</p><p>$T=T_1\infin T_2\infin…\infin T_k$</p><p>有时候表T被分解后，不能通过将分解出的表连接起来恢复原始表的所有信息，往往是因为<strong>我们得到了原先没有的行</strong></p><p>有损分解：$T\sub T_1\infin T_2\infin …\infin T_k$</p><img src="https://i.loli.net/2019/12/24/4rWG8jMvEP751Hw.png" style="zoom:67%;"><h3 id="数据库模式（Scheme）"><a href="#数据库模式（Scheme）" class="headerlink" title="数据库模式（Scheme）"></a>数据库模式（Scheme）</h3><p>一个数据库模式是数据库中<strong>所有表的标题的集合</strong>，以及设计者希望在那些表的连接上<strong>成立的所有函数依赖</strong>的集合</p><p>定理：给定表T和属性集$X\sub Head（T）$，下面的两个陈述是等价的：</p><ul><li>X是T的一个超键</li><li>$X→Head(T)$，即属性集X函数决定了T中的所有属性</li></ul><p>等价表述为：$X^+=Head(T)$</p><p>定理：给定表T和它的有效函数依赖集F，一个把T分为两个表${T_1,T_2}$的分解是T的一个无损分解，当且仅当$Head(T_1)$和$Head(T_2)$都是$Head(T)$的真子集，$Head(T)=Head(T_1)\cup Head(T_2)$，同时如如下函数依赖之一可以通过F推导出来：</p><ul><li>$Head(T_1)\cap Head(T_2)→Head(T_1)$</li><li>$Head(T_1)\cap Head(T_2)→Head(T_2)$$</li></ul><img src="https://i.loli.net/2019/12/24/bzK7pmkhJM2er9G.png" style="zoom:67%;"><h3 id="多表的无损连接分解"><a href="#多表的无损连接分解" class="headerlink" title="多表的无损连接分解"></a>多表的无损连接分解</h3><p>$T =&gt; { T_1, T_2, …,T_k }$</p><p>我们可以递归使用两个表的结果来证明分解是否是无损分解</p><p>$(((T_1;join;T_2);join;T_3) …;join;T_k)$</p><img src="https://i.loli.net/2019/12/24/cAa6KkWrEVzsuMC.png" style="zoom:67%;"><h2 id="范式-1"><a href="#范式-1" class="headerlink" title="范式"></a>范式</h2><p>模式中出现种种异常的根本原因：F中的一个函数依赖的左边的某个属性（也有可能是属性集合）在它出现的表中可能多次重复出现（也可能出现零次），解决方法是<strong>创建一个单独的表，把这个函数依赖左边的属性以及所有处于右边的所有属性放入其中</strong>，同时<strong>把右边的属性从它们先前出现的表中除去</strong>，这样<strong>函数依赖左边的属性在老的和新的表中都出现，而且决定所有新表中的其他属性，所以这个分解是无损的</strong>（当函数依赖集F中不再有其他函数依赖，我们就可以保证没有其他异常会产生，不需要进一步分解）</p><p>不需要进一步分解的标准：所有只涉及这个模式中单个表的属性的函数依赖只源自该表的键</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/Z8NHvuWxmABJKGD.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="依赖保持（FD-Preserved）"><a href="#依赖保持（FD-Preserved）" class="headerlink" title="依赖保持（FD Preserved）"></a>依赖保持（FD Preserved）</h3><p>设关系模式R上的函数依赖集为F，将关系模式R分解为${T_1, T_2, ……,T_k }$这k个子关系模式，从函数依赖集F中可以推导出的在子关系模式$T_i$上所存在的函数依赖集为$F_i (i=1,2,…,k)$；如果函数依赖集F和$（F_1\cup F_2\cup…\cup F_k）$是相互等价的，即$F^+ = (F_1\cup F_2\cup…\cup F_k)^+$，则我们称该分解是具有依赖保持性的</p><p>即是说，原表的函数依赖被分解后的多个表保持，因此无论何时模式中的一个表被更新，都可以验证任何被这个更新影响的函数依赖仍然有效（不会被破坏）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/vjfDouZ6K8M2PiO.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="超键"><a href="#超键" class="headerlink" title="超键"></a>超键</h3><p>给定表T和函数依赖集F、属性集X，<strong>X是一个超键当且仅当X函数决定T中的所有属性</strong><br>$$<br> X→Head(T);or;X^+_F = Head(T)<br>$$<br>候选键查找算法（候选键可能有多个）：</p><img src="https://i.loli.net/2019/12/24/sHvmf6TVSwxrWEU.png" style="zoom:67%;"><h3 id="主属性（Primary-Attribute）"><a href="#主属性（Primary-Attribute）" class="headerlink" title="主属性（Primary Attribute）"></a>主属性（Primary Attribute）</h3><p>表T的一个主属性是表T的键（不需要是一个主键）的任何一个属性；除此之外都是非主属性（Non-primary Attribute）</p><p>或者说在表T中，一个属性A称为是主属性当且仅当<strong>属性A存在这个表的某个键K中</strong></p><img src="https://i.loli.net/2019/12/24/oSLM3q784pNWQEF.png" style="zoom:80%;"><h3 id="BCNF（Boyce-Codd-Normal-Form，修正的第三范式）"><a href="#BCNF（Boyce-Codd-Normal-Form，修正的第三范式）" class="headerlink" title="BCNF（Boyce-Codd Normal Form，修正的第三范式）"></a>BCNF（Boyce-Codd Normal Form，修正的第三范式）</h3><p>一个数据库模式中的表T及函数依赖集F被称为符合BCNF的当且仅当：</p><p>任何F可推导出的函数依赖$X→A$都在T中，这里<strong>A是不在X中的单一属性，X必须是T的一个超键</strong>；</p><p>当一个数据库模式包含的所有表都符合BCNF时，这个数据库被称为符合BCNF</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/irFUARCZoLpQWuI.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我们希望总可以从一个通用的表开始进行无损分解到满足BCNF来保证函数依赖的保持</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/15zMjJX2QLaCEYr.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="3NF（Third-Normal-Form，第三范式）"><a href="#3NF（Third-Normal-Form，第三范式）" class="headerlink" title="3NF（Third Normal Form，第三范式）"></a>3NF（Third Normal Form，第三范式）</h3><p>对任何由F推导出来并存在于表T中的函数依赖$X→A$（这里A是单个属性且不在X中），下面两个属性之一必须成立：</p><ul><li>（A是T的一个非主属性时）X是T的一个超键</li><li>A是T的一个主属性</li></ul><p>当一个数据库模式包含的所有表符合3NF时，这个数据库模式称为符合3NF</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/xf2ASa6YHLpG8Cz.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>当一个表不能成为3NF时，它一定含有一个有效的非平凡函数依赖$X→A$，这里的<strong>A是非主属性且X不是T的一个超键</strong>；如果一个表是符合BCNF的，那么它一定符合3NF</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/9JmpYQZsAluo3HO.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>获得良好的3NF分解的算法（它产生一个符合第三范式且保持F中的函数依赖的如孙连接分解，算法的输出是数据库模式中表的标题（属性集合）的一个集合）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/WqBF6vNzfUtDPlp.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可以看到算法的包括三个过程：</p><ul><li>计算最小覆盖，然后后面的算法都是基于最小覆盖进行的</li><li>根据函数依赖来计算生成的新表</li><li>根据候选键计算生成的新表</li></ul><h3 id="2NF（Second-Normal-Form，第二范式）"><a href="#2NF（Second-Normal-Form，第二范式）" class="headerlink" title="2NF（Second Normal Form，第二范式）"></a>2NF（Second Normal Form，第二范式）</h3><p>对于存在于T中由F推导的任何函数依赖$X→A$（A是一个不在X中的单一属性而且是非主属性），<strong>X不是T的任何键K的真子集</strong>；</p><p>当一个数据库模式包含的所有表都符合2NF时，这个数据库模式称为符合2NF</p><p>可见，一个2NF的表，不允许有被键K的真子集函数决定的属性</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/w5ZcB7hHqWkroF1.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库-数据库设计&quot;&gt;&lt;a href=&quot;#数据库-数据库设计&quot; class=&quot;headerlink&quot; title=&quot;数据库 - 数据库设计&quot;&gt;&lt;/a&gt;数据库 - 数据库设计&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库-完整性、视图、安全性和目录</title>
    <link href="http://QQ876684433.github.io/2019/12/22/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AE%8C%E6%95%B4%E6%80%A7%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
    <id>http://QQ876684433.github.io/2019/12/22/数据库-完整性、视图、安全性和目录/</id>
    <published>2019-12-22T10:54:53.000Z</published>
    <updated>2019-12-25T03:18:09.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库-完整性、视图、安全性和目录"><a href="#数据库-完整性、视图、安全性和目录" class="headerlink" title="数据库 - 完整性、视图、安全性和目录"></a>数据库 - 完整性、视图、安全性和目录</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li></ul></blockquote><p>从数据库设计到物理形式</p><ul><li><p>创建表</p><ul><li>完整性约束（integrity constraints）</li></ul></li><li><p>创建视图</p></li><li><p>安全性</p><ul><li>GRANT和REVOKE语句</li></ul></li><li><p>目录</p><ul><li>模式（Schemes）</li></ul></li></ul><h2 id="完整性约束（Integrity-Constraints）"><a href="#完整性约束（Integrity-Constraints）" class="headerlink" title="完整性约束（Integrity Constraints）"></a>完整性约束（Integrity Constraints）</h2><p>所有违背完整性约束的更新操作——Insert、Update或Delete——都是不能执行的</p><h3 id="CREATE-TABLE"><a href="#CREATE-TABLE" class="headerlink" title="CREATE TABLE"></a>CREATE TABLE</h3><h4 id="CREATE-TABLE语句"><a href="#CREATE-TABLE语句" class="headerlink" title="CREATE TABLE语句"></a>CREATE TABLE语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [schema.]<span class="keyword">table</span></span><br><span class="line">(</span><br><span class="line">    &#123; <span class="keyword">column</span> datatype [<span class="keyword">DEFAULT</span> expr]</span><br><span class="line">    [ col_constraint &#123; , col_constraint &#125; ]</span><br><span class="line">    &#125;</span><br><span class="line">    |</span><br><span class="line">    [ table_constraint &#123; , table_constraint &#125; ]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>它包括以下的一些信息：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/kSLGyBzJHvw9gOT.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customers (</span><br><span class="line">    cid <span class="built_in">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    cname <span class="built_in">varchar</span>(<span class="number">13</span>),</span><br><span class="line">    city <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    discnt <span class="built_in">real</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(cid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><ul><li><p>对于单列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; NOT NULL |</span><br><span class="line">    [ CONSTRAINT constraint_name ]</span><br><span class="line">        UNIQUE</span><br><span class="line">        | PRIMARY KEY</span><br><span class="line">        | <span class="keyword">CHECK</span> ( search_condition )</span><br><span class="line">        | <span class="keyword">REFERENCES</span> table_name [ ( column_name ) ]</span><br><span class="line">            [<span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>|RESTRICT|<span class="keyword">SET</span> <span class="literal">NULL</span>]</span><br><span class="line">            [<span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span>|RESTRICT|<span class="keyword">SET</span> <span class="literal">NULL</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于多列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ CONSTRAINT constraint_name ]</span><br><span class="line">&#123; UNIQUE ( colname &#123; , colname ... &#125; )</span><br><span class="line">    | PRIMARY KEY ( colname &#123; , colname ... &#125; )</span><br><span class="line">    | <span class="keyword">CHECK</span> ( search_condition )</span><br><span class="line">    | <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> ( colname &#123; , colname ... &#125; )</span><br><span class="line">    <span class="keyword">REFERENCES</span> tab_name [ (colname &#123;, ...&#125;) ]</span><br><span class="line">    [<span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>|RESTRICT|<span class="keyword">SET</span> <span class="literal">NULL</span>]</span><br><span class="line">    [<span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span>|RESTRICT|<span class="keyword">SET</span> <span class="literal">NULL</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="列约束"><a href="#列约束" class="headerlink" title="列约束"></a>列约束</h5><ul><li><p>NOT NULL表示列中不能出现空值，且DEFAULT子句不能指定为NULL；如果既没有DEFAULT子句也没有NOT NULL子句，那么<strong>缺省地使用DEFAULT NULL</strong></p></li><li><p>CONSTRAINT constraintname子句可以为除了NOT NULL子句以外的列约束命名；它是可选的，可以通过ALTER TABLE语句和constraintname来去掉该约束</p></li><li><p>UNIQUE表明该列中的所有的非空值必须是唯一的，但允许多个空值存在；其中，<strong>如果一列既声明为NOT NULL又声明为UNIQUE，那么该列成为候选键</strong></p></li><li><p>PRIMARY KEY子句指定一列为主键——被REFERENCES子句中的另一个表<strong>缺省引用的候选键</strong>；隐式为NOT NULL和UNIQUE；<strong>一个CREATE TABLE中至多包含一个PRIMARY KEY子句（不论是表约束还是列约束）</strong>；</p><p>PRIMARY KEY不能和UNIQUE出现在一列上，但可以和NOT NULL一起用</p></li><li><p>如果出现CHECK子句，那么每一行该列必须包含满足特定的搜索条件的值</p></li><li><p>如果一列用REFERENCES table_name [ ( column_name ) ]子句定义，该列中的值或者为空，或者是在被引用表的一列中出现的值；被引用的表中的列或者是该表的单列主键（缺省），或者是在REFERENCES子句中可选的列名处指定的列</p><p>被引用表中指定的列的值必须是唯一的，否则包含REFERENCES子句的CREATE TABLE语句将失败（但允许为空值）</p><ul><li><p>ON DELETE CASCADE子句</p><p>（很混乱，直接贴原图，可能在下面的表约束中讲的比较清晰，参考：<a href="https://dba.stackexchange.com/questions/44956/good-explanation-of-cascade-on-delete-update-behavior）" target="_blank" rel="noopener">https://dba.stackexchange.com/questions/44956/good-explanation-of-cascade-on-delete-update-behavior）</a></p><p><img src="https://i.loli.net/2019/12/24/bahMElJnD42Gyfv.png" alt></p></li><li><p>NO DELETE子句</p><p>被引用的行不允许被删除</p></li></ul></li></ul><h5 id="表约束"><a href="#表约束" class="headerlink" title="表约束"></a>表约束</h5><p>（跟列约束差不多，直接上图）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/mErPDC4xfJnHUAK.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="主键、外键和参照完整性"><a href="#主键、外键和参照完整性" class="headerlink" title="主键、外键和参照完整性"></a>主键、外键和参照完整性</h3><h4 id="外键（Foreign-Key）"><a href="#外键（Foreign-Key）" class="headerlink" title="外键（Foreign Key）"></a>外键（Foreign Key）</h4><p>如果表$T_1$中任意行的F的值的组合，至少包含一个空值或与被引用表$T_2$中<strong>为候选键或主键的列集合P</strong>的组合值匹配，则列集合F被定义为外键</p><p>如果外键支持的关系是可选参与，则外键中至少有一列的值必须为可空的</p><h4 id="参照完整性（Referential-Integrity）"><a href="#参照完整性（Referential-Integrity）" class="headerlink" title="参照完整性（Referential Integrity）"></a>参照完整性（Referential Integrity）</h4><p>如果表$T_1$的每一行中F的列都满足：</p><ul><li>至少有一列为空值（如果该列允许为空，<strong>此时整个外键是无效的</strong>）</li><li>如果不包含空值，就必须与表$T_2$中某些行的相应P的组合值相等</li></ul><p>则参照完整性约束是有效的</p><h4 id="外键约束（Foreign-Key-Constraints）"><a href="#外键约束（Foreign-Key-Constraints）" class="headerlink" title="外键约束（Foreign Key Constraints）"></a>外键约束（Foreign Key Constraints）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/RelOup8EXSfWD12.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/h8OikEpzl6v9mbH.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/il9Ze5PHLSDhuaE.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/g3wc6hRmPTHDerB.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="ALTER-TABLE语句"><a href="#ALTER-TABLE语句" class="headerlink" title="ALTER TABLE语句"></a>ALTER TABLE语句</h3><p>用来修改表的结构和完整性约束</p><ul><li>列<ul><li>ADD</li><li>DROP</li><li>MODIFY</li></ul></li><li>约束<ul><li>ADD</li><li>DROP</li></ul></li></ul><h3 id="数据库触发器"><a href="#数据库触发器" class="headerlink" title="数据库触发器"></a>数据库触发器</h3><p>数据库触发器是过程性代码，响应于数据库中特定表或视图上的某些事件而自动执行；数据库触发器通常用来维护数据库信息的完整性</p><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name &#123; <span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span> &#125;</span><br><span class="line">    &#123; <span class="keyword">INSERT</span> | <span class="keyword">DELETE</span></span><br><span class="line">    | <span class="keyword">UPDATE</span> [ <span class="keyword">OF</span> colname &#123; , colname ... &#125; ] &#125;</span><br><span class="line">    <span class="keyword">ON</span> table_name</span><br><span class="line">    [ <span class="keyword">REFERENCING</span> corr_name_def &#123; , ...... &#125; ]</span><br><span class="line">    [ <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> | <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">STATEMENT</span> ]</span><br><span class="line">        [ <span class="keyword">WHEN</span> ( search_condition ) ]</span><br><span class="line">        &#123; <span class="keyword">statement</span></span><br><span class="line">        | BEGIN ATOMIC statement; &#123; ... &#125; END</span><br></pre></td></tr></table></figure><p>其中corr_name_def是用来定义别名的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; OLD [ ROW ] [ AS ] old_row_corr_name</span><br><span class="line">    | NEW [ ROW ] [ AS ] new_row_corr_name</span><br><span class="line">    | OLD TABLE [ AS ] old_table_corr_name</span><br><span class="line">    | NEW TABLE [ AS ] new_table_corr_name &#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/24/f9yjrNqmuigC6OP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>两类更新触发器：</p><ul><li><p>行级别触发器（Row Level Trigger）</p><p>在某一行的任意一列的值发生改变前或者改变后触发执行</p></li><li><p>列级别触发器（Column Level Trigger）</p><p>在某一特定列的值发生改变前或者发生改变后触发执行</p></li></ul><p>四种触发器</p><ul><li>For Each Row Type<ul><li>This trigger gets executed once for each row of the result set affected by an insert/update/delete</li><li>before/after</li></ul></li><li>For Each Statement Type<ul><li>This trigger gets executed only once for the entire result set, but fires each time the statement is executed</li><li>before/after</li></ul></li></ul><p>例子：</p><p>删除一个客户元组时， 需要将该客户所有订单上的cid置为空值(set null)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> foreign_cid</span><br><span class="line">    <span class="keyword">after</span> <span class="keyword">delete</span> <span class="keyword">on</span> customers</span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">old</span> <span class="keyword">as</span> old_custom</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">update</span> orders</span><br><span class="line">            <span class="keyword">set</span> cid = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">where</span> cid = :old_custom.cid ;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><h3 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h3><ul><li><p>Idea</p><p>SQL SELECT语句查询到的数据是以表的形式得到的，我们希望能够在其他SELECT语句中的FROM子句中使用这张表</p></li><li><p>Method</p><ul><li>FROM子句中进行子查询</li><li>创建视图</li></ul></li></ul><h3 id="视图表（View-Table）"><a href="#视图表（View-Table）" class="headerlink" title="视图表（View Table）"></a>视图表（View Table）</h3><p>定义：视图表是子查询得到的表，但是它有自己的名字（表名和属性名）；它可以像<strong>基本表（BASE TABLE</strong>，由CREATE TABLE语句创建的）一样使用</p><ul><li><p>属性</p><ul><li>它不会产生数据存储，只是基本表数据的一个窗口；通常被看做<strong>虚拟表（Virtual Table）</strong></li></ul></li><li><p>缺点</p><ul><li>视图更新有限制</li></ul></li></ul><h3 id="创建视图的语句"><a href="#创建视图的语句" class="headerlink" title="创建视图的语句"></a>创建视图的语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name [(col_name &#123;, …...&#125;)]</span><br><span class="line"><span class="keyword">AS</span> subquery</span><br><span class="line">[ <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span> ]</span><br></pre></td></tr></table></figure><ul><li><p>列名的列表[(col_name {, ……})]</p><ul><li><p>subquery的Select子句中不需要限定词的列名可以直接放入列名列表</p></li><li><p>对于subquery的Select子句中的表达式或者有歧义的列名，列名列表中需要为这些列名给出新的列名</p></li><li><p>可以给列以任何方式重命名</p></li></ul></li><li><p>子查询subquery</p></li><li><p>只比完整的Select子句少一个ORDER BY子句</p></li><li><p>WITH CHECK OPTION</p><ul><li>如果对可更新视图的update或者insert操作，它们会导致修改的行的结果在视图的子查询中变成是不可见的，那么这个操作将不被允许</li></ul><p>例子：</p><p><img src="https://i.loli.net/2019/12/24/X9oMGc3Z5Q6JsTi.png" alt></p><blockquote><p>通过有with check option选项的视图操作基表(只是面对单表，对连接多表的视图正在寻找答案)，有以下结论：<br>首先视图只操作它可以查询出来的数据，对于它查询不出的数据，即使基表有，也不可以通过视图来操作。<br>1.对于update,有with check option，要保证update后，数据要被视图查询出来<br>2.对于delete,有无with check option都一样<br>4.对于insert,有with check option，要保证insert后，数据要被视图查询出来<br>对于没有where 子句的视图，使用with check option是多余的</p><p>来源：<a href="https://blog.csdn.net/chunhua_love/article/details/9196599" target="_blank" rel="noopener">https://blog.csdn.net/chunhua_love/article/details/9196599</a></p><p>要避免将某个视图的某一行更新为使其不再满足视图的条件，请在创建视图时添加 WITH CHECK OPTION 关键字。该子句要求数据库服务器对插入或更新的每一行进行测试，以确保其符合视图的 WHERE 子句设置的条件。如果不符合条件，那么数据库服务器将拒绝该操作，并显示错误</p><p>来源：<a href="https://www.ibm.com/support/knowledgecenter/zh/SSGU8G_12.1.0/com.ibm.ddi.doc/ids_ddi_096.htm" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/zh/SSGU8G_12.1.0/com.ibm.ddi.doc/ids_ddi_096.htm</a></p></blockquote></li></ul><p>不是所有的视图都能接受更新并将更新实施到基本表上；可以被更新的视图称为<strong>可更新视图</strong></p><h3 id="嵌套视图定义（Nested-View-definition）"><a href="#嵌套视图定义（Nested-View-definition）" class="headerlink" title="嵌套视图定义（Nested View definition）"></a>嵌套视图定义（Nested View definition）</h3><p>基于其他视图创建新的视图</p><h3 id="创建视图语句的执行"><a href="#创建视图语句的执行" class="headerlink" title="创建视图语句的执行"></a>创建视图语句的执行</h3><ul><li>视图的定义会作为数据库的一个<strong>独立的对象</strong>存放在系统目录中</li><li>但是没有数据被检索或者存储</li></ul><h3 id="通过视图的操作"><a href="#通过视图的操作" class="headerlink" title="通过视图的操作"></a>通过视图的操作</h3><ul><li>查询修改<ul><li>访问视图的更新或者查询语句可以被修改（修改成实际的访问执行语句）</li><li>因此对视图的更新或者查询操作实际上是对基本表的访问</li></ul></li></ul><h3 id="视图的特权"><a href="#视图的特权" class="headerlink" title="视图的特权"></a>视图的特权</h3><ul><li><p>创建视图的用户是该视图的拥有者</p></li><li><p>视图的拥有者拥有对视图的更新权限，前提是：</p><ul><li><p>视图是可更新的</p></li><li><p>对于视图定义的基本表，用户必须拥有对该基本表的更新权限</p></li></ul></li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="创建视图-1"><a href="#创建视图-1" class="headerlink" title="创建视图"></a>创建视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> agentorders (ordno, <span class="keyword">month</span>, cid, aid,</span><br><span class="line">    pid, qty, charge, aname, acity, <span class="keyword">percent</span>)</span><br><span class="line">    <span class="keyword">AS</span> <span class="keyword">SELECT</span> o.ordno, o.month, o.cid, o.aid, o.pid,</span><br><span class="line">    o.qty, o.dollars, a.aname, a.city, a.percent</span><br><span class="line">        <span class="keyword">FROM</span> orders o, agents a</span><br><span class="line">        <span class="keyword">WHERE</span> o.aid = a.aid;</span><br></pre></td></tr></table></figure><p>由于上面的Select子句的列名列表可以不需要限定词，因此等价于下面的定义：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> agentorders</span><br><span class="line">    <span class="keyword">AS</span> <span class="keyword">SELECT</span> o.ordno, o.month, o.cid, o.aid, o.pid,</span><br><span class="line">    o.qty, o.dollars, a.aname, a.city, a.percent</span><br><span class="line">        <span class="keyword">FROM</span> orders o, agents a</span><br><span class="line">        <span class="keyword">WHERE</span> o.aid = a.aid;</span><br></pre></td></tr></table></figure><h4 id="基于视图的查询"><a href="#基于视图的查询" class="headerlink" title="基于视图的查询"></a>基于视图的查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span> (charge)</span><br><span class="line"><span class="keyword">FROM</span> agentorders</span><br><span class="line"><span class="keyword">WHERE</span> acity = <span class="string">'Toledo'</span>;</span><br></pre></td></tr></table></figure><h4 id="查询修改"><a href="#查询修改" class="headerlink" title="查询修改"></a>查询修改</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/25/cgrdDqRUI2XK4pu.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="非法视图定义"><a href="#非法视图定义" class="headerlink" title="非法视图定义"></a>非法视图定义</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/25/nM7l91i2WILdetc.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>原因是c.city 和 a.city的限定词不能去掉，否则会出现歧义，因此必须在列名列表中给它们重命名</p><h4 id="创建带有WITH-CHECK-OPTION的视图定义"><a href="#创建带有WITH-CHECK-OPTION的视图定义" class="headerlink" title="创建带有WITH CHECK OPTION的视图定义"></a>创建带有WITH CHECK OPTION的视图定义</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> custs <span class="keyword">AS</span></span><br><span class="line">    <span class="keyword">SELECT</span> *</span><br><span class="line">    <span class="keyword">FROM</span> customers</span><br><span class="line">    <span class="keyword">WHERE</span> discnt &lt;= <span class="number">15.0</span></span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>;</span><br></pre></td></tr></table></figure><p>假设customers的属性discnt没有CHECK子句，那么以下操作将失败：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> custs <span class="keyword">values</span>(‘c009’, ‘AM’, ‘Kyoto’, <span class="number">16.0</span>);</span><br></pre></td></tr></table></figure><p>因为不能将discnt&gt;15.0的行插入或者更新到custs中</p><p>但是对于以下更新：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> custs <span class="keyword">set</span> discnt = discnt + <span class="number">4.0</span>;</span><br></pre></td></tr></table></figure><p>PPT上面的原话是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/25/CwZQEndGvMm7Wia.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>*<u>有个问题不太明白就是：这个更新操作到底是部分执行成功（即除了c002外，其他的行的discnt都完成了+4.0的更新），还是整个失败（即没有任何行更新成功）？目前尚未找到相关资料</u>*</p><p>当然上面的插入和更新操作在基本表上是可以成功执行的</p><h4 id="嵌套视图"><a href="#嵌套视图" class="headerlink" title="嵌套视图"></a>嵌套视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> acorders (ordno, <span class="keyword">month</span>, cid, aid,</span><br><span class="line">pid, qty, dollars, aname, cname)</span><br><span class="line">    <span class="keyword">AS</span> <span class="keyword">SELECT</span> ao.ordno, ao.month, ao.cid, ao.aid,</span><br><span class="line">            ao.pid, ao.qty, ao.charge, ao.aname,</span><br><span class="line">            c.cname</span><br><span class="line">        <span class="keyword">FROM</span> agentorders ao, customers c</span><br><span class="line">        <span class="keyword">WHERE</span> ao.cid = c.cid;</span><br></pre></td></tr></table></figure><h3 id="列出已定义的视图"><a href="#列出已定义的视图" class="headerlink" title="列出已定义的视图"></a>列出已定义的视图</h3><ul><li><p>在oracle中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> view_name <span class="keyword">from</span> user_views;</span><br><span class="line"><span class="keyword">DESCRIBE</span> &#123; view_name | table_name &#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除表和视图"><a href="#删除表和视图" class="headerlink" title="删除表和视图"></a>删除表和视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123; <span class="keyword">TABLE</span> table_name | <span class="keyword">VIEW</span> view_name &#125;</span><br><span class="line">&#123; <span class="keyword">CASCADE</span> | RESTRICT &#125;;</span><br></pre></td></tr></table></figure><ul><li>注意：当仅仅删除视图表的时候，不会删除任何实际的数据表中的行</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/25/BfXloN13Uby7k95.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="可更新和只读视图"><a href="#可更新和只读视图" class="headerlink" title="可更新和只读视图"></a>可更新和只读视图</h3><p>视图不允许更新的最充分理由是：有时不知道如何将对视图的更新转化成对其基本表的更新，以反映视图的创建者和提出更新要求的用户的意图</p><p>由连接操作得到的视图都不能被更新</p><ul><li>可更新视图：允许Insert、Update和Delete操作</li><li>只读视图则不允许（所有的基本表都被认为是可更新的）</li></ul><p>一个视图是可更新视图时必须遵守的标准规则</p><p>一个视图表是可更新的当且仅当它的subquery子句的下列条件成立：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/25/HZn1c9XDgkxGjzR.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>The FROM clause of the Subquery must contain only a single table, and if that table is a view table it must also be an updatable view table.</li><li>Neither the GROUP BY nor HAVING clause is present.</li><li>The DISTINCT keyword is not specified.</li><li>The WHERE clause does not contain a Subquery that references any table in the FROM clause, directly or indirectly via views.</li><li>All result columns of the Subquery are simple column names: no expressions, no column name appears more than once.</li></ul><p>下面两个例子都是只读视图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/25/O2iv1LKZaSECz7m.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>第一个视图定义中的FROM子句包含了两个表</li><li>第二个视图定义中subquery的Select子句出现了表达式：sum(dollars)</li></ul><h3 id="ORACLE中的可更新视图"><a href="#ORACLE中的可更新视图" class="headerlink" title="ORACLE中的可更新视图"></a>ORACLE中的可更新视图</h3><ul><li><p>可以更新join视图，当一下两个条件同时成立：</p><ul><li>join是一个N-1（多对一）联系</li><li>视图的列包含“N方”表的主键（这样得到的是无损连接）</li></ul><p><img src="https://i.loli.net/2019/12/25/8kiDNSKn1IXZ6Gj.png" alt></p></li><li><p>并且我们<strong>只能更新视图中原先位于“N方”表中的属性</strong></p><p>如下的例子中，我们只能更新与表orders一对一的列，不能更新列aname，acity和percent，也不能修改决定连接的列aid</p><p>例子：</p><img src="https://i.loli.net/2019/12/25/3YhzKrIQ1UWoiOa.png" style="zoom:67%;"><img src="https://i.loli.net/2019/12/25/9OiGBuxCtq6TrFI.png" style="zoom:67%;"></li><li><p>显示该视图中的可更新列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name, updatable</span><br><span class="line"><span class="keyword">from</span> user_updatable_columns</span><br><span class="line"><span class="keyword">where</span> table_name = ‘AGENTORDERS’</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图的价值"><a href="#视图的价值" class="headerlink" title="视图的价值"></a>视图的价值</h3><ul><li><p>视图提供了一种方法，使复杂的、经常用到的查询写起来更容易</p></li><li><p>视图允许过时的表和引用过时表的程序不被重新组织</p><ul><li>通过这种方法，可以使得对数据的访问独立于其物理结构的改变，这一特性被称为<strong>程序数据独立性</strong>（program-data independence）</li></ul></li><li><p>视图加入了一种安全措施，让不同的用户以不同的方式看相同的数据</p><ul><li>例如我们可以对同一个表employeess建立不同的视图，对访问这些视图的不同用户采用不同的安全措施</li></ul></li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="SQL中的GRANT语句"><a href="#SQL中的GRANT语句" class="headerlink" title="SQL中的GRANT语句"></a>SQL中的GRANT语句</h3><p>助记：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> ... <span class="keyword">ON</span> ... <span class="keyword">TO</span> ... ;</span><br></pre></td></tr></table></figure><p>完整的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &#123;<span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span>|privilege &#123;, privilege … &#125;&#125;</span><br><span class="line">    <span class="keyword">ON</span> [ <span class="keyword">TABLE</span> ] tablename | viewname</span><br><span class="line">    <span class="keyword">TO</span> &#123; <span class="keyword">PUBLIC</span> | <span class="keyword">user</span>-<span class="keyword">name</span> &#123; , <span class="keyword">user</span>-<span class="keyword">name</span> … &#125; &#125;</span><br><span class="line">    [ <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span> ]</span><br></pre></td></tr></table></figure><ul><li><p>GRANT语句是被表的拥有者使用的</p><ul><li>表的拥有者拥有该表的所有特权，并且不能被取消</li><li>其他用户如果没有相关的权限就不能访问该表</li></ul></li><li><p><strong>列特权（column privileges）</strong>可以通过视图来实现</p></li><li><p>特权（privileges）</p><p>若要在一个视图上授予插入、删除或更新权限，<strong>视图必须是可更新的</strong></p><ul><li><p>SELECT, DELETE, INSERT</p></li><li><p>UPDATE [ col_name {, col_name …} ]</p><p>如果UPDATE权限中没有指定列名列表，表中现有或将会有的所有列都会加上这一权限</p></li><li><p>REFERENCES [ col_name {, col_name …} ]</p><ul><li>允许用户在引用该表的表上建立外键约束</li></ul></li></ul></li><li><p>PUBLIC</p><p>数据库中现在以及将来的用户</p></li><li><p>WITH GRANT OPTION</p><p>可选的，允许有这个权限的用户授予其他用户同样的权限</p></li></ul><p>例子：</p><ul><li><p>表特权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> customers <span class="keyword">to</span> eoneil;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">update</span>, <span class="keyword">insert</span> <span class="keyword">on</span> orders <span class="keyword">to</span> eoneil;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> products <span class="keyword">to</span> eoneil;</span><br></pre></td></tr></table></figure></li><li><p>视图特权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> custview <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> cid, cname, city <span class="keyword">from</span> customers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span>, <span class="keyword">delete</span>, <span class="keyword">insert</span>,</span><br><span class="line">    <span class="keyword">update</span>(cname, city) <span class="keyword">on</span> custview</span><br><span class="line">    <span class="keyword">to</span> eoneil;</span><br></pre></td></tr></table></figure><p>这种情况下，被授权的用户enoneil<strong>不需要拥有对基本表的相应权限</strong></p></li></ul><h3 id="SQL中的REVOKE语句"><a href="#SQL中的REVOKE语句" class="headerlink" title="SQL中的REVOKE语句"></a>SQL中的REVOKE语句</h3><p>助记：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> ... <span class="keyword">ON</span> ... <span class="keyword">FROM</span> ... ;</span><br></pre></td></tr></table></figure><p>完整语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &#123; <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span></span><br><span class="line">    | privilege &#123;, privilege …&#125; &#125;</span><br><span class="line">    <span class="keyword">ON</span> tablename | viewname</span><br><span class="line">    <span class="keyword">FROM</span> &#123; <span class="keyword">PUBLIC</span> | <span class="keyword">user</span>-<span class="keyword">name</span> &#123;, <span class="keyword">user</span>-<span class="keyword">name</span> … &#125;&#125;</span><br><span class="line">    &#123; <span class="keyword">CASCADE</span> | RESTRICT &#125;</span><br></pre></td></tr></table></figure><h2 id="系统目录和模式"><a href="#系统目录和模式" class="headerlink" title="系统目录和模式"></a>系统目录和模式</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><h4 id="数据字典（data-dictionary）"><a href="#数据字典（data-dictionary）" class="headerlink" title="数据字典（data dictionary）"></a>数据字典（data dictionary）</h4><p>所有由SQL命令创建出来的对象都作为表的对象列举出来，并且由系统来维护</p><h3 id="模式（scheme）"><a href="#模式（scheme）" class="headerlink" title="模式（scheme）"></a>模式（scheme）</h3><p><strong>模式是表、视图、索引及其他与数据库有关的对象的集合，这些对象通常是为单个用户设计的</strong>；数据库目录中表的完整名是：<code>模式名.表格名</code>（模式名通常是一个用户名）</p><p>这样的命名系统允许不同的用户使用同名的表，而不会在整个数据库中造成混淆</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/25/Z5XxKfn6MsgiRNb.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库-完整性、视图、安全性和目录&quot;&gt;&lt;a href=&quot;#数据库-完整性、视图、安全性和目录&quot; class=&quot;headerlink&quot; title=&quot;数据库 - 完整性、视图、安全性和目录&quot;&gt;&lt;/a&gt;数据库 - 完整性、视图、安全性和目录&lt;/h1&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-文件管理</title>
    <link href="http://QQ876684433.github.io/2019/12/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>http://QQ876684433.github.io/2019/12/21/操作系统-文件管理/</id>
    <published>2019-12-21T10:17:13.000Z</published>
    <updated>2019-12-22T09:10:25.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li></ul></blockquote><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><blockquote><p>简单内容直接阅读第5章PPT1和2，这里略过</p></blockquote><h3 id="文件存取方法"><a href="#文件存取方法" class="headerlink" title="文件存取方法"></a>文件存取方法</h3><p>存取方法是指<strong>读写文件存储器上的物理记录</strong>的方法，常见的有：</p><ul><li><p>顺序存取</p><p>无论是无结构的字节流文件，还是有结构的记录式文件，存取操作都是<strong>在上次操作的基础上进行</strong>；系统设置两个位置指针，指向要读出或写入的字节位置或记录位置，并且根据读出或写入的字节个数或记录号，系统自动修改相应的指针值</p><p>允许对固定长度记录的顺序文件采用随机访问（类似于数组访问）</p><p>顺序存取主要用于<strong>磁带文件</strong>，但也适用于<strong>磁盘上的顺序文件</strong></p></li><li><p>直接存取（随机存取）</p><p>可以<strong>非顺序地</strong>从文件中的<strong>任何位置</strong>存取文件内容</p><p>为了实现直接存取，一个文件可以看作由顺序编号的物理块组成，这些块划分成等长，作为定位和存取的最小单位</p></li><li><p>索引存取</p><p>基于索引文件的存取方法，由于文件中的记录<strong>不按位置而是按其记录名或记录键来编址</strong>，因此用户提供记录名或记录键之后，先按名搜索，再查找所需要的记录</p><p>在实际系统中，大都采用<strong>多级索引</strong>以加速记录的查找过程</p></li></ul><h3 id="文件的安全与保护"><a href="#文件的安全与保护" class="headerlink" title="文件的安全与保护"></a>文件的安全与保护</h3><p>文件是计算机系统的重要资源， 因此， 要求文件系统具有保障文件安全的手段， 提供文件保密的措施， 有效地实现文件的共享</p><ul><li><p><strong>文件共享</strong>是指不同用户共同使用某些文件</p></li><li><p><strong>文件保护</strong>是指防止文件被破坏</p><p>常用的文件保护办法</p><ol><li><p>文件副本：文件系统必须要有<strong>防止硬软件故障</strong>，<strong>保存信息完整性</strong>的能力</p><p>文件副本是主要实现机制</p><ul><li><p>动态多副本技术：在多个介质上维持同一内容的文件， 并且在更新内容时同时进行</p><p>这种方法需要增加设备费用和系统负载一般适用<strong>于容量较小且较为重要</strong>的文件， 例如不需更新的系统文件及专用文件， 当文件发生故障时只要切换到备用设备就可</p></li><li><p>转储、 备份与恢复：定时把文件复制转储到其它介质上， 当某介质上出现故障时， 复原转储文件</p><p>转储又可分成两种方式：</p><ul><li>在一定时间间隔或一个单位处理结束时， 系统自动复写更新过的文件和数据</li><li>每天或每周把文件信息全部复写一遍，需要时再通过装入转储文件来恢复系统，诸如BACKUP、 RESTORE等命令</li></ul></li></ul></li><li><p>文件存取矩阵与文件存取表</p><p>系统为每个用户设置访问每个文件对象的存取属性；系统的全部用户对全部文件的存取属性就组成的一个二维矩阵， 称为存取控制矩阵</p><p><img src="https://i.loli.net/2019/12/22/ZwJyBzePbiRCmh1.png" alt></p><p>由于操作系统拥有很多用户和众多文件，存取控制矩阵是一个稀疏矩阵， 可以将其简化为一张存取控制表；每行包括： 用户、 文件、 存取属性；存取控制表<strong>仅登记那些对文件拥有存取属性的部分</strong></p><p>系统通过查阅(矩阵/表)核对用户对文件的存取权限</p><p>文件属主使用GRANT、 REVOKE等命令进行授权， 甚至把授权权转授给他信任的用户</p><p>系统管理用户（超级用户） 等同于文件属主权限， 并获得对系统文件的授访问权权限；系统管理员/系统用户对文件的访问身份都是<strong>以文件属主的身份</strong>访问</p></li><li><p>文件属性</p><p>存取控制表的一种<strong>简化方法</strong>是用户分类（用户分类： 属主、 合作者、 其他），再针对每类用户规定文件属性（文件属性： 读、 写、 执行、 …）</p><p>文件属性可以<strong>放在文件目录项</strong>中， 管理大为简化；用户使用文件时， 通过核对文件属性，实现保护</p></li></ol></li><li><p><strong>文件保密</strong>则是指文件及其内容不能被未经文件主授权的其他用户窃取</p><p>文件的保密措施有以下几种：</p><ol><li>隐蔽文件目录</li><li>设置口令</li><li>使用密码</li></ol></li></ul><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><ul><li>文件目录是实现文件的<strong>按名存取</strong>的关键数据结构</li><li>文件系统的基本功能之一就是负责文件目录的建立、 维护和检索， 要求编排的目录便于查找、 防止冲突</li><li>文件目录需要永久保存， 因此也组织成文件存放在磁盘上， 称<strong>目录文件</strong></li></ul><h3 id="文件控制块、文件目录与目录文件"><a href="#文件控制块、文件目录与目录文件" class="headerlink" title="文件控制块、文件目录与目录文件"></a>文件控制块、文件目录与目录文件</h3><p>文件控制块（File Control Block, FCB）是操作系统为每个文件建立的唯一数据结构，于是一个文件由两部分组成：FCB和文件体（文件信息）；有了FCB就可以方便地实现文件的按名存取</p><p>为了加快文件查找速度，通常把FCB汇集和组织在一起形成文件目录，文件目录包含许多目录项，目录项有两种，分别用来<strong>描述子目录</strong>和<strong>描述文件</strong>，全部的目录项所构成的文件称为目录文件，并保存在外存上，查找文件时调入内存工作区</p><p>目录文件永远不会空，它至少包含两个目录项：当前目录项<code>.</code>和父目录项<code>..</code></p><p>文件目录的作用是将文件名转换成文件信息在磁盘上的物理位置</p><h3 id="层次目录结构"><a href="#层次目录结构" class="headerlink" title="层次目录结构"></a>层次目录结构</h3><h4 id="一级目录结构"><a href="#一级目录结构" class="headerlink" title="一级目录结构"></a>一级目录结构</h4><p>所有FCB排列在一张线性表中，与每个文件的相关属性占用一个目录项， 构成了一级目录结构</p><p>缺点：文件重名和文件共享问题难以解决</p><h4 id="二级目录结构"><a href="#二级目录结构" class="headerlink" title="二级目录结构"></a>二级目录结构</h4><ul><li>第一级为主文件目录， 它用于管理所有用户文件目录， 它的目录项登记了<strong>系统接受的用户的名字</strong>及<strong>该用户文件目录的地址</strong></li><li>第二级为用户的文件目录， 它为该用户的每个文件保存一个登记栏， 其内容与一级目录的目录项相同</li><li><strong>每一用户只允许查看自己的文件目录</strong></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/6XEkFPW1wevdTgf.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>特点：</p><ul><li>采用二级目录管理文件时， 因为任何文件的存取都通过主文件目录， 于是可以<strong>检查访问文件者的存取权限</strong>， 避免一个用户未经授权就存取另一个用户的文件， 使用户文件的私有性得到保证， 实现了对文件的保密和保护</li><li>特别是不同用户具有同名文件时， 由于各自有不同的用户文件目录而不会导致混乱</li><li>对于同一个用户而言， 同样存在文件多、 容易重名问题</li></ul><h4 id="树形目录结构"><a href="#树形目录结构" class="headerlink" title="树形目录结构"></a>树形目录结构</h4><ul><li><p>每一级目录可以登记下一级目录， 也可以登记文件， 从而形成了层次文件目录结构</p></li><li><p>层次目录结构通常采用树形目录结构，它是一棵倒向的有根树， 树根是根目录； 从根向下， 每一个<strong>树分叉是一个子目录</strong>； 而<strong>树叶是文件</strong></p></li></ul><p>特点：</p><ul><li>较好地反映现实世界中<strong>具有层次关系的数据集合</strong>和较确切地反映<strong>系统内部文件的组织结构</strong></li><li>不同文件可以重名， 只要它们不位于同一末端的子目录中</li><li>易于规定<strong>不同层次或子树中文件的不同存取权限</strong>， 便于文件的保护、 保密和共享</li></ul><p>一个<strong>文件的全名</strong>包括从根目录开始到文件为止， 通路上遇到的所有子目录路径， 又称为路径名</p><p>如果每个文件都只有一个父目录，那么称为纯树型目录结构</p><p>有向无环图目录结构中一个文件可能有多个父目录，<strong>需要为每个文件维护一个引用计数</strong>，用来记录文件的父目录个数，当且仅当引用计数值为1时，删除操作才移去文件，否则仅仅把相关记录从父目录中删除，引用计数减1</p><h3 id="文件目录检索"><a href="#文件目录检索" class="headerlink" title="文件目录检索"></a>文件目录检索</h3><p>每个目录在创建时都自动含有两个特殊目录项：</p><ul><li><code>.</code>项指出目录自身的inode入口</li><li><code>..</code>项指出其父目录的inode入口</li></ul><p>当<code>.</code>和<code>..</code>都指向同一个inode时，说明当前目录是根目录</p><h2 id="文件组织与数据存储"><a href="#文件组织与数据存储" class="headerlink" title="文件组织与数据存储"></a>文件组织与数据存储</h2><h3 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h3><ul><li><p>逻辑文件， 又称为文件的逻辑结构</p><ul><li><p>独立于物理环境的， 用户概念中的抽象信息组织方式</p></li><li><p>用户能观察到的， 并加以处理的数据集合</p></li></ul></li><li><p>文件的逻辑结构分为两种形式</p><ul><li>一种是流式文件</li><li>一种是记录式文件</li></ul></li></ul><h4 id="流式文件"><a href="#流式文件" class="headerlink" title="流式文件"></a>流式文件</h4><p>文件内的数据不再组成记录， 只是由一串依次的字节组成的信息流序列，称为字节流文件；这种文件常常<strong>按长度来读取所需信息</strong>，也可以用插入的特殊字符作为分界</p><h4 id="记录式文件"><a href="#记录式文件" class="headerlink" title="记录式文件"></a>记录式文件</h4><p>一种有结构的文件， 它是<strong>若干逻辑记录信息所组成的记录流文件</strong>，<strong>逻辑记录</strong>是文件中按信息在逻辑上的独立含义所划分的信息单位</p><p>逻辑纪录是文件内独立的最小信息单位，每次总是为使用者存储、检索或更新一条逻辑记录，通过文件的记录位置来对文件信息进行访问</p><p>记录式问有两种常见的记录组织和使用方法：</p><ul><li><p>记录式顺序文件</p><p>文件的记录顺序生成并被顺序访问</p></li><li><p>记录式索引顺序文件</p><p>使用索引表，表项包含<strong>记录键和索引指针</strong>；记录键由应用程序确定，<strong>索引指针便指向相应的记录</strong>；它可对特定记录进行存取，也保持顺序访问记录的功能</p></li></ul><h4 id="成组和分解"><a href="#成组和分解" class="headerlink" title="成组和分解"></a>成组和分解</h4><ul><li>逻辑记录是按信息在逻辑上的独立含义由用户划分的单位</li><li>块是系统划分的存储介质上连续信息所组成的区域</li></ul><p>一条逻辑记录被存放到文件存储器的存储介质上时，可能占用一块或多块，或者一个物理块包含多条逻辑记录</p><p>记录成组</p><ul><li>若干个逻辑记录合并成一组， 写入一个块叫记录的成组；每块中的逻辑记录数称<strong>块因子</strong></li><li>成组操作先在系统输出缓冲区上进行，凑满一块后才将缓冲区的信息写到存储介质上</li></ul><p>记录分解</p><ul><li>当存储介质上的<strong>一个物理记录</strong>读进输入缓冲区后， <strong>把逻辑记录从块中分离出来</strong>的操作叫记录的分解操作</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/IoDBnNhpJj4gqls.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>优点：</p><ul><li><p>节省存储空间</p><p>不会由于逻辑记录比物理记录小而导致物理空间的浪费</p></li><li><p>减少输入输出操作次数， 提高系统效率</p><p>一次读取一个物理记录，然后将物理记录中的逻辑记录分解出来传输给用户空间，而不需要每次读取一条逻辑记录就发起一次I/O操作；</p><p>当一个写请求所传送的逻辑记录刚好填满系统缓冲区时，文件管理才发出一次I/O请求，将填满的系统缓冲区内容写到存储介质相应的块中</p></li></ul><p>缺点：</p><ul><li>需要软件进行<strong>成组和分解的额外操作</strong></li><li>需要能<strong>容纳最大块长的系统I/O缓冲区</strong></li></ul><p>记录成组与分解处理带来的新特征：</p><ul><li>用户读请求， 导致包含该逻辑记录的物理块读入输入缓冲区； 这一操作可能读入了多个逻辑记录， 这一现象称为<strong>提前读</strong></li><li>用户写请求， 首先是写入输出缓冲区， 只有当该缓冲区中的逻辑记录满后才会引起实际输出， 这一现象称为<strong>推迟写</strong></li></ul><h3 id="文件物理结构"><a href="#文件物理结构" class="headerlink" title="文件物理结构"></a>文件物理结构</h3><ul><li><strong>文件的物理结构</strong>和组织是指文件在<strong>物理存储空间</strong>中的存放方法和组织关系（这时的文件看作物理文件，即相关物理块的集合）</li><li>文件的存储结构涉及块的划分、 记录的排列、 索引的组织、 信息的搜索等许多问题，其优劣直接影响文件系统的性能</li></ul><p>有两种构造文件物理结构的方法：</p><ul><li><p>计算法：对记录键进行计算转换成对应的物理地址，从而找到所需的记录；包括直接寻址文件、计算寻址文件、顺序文件等</p><p>存取效率高，不必增加存储空间存放附加控制信息，能够把分布范围较广的键均匀地映射到一个存储区域</p></li><li><p>指针法：设置专门的指针，指明<strong>相应记录的物理地址</strong>或<strong>表达各记录之间的关联</strong>；索引文件、顺序索引文件、连接文件等均属此类</p><p>优点：可将文件信息的逻辑次序与在存储介质上的物理排列依次完全分开，便于随机存取，便于更新，加快存取速度</p><p>缺点：指针要占用较多存储空间，大型文件的索引查找要耗费较多处理器时间</p></li></ul><h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p>将一个文件中<strong>逻辑上连续的信息</strong>存放到<strong>存储介质的依次相邻的块中</strong>便形成顺序结构， 这类文件叫顺序文件， 又称连续文件；FCB中只需要保存<strong>文件的第一个物理块地址</strong>和<strong>文件信息块的总块数</strong></p><p>优点： 顺序存取记录时速度较快</p><ul><li>批处理文件， 系统文件用得最多</li><li>采用磁带存放顺序文件时， 总可以保持快速存取的优点</li></ul><p>缺点：</p><ul><li>建立文件前需要能<strong>预先确定文件长度</strong>，以便分配存储空间</li><li><strong>修改、 插入和增加文件记录有困难</strong></li><li>对变长记录的处理很困难</li><li>对磁盘作连续分配会造成空闲块的浪费</li></ul><h4 id="连接文件"><a href="#连接文件" class="headerlink" title="连接文件"></a>连接文件</h4><p>使用<strong>连接字（又称为指针）</strong>来表示文件中各个物理块之间的先后次序，称为连接文件或者串联文件，输入井、输出井都是用此类文件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/NEgRdVjxPnputFQ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>文件信息存放在磁盘的若干物理块中，<strong>第一块文件信息的物理地址由FCB给出</strong>，而每块的连接字指出文件的下一个物理块的位置；连接字内容为0时， 表示文件至本块结束</p><p>优点：</p><ul><li>易于对文件记录做增、 删、 改， 易于动态增长记录</li><li>不必预先确知文件长度</li><li>存储空间利用率高</li></ul><p>缺点：</p><ul><li>必须将连接字与数据信息混合存放，破坏数据块的完整性</li><li>存放指针需额外的存储空间</li><li>由于存取须通过缓冲区， 待获得连接字后， 才能找到下一物理块的地址，因而<strong>仅适用于顺序存取</strong></li></ul><h4 id="直接文件"><a href="#直接文件" class="headerlink" title="直接文件"></a>直接文件</h4><p>在直接存取存储设备上，利用哈希法<strong>将记录的关键字与其地址之间建立某种对应关系</strong>，以便实现快速存取的文件叫做直接文件（散列文件或哈希文件）</p><p>计算寻址结构可能出现‘冲突’ ， 即不同的关键字可能变换出相同的地址来， 解决办法有拉链法、 循环探查法、二次散列法、 溢出区法等</p><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p>系统为每个文件建立索引表（index table），可以有不同的索引形式：</p><ul><li><p>记录组成文件的磁盘块号，这种索引表只是磁盘块号的序列，适用于流式文件</p><p><img src="https://i.loli.net/2019/12/21/h7LFORyQCvXgcor.png" alt></p></li><li><p>其索引表项包含记录键及其磁盘块号，适用于记录式文件</p><p><img src="https://i.loli.net/2019/12/21/K4lrXEDNZqnFgP9.png" alt></p></li></ul><p>利用索引表来搜索记录的文件称为索引文件，<strong>索引表可以存放在FCB中</strong>，查阅索引表先找到相应记录键(或逻辑记录号)， 然后获得数据存储地址，大文件的索引表会很大；有些文件系统将索引表置于<strong>单独的物理块</strong>中，且可以驻留在磁盘上，<strong>FCB仅包含索引表的地址</strong></p><p>索引文件访问方式</p><ul><li>索引文件在文件存储器上分两个区：<strong>索引区</strong>和<strong>数据区</strong></li><li>访问索引文件需两步操作： 第一步查找索引表， 第二步获得记录物理地址</li><li>需要两次访问辅助存储器， 若文件索引已预先调入主存储器， 那么就可减少一次内外存信息交换</li></ul><p>优点：</p><ul><li>具有连接文件的优点</li><li>记录可以散列存储</li><li>具有直接读写任意记录的能力</li><li>便于信息的增、删、改</li></ul><p>缺点：</p><ul><li>（大文件）索引表的空间开销和查找时间的开销大</li></ul><p>索引的组织：</p><ul><li>一级索引</li><li>两级索引</li><li>多级索引<ul><li>缺点：多次间接索引会降低查找速度</li></ul></li></ul><p>考虑到不同文件大小不一，而且差别很大的情况，一般来说都是混合使用直接索引、一级间接索引、二级间接索引和多级间接索引（不对称多级索引），这样既能够降低索引表的空间开销，同时提供了小文件的快速存取（如果都采用三级索引，对于小文件来说磁盘的I/O开销大，因此要多次索引才能找到物理记录的地址）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/22/6QODen4TdhIFw8b.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Unix最初的设计中, 直接地址存10个， 现代Linux系统改为15个；如图中所示，一般来说一个物理块512B，而每个盘块号占4B，因此一个盘快可以存放128个物理盘块号（Linux中不提供记录式文件，都是流式文件，因此索引中只需存储物理盘块号而不需要存储记录键）</p><p>例题：</p><p>在UNIX系统中， 每个i节点中分别含有10个直接地址的索引和一、 二、 三级间接索引。 若每个盘块放128个盘块地址， 则一个1MB的文件分别占用多少各级索引所使用的数据物理块？ 20MB的文件呢？ 设每个盘块有512B</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/22/qSvgWB6NfaHJzoe.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="文件系统功能及实现"><a href="#文件系统功能及实现" class="headerlink" title="文件系统功能及实现"></a>文件系统功能及实现</h2><p>文件系统通常采用分层结构实现：</p><ul><li><p>文件管理</p><p>实现文件的逻辑结构，为用户提供各种文件系统调用及文件访问权限的设置等</p></li><li><p>目录管理</p><p>负责查找文件描述符，进而找到需要访问的文件，并进行访问权限检查等工作，此外还需完成目录的添加、删除、重排等操作</p></li><li><p>磁盘管理</p><p>管理文件空间，将文件的逻辑地址转成磁盘的物理地址（即由逻辑块号找到柱面号、磁头号和扇区号）</p></li></ul><p>文件系统的信息空间可认为是由一系列的逻辑块所组成的，每个逻辑块长度通常为512B（一个扇区的大小）的整数倍</p><h3 id="文件类系统调用"><a href="#文件类系统调用" class="headerlink" title="文件类系统调用"></a>文件类系统调用</h3><p>文件系统提供给用户程序的一组系统调用， 包括： 创建、 删除、 打开、 关闭、 读、 写和控制， 通过这些系统调用用户能获得文件系统的各种服务</p><p>在为应用程序服务时， <strong>文件系统需要沿路径查找目录以获得该文件的各种信息（FCB）</strong>， 这往往<strong>要多次访问文件存储器， 使访问速度减慢</strong>， 若把所有文件目录都复制到主存， 访问速度可加快， 但却又增加主存开销</p><p>解决方案：把<strong>常用</strong>和<strong>正在使用的</strong>那些文件目录复制进主存</p><p>好处：既不增加太多主存开销， 又可明显减少查找时间</p><p>过程：</p><ul><li>系统为<strong>每个用户进程</strong>建立一张<strong>活动文件表</strong>， 用户使用文件之前先通过“ 打开” 操作， 把该文件的文件目录复制到指定主存区域</li><li>当不再使用该文件时， 使用“ 关闭” 操作切断和该文件目录的联系， 这样， 文件被打开后， 可被用户多次使用， 直至文件被关闭或撤销， 大大减少访盘次数， 提高文件系统的效率。</li></ul><h4 id="Linux文件系统磁盘结构"><a href="#Linux文件系统磁盘结构" class="headerlink" title="Linux文件系统磁盘结构"></a>Linux文件系统磁盘结构</h4><p>内核将磁盘作为主要的文件存储器，磁盘按扇区编号，扇区序列分成三个部分：</p><ul><li><p>超级块： 占用1#号块，存放文件系统结构和管理信息，如记录：</p><ul><li>inode表所占盘块数、</li><li>文件数据所占盘块数、</li><li>主存中登记的空闲盘块数、</li><li>主存中登记的空闲块物理块号、</li><li>主存中登记的空闲inode数、</li><li>主存中登记的空闲inode编号，</li><li>及其他文件管理控制信息，</li></ul><p>可见超级块既有<strong>盘位示图的功能</strong>， 又<strong>记录整个文件卷的控制数据</strong>。<br>每当一个块设备作为文件卷被安装时， 该设备的<strong>超级块就要复制到主存系统区中备用</strong>， 而拆卸文件卷时， <strong>修改过的超级块需复制回磁盘的超级块中</strong></p></li><li><p>索引节点区：2#～k+1#块</p><p>存放inode表， 每个文件都有各种属性， 它们被记录在称为<strong>索引节点inode的结构</strong>中； 所有inode都有相同大小， 且inode表是inode结构的列表， 文件系统中的<strong>每个文件在该表中都有一个inode</strong>。 又分：</p><ul><li><strong>磁盘inode表</strong></li><li><strong>主存活动inode表</strong></li></ul><p>后者解决频繁访问磁盘inode表的效率问题</p></li><li><p>数据区： k+2#～n#为数据块</p><p>文件的内容保存在这个区域， 磁盘上所有物理块的大小是一样的， 如果文件包含超过一块的数据， 则文件内容会存放在多个盘块中</p></li></ul><p>重要数据结构：</p><ul><li><p>用户打开文件表：<br>进程的<strong>PCB结构中保留一个files_struct</strong>， 称为用户打开文件表或文件描述符表， <strong>表项的序号为文件描述符fd</strong>， 该登记项内登记系统打开文件表的一个入口指针fp， 通过此系统打开文件表项连接到打开文件的活动inode</p></li><li><p>系统打开文件表：</p><p>是为解决<strong>多用户进程共享文件、 父子进程共享文件</strong>而设置的系统数据结构file_struct， 主存专门开辟最多可登记<strong>256项</strong>的系统打开文件表区， 当打开一个文件时， 通过此表项<strong>把用户打开文件表的表项与文件活动inode联接起来</strong>， 以实现数据的访问和信息的共享</p></li><li><p>主存活动inode表：<br>为解决频繁访问磁盘索引节点inode表的效率问题， 系统开辟的主存区， <strong>正在使用的文件的inode被调入主存活动索引节点inode中</strong>， 以加快文件访问速度</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/22/52UKSW8lLQxtBiz.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/22/8lvHEbzBA5xIRwL.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="文件的创建"><a href="#文件的创建" class="headerlink" title="文件的创建"></a>文件的创建</h4><p>系统调用C语言格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd, mode;</span><br><span class="line"><span class="keyword">char</span> *filenamep;</span><br><span class="line">fd = create (filenamep, mode);</span><br></pre></td></tr></table></figure><ul><li>为新文件分配<strong>索引节点（磁盘inode）和活动索引节点（活动inode）</strong>， 并把索引节点编号（inode号）与文件分量名（即不包含路径的文件名）组成新目录项， 记到目录中</li><li>在新文件所对应的活动索引节点（活动inode）中置初值， 如置存取权限i_mode， 连接计数i_nlink等</li><li>分配<strong>用户打开文件表项</strong>和<strong>系统打开文件表项</strong>， 置表项初值，读写位移f_offset清“0”</li><li>把用户打开文件表项、系统打开文件表项以及文件对应的活动inode用指针连接起来， 把文件描述字fd返回给调用者</li></ul><h4 id="文件的删除"><a href="#文件的删除" class="headerlink" title="文件的删除"></a>文件的删除</h4><ul><li><p>删除把指定文件从所在的目录文件中除去。</p></li><li><p>如果没有连接用户(i_nlink 为“1”)， 还要把文件占用的存储空间释放。 删除系统调用形式为： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink (filenamep);</span><br></pre></td></tr></table></figure></li><li><p>在执行删除时， 必须要求用户对该文件具有“写”操作权</p></li></ul><h4 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h4><p>调用方式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd, mode;</span><br><span class="line"><span class="keyword">char</span> * filenamep;</span><br><span class="line">fd = open (filenamep, mode);</span><br></pre></td></tr></table></figure><p>文件在使用之前必须先打开，以建立进程与文件之间的联系，而<strong>文件描述符唯一地标识这种连接</strong>，其任务是<strong>把文件的磁盘inode复制到内存活动inode表中</strong>，同时建立一个独立的读写文件的数据结构，即系统打开文件表的一个表项</p><p>执行过程：</p><ul><li>检索目录，要求打开的文件应该是已经创建的文件，它应该登记在文件目录中，否则出错；检索到文件后，把它的外存索引节点（磁盘inode）复制到活动索引节点inode表中</li><li>根据参数mode与活动inode中在创建文件时所记录的文件访问权限进行比较， 如果非法， 则这次打开失败</li><li>当“打开” 合法时， 为文件分配<strong>用户打开文件表项</strong>和<strong>系统打开文件表项</strong>， 并为后者设置初值。 通过指针建立这些表项与活动索引节点inode之间的联系， 把文件描述字fd， 即用户打开文件表中相应文件表项的序号返回给调用者</li></ul><p>可见，不论是打开成功还是失败（例如权限不符合），对应的磁盘inode都会被复制到活动inode表中</p><p>另外要注意：如果在执行文件打开过程之前，其他用户已经打开同一文件，则活动inode表中已经有此文件的inode，于是不需要再进行inode复制工作，而仅仅把活动inode的计数器i_count加1即可；i_count表示<strong>通过不同系统打开文件表项来共享同一活动inode</strong>的进程数目，它是以后执行文件关闭操作时活动inode能够被释放的依据</p><h4 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h4><p>文件使用完毕，执行关闭系统调用来切断应用程序与文件的联系，调用方式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">close (fd);</span><br></pre></td></tr></table></figure><p>显然要关闭的文件先前已打开，故文件描述符fd一定存在，执行过程如下：</p><ul><li>根据fd找到用户打开文件表项， 再找到系统打开文件表项；释放用户打开文件表项</li><li>把对应系统打开文件表项中的f_count减“1”， 如果非“0”， 说明还有<strong>进程共享这一表项</strong>， 不用释放直接返回；否则释放表项，并找到与之连接的活动inode</li><li>把活动inode中的i_count减“1”， 若不为“0”， 表明还有<strong>用户进程正在使用该文件</strong>， 不用释放而直接返回，否则把该活动inode中的内容复制回文件卷上的相应磁盘inode中， 释放该活动inode</li></ul><p>f_count（系统打开文件表中）和i_count（活动inode表中）分别反映进程动态地共享一个文件的两种方式：</p><ul><li>f_count反映不同进程通过同一个系统打开文件表项共享一个文件的情况</li><li>i_count反映不同进程通过不同系统打开文件表项共享一个文件的情况</li></ul><p>通过两种方式， 进程之间既可用<strong>相同的位移指针f_offset</strong>，也可用<strong>不同位移指针f_offset</strong>共享同一个文件</p><h4 id="文件读"><a href="#文件读" class="headerlink" title="文件读"></a>文件读</h4><p>文件读指文件的内容读入用户数据区，由系统打开文件表项的f_offset决定从哪个逻辑位置读入数据</p><p>调用的形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nr, fd, count;</span><br><span class="line"><span class="keyword">char</span> buf [ ]</span><br><span class="line">nr = read (fd, buf, count);</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/22/TXoclJjB9NnHstf.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>说明：i_addr[…]对应于Linux中的i_data[…]？</p><p>文件读执行过程：</p><ul><li>系统根据f_flag中的信息， 检查读操作合法性，</li><li>如果合法，再根据活动inode中i_addr指出的文件物理块存放地址，从文件当前位移量f_offset值读取所要求的字节数count到块设备缓冲区中， 然后再送到bufp指向的用户数据区中</li></ul><h4 id="文件写"><a href="#文件写" class="headerlink" title="文件写"></a>文件写</h4><p>文件写指把用户数据区中的信息写入文件，由系统打开文件表项的f_offset决定把数据写入文件的哪个逻辑位置调用的形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nw = write (fd, buf, count);</span><br></pre></td></tr></table></figure><p>buf是信息传送的源地址， 即把buf所指向的用户数据区中的信息， 写入到文件中</p><h4 id="文件随机存取"><a href="#文件随机存取" class="headerlink" title="文件随机存取"></a>文件随机存取</h4><p>在文件初次“打开” 时， 文件的位移量f_offset清空为0，以后的文件读写操作总是<strong>根据offset的当前值， 顺序地读写文件</strong>。 为了支持文件的随机访问， 提供系统调用lseek， 它允许用户在读、 写文件前， 事先改变f_offset的指向</p><p>系统调用的形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lseek;</span><br><span class="line"><span class="keyword">long</span> offset;</span><br><span class="line"><span class="keyword">int</span> whence, fd;</span><br><span class="line">lseek (fd, offset, whence);</span><br></pre></td></tr></table></figure><p>文件描述字fd必须指向一个用读或写方式打开的文件</p><ul><li>当whence是“0”时， 则f_offset被置为offset</li><li>当whence是“1”时， 则f_offset被置为文件当前位置加上offset</li></ul><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>文件共享是指不同进程共同使用同一个文件，文件共享不仅为不同进程完成共同任务所必需，而且还节省大量外存空间，减少因文件复制而增加的I/O操作次数</p><h4 id="文件静态共享"><a href="#文件静态共享" class="headerlink" title="文件静态共享"></a>文件静态共享</h4><p>静态共享是通过文件所对应的inode节点来实现链接的，并且只允许链接到文件而非目录；文件链接系统调用形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chat * oldnamep, * newnamep;</span><br><span class="line">link (oldnamep, newnamep);</span><br></pre></td></tr></table></figure><p>执行过程：</p><ul><li>检索目录找到oldnamep所指向文件的索引节点inode编号</li><li>再次检索目录找到newnamep所指文件的父目录文件，并<strong>把已存在文件的索引节点inode编号与别名构成一个目录项</strong>， 记入到该目录中去</li><li>把已存在文件索引节点inode的连接计数i_nlink加“1”</li></ul><p>所谓链接，实际上是共享已存在文件的inode；无论进程是否允许，这种链接关系都是存在的</p><p>文件解除链接调用形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink (namep);</span><br></pre></td></tr></table></figure><p>解除链接与文件删除执行的是同一系统调用代码。 删除文件是从文件主角度讲的， 解除文件连接是从共享文件的其他用户角度讲的，都要删去目录项，把i_nlink减“1”， 不过， 只有当i_nlink减为“0”时才释放文件的物理存储空间，从而真正删除文件</p><h4 id="文件动态共享"><a href="#文件动态共享" class="headerlink" title="文件动态共享"></a>文件动态共享</h4><p>指系统中不同的应用进程或同一用户的不同进程并发地访问同一文件，这种共享关系只有当进程存在时才可能出现，一旦进程消亡，其共享关系也就随之消失</p><p>问题：应让多个进程共用同一个读/写位移， 还是各个进程具有各自的读写位移呢？</p><ul><li><p>若是<strong>先执行fork()，再用“打开”来打开同一个文件名的文件</strong>，则系统分别为两个进程分配不同的系统打开文件表项并指向同一活动inode，于是两进程独立地使用各自的读写位移量指针</p><p>多用户共享文件， 每个希望独立地读、 写文件， 这时不能只设置一个读写位移指针， 须为每个用户进程分别设置一个读、写位移指针<br>位移指针应放在每个进程用户打开文件表的表目中。 这样，当一个进程读、 写文件， 并修改位移指针时， 另一个进程的位移指针不会随之改变， 从而使两个进程能独立地访问同一文件</p><p><img src="https://i.loli.net/2019/12/22/aWEPZ8sGt4VMfxU.png" alt></p></li><li><p>如果<strong>进程在打开一个文件之后，再用fork()系统调用创建子进程</strong>，由于子进程的用户打开文件表项是从父进程那里复制得到的，它自然会指向父进程所使用的系统打开文件表项，因此父子进程就公用同一个位移量指针来共享文件</p><p>同一用户父、 子进程协同完成任务， 使用同一读/写位移，同步地对文件进行操作<br>该位移指针宜放在相应文件的活动索引节点中。 当用系统调用fork建立子进程时， 父进程的PCB结构被复制到子进程的PCB结构中， 使两个进程的打开文件表指向同一活动的索引节点， 达到共享同一位移指针的目的</p><p><img src="https://i.loli.net/2019/12/22/JhzL8tV6rBlET3Q.png" alt></p></li></ul><p>系统打开表项的申请和释放过程：</p><ul><li>当进程要求打开文件时，首先系统为它申请一个系统打开文件表项，并建立此表项与相应文件活动inode之间的联系；然后把用户打开文件表项中的一个空闲项指向它</li><li>如果此后进程通过fork()创建一个子进程，系统自动把用户打开文件表项所指的系统打开文件表项中的f_count值加1（因为先打开文件后，再fork出的子进程和父进程共享相同的系统打开文件表项）</li><li>反之，当进程关闭一个文件时，系统不能简单地释放系统打开的文件表项，必须首先判断f_count的值是否大于1，如果其值大于1，说明还有进程共享相应的系统打开文件表项，此时只需把f_count值减1即可</li></ul><h4 id="文件符号链接共享"><a href="#文件符号链接共享" class="headerlink" title="文件符号链接共享"></a>文件符号链接共享</h4><p>操作系统可支持多个物理磁盘或多个逻辑磁盘(分区)， 那么，文件系统是建立一棵目录树还是多棵目录树呢?</p><ul><li><p>Windows采用将盘符或卷标分配给磁盘或分区， 并将其名字作为文件路径名的一部分</p></li><li><p>UNIX/Linux的每个分区有自己的文件目录树， 当有多个文件系统时， 可通过安装的办法整合成一棵更大的文件目录树</p></li></ul><p>问题： 系统中每个文件对应一个inode， 编号是惟一的，但两个不同的磁盘或分区都含有相同inode号对应的文件， 也就是说， 整合的目录树中， inode号并不惟一地标识一个文件？<br>办法： <strong>拒绝创建跨越文件系统的硬链接</strong></p><ul><li><p>硬链接指的是将文件名和自身的inode链接起来；</p><p>缺点：只能用于单个文件系统，不能跨越文件系统，可用于文件共享却不能用于目录共享</p><p>优点：实现简单，访问速度快</p></li><li><p>软链接：符号链接，只有文件名、不指向inode的链接，通过名称来引用文件；</p><p>符号链接共享文件的实现思想：<br>用户A目录中形式为afile→bfile， 实现A的目录与B的文件的链接。 其中只包含被链接文件bfile的路径名而不是它的inode号， 而<strong>文件的拥有者才具有指向inode的指针</strong>；当用户A要访问被符号链接的用户B的文件bfile， 且要读“符号链接” 类文件时， <strong>被操作系统截获， 它将依据符号链接中的路径名去读文件</strong>， 于是就能实现用户A使用文件名afile对用户B的文件bfile的共享</p><p>优点：能用于链接计算机系统中不同文件系统中的文件，可链接计算机网络中不同机器上的文件， 此时， 仅需提供文件所在机器地址和该机器中文件的路径名</p><p>缺点：搜索文件路径开销大， 需要额外的空间查找存储路径</p></li></ul><h3 id="文件空间管理"><a href="#文件空间管理" class="headerlink" title="文件空间管理"></a>文件空间管理</h3><p>磁盘文件空间分配采用两种办法</p><ul><li>连续分配： 文件存放在辅存空间连续存储区中， 在建立文件时， 用户必须给出文件大小， 然后， 查找到能满足的连续存储区供使用</li><li>非连续分配： 一种方法是<strong>以块(扇区)为单位</strong>， 扇区不一定要连续， <strong>同一文件的扇区按文件记录的逻辑次序用链指针连接或位示图指示</strong></li></ul><p>另一种方法是以簇为单位， 簇是由若干个连续扇区组成的分配单位； 实质上是连续分配和非连续分配的结合。 各个簇可以用链指针、 索引表， 位示图来管理</p><h4 id="磁盘空闲空间管理方法"><a href="#磁盘空闲空间管理方法" class="headerlink" title="磁盘空闲空间管理方法"></a>磁盘空闲空间管理方法</h4><ul><li><p>位示图</p><ul><li>磁盘空间通常使用固定大小的块， 可方便地用位示图管理， 用若干字节构成一张位示图， 其中每一字位对应一个物理块， 字位的次序与块的相对次序一致， 字位为‘ 1’表示相应块已占用，字位为‘ 0’表示该块空闲</li><li>微型机操作系统VM/SP、 Windows和Macintosh等操作系统均使用这种技术管理文件存储空间</li><li>主要优点是： <strong>每个盘块仅需1个附加位</strong>， 如盘块长1KB， 位示图开销仅占0.012%； <strong>可把位示图全部或大部分保存在主存</strong>， 再配合现代机器都具有的位操作指令， 实现高速物理块分配和去配</li></ul></li><li><p>空闲区表</p><ul><li>该方法常用于连续文件， 将<strong>空闲存储块的位置</strong>及<strong>其连续空闲的块数</strong>构成一张表</li><li>分配时， 系统依次扫描空闲区表， 寻找合适的空闲块并修改登记项</li><li>删除文件释放空闲区时， 把空闲区位置及连续的空闲区长度填入空闲区表， <strong>出现邻接的空闲区时， 还需执行合并操作并修改登记项</strong></li><li>空闲区表的搜索算法有首次适应、 邻近适应、 最佳适应和最坏适应算法等， 参见pp.239</li></ul></li><li><p>空闲块链</p><ul><li><p>把所有空闲块连接在一起， 系统保持指针指向第一个空闲块，每一空闲块中包含指向下一空闲块的指针</p></li><li><p>申请一块时， 从链头取一块并修改系统指针</p></li><li><p>删除时释放占用块， 使其成为空闲块并将它挂到空闲链上</p></li></ul><p>缺点：这种方法效率低， 每申请一块都要读出空闲块并取得指针， 申请多块时要多次读盘</p><p>优点：便于文件动态增长和收缩</p></li><li><p>空闲块列表</p><p>把所有空闲块物理地址放到一个空闲块列表文件中；由于空闲块列表较大，不可能全部放在内存中，因此可以小部分保存在内存中：</p><ul><li><p>列表用一个下推栈实现：栈中靠前数千个元素保存在内存专用区中；当分配一个新空闲块时，从栈顶弹出；当一个物理块被解除分配时，它被压入内存专用区的栈尾中</p><p>只有当下推栈中在内存的部分满或空时，才需要在内存和磁盘之间进行传送；因此该技术在大多数情况下都提供了零时间的访问</p></li><li><p>列表用一个FIFO队列实现：队列头和队列尾的几千项放在内存专用区中；分配空闲块时从队列头取出首项，取消分配时可以把它添加在内存专用区队列尾</p><p>只有当队列头部空或内存中的队列尾部满时，才需要在磁盘和内存直接进行传送</p></li></ul><p>在上面两种策略中，一个后台线程可以对内存中的列表慢慢地进行排序，从而使连续分配变得快速和容易</p></li><li><p>空闲块成组链接</p><p><img src="https://i.loli.net/2019/12/22/WwAPBOTlCEsYXrS.png" alt></p><p>存储空间分成512字节一块。 假定文件卷启用时共有可用文件338块， 编号从12至349。每100块划分一组， <strong>每组第一块（如图中的50、68和188）登记下一组空闲块的盘物理块号和空闲总数</strong>；在最后一组中，第1项是0，作为结束标志，表明系统空闲盘块链已经结束</p><p>操作系统启动时，将磁盘专用块复制到内存系统工作区中，访问内存专用块就可以完成申请或释放空闲盘块的操作</p><ul><li>分配空闲盘块时：先把专用块中的空闲块计数减1，以它为指针找到专用块的相应表项，其内容就是要分配的空闲磁盘块号；<strong>当空闲块计数减1后等于0时，专用块仅剩1个磁盘块号</strong>，此时要取出表项中的磁盘块号（设为i），再把此盘块中所保存的<strong>下一组空闲磁盘块链接</strong>信息经缓冲区复制到内存专用块中，然后把当前磁盘块i分配出去</li><li>释放存储块时，将磁盘块号记录在由专用块所指示的表项中，然后空闲块计数加1；若发现此表已满（达100项），则应把整个表的内容经缓冲区复制到下面要释放的磁盘块中，然后将释放块的块号写入专用块的第一个位置，置空闲块计数为1；搜索到磁盘块的第一项是0时，系统要发出警告，表明空闲块已经用完</li></ul></li></ul><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>解决文件读写效率低下的基本思路：把磁盘访问转变为内存访问，实现这种转变的手段是<strong>内存映射文件（Memory Mapped File，MMF）</strong></p><p>基本原理：把进程需要访问的文件映射到其虚地址空间中，于是便可通过读写这段虚地址进行文件访问，而磁盘访问变成内存访问</p><p>内存映射文件是按照文件名来访问的，多个进程可以把同一个文件映射到各自的虚地址空间中，且虚地址不必相同；随着进程的运行，被引用的映射文件由存储管理程序装入内存，多个进程读写虚存的映射文件区就可以共享文件信息</p><p>优点是： 方便易用、 节省空间、 便于共享、 灵活高</p><p>系统提供两个新的系统调用：</p><ul><li>映射文件mmap()， 有两个参数： 一个文件名和一个虚拟地址， 把一个文件映射到进程地址空间</li><li>移去映射文件unmmap()， 让文件与进程地址空间断开， 并把映射文件的数据写回磁盘文件</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/22/Ou71wjqHrQix8tk.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>只需要让进程映射的进程虚存空间的页表项的外存地址指向文件所在的磁盘块，就很容易实现映射文件和移去映射文件系统调用；当多进程共享文件时，实现技术是：<strong>把共享映射文件的进程的虚页面指向相同的页框，而页框则保存磁盘的页面副本</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/22/819AOQTwPXvrftm.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="文件系统的实现层次"><a href="#文件系统的实现层次" class="headerlink" title="文件系统的实现层次"></a>文件系统的实现层次</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/22/5OdNqk1m7hE4LzX.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件管理&quot;&gt;&lt;a href=&quot;#文件管理&quot; class=&quot;headerlink&quot; title=&quot;文件管理&quot;&gt;&lt;/a&gt;文件管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="文件管理" scheme="http://QQ876684433.github.io/tags/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-设备管理</title>
    <link href="http://QQ876684433.github.io/2019/12/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <id>http://QQ876684433.github.io/2019/12/21/操作系统-设备管理/</id>
    <published>2019-12-21T01:44:20.000Z</published>
    <updated>2019-12-21T10:16:05.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li></ul></blockquote><p>外部设备分类：</p><ul><li><p>存储型设备</p><p>磁带机、磁盘机等</p></li><li><p>I/O型设备</p><p>显示器、打印机、通信设备等</p></li></ul><p>设备管理通常使用I/O中断、缓冲区管理、通道、设备驱动调度等多种技术，这很好地克服了由于<strong>设备和CPU速度不匹配</strong>所引起的问题，使得主机和设备能够并行工作，提高设备的使用效率</p><p>另外操作系统将所有设备都<strong>抽象成文件</strong>，将其统一在文件系统之下，赋予文件属性，对设备的操作类似于对文件的操作，优点是：</p><ul><li>尽可能统一文件和设备的I/O的处理</li><li>尽可能把设备文件和普通文件纳入统一保护机制下</li></ul><p>为了方便用户或者高层软件使用，设备管理还<strong>对各种设备进行抽象</strong>，配置设备驱动程序，屏蔽物理细节和操作过程，提供统一使用界面，因此设备管理应该具备以下功能：</p><ul><li>设备中断处理</li><li>缓冲区管理</li><li>设备分配和去配</li><li>设备驱动调度</li><li>实现虚拟设备</li></ul><h2 id="I-O硬件原理"><a href="#I-O硬件原理" class="headerlink" title="I/O硬件原理"></a>I/O硬件原理</h2><h3 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h3><p>设备分类</p><ul><li><p>按照操作特性</p><ul><li><p>输入型设备</p></li><li><p>输出型设备</p></li><li><p>存储型设备</p><ul><li><p>顺序存取存储设备</p><p>严格依赖信息的物理位置进行定位和读写，如磁带</p></li><li><p>直接存取存储设备（随机存取存储设备）</p><p>存取任何一个物理块所需时间几乎不依赖于此信息所处位置，如磁盘</p></li></ul></li></ul></li><li><p>按照信息交换单位</p><ul><li><p>字符设备</p><p>通常是输入型设备和输出型设备，它与内存进行信息交换的单位是<strong>字节</strong>，即一次交换一个或多个字节</p></li><li><p>块设备</p><p>通常是存储型设备，所谓块是存储介质上<strong>连续信息所组成的一个区域</strong>，块设备每次与内存交换一块或多块信息</p></li></ul></li></ul><p>不同设备之间的物理特性的差异：</p><ul><li>数据传输速率差别很大</li><li>数据表示方式和传输单位不同</li><li>错误的性质、报错方式以及应对措施都不一样</li></ul><h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h3><p>CPU和设备并行工作能大幅提高<strong>计算机系统效率</strong>和<strong>资源利用率</strong></p><h4 id="轮询方式"><a href="#轮询方式" class="headerlink" title="轮询方式"></a>轮询方式</h4><p>程序直接控制方式，使用查询指令测试设备控制器的<strong>忙闲状态位</strong>，确定内存和设备是否能交换数据</p><p>轮询方式的传输过程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/aM4kPUBHnY2cT7j.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>缺点：</p><ul><li>CPU轮询设备当前的状态会终止原程序的执行（完成I/O操作后才能继续往后面执行，同步方式），浪费宝贵的时间</li><li>I/O准备就绪后，需要CPU参与数据传输工作</li><li>CPU和设备只能串行工作，使<strong>主机不能充分发挥功效</strong>，<strong>设备也不能得到合理利用</strong>，整个系统效率很低</li></ul><h4 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h4><p>中断方式要求：CPU与设备控制器之间存在中断请求线，设备控制器的状态寄存器有相应的中断允许位</p><p>中断方式的传输数据过程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/5STvlp3WBaPtHUA.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>缺点：</p><ul><li>如果设备控制器的数据缓冲区较小，每次当缓冲器装满后便会发生中断，那么在数据传输过过程中会发生多次中断，耗用大量的CPU时间</li><li>当系统的设备较多，并且都通过中断方式实现并行，那么中断次数会急剧增加，造成CPU来不及响应或丢失数据的现象</li></ul><p>优点：</p><ul><li>中断方式I/O不必忙式轮询设备，可实现<strong>CPU和设备部分并行操作</strong></li><li>与轮询方式I/O相比，<strong>CPU资源得到更充分的利用</strong></li></ul><h4 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h4><p>直接存储器存取（Direct Memory Access，DMA）方式，内存和设备之间有一条数据通路成块地传输数据，无须CPU干预，<strong>实际数据传输操作由DMA直接完成</strong></p><p>为了实现直接存储器存取操作，还需要以下逻辑部件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/uVN8UKqvzTlBk6d.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>控制器从设备读取数据后不立即将其送入内存，而需要内部缓冲区的原因：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/1fZcVH3OPW47qXB.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>DMA不仅设有中断机制，还有DMA传输控制器：若出现DMA与CPU同时经总线访问内存的情况，CPU总是把总线占有权让给DAM，这种方式称为”周期窃取“，窃取时间通常是一个存取周期</p><p>DMA方式实现线路简单，价格低廉，<strong>适用于小型和微型计算机</strong>，但是不能满足大中型计算机（使用通道技术）</p><h4 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h4><p>引入通道技术的目的：</p><ul><li>充分发挥CPU和设备之间的并行工作能力</li><li>让种类繁多且物理特性各异的设备能够以标准的接口连接到系统中</li></ul><p>通道又称为I/O处理器，能完成内存和设备之间的信息传送，与CPU并行地执行操作，由通道管理和控制I/O操作。具有通道装置的计算机系统的<strong>主机、通道、控制器和设备</strong>之间<strong>采用四级连接、实施三级控制</strong>：</p><ul><li>一个CPU通常可以连接若干通道；一个通道可以连接若干控制器；一个控制器可以连接若干设备</li><li>CPU通过执行I/O指令对通道实施控制；通道通过执行通道命令对控制器实施控制；控制器发出动作序列对设备实施控制，设备执行相应的I/O操作</li></ul><p>通道方式下的I/O操作过程：CPU在执行主程序时遇到I/O请求，启动在指定通道上选址的设备，一旦启动成功，通道开始控制设备进行操作，这时CPU就可以执行其他任务并与通道并行工作，直到I/O操作完成；当通道发出I/O操作结束中断时，处理器才响应并停止当前工作，转而处理I/O操作结束事件</p><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>设备控制器是CPU和设备之间的接口，它<strong>接收从CPU发来的命令，控制设备操作</strong>，实现内存和设备之间的数据传输；设备控制器是可编址设备，当它连接多台设备时，应具有多个设备地址</p><p>设备控制器的主要功能：</p><ul><li>接收和识别CPU或通道发来的命令（控制寄存器和译码器）</li><li>实现数据交换（数据缓冲寄存器或数据缓冲区），包括设备和控制器之间、控制器与内存之间（通过数据总线或通道）的数据传输</li><li>发现和记录设备及自身的状态信息（状态寄存器），供CPU处理使用</li><li>设备地址识别（地址译码器和对设备操作进行控制的I/O逻辑）</li></ul><h2 id="I-O软件原理"><a href="#I-O软件原理" class="headerlink" title="I/O软件原理"></a>I/O软件原理</h2><p>I/O软件设计的总目标：</p><ul><li><strong>高效率</strong>： 改善设备效率， 尤其是磁盘I/O操作的效率</li><li><strong>通用性</strong>： 用统一的标准来管理所有设备</li></ul><p>设计思路：</p><ul><li>把软件组织成<strong>层次结构</strong></li><li>低层软件用来屏蔽硬件细节</li><li>高层软件向用户提供简洁、 友善的界面</li></ul><p>主要考虑的问题：</p><ul><li><p><strong>设备无关性</strong>： 编写访问文件的程序与具体设备无关</p></li><li><p><strong>出错处理</strong>： 低层软件能处理的错误不让高层软件感知</p><p>使得用户体验较好</p></li><li><p><strong>同步/异步传输</strong>： 支持阻塞和中断驱动两种工作方式</p><p>可以不同步的工作尽量让它异步执行，提高系统效率；对于有数据依赖的IO操作（只能同步，只能使用同步，否则会出错）</p></li><li><p><strong>缓冲技术</strong>： 建立数据缓冲区， 提高吞吐率</p><p>充分考虑缓冲技术，提高性能；建立缓冲区不一定要使用内存空间，也可以考虑使用相对高速的磁盘</p></li></ul><p>软件层次结构：</p><ul><li>中断处理程序</li><li>设备驱动程序</li><li>独立于设备的I/O软件</li><li>用户空间的I/O软件</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/NuFKQzmCBInerDU.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><ul><li>位于操作系统底层， 与硬件设备密切相关， 与系统其余部分尽可能少地发生联系</li><li>进程请求I/O操作时， 通常被挂起， 直到<strong>数据传输结束后并产生I/O中断</strong>时， 操作系统接管CPU后转向中断处理程序</li><li>当设备向CPU提出中断请求时， CPU响应请求并转入中断处理程序</li></ul><p>功能：</p><p>检查设备状态寄存器内容， 判断产生中断的原因，<strong>根据I/O操作的完成情况</strong>进行相应的处理</p><ul><li>如果<strong>数据传输有错</strong>， 向上层软件报告设备的出错信息， 实施重新执行</li><li>如果<strong>正常结束</strong>， 唤醒等待传输的进程， 使其转换为就绪态</li><li>如果<strong>有等待传输的I/O命令</strong>， 通知相关软件启动下一个I/O请求</li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>设备驱动程序包括<strong>与设备密切相关的所有代码</strong></p><p>任务：从<strong>独立于设备的软件</strong>中接收并执行I/O请求</p><ul><li>把用户提交的<strong>逻辑I/O请求</strong>转化为<strong>物理I/O操作的启动和执行</strong></li><li>监督设备是否正确执行， 管理数据缓冲区， 进行必要的纠错处理</li></ul><p>功能：</p><ul><li>设备初始化<ul><li>在系统初次启动或设备传输数据时， 预置设备和控制器以及通道状态</li></ul></li><li>执行设备驱动例程<ul><li>负责启动设备， 进行数据传输</li><li>对于具有通道方式， 还负责生成通道指令和通道程序， 启动通道工作</li></ul></li><li>调用和执行中断处理程序<ul><li>负责处理设备和控制器及通道所发出的各种中断</li></ul></li></ul><p>每个设备驱动程序只处理<strong>一种设备</strong>， 或者<strong>一类紧密相关的设备</strong></p><p>设备驱动程序分为<strong>整体驱动程序</strong>和<strong>分层驱动程序</strong></p><ul><li>整体驱动程序<strong>直接向操作系统提供接口和控制硬件</strong><ul><li>适用于功能简单的驱动程序， 效率较高， 但较难迁移</li></ul></li><li>分层驱动程序<strong>将驱动程序分成多层</strong>， 放在栈中， 系统接到I/O请求时先调用栈顶的驱动程序， 栈顶的驱动程序可以直接处理请求或向下调用更低层的驱动程序， 直至请求被处理<ul><li>适用于功能复杂、 重用性要求较高的驱动程序， 结构清晰且便于移植， 但会增加一部分系统开销</li></ul></li></ul><h3 id="独立于设备的I-O软件"><a href="#独立于设备的I-O软件" class="headerlink" title="独立于设备的I/O软件"></a>独立于设备的I/O软件</h3><p>执行适用于所有设备的常用I/O功能， 并向用户层软件提供一致性接口（屏蔽物理设备的细节）</p><p>功能：</p><ul><li><p>设备命名： 通过路径名寻址设备</p></li><li><p>设备保护： 检查用户是否有权访问所申请设备</p><p>大多数大中型计算机系统中，用户进程对I/O设备的直接访问是绝对禁止的，<strong>I/O指令定义为特权指令</strong>，通过<strong>系统调用方式</strong>间接地供用户使用</p></li><li><p>提供与设备无关的数据单位： 字符数量， 块尺寸</p><p><img src="https://i.loli.net/2019/12/21/683z5mKg1VXpZUn.png" alt></p></li><li><p>缓冲技术： 传输速率， 时间约束， 不能直接送达目的地</p><p>通过缓冲区来消除填满速率和清空速率的影响，通常在内核空间开辟缓冲区，数据在缓冲区中缓冲后，再在用户缓冲区和设备之间传输</p></li><li><p>设备分配和状态跟踪： 分配不同类型的设备</p><p>设备分配策略有：静态分配、动态分配、虚拟分配</p></li><li><p>错误处理和报告： 驱动程序无法处理的错误</p><p>错误应该在尽量接近硬件的地方加以处理，如果控制器发现错误，应该设法纠正和加以解决；如果发现错误处理不成功或者不能处理错误，可向独立于设备的I/O软件报错，此后错误的处理就与设备驱动程序无关</p><p>即<strong>与设备无关的错误、驱动程序无法/不能处理的错误</strong>应该由独立于设备的I/O软件完成：例如I/O编程指令错误（无效操作码、无效设备、无效缓冲区地址等），读关键系统数据结构等出错</p></li></ul><h3 id="用户空间的I-O软件"><a href="#用户空间的I-O软件" class="headerlink" title="用户空间的I/O软件"></a>用户空间的I/O软件</h3><ul><li>库函数<ul><li>一小部分I/O软件不在操作系统中， 是与应用程序链接在一起的库函数， 甚至完全由运行于用户态的程序组成</li><li>系统调用通常由库函数封装后供用户使用， 封装函数只是<strong>将系统调用所用的参数放在合适位置</strong>， 然后执行访管指令来陷入内核， 再<strong>由内核函数实现真正的I/O操作</strong></li></ul></li><li>SPOOLing软件<br>在<strong>内核外运行的系统I/O软件</strong>， 采用<strong>预输入、 缓输出和井管理技术</strong>， 通过创建守护进程和特殊目录<strong>解决独占型设备的空占问题</strong></li></ul><h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><p>目的：</p><ul><li><p>解决<strong>CPU与设备之间速度不匹配的</strong>矛盾</p></li><li><p>协调<strong>逻辑记录大小</strong>和<strong>物理记录大小不一致</strong>的问题</p><p>例如读取磁盘时我们一般读30、50或者80字节等，但是磁盘往往是以一个扇区（512字节）为基本单位来存储和读取的</p><p><img src="https://i.loli.net/2019/12/21/gOltdQhcBAF54Kk.png" alt></p></li><li><p>提高CPU和设备的并行性</p></li><li><p>减少I/O操作对CPU的中断次数</p></li><li><p>放宽对CPU中断响应时间的要求</p></li></ul><p>缓冲区：在内存中开辟的存储区， 专门用于临时存放I/O操作的数据</p><p> 操作</p><ul><li>写操作： 将数据送至缓冲区， 直到装满， 进程继续计算，同时系统将缓冲区的内容写到设备上</li><li>读操作： 系统将设备上的物理记录读至缓冲区， 根据要求将当前所需要的数据从缓冲区中读出并传送给进程</li></ul><h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><p>操作系统在<strong>主存的系统区</strong>中开设一个缓冲区</p><ul><li>输入： 将数据读至缓冲区， 系统将缓冲区数据送至用户区， 应用程序对数据进行处理， 同时系统读入接下来的数据</li><li>输出： 把数据从用户区复制到缓冲区， 系统将数据输出后， 应用程序继续请求输出</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/Hq67XgCUdfrAsV1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>使用两个缓冲区</p><ul><li>输入： 设备先将数据输入缓冲区1， 系统从缓冲区1把数据传到用户区， 供应用程序处理， 同时设备将数据传送到缓冲区2</li><li>输出： 应用程序将数据从用户传送到缓冲区1， 系统将数据传送到设备， 同时应用程序将数据传送到缓冲区2</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/Kv7YH1RzAw8F9kC.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>双缓冲技术实际上是两个缓冲区交替使用，即其中一个缓冲区在输入（从设备到缓冲区）时，另一个缓冲区可以读取（从缓冲区到用户区），但并不是说输入和输出同时进行，只是说把输入或者输出的两个阶段（设备和缓冲区之间、缓冲区和用户区之间）的操作分别在两个缓冲区中进行，只要两个缓冲区不同时满或者同时为空，进程或设备都无需等待</p><h3 id="多缓冲"><a href="#多缓冲" class="headerlink" title="多缓冲"></a>多缓冲</h3><p>操作系统分配一组缓冲区， 每个缓冲区度有指向下一个缓冲区的链接指针，最后一个缓冲区指针指向第一个缓冲区， 构成循环缓冲，缓冲区的大小等于物理记录的大小</p><ul><li>解决设备和进程速度不匹配的问题</li><li>为系统公共资源， 供进程共享并由系统统一分配和管理</li></ul><p>分类：</p><ul><li>输入缓冲区</li><li>输出缓冲区</li><li>处理缓冲区</li></ul><p>为了管理各类缓冲区，执行各种操作，必须引入<strong>缓冲区自动管理系统</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/u2MPH9SX4TiZBhK.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="驱动调度技术"><a href="#驱动调度技术" class="headerlink" title="驱动调度技术"></a>驱动调度技术</h2><p>计算即可能会同时有若干传输请求来到并等待处理，必须采用一种调度策略，能够按照最佳次序执行要求访问的诸多请求，这叫做<strong>驱动调度</strong>，所使用的算法叫做<strong>驱动调度算法</strong></p><p>除了<strong>I/O请求的优化分布</strong>外，信息在磁盘上的排列方式、存储空间的分配方法都能影响存取访问速度</p><h3 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h3><ul><li>一个盘面上的读写磁头的轨迹称为<strong>磁道</strong></li><li>读写磁头写的所有磁道所组成的圆柱体称为<strong>柱面</strong></li><li>一个磁道又可划分成多个<strong>扇区（物理块）</strong></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/KqB9uFSQWptaNcV.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>文件信息通常并不记录在统一盘面的磁道上，而是<strong>记录在同一柱面的不同磁道上</strong>，这样可减少移动臂的移动次数，缩短存取信息的时间</p><p>为了访问磁盘上的一条物理记录，必须给出三个参数：<strong>柱面号、磁头号、扇区号</strong></p><h3 id="循环排序"><a href="#循环排序" class="headerlink" title="循环排序"></a>循环排序</h3><p>在最少的旋转圈数内完成位于同一柱面的访问请求</p><p><strong>旋转位置测定硬件</strong>和<strong>多磁头同时读写技术</strong>有利于提高旋转调度的效率；如果无法测定磁头当前位置，那么就需要多花费半周时间来定位第一个读取的记录块</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/DZq8jKNvBlQ9rUC.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/KCOaNyq7Vodt3mB.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="优化分布"><a href="#优化分布" class="headerlink" title="优化分布"></a>优化分布</h3><p>信息在存储空间中的排列方式会影响存取等待时间，例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/MbDGkVi1LUdwXFy.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="搜查定位"><a href="#搜查定位" class="headerlink" title="搜查定位"></a>搜查定位</h3><p>对于磁盘，除了<strong>旋转延迟</strong>外，还有<strong>搜查寻道延迟</strong>；因此对于磁盘设备</p><ul><li>在启动前按<strong>驱动调度策略</strong>对访问的I/O请求进行优化排序十分必要</li><li>除了使旋转圈数达到最少的调度策略外，还应该考虑<strong>移动臂的移动时间最短的调度策略</strong></li></ul><h4 id="先来先服务算法FIFO-FCFS"><a href="#先来先服务算法FIFO-FCFS" class="headerlink" title="先来先服务算法FIFO/FCFS"></a>先来先服务算法FIFO/FCFS</h4><p>磁盘臂是随机移动的，不考虑各I/O请求之间的相对次序和移动臂当前所处位置</p><ul><li>按顺序处理请求</li><li>对于所有进程是公平的</li></ul><p>缺点：进程等待I/O请求的时间会很长，寻道性能较差</p><h4 id="最短查找时间优先算法SSTF"><a href="#最短查找时间优先算法SSTF" class="headerlink" title="最短查找时间优先算法SSTF"></a>最短查找时间优先算法SSTF</h4><p>最短服务时间优先(SSTF, Shortest Service Time First)</p><ul><li>选择使磁头臂<strong>从当前位置开始移动最少的磁盘I/O请求</strong>， 因此SSTF策略总是选择导致最小寻道时间的请求</li><li>总是选择最小寻道时间<strong>并不能保证平均寻道时间最小</strong>， 但是，它的性能比FIFO更好</li></ul><p>缺点：此算法存在“饥饿”现象，随着靠近当前磁头位置读写请求的不断到来，使得到来时间较早但距离当前磁头位置较远的I/O请求服务被无限期地推迟</p><h4 id="扫描算法SCAN"><a href="#扫描算法SCAN" class="headerlink" title="扫描算法SCAN"></a>扫描算法SCAN</h4><ul><li>要求磁头臂<strong>仅仅沿一个方向移动</strong>， 并在途中满足所有为完成的请求， <strong>直到它到达这个方向上的最后一个磁道</strong>；它与电梯调度算法不同之处在于：<ul><li><strong>即使当前移动方向暂时没有I/O请求，移动臂也需要扫描到头</strong></li></ul></li><li>接着反转服务方向， 沿着相反方向扫描， 同样按顺序完成所有请求</li></ul><p>缺点：</p><ul><li>扫描算法<strong>偏爱那些最接近里面或者靠近外面（即盘面两端）的请求</strong>，对最近扫描所跨区域的I/O请求的响应速度会较慢</li><li>每次都移动到柱面尽头，无论前方是否有访问请求，效率较低</li></ul><h4 id="分步扫描算法N-step-Scan"><a href="#分步扫描算法N-step-Scan" class="headerlink" title="分步扫描算法N-step-Scan"></a>分步扫描算法N-step-Scan</h4><p>进程重复请求同一磁道会垄断整个设备， “造成磁头臂的粘性”，采用分步扫描可避免这类问题</p><ul><li>把磁盘请求队列分成长度为N的子队列，按FIFO算法依次处理每个子队列，每一次用SCAN处理一个子队列</li><li>在处理一个队列时， <strong>新请求必须添加到其他某个队列中</strong></li><li>如果<strong>在扫描的最后剩下的请求数小于N， 则它们全部将在下一次扫描时处理</strong></li></ul><p>当N很大时， N-step-SCAN的性能接近SCAN； 当N=1时， 实际上是FIFO</p><h4 id="电梯调度算法-LOOK算法"><a href="#电梯调度算法-LOOK算法" class="headerlink" title="电梯调度算法/LOOK算法"></a>电梯调度算法/LOOK算法</h4><p>它是扫描算法的一种改进，无访问请求时，移动臂停止不动；有访问请求时，移动臂按电梯规律移动：</p><ul><li>每次总是选择沿移动臂的移动方向上最近的那个柱面<ul><li>若一个柱面上有多个请求，还需要旋转优化</li></ul></li><li>如果当前移动方向上没有但相反方向有访问请求时，就改变移动臂的移动方向，然后处理所遇到的最近的I/O请求</li></ul><p><strong>移动臂移动方向</strong>和<strong>空闲时移动臂停留的位置</strong>都需要记录下来</p><p>说明：磁盘柱面号通常由外向里递增，磁头越向外，所处的柱面号越小，反之越大</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/lwGQBmAJYzFc3hf.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="循环扫描算法C-SCAN"><a href="#循环扫描算法C-SCAN" class="headerlink" title="循环扫描算法C-SCAN"></a>循环扫描算法C-SCAN</h4><p>对于不断有大量柱面均匀分布的存取请求进入系统的情况，循环扫描算法效率很高</p><ul><li>把扫描限定在一个方向</li><li>当访问到沿某个方向的最后一个磁道时， 磁头臂返回到磁盘相反方向磁道的末端， 并再次开始扫描</li></ul><p>移动臂总是从0号柱面至最大柱面顺序扫描，然后直接返回0号柱面重复进行，归途中不再提供服务，构成一个循环，缩短处理新来的请求的最大延迟</p><h4 id="FSCAN算法"><a href="#FSCAN算法" class="headerlink" title="FSCAN算法"></a>FSCAN算法</h4><ul><li>使用两个子队列</li><li>当开始扫描时， <strong>所有请求都在一个队列中</strong>， 而<strong>另一个队列为空</strong></li><li>在扫描过程中， <strong>所有新到的请求都被放入另一个队列中</strong></li><li>因此， 对新请求的服务延迟到处理完成所有老请求之后</li></ul><h4 id="后进先出算法LIFO"><a href="#后进先出算法LIFO" class="headerlink" title="*后进先出算法LIFO"></a>*后进先出算法LIFO</h4><ul><li>在事务处理系统中， 把设备资源提供给最近的用户， 会导致磁头臂在一个顺序文件中移动时移动得很少， 甚至不移动</li><li>利用这种局部性可以提高吞吐量， 减少队列长度只要一个作业积极地使用文件系统， 它就可以尽可能快地得到处理</li><li>如果由于工作量大而磁盘保持忙状态， 就有可能出现饿死的情况</li><li>当一个作业已经往队列中送入一个I/O请求， 并且错过了可以提供服务的位置时， 该作业就有可能永远得不到服务， 除非它之前的队列变为空</li></ul><h4 id="优先级Priority"><a href="#优先级Priority" class="headerlink" title="*优先级Priority"></a>*优先级Priority</h4><ul><li>这种方法并不会优化磁盘的使用率， 但可以满足操作系统的其他目标</li><li>通常<strong>比较短的批作业和交互作业的优先级较高</strong>， 而<strong>较长计算时间的长作业优先级低</strong>， 这就使得大量短作业能够迅速地通过系统， 并且可以提供比较好的交互响应时间</li><li>但是长作业不得不等待很长的时间</li></ul><h3 id="提高磁盘I-O速度的方法"><a href="#提高磁盘I-O速度的方法" class="headerlink" title="提高磁盘I/O速度的方法"></a>提高磁盘I/O速度的方法</h3><p>通常为磁盘设置数据缓冲区高速缓存，这样能够显著缩短等待磁盘I/O的时间</p><h4 id="提前读"><a href="#提前读" class="headerlink" title="提前读"></a>提前读</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/home/steve/.config/Typora/typora-user-images/1576918288946.png" alt="1576918288946" title>                </div>                <div class="image-caption">1576918288946</div>            </figure><h4 id="延迟写"><a href="#延迟写" class="headerlink" title="延迟写"></a>延迟写</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/M7sgu4CvDaklIzU.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/21/QvukqJ.png" alt="QvukqJ.png" title>                </div>                <div class="image-caption">QvukqJ.png</div>            </figure><h4 id="虚拟盘"><a href="#虚拟盘" class="headerlink" title="虚拟盘"></a>虚拟盘</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/21/QvuZI1.png" alt="QvuZI1.png" title>                </div>                <div class="image-caption">QvuZI1.png</div>            </figure><h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><p>作业执行前对设备提出申请时， 指定某台具体的物理设备会让设备分配变得简单， 但如果所指定设备出现故障， 即便计算机系统中有同类设备也不能运行</p><p>定义：用户通常不指定物理设备， 而是指定逻辑设备， 使得<strong>用户作业和物理设备分离开来</strong>， 再通过其它途径建立逻辑设备和物理设备之间的映射</p><ul><li>逻辑设备名（号）是用户命名的，是可更改的</li><li>物理设备名（号）是系统规定的，是不可更改的</li></ul><p>设备管理的功能之一就是<strong>把逻辑设备名（号）转换成物理设备名（号）</strong>，为此系统需要提供逻辑设备名和物理设备名（设备地址）的对照表以供转换使用</p><p>优点：</p><ul><li>应用程序与具体物理设备无关，系统增减或变更设备时不需要修改源程序</li><li>易于<strong>应对I/O设备故障</strong>， 提高系统可靠性</li><li>增加<strong>设备分配的灵活性</strong>， 更有效地利用设备资源，实现多道程序设计</li></ul><h3 id="设备分配-1"><a href="#设备分配-1" class="headerlink" title="设备分配"></a>设备分配</h3><p>设备分类：</p><ul><li><p>独占型设备（静态分配）</p><p>例如光盘、磁带等</p><p>在作业执行前，将所要使用的设备全部分配给它（即<strong>运行前先申请</strong>），当作业执行过程中不再需要使用这类设备或作业执行结束将要撤离时再回收设备</p><p>优点：实现简单，能够防止系统死锁</p><p>缺点：降低设备利用率（因为在进程结束之前很长一段时间内，设备可能是空闲的）</p></li><li><p>共享设备（动态分配）</p><p>像磁盘这种共享型设备一般不需要分配，设备管理的主要工作是驱动调度和实施驱动</p><p>优点：设备利用率高</p><p>缺点：实现复杂，需要仔细检查以避免死锁</p></li><li><p>虚拟设备（虚拟分配）</p></li></ul><h3 id="设备分配的数据结构"><a href="#设备分配的数据结构" class="headerlink" title="设备分配的数据结构"></a>设备分配的数据结构</h3><h4 id="设备类表"><a href="#设备类表" class="headerlink" title="设备类表"></a>设备类表</h4><ul><li><p><strong>每类设备对应于设备类表的中一栏</strong></p></li><li><p>包括： 设备类， 总台数， 空闲台数， 设备表起始地址等</p></li><li><p>支持设备独立性时才会使用；进程申请设备时，是<strong>申请设备类表中的某一中逻辑设备</strong>，用以实现设备独立性</p></li></ul><h4 id="设备表"><a href="#设备表" class="headerlink" title="设备表"></a>设备表</h4><ul><li><strong>每类设备都有各自的设备表</strong>， 用来登记<strong>这类设备中的每台物理设备</strong></li><li>包括： 物理设备名（号） ， 逻辑设备名（号） ， 占有设备的进程号， 是否分配， 好/坏标志等</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/21/Qv3Xlt.png" alt="Qv3Xlt.png" title>                </div>                <div class="image-caption">Qv3Xlt.png</div>            </figure><h2 id="虚拟设备"><a href="#虚拟设备" class="headerlink" title="虚拟设备"></a>虚拟设备</h2><p>SPOOLing技术：是用一类物理设备模拟另一类物理设备的技术，是使独占型设备变成共享型设备的一种技术</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/CUKbimLYEfwB1Wd.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="SPOOLing设计与实现"><a href="#SPOOLing设计与实现" class="headerlink" title="SPOOLing设计与实现"></a>SPOOLing设计与实现</h3><p>为了存放从输入设备输入的信息以及作业执行后的输出结果，系统在磁盘上开辟输入井和输出井，井是用作缓冲的存储区域；为此必须有“</p><ul><li>能将信息从输入设备输入磁盘输入缓冲区的“预输入程序”</li><li>能将信息从磁盘输出缓冲区输出至输出设备的“缓输出程序”</li><li>控制作业和磁盘缓冲区之间交换信息的“井管理程序”</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/HXRmZKNVJtI5a4D.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>系统有一张作业表来登记进入系统的所有作业的JCB，包含作业名、作业状态、预输入表位置、缓输出表位置等信息</p><ul><li>预输入表用来登记作业的各个输入文件的情况，包括设备类、文件名、信息长度及存放位置等</li><li>缓输出表用来登记作业的各个输出文件的情况，包括设备类、文件名、信息长度及存放位置等</li></ul><h4 id="预输入程序"><a href="#预输入程序" class="headerlink" title="预输入程序"></a>预输入程序</h4><p>其任务是<strong>控制信息从输入设备输入至输入井</strong>，<strong>填写预输入表</strong>以便在作业执行过程中要求输入信息时可以随时找到其存放位置</p><p>输入井中的作业状态：</p><ul><li><p>输入状态</p><p>作业信息正在从输入设备上预输入</p></li><li><p>收容状态</p><p>作业预输入完成，但未被选中执行</p></li><li><p>执行状态</p><p>作业已被选中运行，它在运行过程中可以从输入井中读取数据，也可以向输出井写入数据</p></li><li><p>完成状态</p><p>作业已经撤离，作业的输出结果等待缓输出</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/21/QvNnJg.png" alt="QvNnJg.png" title>                </div>                <div class="image-caption">QvNnJg.png</div>            </figure><p>作业表的状态项指示哪些作业正在预输入，哪些作业已经完成预输入，哪些作业正在执行等，作业调度程序根据预定的调度算法<strong>选择处于收容状态的作业执行</strong></p><p>存放在井中的文件称为井文件，井文件被划分成<strong>等长的物理块</strong>，每块用于存放一条或多条逻辑记录，存放方式有：</p><ul><li>连接方式：类似于链表的方式</li><li>计算方式：类似于数组的方式</li></ul><h4 id="井管理程序"><a href="#井管理程序" class="headerlink" title="井管理程序"></a>井管理程序</h4><p>作业执行过程中要求启动某台设备进行I/O操作时，作业控制程序截获这个要求并调用井管理程序控制从输入井读取信息，或将信息送至输出井</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/mDnGgI7EaT6kRjS.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="缓输出程序"><a href="#缓输出程序" class="headerlink" title="缓输出程序"></a>缓输出程序</h4><p>当<strong>处理器空闲</strong>时，操作系统调用缓输出程序执行缓输出</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/21/93Hm1tQTsPEL5jK.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="SPOOLing应用"><a href="#SPOOLing应用" class="headerlink" title="SPOOLing应用"></a>SPOOLing应用</h3><p>实现方式：守护进程 + SPOOL文件目录，要进行输出的文件首先传送至SPOOL目录，然后在设备空闲时守护进程将SPOOL目录下的文件传送到设备</p><p>并且，守护进程是唯一有特权使用设备的进程</p><h4 id="打印机SPOOLing守护进程"><a href="#打印机SPOOLing守护进程" class="headerlink" title="打印机SPOOLing守护进程"></a>打印机SPOOLing守护进程</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/21/QvNTTf.png" alt="QvNTTf.png" title>                </div>                <div class="image-caption">QvNTTf.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/21/QvNqfg.png" alt="QvNqfg.png" title>                </div>                <div class="image-caption">QvNqfg.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/21/QvUcBq.png" alt="QvUcBq.png" title>                </div>                <div class="image-caption">QvUcBq.png</div>            </figure><h4 id="网络通信SPOOLing守护进程"><a href="#网络通信SPOOLing守护进程" class="headerlink" title="网络通信SPOOLing守护进程"></a>网络通信SPOOLing守护进程</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/12/21/QvNvXn.png" alt="QvNvXn.png" title>                </div>                <div class="image-caption">QvNvXn.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设备管理&quot;&gt;&lt;a href=&quot;#设备管理&quot; class=&quot;headerlink&quot; title=&quot;设备管理&quot;&gt;&lt;/a&gt;设备管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="设备管理" scheme="http://QQ876684433.github.io/tags/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>CPP输入输出</title>
    <link href="http://QQ876684433.github.io/2019/12/17/CPP%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://QQ876684433.github.io/2019/12/17/CPP输入输出/</id>
    <published>2019-12-17T10:57:43.000Z</published>
    <updated>2019-12-17T15:15:32.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-输入输出"><a href="#C-输入输出" class="headerlink" title="C++输入输出"></a>C++输入输出</h1><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><blockquote><p>参考资料：<a href="https://liam.page/2017/12/31/buffer-of-stream-in-Cpp/" target="_blank" rel="noopener">https://liam.page/2017/12/31/buffer-of-stream-in-Cpp/</a></p></blockquote><p>C++ 中的流对象实际上是对缓冲区进行操作，因此只需要通过替换输入（cin）和输出（cout）的缓冲区即可实现输入或者输出重定向</p><p><code>std::basic_ios</code> 的成员函数 <code>rdbuf</code> 是读取和设置流对象（<code>std::basic_ios</code> 的对象）绑定缓冲区的成员函数，它有两个不同的重载形式，分别如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::basic_streambuf&lt;CharT, Traits&gt;*</span><br><span class="line">rdbuf() <span class="keyword">const</span>;                                      <span class="comment">// 1.</span></span><br><span class="line"><span class="built_in">std</span>::basic_streambuf&lt;CharT, Traits&gt;*</span><br><span class="line">rdbuf( <span class="built_in">std</span>::basic_streambuf&lt;CharT, Traits&gt;* sb );   <span class="comment">// 2.</span></span><br></pre></td></tr></table></figure><p>两个重载版本，第一版不接受任何参数，第二版接受一个指向 <code>std::basic_streambuf</code> 类型对象的指针。</p><p>不接受参数的版本返回流对象绑定的缓冲区对象的指针；而若流对象未绑定任何缓冲区对象，则返回空指针 <code>nullptr</code>。接受指针的版本首先返回上述指针，而后与先前绑定的缓冲区对象（如果有）解绑，再绑定参数中传入指针指向的缓冲区对象；而若传入空指针 <code>nullptr</code>，则流对象不与任何缓冲区对象绑定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"in.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"out.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">istrstream <span class="title">iss</span><span class="params">(<span class="string">"istream test"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cin</span>.rdbuf(in.rdbuf());</span><br><span class="line">    <span class="built_in">cout</span>.rdbuf(out.rdbuf());</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>.rdbuf(iss.rdbuf());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">steve@steve-PC:~/MasterCPP/src/io$ cat in.txt </span><br><span class="line">1 2 3</span><br><span class="line">1.2 3.4 5.6</span><br><span class="line">int float</span><br><span class="line">Hello world!</span><br><span class="line">steve@steve-PC:~/MasterCPP/src/io$</span><br></pre></td></tr></table></figure><h2 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h2><blockquote><p>参考来源：<a href="http://c.biancheng.net/view/1346.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1346.html</a></p></blockquote><h3 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h3><p>它会<strong>忽略掉所有前导空白字符</strong>，所以使用 cin&gt;&gt; 就不可能仅输入一个空格或回车符。除非用户输入了空格键、制表符之外的其他字符，否则程序将不可能通过 cin 语句继续执行（一旦输入了这样的字符，在程序可以继续下一个语句之前，仍然需要按回车键）；<strong>遇“空格”、“TAB”、“回车”都结束</strong></p><p>在cin完成一次输入之后，遇到的空白字符如“空格”，“tab”和“回车”等都会留在缓冲区中</p><h3 id="cin-get"><a href="#cin-get" class="headerlink" title="cin.get()"></a>cin.get()</h3><p>cin 对象有一个名为 get 的内置函数很有帮助。因为 get 函数是内置在 cin 对象中的，所以可称之为 cin 的一个成员函数。get 成员函数读取单个字符，包括任何白色空格字符。如果程序需要存储正在读取的字符，则可以通过以下任意一种方式调用 get 成员函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.get (ch);</span><br><span class="line">ch = <span class="built_in">cin</span>.get();</span><br></pre></td></tr></table></figure><p>将 cin &gt;&gt; 与 cin.get 混合使用可能会导致烦人且难以发现的问题。请看下面的代码段示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;    <span class="comment">//定义一个字符变量</span></span><br><span class="line"><span class="keyword">int</span> number; <span class="comment">//定义一个整型变量</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a number: ”;</span></span><br><span class="line"><span class="string">cin &gt;&gt; number;   // 读取整数</span></span><br><span class="line"><span class="string">cout &lt;&lt; "</span>Enter a character: <span class="string">";</span></span><br><span class="line"><span class="string">ch = cin.get() ;   // 读取字符</span></span><br><span class="line"><span class="string">cout &lt;&lt; "</span>Thank You!\n<span class="string">";</span></span><br></pre></td></tr></table></figure><p>这些语句允许用户输入一个数字，而不是一个字符。看来第 6 行的 cin.get 语句已经被跳过了。这是因为 cin&gt;&gt; 和 cin.get 使用略有不同的技术来读取数据。<br>在示例代码段中，当执行第 4 行时，用户输入一个数字，然后按回车键。假设输入的是数字 100。按回车键会导致一个换行符(‘\n’)存储在键盘缓冲区数字 100 之后，如图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://c.biancheng.net/uploads/allimg/181114/2-1Q114130JI45.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><p>当第 6 行中的 cin.get 函数执行时，它开始从先前输入操作停止的键盘缓冲区读取，并发现了换行符，所以它无须等待用户输入另一个值。这种问题最直接的解决办法是<strong>使用 cin.ignore 函数</strong>。</p><p><strong>cin.get(字符数组名,接收字符数目)用来接收一行字符串</strong>，但是实际上接受字符数目中最后一个字符是字符串的结束字符<code>\0</code>，例如：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/rAHeaftnWU4mEV1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/MisterLing/article/details/51697098" target="_blank" rel="noopener">https://blog.csdn.net/MisterLing/article/details/51697098</a></p></blockquote><ul><li><p>在头文件&lt;istream&gt;中，是istream类的成员函数，如cin.getline(…)，它有两种重载形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(<span class="keyword">char</span>* s, streamsize n )</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(<span class="keyword">char</span>* s, streamsize n, <span class="keyword">char</span> delim )</span></span>;</span><br></pre></td></tr></table></figure><p>作用是： 从istream中读取<strong>至多n个字符(包含结束标记符)</strong>（换行符会被丢弃）保存在s对应的数组中。即使还没读够n个字符，如果遇到delim或字数达到限制，则读取终止，<strong>delim都不会被保存进s对应的数组中</strong></p><p><img src="https://i.loli.net/2019/12/17/iSGwO9phq7VLjKg.png" alt></p></li><li><p>在&lt;string&gt;中的getline函数有四种重载形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;  is, <span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;&amp; is, <span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;  is, <span class="built_in">string</span>&amp; str)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp;&amp; is, <span class="built_in">string</span>&amp; str)</span></span>;</span><br></pre></td></tr></table></figure><p>用法和上第一种类似，但是读取的istream是作为参数is传进函数的。读取的字符串<strong>保存在string类型的str中</strong></p><p>is   ：表示一个输入流，例如cin。</p><p>str  ：string类型的<strong>引用</strong>，用来<strong>存储输入流中的流信息</strong>。</p><p>delim ：char类型的变量，所设置的截断字符；在<strong>不自定义设置的情况下，遇到’\n’</strong>，则终止输入。</p><p><img src="https://i.loli.net/2019/12/17/em3f9dAXvhSyCG6.png" alt></p><p>getline不是C库函数，而是C++库函数。它遇到以下情况发生会导致生成的本字符串结束：</p><p>(1)到文件结束，(2)遇到函数的定界符，(3)输入达到最大限度</p></li></ul><p>getline()函数在while中作为条件判断时，while判断语句的真实判断对象是cin的状态，也就是判断当前是否存在有效的输入流；而输入流是对象，判断的是流返回的状态。所以正常的情况下，你怎么输入都是跳不出它的循环。我们可以手动输入输入流结束字符来跳出循环（<strong>按Ctrl+Z(Windows)(Ctrl+D(Linux))或键入EOF(参考MSDN)</strong>）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/8m3eD92tOSyKhGH.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>当设置了分隔符之后，输入回车也不会导致getline结束一次输入，只有遇到设置的分隔符才会完成一次输入：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/GYhpF2Dny5QlzbK.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/hustfoxy/article/details/23473805" target="_blank" rel="noopener">https://blog.csdn.net/hustfoxy/article/details/23473805</a></p></blockquote><h4 id="strtok函数"><a href="#strtok函数" class="headerlink" title="strtok函数"></a>strtok函数</h4><p>函数原型：char * strtok (char *str, const char * delimiters);<br>参数：str，待分割的字符串（c-string）；delimiters，分割符字符串。<br>该函数用来将字符串分割成一个个片段。参数str指向欲分割的字符串，参数delimiters则为分割字符串中包含的所有字符。当strtok()在参数s的字符串中发现参数delimiters中包涵的分割字符时，则会将该字符改为\0 字符。在第一次调用时，strtok()必需给予参数s字符串，往后的调用则将参数s设置成NULL。每次调用成功则返回指向被分割出片段的指针。<br>需要注意的是，使用该函数进行字符串分割时，会破坏被分解字符串的完整，调用前和调用后的s已经不一样了。第一次分割之后，原字符串str是分割完成之后的第一个字符串，剩余的字符串存储在一个静态变量中，因此多线程同时访问该静态变量时，则会出现错误。</p><p>在cpp中的例子（注意要引入cstring和cstdlib两个头文件）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"ab,cd,ef"</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"before strtok: str="</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"begin:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ptr = strtok(str, <span class="string">","</span>);</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="string">"str="</span>) &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="string">"ptr="</span>) &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ptr = strtok(<span class="literal">NULL</span>, <span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before strtok: str=ab,cd,ef</span><br><span class="line">begin:</span><br><span class="line">str=ab</span><br><span class="line">ptr=ab</span><br><span class="line">str=ab</span><br><span class="line">ptr=cd</span><br><span class="line">str=ab</span><br><span class="line">ptr=ef</span><br></pre></td></tr></table></figure><h4 id="strtok-s函数"><a href="#strtok-s函数" class="headerlink" title="strtok_s函数"></a>strtok_s函数</h4><p>strtok_s是windows下的一个分割字符串安全函数，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok_s</span><span class="params">( <span class="keyword">char</span> *strToken, <span class="keyword">const</span> <span class="keyword">char</span> *strDelimit, <span class="keyword">char</span> **buf)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数将剩余的字符串存储在buf变量中，而不是静态变量中，从而保证了安全性。</p><h4 id="strtok-r函数"><a href="#strtok-r函数" class="headerlink" title="strtok_r函数"></a>strtok_r函数</h4><p>strtok_s函数是linux下分割字符串的安全函数，函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok_r</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *delim, <span class="keyword">char</span> **saveptr)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数也会破坏带分解字符串的完整性，但是其将剩余的字符串保存在saveptr变量中，保证了安全性。</p><p>例子（注释里的是另一种写法，效果一样）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"ab,cd,ef"</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="comment">// char **tmpStr;</span></span><br><span class="line">    <span class="keyword">char</span> *tmpStr;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"before strtok: str="</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"begin:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// ptr = strtok_r(str, ",", tmpStr);</span></span><br><span class="line">    ptr = strtok_r(str, <span class="string">","</span>, &amp;tmpStr);</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="string">"str="</span>) &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="string">"ptr="</span>) &lt;&lt; ptr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// ptr = strtok_r(*tmpStr, ",", tmpStr);</span></span><br><span class="line">        ptr = strtok_r(tmpStr, <span class="string">","</span>, &amp;tmpStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before strtok: str=ab,cd,ef</span><br><span class="line">begin:</span><br><span class="line">str=ab</span><br><span class="line">ptr=ab</span><br><span class="line">str=ab</span><br><span class="line">ptr=cd</span><br><span class="line">str=ab</span><br><span class="line">ptr=ef</span><br></pre></td></tr></table></figure><h4 id="用STL进行字符串的分割"><a href="#用STL进行字符串的分割" class="headerlink" title="用STL进行字符串的分割"></a>用STL进行字符串的分割</h4><blockquote><p>参考来源：<a href="https://www.cnblogs.com/MikeZhang/archive/2012/03/24/MySplitFunCPP.html" target="_blank" rel="noopener">https://www.cnblogs.com/MikeZhang/archive/2012/03/24/MySplitFunCPP.html</a></p></blockquote><p>上面提到的是对C风格数组字符串的分割函数，这里的是C++中string的分割函数；涉及到string类的两个函数find和substr：<br>1、find函数<br>原型：<code>size_t find ( const string&amp; str, size_t pos = 0 ) const;</code><br>功能：查找子字符串第一次出现的位置。<br>参数说明：str为子字符串，pos为初始查找位置。<br>返回值：找到的话返回第一次出现的位置，否则返回string::npos </p><p>2、substr函数<br>原型：<code>string substr ( size_t pos = 0, size_t n = npos ) const;</code><br>功能：获得子字符串。<br>参数说明：pos为起始位置（默认为0），n为结束位置（默认为npos）<br>返回值：子字符串 </p><p>例子（多个分隔符版本）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split(<span class="built_in">string</span> str, <span class="built_in">string</span> pattern)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> patSize = pattern.size();</span><br><span class="line">    <span class="keyword">auto</span> strSize = str.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splits;</span><br><span class="line">    <span class="keyword">size_t</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; strSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = pattern.find(str[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; patSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前是分隔符</span></span><br><span class="line">            splits.push_back(str.substr(start, i - start));</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理最后一个</span></span><br><span class="line">    splits.push_back(str.substr(start, strSize));</span><br><span class="line">    <span class="keyword">return</span> splits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">" jai sdis sa,,dj  fia ,"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splits = split(str, <span class="string">" ,"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">string</span> s : splits)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">jai</span><br><span class="line">sdis</span><br><span class="line">sa</span><br><span class="line"></span><br><span class="line">dj</span><br><span class="line"></span><br><span class="line">fia</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-输入输出&quot;&gt;&lt;a href=&quot;#C-输入输出&quot; class=&quot;headerlink&quot; title=&quot;C++输入输出&quot;&gt;&lt;/a&gt;C++输入输出&lt;/h1&gt;&lt;h2 id=&quot;重定向&quot;&gt;&lt;a href=&quot;#重定向&quot; class=&quot;headerlink&quot; title=&quot;重
      
    
    </summary>
    
      <category term="C++" scheme="http://QQ876684433.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://QQ876684433.github.io/tags/C/"/>
    
      <category term="输入输出" scheme="http://QQ876684433.github.io/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据库-函数依赖和范式</title>
    <link href="http://QQ876684433.github.io/2019/12/04/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%92%8C%E8%8C%83%E5%BC%8F/"/>
    <id>http://QQ876684433.github.io/2019/12/04/数据库-函数依赖和范式/</id>
    <published>2019-12-04T14:26:41.000Z</published>
    <updated>2019-12-24T06:43:30.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库-函数依赖和范式"><a href="#数据库-函数依赖和范式" class="headerlink" title="数据库-函数依赖和范式"></a>数据库-函数依赖和范式</h1><blockquote><p>链接：<a href="https://www.nowcoder.com/questionTerminal/1acb9fc7610a4781b87363204f83609b?toCommentId=229287" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/1acb9fc7610a4781b87363204f83609b?toCommentId=229287</a></p><p>来源：牛客网</p></blockquote><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="第1范式"><a href="#第1范式" class="headerlink" title="第1范式"></a>第1范式</h3><p>定义：如果关系R 中所有属性的值域都是单纯域，那么关系模式R是第一范式的</p><p>那么符合第一模式的特点就有</p><p>1)有主关键字</p><p>2)主键不能为空，</p><p>3)主键不能重复,</p><p>4)字段不可以再分</p><h3 id="第2范式"><a href="#第2范式" class="headerlink" title="第2范式"></a>第2范式</h3><p>数据库表中<strong>不存在非关键字段</strong>对任一<a href="http://baike.baidu.com/view/549695.htm" target="_blank" rel="noopener">候选关键字</a>段的 <strong><a href="http://baike.baidu.com/view/4807244.htm" target="_blank" rel="noopener">部分函数依赖</a></strong>（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</p><h3 id="第3范式"><a href="#第3范式" class="headerlink" title="第3范式"></a>第3范式</h3><p>在第二范式的基础上，数据表中如果<strong>不存在非关键字段</strong>对任一候选关键字段的<strong><a href="http://baike.baidu.com/view/550979.htm" target="_blank" rel="noopener">传递函数依赖</a></strong>则符合第三范式。因此，满足第三范式的数据库表应该不存在如下依赖关系：           </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关键字段 → 非关键字段x → 非关键字段y</span><br></pre></td></tr></table></figure><h3 id="BCNF（-鲍依斯-科得范式-）："><a href="#BCNF（-鲍依斯-科得范式-）：" class="headerlink" title="BCNF（ 鲍依斯-科得范式 ）："></a>BCNF（ 鲍依斯-科得范式 ）：</h3><p>​    在第三范式的基础上，数据库表中如果<strong>不存在任何字段</strong>对任一候选关键字段的<strong><a href="http://baike.baidu.com/view/550979.htm" target="_blank" rel="noopener">传递函数依赖</a></strong>则符合BCNF。<br>​      </p><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><ol><li>数据依赖<br> 数据依赖指的是通过一个关系中属性间的相等与否体现出来的数据间的相互关系，其中最重要的是函数依赖和多值依赖。<br>​    </li><li>函数依赖<br> 设X,Y是关系R的两个属性集合，当任何时刻R中的任意两个元组中的X属性值相同时，则它们的Y属性值也相同，则称X函数决定Y，或Y函数依赖于X。<br>​    </li><li>平凡函数依赖<br> 当关系中属性集合Y是属性集合X的子集时(Y?X)，存在函数依赖X→Y，即一组属性函数决定它的所有子集，这种函数依赖称为平凡函数依赖。<br>​    </li><li>非平凡函数依赖<br> 当关系中属性集合Y不是属性集合X的子集时，存在函数依赖X→Y，则称这种函数依赖为非平凡函数依赖。<br>​    </li><li>完全函数依赖<br> 设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。<br>​    </li><li>部分函数依赖<br> 设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。<br>​    </li><li>传递函数依赖<br> 设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库-函数依赖和范式&quot;&gt;&lt;a href=&quot;#数据库-函数依赖和范式&quot; class=&quot;headerlink&quot; title=&quot;数据库-函数依赖和范式&quot;&gt;&lt;/a&gt;数据库-函数依赖和范式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://w
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="转载" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="函数依赖" scheme="http://QQ876684433.github.io/tags/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/"/>
    
      <category term="范式" scheme="http://QQ876684433.github.io/tags/%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CPP操作符重载</title>
    <link href="http://QQ876684433.github.io/2019/12/03/CPP%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://QQ876684433.github.io/2019/12/03/CPP操作符重载/</id>
    <published>2019-12-03T08:12:10.000Z</published>
    <updated>2019-12-17T01:53:05.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-操作符重载"><a href="#C-操作符重载" class="headerlink" title="C++操作符重载"></a>C++操作符重载</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>重载的运算符是具有特殊名字的函数：函数的名字由关键字operator和其后要定义的运算符号共同组成</p></li><li><p>重载运算符函数的参数数量与该运算符作用的运算对象的数量一样多</p></li><li><p>除了重载的函数调用运算符operator()之外，其他的重载运算符不能含有默认实参</p></li><li><p>当一个重载的运算符是成员函数时，this对象指针绑定到左侧运算对象（即运算符重载函数的第一个参数）</p></li><li><p>不能重载内置类型的运算符</p></li><li><p>我们只能重载已有的运算符</p></li><li><p>对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符一致</p><p>即<code>x == (y + z)</code>永远等价于<code>x == (y + z)</code></p></li></ul><p>其中<code>::</code>、<code>.*</code>、<code>.</code>和<code>?:</code>不能被重载：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/03/hTq6WVGOiKXpnft.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>运算符重载函数是可以像普通函数一样被显式调用的</p><ul><li><p>非成员函数运算符重载函数的等价调用</p><p><img src="https://i.loli.net/2019/12/03/PzaKcW3mkhQ7jMU.png" alt></p></li><li><p>成员函数运算符重载函数的等价调用</p><p><img src="https://i.loli.net/2019/12/03/cmJEn5YrWvPfaMj.png" alt></p></li></ul></li></ul><h3 id="某些运算符不应该被重载"><a href="#某些运算符不应该被重载" class="headerlink" title="某些运算符不应该被重载"></a>某些运算符不应该被重载</h3><p>某些运算符指定了运算对象的求值顺序，使用重载的运算符本质上是一次函数调用，所以这些关于<strong>运算符对象求值顺序的规则</strong>无法应用到重载的运算符上：逻辑与运算符（&amp;&amp;）、逻辑或运算符（||）和逗号运算符的运算对象求值顺序规则无法保留下来；此外逻辑与运算符（&amp;&amp;）、逻辑或运算符（||）的<strong>短路求值属性</strong>也无法保留，两个运算对象总是会被求值</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/16/DY4N2BxTgMSlyRr.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="使用与内置类型一致的含义"><a href="#使用与内置类型一致的含义" class="headerlink" title="使用与内置类型一致的含义"></a>使用与内置类型一致的含义</h3><p>重载运算符的<strong>返回类型</strong>通常情况下应该<strong>与其内置版本的返回类型兼容</strong>：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回<u><em>左侧运算对象</em></u>的一个引用</p><h3 id="选择作为成员或者非成员"><a href="#选择作为成员或者非成员" class="headerlink" title="选择作为成员或者非成员"></a>选择作为成员或者非成员</h3><ul><li><p>作为成员</p><p>（或者说，单目运算符多是作为成员？）</p><ul><li><strong>赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）运算符</strong>必须是成员</li><li>复合赋值运算符（+=、-=、*=、/=、%=等）一般来说是成员</li><li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员</li></ul></li><li><p>作为普通的非成员</p><ul><li>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/16/Fg6t7Sh5xK2WQ8U.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="输入输出运算符"><a href="#输入输出运算符" class="headerlink" title="输入输出运算符"></a>输入输出运算符</h2><h3 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h3><ul><li>输出运算符的第一个形参是一个<strong>非常量</strong>ostream对象的<strong>引用</strong><ul><li>非常量：向流写入内容会改变其内容</li><li>引用：我们无法直接复制一个ostream对象</li></ul></li><li>第二个形参一般来说是一个<strong>常量</strong>的<strong>引用</strong><ul><li>常量：通常情况下打印对象不会改变对象的内容</li><li>引用：我们希望避免复制实参</li></ul></li><li>operator&lt;&lt; 一般要<strong>返回它的ostream形参</strong>（是一个引用）</li></ul><h4 id="输出运算符尽量减少格式化操作"><a href="#输出运算符尽量减少格式化操作" class="headerlink" title="输出运算符尽量减少格式化操作"></a>输出运算符尽量减少格式化操作</h4><p>输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符<strong>不应该打印换行符</strong></p><h4 id="输入输出运算符必须是非成员函数"><a href="#输入输出运算符必须是非成员函数" class="headerlink" title="输入输出运算符必须是非成员函数"></a>输入输出运算符必须是非成员函数</h4><p>如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数；由于通常要读取类的非公有数据成员，所以<strong>IO运算符一般被声明成友元</strong></p><h3 id="重载输入运算符-gt-gt"><a href="#重载输入运算符-gt-gt" class="headerlink" title="重载输入运算符&gt;&gt;"></a>重载输入运算符&gt;&gt;</h3><ul><li>输入运算符的第一个形参是运算符将要读取的流的引用</li><li>第二个形参是将要读入到<strong>（非常量）对象</strong>的<strong>引用</strong><ul><li>非常量（必须）：因为输入运算符本身的目的就是将数据读入到这个对象（修改其内部状态）</li></ul></li><li>运算符通常会返回某个给定流的引用</li></ul><p><u><em>输入运算符必须处理 输入可能失败的情况，而输出运算符不需要</em></u></p><h4 id="输入时的错误"><a href="#输入时的错误" class="headerlink" title="输入时的错误"></a>输入时的错误</h4><ul><li>当<strong>流含有错误类型的数据</strong>时读取操作可能失败，那么读取操作和后续对流的使用都将失败</li><li>当<strong>读取操作到达文件末尾或者遇到输入流的其他错误</strong>时也会失败</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/16/FVMQjZd35KwIubG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="标示错误"><a href="#标示错误" class="headerlink" title="标示错误"></a>标示错误</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/16/InHA5YWrR1tThzo.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="算术和关系运算符"><a href="#算术和关系运算符" class="headerlink" title="算术和关系运算符"></a>算术和关系运算符</h2><ul><li>通常将算术和关系运算符定义为<strong>非成员函数</strong>以<strong>允许对左侧或右侧的运算对象进行转换</strong></li><li>形参都是<strong>常量的引用</strong>，因为这些<strong>运算符通常不需要改变运算对象的状态</strong></li></ul><p>算术运算符通常会计算两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量内，操作完成后返回该局部变量的副本作为其结果</p><p>一般来说可以<strong>使用复合赋值符来定义算术运算符</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data</span><br><span class="line"><span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">Sales_data sum = lhs;</span><br><span class="line">sum += rhs;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/16/si3NSTIUp5QCmA7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>C++中的类通常通过定义一个相等运算符来检验两个对象是否相等：它会比较对象的每个数据成员，只有当所有对应的成员都相等时才认为两个对象相等</p><ul><li>相等运算符应该具有传递性：如果a==b和b==c都为真，那么应该有a==c为真</li><li>如果类定义了operator==，则这个类也应该定义operator!=</li><li>相等运算符和不相等运算符中的一个应该把工作委托给另一个</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp;</span><br><span class="line">lhs.units_sold == units_sold &amp;&amp;</span><br><span class="line">lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>通常情况下关系运算符应该：</p><ul><li>定义顺序关系，令其与关联容器对关键字的要求一致</li><li>如果类同时也含有==运算符的话，则定义一种关系令其与==保持一致；特别是，如果两个对象是!=的，那么一个对象应该&lt;另一个</li></ul><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><h4 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h4><ul><li>倾向于把包括复合赋值在内的赋值运算都定义在类的内部</li><li>另一个参数通常是<strong>常量的引用</strong>，因为复合赋值运算符往往不会改变另一个参数的值，并且可以避免引起拷贝</li><li>为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要<strong>返回其左侧运算对象的引用</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data &amp;Sales_data::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">units_sold += rhs.units_sold;</span><br><span class="line">revenue += rhs.revenue;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>下标运算符<strong>必须是成员函数</strong></p><ul><li><p>通常以<strong>所访问元素的引用</strong>作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端</p></li><li><p>我们最好同时定义下标运算符的常量版本和非常量版本，以便作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值</p><ul><li><p>一个返回普通引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span><br><span class="line">&#123; <span class="keyword">return</span> elements[n]; &#125;</span><br></pre></td></tr></table></figure></li><li><p>另一个是类的常量成员并且返回常量引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span></span><br><span class="line">&#123; <span class="keyword">return</span> elements[n]; &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><p>由于递增递减运算符改变的是所操作对象的状态，所以建议将其设定为成员函数</p><h3 id="定义前置递增-递减运算符"><a href="#定义前置递增-递减运算符" class="headerlink" title="定义前置递增/递减运算符"></a>定义前置递增/递减运算符</h3><p>为了与内置版本保持一致，前置运算符<strong>应该返回递增或递减后对象的引用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="区分前置和后置运算符"><a href="#区分前置和后置运算符" class="headerlink" title="区分前置和后置运算符"></a>区分前置和后置运算符</h3><p>普通的重载版本无法区分这两种情况，它们使用的是同一个符号，意味着其重载版本所用的名字将是相同的，并且运算对象的数量和类型也相同</p><ul><li>为了解决这个问题，<strong>后置版本接受一个额外的（不被使用）int类型的形参</strong>；当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参</li><li>为了与内置版本保持一致，后置运算符应该<strong>返回对象的原值（递增或递减之前的值）</strong>，返回形式是<strong>一个值而非引用</strong></li><li>因此在递增对象之前需要<strong>首先记录对象的状态</strong></li><li>可以使用前置运算符来实现后置运算符（委托）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递增/递减对象的值但是返回原值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此处无须检查有效性，调用前置递增运算符时才需要检查</span></span><br><span class="line">        StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 向前移动一个元素，前置++需要检查递增的有效性</span></span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">// 返回之前记录的值</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">        --*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前置递增运算符首先检查递增/递减操作是否安全，根据检查的结果<strong>抛出一个异常</strong>或者<strong>执行递增/递减操作</strong></p><h3 id="显式调用前置-后置运算符"><a href="#显式调用前置-后置运算符" class="headerlink" title="显式调用前置/后置运算符"></a>显式调用前置/后置运算符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;</span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);<span class="comment">// 调用后置版本</span></span><br><span class="line">p.<span class="keyword">operator</span>++();<span class="comment">// 调用前置版本</span></span><br></pre></td></tr></table></figure><h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><blockquote><h4 id="重载要求："><a href="#重载要求：" class="headerlink" title="重载要求："></a>重载要求：</h4><p>  1、箭头运算符必须是类的成员函数。解引用运算符一般也应该声明为类的成员函数，但不是必须。</p><p>  2、箭头用算符<strong>返回值必须是一个指针</strong>，或者是一个<strong>重载了箭头运算符的对象</strong>。</p><p>​     a）如果返回的是一个指针将调用内置的箭头运算符。执行相当于<code>(*(p.operator-&gt;()).mem;</code>的操作。</p><p>​     b）如果返回是一个重载了箭头运算符的对象，则继续对该对象调用其重载了的箭头运算符，直到返回的是一个指针，将对该指针调用a)的操作。操作相当于<code>(*(p.operator-&gt;().operator-&gt;())).mem;</code></p><p>   总的来说<strong>重载的箭头运算符就是为了改变从哪个对象中获取成员</strong></p><p>——来源：<a href="https://my.oschina.net/flylxl/blog/603114" target="_blank" rel="noopener">https://my.oschina.net/flylxl/blog/603114</a></p></blockquote><p>在实际中可以通过解引用运算符（*）来实现箭头运算符（-&gt;）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];</span><br><span class="line">    &#125;</span><br><span class="line">    str::<span class="built_in">string</span>* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>箭头运算符必须是类的成员</li><li>解引用运算符通常是类的成员，但并非必须如此</li></ul><h3 id="对箭头运算符返回值的限定"><a href="#对箭头运算符返回值的限定" class="headerlink" title="对箭头运算符返回值的限定"></a>对箭头运算符返回值的限定</h3><ul><li><p>解引用运算符可以返回任意值，但是箭头运算符不是这样：它永远不能丢掉<strong>成员访问</strong>这个最基本的含义</p></li><li><p>当我们重载箭头时，<strong>可以改变的是从哪个对象中获取成员</strong>，而箭头获取成员这一事实则永远不变</p></li><li><p>对于形如<code>point-&gt;mem</code>表达式来说，point必须是<strong>指向类对象的指针</strong>或是一个<strong>重载了operator-&gt;的类的对象</strong>；也即是说，重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*point).mem;<span class="comment">// point是一个内置的指针类型</span></span><br><span class="line">point.<span class="keyword">operator</span>()-&gt;mem;<span class="comment">// point是类的一个对象</span></span><br></pre></td></tr></table></figure></li></ul><p><code>point-&gt;mem</code>的执行过程：</p><ol><li><p>如果point是指针，则我们应用内置的箭头运算符，表达式等价于<code>(*point).mem</code>；首先解引用该指针，然后从所得的对象中获取指定的成员</p></li><li><p>如果point是定义了operator-&gt;的类的一个对象，则我们使用<code>point.operator-&gt;()</code>的结果来获取mem</p><ul><li>如果该结果是一个指针，则重复第1步</li><li>如果该结果本身含有重载的<code>operator-&gt;()</code>，则重复调用步骤2</li></ul><p>最终当这一过程结束时，程序或者返回了所需的内容，或者返回一些表示程序错误的消息</p></li></ol><p>注意：如果重载的operator-&gt;返回值是对象自身，会导致无限递归，编译器报错；但是如果返回的是对象自身的指针（例如this指针），编译器不会报错</p><p>（因为如果返回值是类的指针，那么编译器会进行步骤1，直接在对应的对象内部查找成员；而如果返回值是对象自身的值，那么编译器会反复调用步骤2，造成无限递归）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/16/MaeSfgPIu7NRnL8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象；这样的类同时能够存储状态，所以比普通函数更加灵活</p><p><strong>函数调用运算符必须是成员函数</strong>；一个类可以定义多个不同版本的函数调用运算符，相互之间应该在参数数量或者类型上有区别</p><p>如果类定义了调用运算符，则该类的对象称作<strong>函数对象</strong>；函数对象通常作为泛型算法的实参</p><h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><p>（先跳过）</p><h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>（先跳过）</p><h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><p>C++中可调用对象的种类：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类</p><ul><li>lambda有它自己唯一的（未命名）类类型</li><li>函数及函数指针的类型则由其返回值类型和实参类型决定</li></ul><p>两个不同类型的可调用对象可能共享一种<strong>调用形式（call signature）</strong>：它指明了调用<strong>返回的类型</strong>以及<strong>传递给调用的实参类型</strong>；例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>是一个调用形式，接受两个int，返回一个int</p><h4 id="不同类型可能具有相同的调用形式"><a href="#不同类型可能具有相同的调用形式" class="headerlink" title="不同类型可能具有相同的调用形式"></a>不同类型可能具有相同的调用形式</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/fyW1Qhpu7Si4LvK.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>例如上面的三个函数类型具有相同的调用形式：<code>int(int, int)</code></p><p>但是具有相同的调用形式却不一定可以看作是相同的类型：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/lVL9w1cHvq3TR7W.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（《Primer C++ 5th》中说mod不是一个函数指针，不能添加到funcTable中，但是我在Linux g++下面是可以编译运行的，emmm）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/4ujQnv3BXtACMEf.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="标准库function类型"><a href="#标准库function类型" class="headerlink" title="标准库function类型"></a>标准库function类型</h4><p>标准类型function定义在头文件functional中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/D3qI6fjSTumyeLv.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在调用时在尖括号中提供调用形式即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; func;</span><br></pre></td></tr></table></figure><p>这里创建了一个function对象func，可接受的调用形式是<code>int(int,int)</code></p><p>这样的func可以接受的可调用对象包括函数指针、lambda或者函数对象等</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/NByJ3iCsPmFtHUv.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="重载的函数与function"><a href="#重载的函数与function" class="headerlink" title="重载的函数与function"></a>重载的函数与function</h4><p>不能直接将重载函数的名字存入function类型对象中，即使这个重载函数的调用形式不同：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/17/gYrFMBqdl9NUO5G.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>解决方法有两种：</p><ul><li>通过函数指针给重载函数的其中一个版本定义新名字</li><li>使用lambda包装要存储的重载版本</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/home/steve/.config/Typora/typora-user-images/1576547582277.png" alt="1576547582277" title>                </div>                <div class="image-caption">1576547582277</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-操作符重载&quot;&gt;&lt;a href=&quot;#C-操作符重载&quot; class=&quot;headerlink&quot; title=&quot;C++操作符重载&quot;&gt;&lt;/a&gt;C++操作符重载&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="C++" scheme="http://QQ876684433.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://QQ876684433.github.io/tags/C/"/>
    
      <category term="操作符重载" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>编译原理课堂笔记</title>
    <link href="http://QQ876684433.github.io/2019/11/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    <id>http://QQ876684433.github.io/2019/11/29/编译原理课堂笔记/</id>
    <published>2019-11-29T08:38:13.000Z</published>
    <updated>2019-12-20T07:54:57.917Z</updated>
    
    <content type="html"><![CDATA[<p>Method 4 电路状态转换图</p><p>奇偶问题</p><blockquote><p>电路状态转换法解题步骤：</p><ol><li>构造电路状态转换图<br>首先确定状态，如果有n个元素，则存在2^n个状态。<br>然后链接状态。<br>示例：三个元素下的所有状态转换：<br><img src="http://artimg.ishenping.com/20190909054639960_UOPSSE.jpg" alt="在这里插入图片描述"></li><li>确定开始状态和结束状态<br>开始状态和结束状态是相对的，视题目具体情况确定。<br>1）以全是0作为结束状态，以题目要求作为开始状态。<br>2）以题目要求作为结束状态，以全是0作为开始状态。<br>比如对于某种语言，以a或b开头，以c结尾，abc的数量皆是偶数，那么开始状态就不是唯一的，就不能用全是0作为开始状态。而结束状态是唯一的，所以可以拿全是0作为结束状态</li><li>命名各个状态<br>初始状态用S命名，其他状态用A、B、C…命名</li><li>写出相应的产生式<br>每条边上的变化都对应一条产生式<br>对结束状态要增加一条产生式：G-&gt;ε<br>严格来说，最后可以写出2^n (n+1) + 1条产生式。</li></ol><p>来源：<a href="http://www.ishenping.com/ArtInfo/3505373.html" target="_blank" rel="noopener">http://www.ishenping.com/ArtInfo/3505373.html</a></p></blockquote><p>Ω属于{a，b，c，d}，其中a、b个数是奇数，c个数是偶数</p><p>（1）画出电路转换图</p><p>（2）确定开始状态和结束状态</p><p>全是0的状态特殊考虑：</p><ul><li><p>000：作为终态</p><p>根据需求确定初态（那么初态是110，表示a、b个数是1奇数，c的个数是0偶数）</p><p>然后将“上帝之手”指向初态</p><p>（原因是，从$110-&gt;000$，无论在电路图上怎么走，最终a、b变化的都是奇数次，c是偶数次）</p></li><li><p>000：作为初态</p><p>根据需求确定终态</p></li><li><p>随机</p><p>例如开始状态是101，那么终态是$101+110=011$</p></li></ul><p>（3）命名每个状态</p><p>开始状态必是S，若其他7个状态表示为A-G</p><p>（4）写出相应的产生式（related production）</p><p>每条边对应一个产生式，例如AB之间有一条边A &lt;a&gt; B，那么A-&gt; aB</p><p>对于终态Z（两个圈表示），要有Z -&gt; ∅</p><p>所以最终的产生式：</p><ul><li>$S-&gt;aA|bC|cG|dS$</li><li>$A-&gt;aS|bB|cE|dA$</li><li>$B-&gt;aC|bA|cD|dB$</li><li>……</li></ul><p>所以最终生成式的个数：$2^n*(n+m)+1$，其中+1表示的是终态$Z-&gt;∅$</p><p>终态和初态可能是相同的，最后要检查最终的产生式的个数是否相同</p><p>Method 5 FA-based Method</p><p>子序列（subsequence）和子串（substring）的区别：子序列不要求在原串中连续</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/15/pAqFX2B5M97jOtE.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/15/afK3MUhHgSxqToY.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Method 6 Hybrid Method</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/15/bwYA1qXVzDrTBmU.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Section 4 文法的二义性</p><p>$E-&gt;E+E|E*E|i$</p><p>$i+i*i$有不止一个分析树</p><h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><p>写程序时，首先考虑程序<strong>外部特性</strong>：程序的输入、输出；然后再考虑<strong>内部特性</strong></p><p>词法分析程序：</p><ul><li><p>输入：源程序</p></li><li><p>输出：token</p><p>token（lexeme（actual word），catalog，inner_code）</p><p>标识符放在标识符表中（ID Table），但是同一个word可能有多个含义，因此需要使用inner_code来进行区分，例如可以使用ID Table中的行号作为inner_code</p><p>例如x=y+2，那么ID Table如下：</p><p>(“X”, ID, 1)</p><p>(“=”, ASSIGN_SYM, _)  // 因为赋值符号是单例的，即赋值符号没有其他的含义，那么就不需要inner_code来进行区分</p><p>(“Y”, ID, 2)</p><p>……</p></li></ul><h3 id="Section-2"><a href="#Section-2" class="headerlink" title="Section 2"></a>Section 2</h3><p>单词构造规则（word construction rule），如何描述<strong>单词构造规则</strong>：</p><ul><li>正规文法 Regular Grammar：不直观，如abc：S-&gt;aA, A-&gt;bB, B-&gt;c</li><li>正规表达式 Regular Expression，它给出了单词的一个模板template</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/20/Y5C8r9LksAnHoTc.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/20/Fr9JDSOXAdi4KTn.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如何通过RE来构造词法分析程序：FA（有限自动机）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/20/reB2io3j8gk5MLw.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>FA：</p><ul><li><p>DFA（Deterministic） - 机器能接受的</p><p>i状态下读入了a字符，它的后续状态是唯一的</p><p>RE很容易变成NFA，因为a*的0次方是{空}边</p></li><li><p>NFA（Non-deterministic）</p><p>i状态下读入了a字符，它的后续状态可能是j或者k，或者其他</p></li></ul><p>如何将NFA转换成DFA？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/20/quO1FvCcx84RKUB.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/home/steve/Desktop/IMG_20191120_154604.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>怎么将两种方法结合起来？<strong>表驱动</strong>，确定化（DFA）以后的表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/20/hry3jMD9sVI1CwA.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过RE来生成DFA</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/22/ANckXvdzM5tZW8P.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>NFA转成DFA时，DFA中包含原NFA中终态的状态作为DFA的终态</strong></p><h3 id="Optimization-of-a-DFA"><a href="#Optimization-of-a-DFA" class="headerlink" title="Optimization of a DFA"></a>Optimization of a DFA</h3><p>Idea：Reduce the number of states of DFA</p><p>How to reduce?  Equivalent Class Division（等价类划分法，ECD）</p><p>等价：自反、对称、传递</p><p>划分等价类的方法ECD：</p><ul><li><p>Clustering——Bottom-Up Combination</p><p>从单个元素开始，知道类中所有元素都是等价的，类外的元素都是不等价的</p></li><li><p>Classifying——Top-Down Division</p><ul><li><p>首先将所有的状态作为top</p></li><li><p>然后将所有的终态放到一起，所有的非终态放到另一起</p></li><li><p>接下来这两个类别要不要继续分解，要根据<strong>State Equivalence（状态等价）</strong>来决定</p><p>状态等价：</p><ul><li>两个状态发出的边数相同（如果不同，说明两个状态处理的符号数不同，即处理能力不同）</li><li>发出的边上标记相同</li><li>后续状态要相应等价</li></ul><p>状态等价转换成<strong>后续状态等价</strong>的问题</p><p>状态等价有两种：</p><ul><li><p>special case：same（strong  state equivalence，强等价）</p></li><li><p>special case：belong to same leaf of current division tree（weak state equivalence，弱等价）</p><p>即后续状态同属于当前分解树的叶子节点，而不要求所有的后续状态都相同</p></li></ul><p>我们希望的是第二种（弱等价），因为这样分解得到的状态相对少，达到了我们的目的</p><p><img src="https://i.loli.net/2019/11/22/AdpCLI19MkqjWZz.jpg" alt></p></li><li><p>选择代表时，如果包含初态和其他状态，那么只能选择初态作为代表</p><p><img src="https://i.loli.net/2019/11/22/kuDsnLWCZbhxBXY.jpg" alt></p></li></ul><p>Note：<strong>lookback problem</strong>（后续状态的分解会引起前面状态的分解的改变<strong>（即继续分解）</strong>）</p><ul><li>一步一回首：每当有状态分解，就回头检验一下（因为会存在震荡/抖动问题，效率低）</li><li>最后再回首：分解结束后再回来检验叶子节点（效率高，推荐）</li></ul></li></ul><p>$NFA=&gt;DFA=&gt;{DFA}^{0}=&gt;program$</p><p>program：</p><ul><li>hard code：将状态转换表写死在程序中</li><li>sofe code：table-driven，smart personalization configuration file（将控制转成数据，表驱动，$DFA’s;transition;table$）<ul><li>loop up table</li><li>terminate：如果查到空白，则看当前状态是不是终态，如果是则终止，否则出错</li></ul></li></ul><h3 id="Section-5"><a href="#Section-5" class="headerlink" title="Section 5"></a>Section 5</h3><p>如何将RE转成成NFA？</p><h4 id="Method-1-Top-Down-Stepwise-Refinement"><a href="#Method-1-Top-Down-Stepwise-Refinement" class="headerlink" title="Method 1 Top-Down Stepwise Refinement"></a>Method 1 Top-Down Stepwise Refinement</h4><p>top：初始状态=(RE)=&gt;终止状态</p><p>down：边上标记是<strong>单个符号</strong>或者<img src="https://i.loli.net/2019/11/22/jSguUX9w72heBrP.png" style="zoom:50%;">边</p><p>按照RE本身的结构进行分解（庖丁解牛）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/22/UIH2S5XPfGkdLNY.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>容易出错，适合人进行操作</p><h4 id="Method-2-Thompson-Algorithm-Bottom-Up-Combination"><a href="#Method-2-Thompson-Algorithm-Bottom-Up-Combination" class="headerlink" title="Method 2 Thompson Algorithm Bottom-Up Combination"></a>Method 2 Thompson Algorithm Bottom-Up Combination</h4><p>从计算机角度出发，适合计算机来实现，它引入了更多的<img src="https://i.loli.net/2019/11/22/jSguUX9w72heBrP.png" style="zoom:50%;">边</p><img src="https://i.loli.net/2019/11/22/5vGJTmQxIbhFqrc.jpg" style="zoom:80%;"><ul><li>将点·补上，然后将中缀转成后缀：</li></ul><p>$$<br>(a<em>b)</em>(a|b)(a|b)* =&gt; (a<em>·b)*·(a|b)·(a|b)</em> =&gt; a<em>b·</em>ab|·ab|*·<br>$$</p><ul><li><p>最后扫描后缀表达式，使用算法</p><p><img src="https://i.loli.net/2019/11/22/WsjRn9bzJkTNPVK.jpg" alt></p><ul><li><p>遇到字符：生成小的自动机</p></li><li><p>遇到点或者其他符号：进行连接</p></li></ul><p>引入了太多的<img src="https://i.loli.net/2019/11/22/jSguUX9w72heBrP.png" style="zoom:50%;">边，但是能够由计算机计算完成</p></li></ul><p>龙书第三章讲了：直接从RE=&gt;DFA</p><h3 id="Section-6"><a href="#Section-6" class="headerlink" title="Section 6"></a>Section 6</h3><p>如何从语言来构造正规表达式RE？</p><h4 id="Method-1-Stepwise-Refinement"><a href="#Method-1-Stepwise-Refinement" class="headerlink" title="Method 1 Stepwise Refinement"></a>Method 1 Stepwise Refinement</h4><p>看单词特征是不是可分解的</p><p>一般来说是从左向右开始的</p><p>例子：<br>$$<br>L={w|w\in(0,1,2,…,9)^{<em>},w;mod;5=0 }<br>$$<br>先从个位数开始，然后再考虑多位数<br>$$<br>0|5|(1|2|3|…|9)(1|2|3|…|9)^{</em>}(0|5)<br>$$<br>龙书习题：</p><p><strong>先把最简单的情况写出来，后面复杂的情况可以用到简单情况</strong></p><ul><li><p>没有重复数字的字符串{0, 1, 2}</p><p><img src="https://i.loli.net/2019/11/22/dL934kbhzXMQHCq.jpg" alt></p></li><li><p>只有一个重复数字的字符串{0, 1, 2}</p></li></ul><h4 id="Method-2-FA-based"><a href="#Method-2-FA-based" class="headerlink" title="Method 2 FA-based"></a>Method 2 FA-based</h4><p>将电路状态转换图中的<strong>中间状态消除，只留下初始状态和终止状态</strong></p><p>只要有一个终态，就会有正规表达式的一种情形，它是从初态到终态的路径的RE</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/GRo8IMebTgdiwkF.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/vRKfQUrwguLeXbA.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="2019-11-27"><a href="#2019-11-27" class="headerlink" title="2019-11-27"></a>2019-11-27</h3><p>如何从RG=&gt;NFA？</p><p>RG有两种：</p><ul><li><p>*右线性正规文法：从左向右看</p><p><img src="https://i.loli.net/2019/11/27/tus7oiDvdGLXTBJ.jpg" alt></p></li><li><p>左线性正规文法</p></li></ul><p>language=&gt;RE</p><ul><li><p>Method 1：stepwise refinement</p></li><li><p>Method 2：FA-based</p></li></ul><p>对特殊的语言，可以直接从language=&gt;NFA</p><p>NFA至少满足其中一个情形：</p><ul><li>有<img src="https://i.loli.net/2019/11/22/jSguUX9w72heBrP.png" style="zoom:50%;">边</li><li>从同一个边可以到达多个不唯一的后续状态</li></ul><p>RE、RG和FA之间的关系：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/hJkRmUdfxsELwZ7.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="Section-8"><a href="#Section-8" class="headerlink" title="Section 8"></a>Section 8</h3><p>对每个语言都专门写一个词法分析程序很繁琐，可以对相似的程序进行抽象出一个框架</p><p>similar program：</p><ul><li>Framework - common</li><li>Parameter - special</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/bT6Uy8SpKLNaHXA.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/pVszXbn3yFNM5gk.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这个framework就是LEX</p><p><img src="https://i.loli.net/2019/11/27/Re4bN5g3yUqpOwS.jpg" alt></p><p>当有n个RE（每个RE对应一类单词）时，依然是使用同一个词法分析程序来识别所有的单词</p><p>多个RE分别生成NFA，然后再将多个NFA合并成一个大的NFA<br>$$<br>NFA_{i}=&gt;aNFA=&gt;DFA=&gt;DFA^{0}<br>$$<br>$DFA^{0}$可以用来编写词法分析程序</p><ul><li><p>初态两两合并，是为了保证每个状态最多发出两条边，方便后面设计数据结构</p></li><li><p>终态不能合并，因为每个终态对应的含义不同</p><ul><li>优化DFA时将终态放到一起，只是以为这里没有给每个终态赋予含义</li></ul></li></ul><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/29/qr9xQzsXUJChH2y.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="section-1"><a href="#section-1" class="headerlink" title="section 1"></a>section 1</h3><p>词法分析程序输出token 序列，语法分析程序的输入为token序列</p><ul><li><p>Derivation-based：From $S=&gt;\alpha,\alpha\in V_{T}^+$，是一种top-down的分析方法</p></li><li><p>Reduction-based：Bottom-Up方法，Method of Construction of Parse Tree</p><ul><li>从句子实例本身开始，一步步进行抽象</li></ul></li></ul><p>CFGG=&gt;parser</p><h3 id="section-2"><a href="#section-2" class="headerlink" title="section 2"></a>section 2</h3><p>（1）Recursive Descent Parsing（the simplest top-down method）</p><ul><li><p>好处：有文法就可以写语法分析程序</p></li><li><p>缺点：对文法有相应要求</p><ul><li>不能含有公共左因子，如$S=&gt;ABC|AD$，A就是公共左因子，这样会<strong>引起回溯</strong></li><li>不能出现左递归，如$A=&gt;Aa|b $：会<strong>导致无限递归</strong></li></ul></li></ul><p>每个非终结符对应一个子程序</p><p>每个终结符对应一个判定（decision）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/zmsKtNyRCl57UJM.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>会导致回溯（backtracking）问题：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/Ie2YrDFwVCTU3bJ.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>$A=&gt;Aa|b$是一种左递归：会引起无限递归的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">ch=getchar();</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">'b'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）预测分析法（Predictive Parsing Method）</p><p>要求和上面一样：</p><ul><li>不能含有公共左因子，如$S=&gt;ABC|AD$，A就是公共左因子，这样会引起回溯</li><li>不能出现左递归，如$A=&gt;Aa|b $：会导致无限递归</li></ul><p>为了避免回溯和无限递归，提出了预处理方案：</p><p>1）提取最大的公共左因子（extract maximum common left factors）</p><p>因为含有公共左因子时，需要进行试探，试探就会引起回溯</p><p>$A=&gt;\alpha\beta|\alpha\gamma, \alpha,\beta,\gamma\in(V_N,V_T)$</p><p>$A=&gt;\alpha A^{‘}$</p><p>$A^{`}=&gt;\beta|\gamma$</p><p>2）消除左递归</p><p>$左递归：A=&gt;A\alpha|\beta$</p><p>$右递归：A=&gt;\alpha A|\epsilon$</p><ul><li><p>Immediate/Direct left recursion</p><p>通过语言，将左递归变成右递归</p><p><img src="https://i.loli.net/2019/11/29/KF7c5NC1ewAJjyE.jpg" alt></p></li><li><p>Indirect left recursion</p><p>间接左递归：$(1) S → Qc|c (2)Q → Rb|b (3) R → Sa|a$</p><p>消除死锁（死循环）：给它们规定优先级，高优先级能够使用低优先级（以及自身）的资源</p><p><img src="https://i.loli.net/2019/11/29/4qW72ihuzRcf1KV.jpg" alt></p><p>变成直接左递归后，再使用消除直接左递归的方法</p><p>（约定：开始状态的优先级最高）</p></li><li><p>Hybrid left recursion（混合左递归）</p><p>既有直接左递归，也有间接左递归</p><p>$S=&gt;Sa|Ab|b$</p><p>$A=&gt;Ad|Se|f$</p><p><img src="https://i.loli.net/2019/11/29/YApbvtnHz4hdZGw.jpg" alt></p><p>采用前面两种方法无效，无穷无尽</p><p>混合左递归的特点：Loop in Loop，圈中套圈</p><p>方法：</p><ul><li>Inner =&gt; Outer（攘外必先安内）</li><li>Left =&gt; Right</li></ul><p>先消除内部的圈，然后再消除外部的圈（从左向右）</p><p><img src="https://i.loli.net/2019/11/29/ltvr4aVZXUz9Pjx.jpg" alt></p><p><img src="https://i.loli.net/2019/11/29/ph1fItWwOya5mjr.jpg" alt></p></li></ul><p>3）<strong>Construct the PredictIve Parsing Table（PPT，构造预测分析表）</strong></p><p>Table driven：软编码</p><p>对一个输入加入左哨兵$$_L$和右哨兵$$_R$</p><p>如：$i+i;=&gt;$_L;i+i;$_R$</p><p>推导时将右边替换左边（即将左边出栈），同时为了实现最左推到，因此右边应该从右往左入栈</p><p>如果栈顶是终结符，则比较该终结符和指针指向的符号是否相同，相同则继续，指针往后走；不同则报错</p><p>$\epsilon$不压栈，例如$T=&gt;\epsilon$相当于将栈顶的T出栈</p><p>如果指针指向了$$_R$，则只需判断栈中剩余的所有的非终结符能够推导出$\epsilon$</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/29/CwziMIBvphdUnmW.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>最后根据推导序列（Derivation Sequence，预测分析法的灵魂）就能够得出分析树</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/29/q8nuvSd6mWckwNb.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>First：起到预测的作用</p><p>$first(\alpha)={a|\alpha=&gt;a…,a\in V_T}$</p><p>如果一个推导有多个可用产生式，那么经过如下预测，可以知道选用first($\alpha$)=a更合适，能够让推导前进一步</p><p><img src="https://i.loli.net/2019/11/29/cdG1tJlEqNjwRPz.jpg" alt></p><p>如果只有一个可用产生式，就只能用这个，如果最终推导无法匹配，那么将报错</p><p><img src="https://i.loli.net/2019/11/29/UB9CpoSqHwuX2LN.jpg" alt></p><p>迭代法求解递归</p><ul><li>先进行最初始假设</li></ul><p><img src="https://i.loli.net/2019/11/29/6SkbsPRwufpYcWX.jpg" alt></p><p><img src="https://i.loli.net/2019/11/29/638XCMclOTwJnRA.jpg" alt></p><p>这个为了看什么情况下才能够使用$E=&gt;TE^{`}$，根据first(E)的结果知道+和(的情况才能使用，否则报错</p><p>How to solve the application of $A=&gt;\epsilon$？</p><ul><li><p>求$Follow(A)={a|S=&gt;…Aa…,a\in V_T}$，而且是对非终结符求Follow()</p></li><li><p>即栈中推导出的所有的终结符去掉A后，其余部分能够和表达式匹配，那么$A=&gt;\epsilon$将A出栈</p></li><li><p>怎么变成算法（即怎么求follow）？</p><p>观察相应产生式的右部，看哪些产生式的右部包含A</p><ul><li><p>$B=&gt;\alpha A\beta$</p><p>$S=&gt;…=&gt;…B…=&gt;…\alpha A\beta…$</p><p><img src="https://i.loli.net/2019/12/04/DhSObgvXnA3s1EI.jpg" alt></p></li><li><p>$B=&gt;\alpha A$</p></li></ul><p>约定：对于开始符，求follow时，一定要把$$_R$放进follow(开始符)</p></li></ul><p>例子：</p><p><img src="https://i.loli.net/2019/12/04/W69oYkHshAxSc8N.jpg" alt></p><p><img src="https://i.loli.net/2019/12/04/x6nhYRG18ftE5Bz.jpg" alt></p><p><img src="https://i.loli.net/2019/12/04/kInLWZ5AjwGS7Fa.jpg" alt></p><p><img src="https://i.loli.net/2019/12/04/vHlhZwsV9puAL3m.jpg" alt></p></li></ul><p>4）构造预测分析程序</p><p>soft code（table-driven）</p><p>预测分析器：</p><ul><li><p>PPT</p><p>空白格子报错</p></li><li><p>monitor</p><ul><li>Initialization（初始化）：栈初始化，将PPT放入内存（以二维表的方式）</li><li>lookup table：查PPT（需要两个参数，栈顶的非终结符和指针指向的终结符）</li><li>matching程序：栈顶终结符和指针指向的终结符相同则matched</li><li>success report：异常结束、成功结束（栈顶是$$_L$，指针指向$$_R $）</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/URHEohbIpD3KdQt.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>对文法G进行预处理（含有公共左因子和左递归的情况需要进行预处理）得到G’后，如果G’的PPT没有冲突，那么G’称为<strong>LL(1)文法</strong>：</p><ul><li>L：从左向右扫描（scan from Left to right）</li><li>L：最左推导（Left-most derivation）</li><li>1：看读头下的一个符号进行推导（watch the character under the reader）</li><li>LL（1）文法才能用预测分析法进行推导</li></ul><p>$G=&gt;G’=&gt;PPT$</p><p>PPT里的一个格子里如果有两个产生式，那么就会产生冲突</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/N7uKlaZOjpRvP5J.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/TYeHgVFwvW8tSjJ.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/W3nrQwJVsbYzP5D.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>解决二义文法？（例子：ppt4第35张）</p><p>$S → iEtSS<code>|a \\$$S</code> → eS | \epsilon \$<br>$E →b$</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/ZjLxtXGf7ERMQub.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>消除左递归也不能解决二义性文法：</p><ul><li><p>$E=&gt;E+E|E*E|i$</p><p><img src="https://i.loli.net/2019/12/04/wKi5rksR1JygH4I.jpg" alt></p><p><img src="https://i.loli.net/2019/12/04/VqYnGBZrH14Xbkg.jpg" alt></p></li></ul><p><strong>（3）LR分析法（LR parser）</strong></p><p>L: scan from Left to right</p><p>R: Leftmost Reduction</p><p>思想：分层有限自动机（using Layered Finite Automata）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/VtmYw2XEheNs6cd.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>CFGG: Hierarchical Structure </p><p>给个产生式构造小的自动机，然后将相关的小自动机用$\epsilon$边来连接起来</p><p>$S=&gt;\eta | \theta$</p><ul><li><p>引入0号产生式，构造最上层的小自动机（使得初始状态有且只有一个）</p><p><img src="https://i.loli.net/2019/12/04/bhvzaZXflYS5Dmj.jpg" alt></p></li></ul><p>$G+(0)S’=&gt;S=&gt;G’=&gt;Layered; FA（是NFA）=&gt;LR;DFA$</p><p><strong>给分层FA中的每个状态命名，使用LRitem</strong></p><p>LRitem（实际上是一种二维的命名方法）：</p><ul><li>layer: 产生式本身（产生式就代表了层次），即第几层</li><li>position: dot（点），即该层的哪个位置</li></ul><p>LRitem：</p><ul><li>Shift item </li><li>Reduction item</li></ul><p>对于$C=&gt;\epsilon$的小自动机（命名为$C=&gt;.$）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/evosuMngNI9Rb81.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>关键：分层有限自动机、LR项</strong></p><ul><li><p>start point：$S’=&gt;S$</p></li><li><p>$\epsilon$闭包（解决$\epsilon$边的问题）和子集构造法（解决后续状态不唯一的问题）结合使用</p><ul><li><p>$\epsilon$闭包：内部状态扩展（in-state extension）</p><p>直到右部的首字符是终结符或者点走到最后，否则将继续进行内部状态扩展</p></li><li><p>子集构造法：状态间扩展（between-state extension）</p><p>shift dot（将点往后移动一步）</p></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/QUxRPSJ4she6lAb.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>与第三章的DFA的区别：<strong>边上可以是非终结符</strong></p><p>PPT中的例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/qmYTDZcsCB6EznK.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/04/Uoiq6KZ9vxgbnFM.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>LR DFA =&gt; LR parsing table</strong></p><ul><li><p>ACTION子表处理终结符边</p><p>另一个参数是：读头下可以出现的符号</p></li><li><p>GOTO子表处理非终结符边</p><p>另一个参数是：非终结符</p></li></ul><p>从I0开始，观察每一个状态</p><ul><li><p>发出边（outer edges）</p><ul><li>非终止符$V_N$——GOTO子表</li><li>终止符$V_T$——ACTION子表</li></ul></li><li><p>Inner——可规约的LRitem（即点跑到最后的项，例如$S’=&gt;E.$）</p><p>开始求Follow（…），例如求Follow(E)</p><p>使用0号产生式做规约，相当于$r_0=accept$</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/06/zYCySflXhg1vV5a.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>两个栈</p><ul><li>状态栈state，栈底是0号状态$S’$</li><li>符号栈symbol，栈底是$$_L$</li></ul><p>$S_i$的作用是，将读头指向的符号压入符号栈并将读头往后移动一位，同时将i状态压入状态栈，</p><p>$r_i$的作用是，拿i号可规约串做规约，将可规约串右部的符号弹出符号栈（状态栈也要同步弹出），将可规约串左部压入符号栈，并将<strong>GOTO(状态栈栈顶状态，符号栈栈顶符号)</strong>压入状态栈</p><p>（可规约串实际上是将右部规约成左部）</p><p>将规约过程中用到的可规约串作为<strong>规约序列（reduction sequence）</strong>，然后根据这个规约序列可以反向构造出语法分析树</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/06/1LPqgRuGXieVf87.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>$G+(0)=&gt;G’=&gt;LR;DFA=&gt;LR;Parsing;Table;without;conflicts$</p><p>那么G is called SLR(1) grammar</p><ul><li><p>S: simple</p><p>SLR(1)不能够分析所有的非二义文法</p></li><li><p>L: scan from left to right</p></li><li><p>R: leftmost reduction</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/06/E5OuasytmHT3CdW.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>conflicts：</p><ul><li><p>S-R: shift-reduce-conflicts（移进-规约冲突，即同一个格子中同时有S和R）</p></li><li><p>R-R: reduce-reduce-conflicts（规约-规约冲突，即同一个格子中有两个及以上的R）</p></li><li><p>不存在S-S，因为我们是基于LR DFA的，对于一个符号，只会有一个后续状态</p><p><img src="https://i.loli.net/2019/12/06/m8kCJdpxhBTF7ty.jpg" alt></p></li></ul><p><strong>解决方案</strong></p><p>通过LR(1)item，实现SLR(1)===&gt;LR(1)</p><p>LR(1)item = LR item + predictive symbol（预测符号，the character after the reducible string）</p><ul><li><p>可归约项之后会出现的符号</p></li><li><p>符号栈顶已经形成了可规约串，预测符号决定是否要进行规约</p></li></ul><p>预测符号一定属于Follow(规约项左部)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/06/bFkumzfQX2Twlyd.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/06/TY983ZRlkjxHLCv.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/home/steve/.config/Typora/typora-user-images/1575619938033.png" alt="1575619938033" title>                </div>                <div class="image-caption">1575619938033</div>            </figure><p>LR(1)DFA=&gt;LR(1) parsing table</p><ul><li><p>观察每个状态</p><ul><li><p>outer edges</p><ul><li>$V_T$</li><li>$V_N $</li></ul></li><li><p>inner，要带上预测符</p><p>$(A=&gt;\alpha,a)$，那么在(A, a)下面填$r_{规约项}$</p><p>这样就不需要求Follow(A)，直接通过预测符a来填$r_{规约项}$</p></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/06/h5Km2skJEzloPgB.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>2019-12-11</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/11/uwgCcAJosTxYOLG.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/11/tBqEOSby9fHgL4w.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/11/YAO3ceM6ywRuTXq.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>LR(1)DFA的能力比LRDFA强，但是状态更多</p><p>LR(1) state的预测符拿掉后是LR(1)item的核心（core）</p><p>LR(1)DFA可以通过合并同核心状态得到LALR(1)DFA，其中LA是：LookAhead，然后就可以构造LALR(1)分析表</p><p>$SLR(1) \in LR(1)$</p><p>$LALR(1)\in LR(1)$</p><p>LRDFA和LALRDFA的状态数相同</p><p>LRDFA不一定能够通过合并同心项来得到LALRDFA，可能会产生新的冲突，见PPT4第96-99页</p><p>LRDFA的分析能力是最强的，能够分析非二义文法和二义文法</p><p>ambiguous grammar G ==&gt; LR(1) parsing table、SLR(1) parsing table with conflicts</p><p>二义文法的解决方案是：<strong>引入附加条件</strong></p><ul><li><p>表达式文法：$E=&gt;E+E|E*E|(E)|i$，那么引入的附加条件有：</p><ul><li><strong>优先级</strong>（precedence / priority）</li><li><strong>结合性</strong>（left associativity / right associativity）</li></ul><p>方法一（SLR(1)）：</p><ul><li><p>构造SLR(1)分析表，找出冲突</p></li><li><p>通过引入的附加条件解决冲突</p><ul><li><p>给出附加条件，例如*和/的优先级比+和-高，并且都是左结合性</p></li><li><p>解决冲突：</p><p>通过比较读头下的符号和符号栈顶的符号的优先级或者结合性（这是我们引入的附加条件）来决定选择哪个动作</p><p>（已经进栈的写在前面，未进栈的写在后面，然后比较前后的优先级和结合性；符号相同看结合性，符号不同则看优先级）</p></li><li><p>最后就可以将有冲突的分析表变成无冲突的分析表</p></li></ul></li></ul><p><img src="https://i.loli.net/2019/12/11/toB3F5yqn8ebXRf.jpg" alt></p><p>方法二（LR(1)）：</p><ul><li>构造LR(1)分析表来找出冲突</li><li>解决冲突（同方法一）</li></ul></li><li><p>if-else二义文法时，引入附加条件为：else-dangling</p><p>$(0)S’=&gt;S$</p><p>$S=&gt;iS|iSeS|a$</p><ul><li><p>首先构造LR(1)/SLR(1)：$SLR(1): G+(0)=&gt;G’=&gt;LR DFA / SLR(1) DFA$</p></li><li><p>构造SLR(1)分析表，找出冲突</p><p>$i;i;S;;eS$</p></li><li><p>引入附加条件假设</p><ul><li><p>farest: else和最远的if匹配</p><p>那么先规约，再移进</p></li><li><p>nearest: else和最近的if匹配</p><p>那么先移进，再规约</p></li></ul></li></ul></li><li><p>规约-规约冲突时引入的附加条件：位置优先法（position-precedence）</p></li></ul><p>  <img src="https://i.loli.net/2019/12/13/sak5IldM2O13Lof.jpg" alt></p><p>由程序从G生成LL(1)：Yacc（Yet another compiler-compiler）</p><p>关于龙书习题4.8.1：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/13/6Sh5fznKp8sUGCa.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>ch4补充练习</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/18/H3jIhFPZ1DT62eq.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/18/JpIPj3G6SoeA8KO.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><p>Correction：</p><ul><li>legal</li><li>rational —— semantic analyze（语义分析）</li></ul><p>semantic analyze：</p><ul><li><strong>static</strong>: at compiling time (type checking，类型检查)</li><li>dynamic: at running time(黑盒测试)</li></ul><p>how to do semantic analyze? —— syntax directed（语法制导），doing while parsing</p><p>Semantic of a symbol: properties（特征） &lt;= <strong>attributes</strong> of a symbol</p><ul><li>attributes：<ul><li>name（属性名，例如通过属性名的不同来区分不同的类）</li><li>value（属性值，区分同类符号中的不同个体）</li></ul></li></ul><p>parse tree symbols’ attributes</p><ul><li>adding attribute name（给分析树中的符号命名）</li><li>evaluate attributes value（进行属性值的计算）</li></ul><p>—— semantic rules（semantic action，语义规则/语义动作）</p><p><strong>Grammar（CFG）+ Semantic Rules</strong></p><p>how to combine?</p><ul><li><p><strong>Central（集中）—— SDD（syntax-directed definition）</strong></p><p>a production &lt;= semantic rules</p><p>—— related to LR parsing，using semantic rules while reducing</p><p><img src="https://i.loli.net/2019/12/18/4Ev6NLQuUbqJgRM.png" alt></p><p>lexval：词法分析程序送过来的值，$3+2=&gt;i+i$</p><p>$E.val=digit.lexval$是进行属性值的计算，将digit.lexval赋值给E.val</p></li><li><p>Decentral —— Translation Scheme</p><p>语义规则嵌入在产生式中</p><p>$A=&gt;{B.h=2}B{B.t=B.h}$</p><p>—— related to LL(1) parsing, using semantic rules while deriving</p></li></ul><h3 id="SDD"><a href="#SDD" class="headerlink" title="SDD"></a>SDD</h3><p>attributes:</p><ul><li><p>Synthesized——父节点综合了子节点的值<br>$E=&gt;E_1+E_2$</p></li><li><p>Inherited</p><p>$D=&gt;TL, {L.type=T.type}$，即T的值决定了L的值，或者L的值继承了T的值</p><p>$L=&gt;L_1B, {L_1.size=L.side}$，L1继承了L的值</p></li></ul><p>if a SDD has only synthesized attributes, the SDD is called <strong>s-attribute definition</strong></p><p>parse tree + attribute =&gt; Annotated parse tree（加标注的分析树）</p><p>Chapter5的核心：对于s，通过s-attributes definition来构造Annotated parse tree of s</p><p><strong>How to construct the APT?</strong></p><h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><p>Syntax-directed generating while reducing</p><h4 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h4><p>First construct the parse tree, then generate APT</p><p>龙书习题5.2.4</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/18/FHtOjXQrB7qZACg.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="Chapter-6"><a href="#Chapter-6" class="headerlink" title="Chapter 6"></a>Chapter 6</h2><p>Translation =&gt; 目标程序(.obj)</p><p>引入中间代码，是为了优化生成高效的目标代码：</p><p>$Translation =&gt; Intermediate Code =&gt; Optimized Code =&gt; .obj$</p><p>目标代码.obj：</p><ul><li>Independent-machine（机器无关/平台无关的二进制码，例如Java的字节码）</li><li>Dependent-machine</li></ul><p>$.c=&gt;.obj=&gt;_{linking}.exe/.elf$</p><p>选择合适的中间代码形式</p><ul><li>便于人阅读（以便进行优化）</li></ul><p>Graph-based</p><ul><li><p>Parse tree</p></li><li><p>Syntax tree</p><p><img src="https://i.loli.net/2019/12/18/4evHqVpu2wgPEWo.jpg" alt></p></li><li><p>DAG（有向无环图）</p><p>Hierarchical Structure Graph（具有层次结构的图）: Directed Acyclic Graph</p><p><img src="https://i.loli.net/2019/12/18/lRkQDTNoUnzf6qh.jpg" alt></p></li></ul><p>Expression-Based</p><ul><li><p>Infix</p><p>$z=x+y$</p><p>涉及了三个地址：operand1, operand2, result</p><p><strong>Three-Address Code(TAC, 三地址码)</strong></p><p><code>if(a[i]==x)goto L;</code>不是三地址码，含有四个地址</p><p>引入GOTO：</p><p>Conditional expression：Simple Conditional Expression<br>Simple：</p><ul><li><p>logical constant</p><p><code>if(1) goto L;</code></p></li><li><p>logical variable</p><p><code>if(x) goto L;</code></p></li><li><p>relative comparation expression（关系比较表达式，&gt;，&lt;，&gt;=，&lt;=等） with simple data object（简单数据对象）</p></li></ul><p><img src="https://i.loli.net/2019/12/18/tuB2FrQmLhiA67l.png" alt></p><p><img src="https://i.loli.net/2019/12/18/KAw24CabtM1XPVz.png" alt></p></li></ul><ul><li><p>Prefix</p><p>$+xy$</p><p>$mov;ax,;bx$</p><p>$OpCode;Operand1,;Operand2$</p><p><strong>四元组形式（Quadruple）</strong>：$(OpCode,;Operand1,;Operand2,;Result)$</p></li><li><p>Postfix</p></li></ul><p>Syntax-directed Translation into TAC</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/as2648fyrowLzWk.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/cpZevCwI7ljA4aV.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>二维数组转成三地址码（TAC）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/H5zYb4nBL6kXFA8.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>复杂的条件表达式转简单的条件表达式</p><p>—— 短路码（Short-circuit Code）</p><p>$(a&lt;&gt;b)&amp;&amp;(c&lt;&gt;d)$</p><p>=&gt;</p><p>$if(a&lt;&gt;b);goto;L_1$</p><p>$goto;L_2$</p><p>$L_1:if(c&lt;&gt;d);goto;L_3$</p><p>$goto;L_2$</p><p>$L_3:……$</p><p>$L_2:……$</p><p>$(x&lt;&gt;y)||(e&lt;&gt;f)$</p><p>=&gt;</p><p>$if(x&lt;&gt;y);goto;L_1$</p><p>$goto;L_2$</p><p>$L_2:if(e&lt;&gt;f);goto;L_1$</p><p>$goto;L_3$</p><p>$L_1:;…$</p><p>$L_3:;…$</p><h3 id="Backpatching（标号回填技术）"><a href="#Backpatching（标号回填技术）" class="headerlink" title="Backpatching（标号回填技术）"></a>Backpatching（标号回填技术）</h3><p>（有利于使用计算机来完成）</p><ul><li><p>引入记忆机制（Memory Mechanism）：记忆要回填的指令（remember the instructions backpatched）</p><p>对于未知的标号，使用0来占位（因为0不是任何一个指令的编号，编号从1开始）</p><p>$(5)goto;0$</p></li><li><p>使用指令的编号代替标号（replace label with Instruction No.）</p><p>assign  a number to each instruction</p></li><li><p>对每个简单情形的条件表达式，Merge the list with same destination</p></li><li><p>Backpatch by the related semantic rules</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/jIvVDCTa5c9XzMe.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/BqzTH4exK5yEPUX.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/MhaGWmOLwZ4uDgd.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>对于$a[i,j]=a[i,j]+1$，前后两个$a[i,j]$是互相独立的，不能后面的使用前面的相关中间量t</p><p>即：赋值号左右两边有相同的数组元素，那么两个都需要重新做翻译</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/RPboFL7DamvAJ8M.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/SLMR8W5brjYgDcX.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如何优化？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Method 4 电路状态转换图&lt;/p&gt;
&lt;p&gt;奇偶问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;电路状态转换法解题步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造电路状态转换图&lt;br&gt;首先确定状态，如果有n个元素，则存在2^n个状态。&lt;br&gt;然后链接状态。&lt;br&gt;示例：三个元素下的
      
    
    </summary>
    
      <category term="编译原理" scheme="http://QQ876684433.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="编译原理" scheme="http://QQ876684433.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象之继承</title>
    <link href="http://QQ876684433.github.io/2019/11/26/CPP%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF/"/>
    <id>http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/</id>
    <published>2019-11-26T11:06:55.000Z</published>
    <updated>2019-11-29T02:02:20.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-面向对象之继承"><a href="#C-面向对象之继承" class="headerlink" title="C++面向对象之继承"></a>C++面向对象之继承</h1><blockquote><p>参考书籍：《Primer C++, 5th》</p></blockquote><h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><p>下面可能会用到的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUOTE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUOTE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Quote() = <span class="keyword">default</span>;</span><br><span class="line">    Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price) : bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><p>继承关系中，<strong>根节点的类通常会定义一个虚析构函数</strong>，即使该函数不执行任何实际操作也是如此</p><h4 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h4><p>基类中通常有两种成员函数：</p><ul><li><p>虚函数：基类希望其派生类进行覆盖的函数</p><ul><li><p>当使用<strong>指针或者引用</strong>调用虚函数时，该调用将被动态绑定；根据引用或指针所绑定的对象类型的不同，该调用可能执行基类的版本，也可能执行某个派生类的版本</p></li><li><p><strong>任何构造函数之外的非静态函数都可以是虚函数</strong></p></li><li><p>并且virtual只能出现在类内部的声明语句之前，而不能用在类外部的函数定义</p></li><li><p>如果基类把一个函数声明为虚函数，则该函数<strong>在派生类中隐式地也是虚函数</strong>（即使没有virtual关键字）</p></li></ul></li><li><p>普通函数：基类希望派生类直接继承而不要改变的函数</p><p>非虚成员函数的<strong>解析过程发生在编译时而非运行时</strong></p></li></ul><h4 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h4><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权限访问从基类继承而来的成员</p><p>（private、protected、public，过于简单，就不再赘述）</p><h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><p>派生类必须通过使用类派生列表明确指出它从哪些基类继承而来，每个基类前面可以使用三种访问说明符中的一个：public、protected、private</p><p><strong>三种继承方式不影响子类对父类的访问权限，子类对父类只看父类的访问控制权；</strong>三种继承方式都能访问父类中的public和protected成员</p><p>简单来说：访问说明符的作用是控制派生类从基类继承而来的成员是否对<strong>派生类的用户</strong>可见</p><p>如果一个派生是共有的，则<strong>基类的共有成员也是派生类接口的组成部分</strong>，我们能将共有派生类型的对象绑定到基类的引用或指针上</p><h4 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h4><p>派生类经常（但不总是）覆盖它继承的虚函数；如果没有覆盖，则该虚函数的行为类似于其他普通成员，派生类<strong>会直接继承其在基类中的版本</strong></p><h4 id="派生类对象及派生类向基类的类型转换"><a href="#派生类对象及派生类向基类的类型转换" class="headerlink" title="派生类对象及派生类向基类的类型转换"></a>派生类对象及派生类向基类的类型转换</h4><p>派生类对象包含多个组成部分：</p><ul><li>派生类自己定义的（非静态）成员的子对象</li><li>与派生类继承的基类对应的子对象（如果基类有多个，那这样的子对象也有多个）</li></ul><p>正因为如此，我们能够</p><ul><li>把派生类的对象当成基类对象来使用</li><li>能将基类的指针或引用绑定到派生类对象的基类部分上</li><li>可以把派生类对象指针用在需要基类指针的地方</li><li>可以把派生类对象或者派生类对象的引用用到需要基类引用的地方</li></ul><p>继承的关键所在：派生类对象中含有与基类对应的组成部分</p><h4 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h4><p><strong>每个类控制它自己的成员的初始化过程</strong>：意味着派生类不能直接初始化继承的基类成员，需要通过基类的构造函数初始化它的基类部分</p><p>我们可以通过构造函数初始化列表将实参传递给基类构造函数，同时用这个方法指定我们要调用的基类的构造函数版本，否则派生类对象的基类对象会像数据成员一样执行默认初始化</p><p>首先初始化基类的部分，然后<strong>按照声明的顺序</strong>依次初始化派生类的成员</p><h4 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h4><p>派生类可以访问基类的共有成员和受保护成员；派生类对象的作用域嵌套在基类的作用域之内，因此派生类的一个成员使用派生类其他成员的方式与使用基类成员的方式没有什么不同（除了基类private成员）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/Xczqr6LGanyIQVN.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h4><p>如果基类定义了一个静态成员，那么整个继承体系中该静态成员只存在唯一的实例；静态成员遵循通用的访问控制规则， 如果某静态成员是可访问的，那么我们既能通过基类（及其对象）、也能通过派生类（及其对象）使用它</p><h4 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h4><p>派生类的声明<strong>包含类名但是不包含它的派生列表</strong>；派生类列表与定义的其他细节必须与类的主体一起出现</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/tUPW17aKvqQzmsh.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>一条声明语句的目的是<strong>令程序知晓某个名字的存在</strong>以及<strong>该名字表示一个什么样的实体</strong>（如一个类、函数或者变量）</p><h4 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h4><p>一个类必须已经定义而非仅仅声明才能被用作基类：</p><ul><li>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必然要知道基类中定义了哪些成员</li><li>言外之意：一个类不能派生它本身</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/hvtalZF6kLwuqX2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>每个类都会继承直接基类的所有成员；在整个继承体系中，<strong>最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象</strong></p><h4 id="防止继承发生"><a href="#防止继承发生" class="headerlink" title="防止继承发生"></a>防止继承发生</h4><p>C++11新标准：在<strong>类名后跟一个final</strong>，可以防止该类被继承</p><h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><h4 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h4><ul><li>静态类型：编译时就确定的，它是变量声明时的类型或表达式生成的类型</li><li>动态类型：变量或表达式表示的内存中的对象的类型</li></ul><p><u>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致</u></p><h4 id="不存在从基类向派生类的隐式类型转换"><a href="#不存在从基类向派生类的隐式类型转换" class="headerlink" title="不存在从基类向派生类的隐式类型转换"></a>不存在从基类向派生类的隐式类型转换</h4><p>有一种特别的情况：<u>即使一个基类指针或者引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换</u></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/e9NKbaIrXP6SoRm.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或者引用的静态类型来腿短该转换是否合法</p><ul><li><p>如果基类中含有一个或多个虚函数，我们可以使用dynamic_case请求一个类型转换，该<strong>转换的安全检查将在运行时执行</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">Bulk_quote *bulkP = <span class="keyword">dynamic_cast</span>&lt;Bulk_quote *&gt;(itemP);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bulkP-&gt;isbn() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果我们已知某个基类向派生类的转换是安全的，则我们可以使用static_cast来<strong>强制覆盖掉编译器的检查工作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">Bulk_quote *bulkP = <span class="keyword">static_cast</span>&lt;Bulk_quote *&gt;(itemP);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bulkP-&gt;isbn() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="在对象之间不存在类型转换"><a href="#在对象之间不存在类型转换" class="headerlink" title="在对象之间不存在类型转换"></a>在对象之间不存在类型转换</h4><p>派生类向基类的自动类型转换只针对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换：</p><ul><li>初始化或赋值一个类类型对象时，实际上是在调用某个函数<ul><li>执行初始化时，调用的是构造函数</li><li>执行赋值操作时，调用的是赋值运算符</li></ul></li><li>这些成员函数通常都包含一个参数，该参数的类型是类类型的const版本的引用</li></ul><p>这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象，因为<strong>这些操作不是虚函数</strong>，因此：</p><ul><li>当我们给基类的构造函数传递一个派生类对象时，实际运行的<strong>构造函数是基类中定义的那个</strong>，显然该构造函数<strong>只能处理基类自己的成员</strong></li><li>当我们将一个派生类对象赋值给一个基类对象，则实际运行的<strong>赋值运算符也是基类中定义的那个</strong>，该运算符同样<strong>只能处理基类自己的成员</strong></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/MvnOP58KS6wRXji.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="引入知识点：对象切片"><a href="#引入知识点：对象切片" class="headerlink" title="引入知识点：对象切片"></a>引入知识点：对象切片</h5><blockquote><p>原文链接：<a href="https://blog.csdn.net/beckle_ye/article/details/4700612" target="_blank" rel="noopener">https://blog.csdn.net/beckle_ye/article/details/4700612</a></p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/rJ1tRg8UufwXIzn.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>If you upcast to an object instead of a pointer or reference, something will happen that may surprise you: the object is “sliced” until all that remains is the subobject that corresponds to the destination type of your cast.<br>—— Thinking In C++</p></blockquote><p>这句话的意思也就是说：在函数传参处理多态性时，如果一个派生类对象在UpCasting时，<strong>用的是传值的方式</strong>，而不是指针和引用，那么，这个派生类对象在UpCasting以后，将会被slice（切分）成基类对象，也就是说，派生类中独有的成员变量和方法都被slice掉了，只剩下和基类相同的成员变量和属性。这个派生类对象被切成了一个基类对象<br>如下例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> pname;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pet(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name) : pname(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pname; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">description</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is "</span> + pname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Pet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> favoriteActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;activity)</span><br><span class="line">        : Pet(name), favoriteActivity(activity) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">description</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Pet::name() + <span class="string">" likes to "</span> +</span><br><span class="line">               favoriteActivity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe</span><span class="params">(Pet p)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// Slices the object</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.description() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Pet <span class="title">p</span><span class="params">(<span class="string">"Alfred"</span>)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">d</span><span class="params">(<span class="string">"Fluffy"</span>, <span class="string">"sleep"</span>)</span></span>;</span><br><span class="line">    describe(p); <span class="comment">//正常调用基类函数</span></span><br><span class="line">    describe(d); <span class="comment">//对象切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is Alfred</span><br><span class="line">This is Fluffy</span><br></pre></td></tr></table></figure><p>发生对象切片前后的情况是这样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/lkCJV72QrxT9ApB.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>发生Object Slicing后，原先的虚函数Dog vptr表变成了Pet vptr，Dog的成员favoriteActivity也不存在了，其实这时候执行了一些步骤：</p><ul><li>在正常情况下，main函数中执行describe函数，在传递Dog对象d的时候，调用了Pet类的拷贝构造函数，相当于此时，在describe函数中的那个Pet类对象p是拷贝构造的结果，所以，跟Dog对象d已经没有了关系。所以，此时，p.description()执行的会是调用的基类也就是Pet类的description函数</li></ul><p>但是如果将description函数声明为纯虚函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> pname;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pet(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name) : pname(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pname; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">description</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>；</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Pet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> favoriteActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;activity)</span><br><span class="line">        : Pet(name), favoriteActivity(activity) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">description</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Pet::name() + <span class="string">" likes to "</span> +</span><br><span class="line">               favoriteActivity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe</span><span class="params">(Pet p)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// Slices the object</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.description() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Pet <span class="title">p</span><span class="params">(<span class="string">"Alfred"</span>)</span></span>;</span><br><span class="line">    <span class="function">Dog <span class="title">d</span><span class="params">(<span class="string">"Fluffy"</span>, <span class="string">"sleep"</span>)</span></span>;</span><br><span class="line">    describe(p); <span class="comment">//正常调用基类函数</span></span><br><span class="line">    describe(d); <span class="comment">//对象切片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这时候Pet类型就不能被实例化，所以在全局的describe函数中不可能有者拷贝构造函数来实例化一个Pet类对象，此时编译器就会报错</p><p>这里就体现出了纯虚函数的一个重要意义：可以在编译期间<strong>避免对象切片</strong>，从而避免很多可能会出现的问题</p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>使用基类的<strong>引用或指针调用</strong>一个虚成员函数时会执行动态绑定；如果我们通过一个<strong>具有普通类型的表达式</strong>调用虚函数时，在<strong>编译时</strong>就会将调用的版本确定下来</p><p>通常如果我们不使用某个函数，则无须为该函数提供定义；但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，否则会编译出错</p><h3 id="派生类中的虚函数-1"><a href="#派生类中的虚函数-1" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h3><p>基类中的虚函数在派生类中隐含地也是一个虚函数</p><ul><li><p>当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配；</p></li><li><p>派生类中虚函数的返回类型也必须与基类函数匹配</p><ul><li><p>例外情况是，当类的虚函数返回类型是类本身的指针或引用时，该条规则失效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A&amp; <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="function">B&amp; <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即这样也是有效的</p></li></ul></li></ul><h3 id="final和override说明符"><a href="#final和override说明符" class="headerlink" title="final和override说明符"></a>final和override说明符</h3><ul><li><p>我们可以使用override显式指定派生类中的某个函数是覆盖基类对应的虚函数，如果override标记的派生类的函数是<strong>在基类中不存在</strong>，那么编译器将报错</p></li><li><p>如果我们把某个函数指定为final，则之后派生类中任何尝试覆盖该函数的操作将引发错误</p></li></ul><p>注意：final和override都<strong>只能用在虚函数上，</strong>而且也只能出现在形参列表（包括从const或引用修饰符）以及尾置返回类型之后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> A &amp;<span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">B &amp;<span class="title">func</span><span class="params">()</span> override </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> override</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> final</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译器报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test01.cpp:<span class="number">18</span>:<span class="number">10</span>: error: ‘<span class="keyword">void</span> B::func2()’ marked ‘override’, but does <span class="keyword">not</span> override</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> override</span>;</span><br><span class="line">          ^~~~~</span><br><span class="line">Test01.cpp:<span class="number">19</span>:<span class="number">10</span>: error: ‘<span class="keyword">void</span> B::func3()’ marked ‘final’, but is <span class="keyword">not</span> <span class="keyword">virtual</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span> final</span>;</span><br><span class="line">          ^~~~~</span><br></pre></td></tr></table></figure><h3 id="虚函数与默认实参"><a href="#虚函数与默认实参" class="headerlink" title="虚函数与默认实参"></a>虚函数与默认实参</h3><p>虚函数可以拥有默认实参，如果某次函数调用使用了默认实参，则该<strong>实参值由本次调用的静态类型决定</strong></p><p>如果通过基类的引用或者指针调用函数，则<strong>使用基类中定义的默认实参</strong>，即使实际运行的是派生类中的函数版本也是如此，因此传入派生类函数的将是基类函数定义的默认实参；如果派生类函数依赖不同的是实参，则程序结果将与我们的预期不同</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/GjEd7WuLAslzhyk.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h3><p>可以使用作用域运算符来使得虚函数的调用不要进行动态绑定，而是强迫执行虚函数的某个特定版本，这种调用将在编译时完成解析</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/HZ3sVWNPURl8dwp.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>一个纯虚函数无须给出定义，通过在函数体的位置（即声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数（=0只能出现在类内部的虚函数声明语句处）</p><p>当然我们也可以给纯虚函数提供定义，不过<strong>函数体必须定义在类的外部</strong>，也就是说，我们不能在类的内部为一个=0的函数提供函数体</p><h3 id="含有纯虚函数的类是抽象基类"><a href="#含有纯虚函数的类是抽象基类" class="headerlink" title="含有纯虚函数的类是抽象基类"></a>含有纯虚函数的类是抽象基类</h3><p>含有纯虚函数的类是抽象基类，抽象基类负责定义接口，后续的其他类可以覆盖该接口</p><p>我们不能创建一个抽象基类的对象</p><h2 id="访问控制与继承-1"><a href="#访问控制与继承-1" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><h3 id="受保护成员"><a href="#受保护成员" class="headerlink" title="受保护成员"></a>受保护成员</h3><p>受保护成员对于<strong>类的用户</strong>来说是不可访问的，派生类的成员或友元只能<strong>通过派生类对象</strong>来访问基类的受保护成员，派生类对于一个<u><strong>基类对象</strong>的受保护成员</u>没有任何访问特权</p><p>例子如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/aZWzN4d25eVxcgt.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>派生类B的成员函数无法通过基类对象来访问受保护成员</strong>，也就是说此时B是基类A的用户，用户代码B无法访问A的受保护成员，它只能通过this指针来访问</p><p>至于友元函数，则是书上的例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/MrZi38CY4RzgAB6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="公有、私有和受保护继承"><a href="#公有、私有和受保护继承" class="headerlink" title="公有、私有和受保护继承"></a>公有、私有和受保护继承</h3><ul><li><p>派生访问说明符对于派生类的成员及友元能否访问其直接基类的成员没什么影响，对基类成员的访问权限只与基类中的访问说明符有关</p></li><li><p>派生访问说明符的目的是控制<strong>派生类用户</strong>（<strong>包括派生类的派生类在内</strong>）对于基类成员的访问权限</p><ul><li><p>这是私有继承的例子：</p><p><img src="https://i.loli.net/2019/11/28/im3hwSZuBGONYLq.png" alt></p></li><li><p>受保护继承的例子：</p><p><img src="https://i.loli.net/2019/11/28/sxpgqBD3GS8CtFW.png" alt></p></li></ul></li></ul><p>（<em>按照我个人的理解是这样的：私有派生将基类的成员继承过来之后，这部分基类的成员*</em>对外<strong>的访问说明符变成了私有private，即基类的成员不会成为</strong>派生类对外的接口*<em>，而对于派生类内部没有任何影响</em>）</p><h3 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h3><p>有三种情况：</p><ul><li><p>D<strong>公有地继承</strong>B，<strong>用户代码</strong>才能使用派生类向基类的转换；受保护或私有继承不行</p><p><img src="https://i.loli.net/2019/11/28/tR9NWrv3Lg7e1zZ.png" alt></p></li><li><p>不论D如果继承B，D的<strong>成员函数和友元</strong>都能使用派生类向基类的转换</p><p><img src="https://i.loli.net/2019/11/28/pEBSe6ZRH4cGvfW.png" alt></p></li><li><p>如果D<strong>公有地或受保护地</strong>继承B，则<strong>D的派生类</strong>的成员和友元可以使用D向B的类型转换；如果D私有继承B，则不能使用</p><p><img src="https://i.loli.net/2019/11/28/irgp9ow8BfPvX7u.png" alt></p></li></ul><p>书中给出了一个助记的方法：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/SvA6Kz81Oaq4UHd.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="关键概念：类的设计与受保护的成员"><a href="#关键概念：类的设计与受保护的成员" class="headerlink" title="关键概念：类的设计与受保护的成员"></a>关键概念：类的设计与受保护的成员</h4><p>（讲的太好了，没必要自己整理，故全文截图如下）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/1ep5UxZjVhXbETn.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/nls2PwDjX9YAKzg.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h3><p>友元关系<strong>既不能传递，也不能继承</strong></p><p>每个类负责控制自己的成员的访问权限，即使<strong>对于派生类的基类部分也是如此</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/IM8KaB95T4n27Fw.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可以看到例子中，可以通过派生类B在基类A的友元类Test中访问基类A的私有成员，而直接使用B访问x则会报错，这是因为<strong>派生类B的基类子对象部分的访问控制依然是由基类来控制的</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/ktsLipHr4XJuM9q.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h3><p>可以通过using声明来改变派生类<strong>继承的某个名字</strong>的访问级别</p><p>通过在类内部使用using声明语句，我们可以将该类的直接或间接基类中的任何<strong>可访问成员</strong>（例如，非私有成员）标记出来：</p><ul><li>using语句出现在类的private部分：该名字只能被<strong>类的成员和友元</strong>访问</li><li>using语句出现在类的public部分：<strong>类的所有用户</strong>都能访问它</li><li>using语句出现在类的protected部分：该名字对于<strong>成员、友元和类的派生类</strong>是可访问的</li></ul><h3 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h3><p>默认情况下：</p><ul><li>class关键字定义的派生类是私有继承的</li><li>struct关键字定义的派生类是公有继承的</li></ul><p><em>ps：struct和class的唯一差别就是<strong>默认访问说明符和默认派生说明符</strong>；除此之外，再无其他不同之处</em></p><h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>每个类定义自己的作用域，当存在继承关系时，派生类的作用域嵌套在基类的作用域之内</p><p>如果一个名字在派生类的作用域内无法正确解析，则编译器将<strong>继续在外层的基类作用域</strong>中寻找该名字的定义</p><h3 id="在编译时进行名字查找"><a href="#在编译时进行名字查找" class="headerlink" title="在编译时进行名字查找"></a>在编译时进行名字查找</h3><p>一个对象、引用或指针的<strong>静态类型</strong>决定了该对象的哪些成员是可见的；即使静态类型和动态类型不一致，但是我们<strong>能够使用哪些成员依然是由静态类型决定</strong>的</p><p>（按我的个人理解，对象、引用或者指针的静态类型决定了当前作用域，其派生类的作用域对与当前的对象、引用或者指针是不可见的，如果存在继承链A -&gt; B -&gt; C，通过B调用时，查找将从B开始，然后再到A，而C的作用域对B是不可见的）</p><h3 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h3><p>定义在内层作用域（即派生类）中的名字将隐藏外层作用域（即基类）的名字</p><h3 id="通过作用域运算符来使用隐藏的成员"><a href="#通过作用域运算符来使用隐藏的成员" class="headerlink" title="通过作用域运算符来使用隐藏的成员"></a>通过作用域运算符来使用隐藏的成员</h3><p>作用域运算符<code>::</code>能<strong>覆盖掉原有的查找规则</strong>，并指示编译器从基类的作用域中开始查找名字</p><p><strong>名字查找的过程</strong>（以p-&gt;mem()或p.mem()为例）：</p><ul><li>首先确定p的静态类型</li><li>在p的静态类型对应的类中查找名字mem<ul><li>如果找不到，则依次在直接基类中不断查找直至到达继承链顶端；如果仍然找不到，编译器将报错</li><li>一旦找到名字mem，就进行常规的类型检查，以确认对于当前找到的名字mem，本次调用是否合法<ul><li>如果调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码<ul><li>如果mem是虚函数，且我们通过引用或指针进行调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型（即运行时的实际类型）</li><li>反之（mem不是虚函数或者我们是通过对象本身（而非引用或指针）进行调用），编译器将产生一个常规函数调用，并且这个调用是在编译期间就已经确定的</li></ul></li><li>如果调用非法，则编译器报错，并且<strong>不会再向上继续往基类中查找</strong></li></ul></li></ul></li></ul><h3 id="名字查找先于类型检查"><a href="#名字查找先于类型检查" class="headerlink" title="名字查找先于类型检查"></a>名字查找先于类型检查</h3><ul><li>声明在内层作用域的函数并不会重载声明在外层作用域的函数</li><li>因此，定义派生类中的函数也不会重载其基类的成员</li></ul><p>如果派生类（内层作用域）的成员与基类（外层作用域）的某个成员<strong>同名</strong>，则派生类的成员将隐藏其作用域内该基类成员，<strong>即使派生类成员与基类成员的形参列表不一样</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/gZbcrlsvqL9QioM.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="虚函数与作用域-amp-amp-通过基类调用隐藏的虚函数"><a href="#虚函数与作用域-amp-amp-通过基类调用隐藏的虚函数" class="headerlink" title="虚函数与作用域&amp;&amp;通过基类调用隐藏的虚函数"></a>虚函数与作用域&amp;&amp;通过基类调用隐藏的虚函数</h3><p>如果派生类定义的函数名和基类的虚函数一样，但是形参列表不同，那么派生类的函数只是隐藏了基类中的同名虚函数，并没有覆盖，因此运行时发生动态绑定时，依然运行的是基类的虚函数版本</p><p>如下例的<code>bp2-&gt;fcn();</code>调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::fcn()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D1::fcn(int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D1::f2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::fcn(int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::fcn()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2::f2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base bobj;</span><br><span class="line">    D1 d1obj;</span><br><span class="line">    D2 d2obj;</span><br><span class="line">    Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;</span><br><span class="line">    bp1-&gt;fcn();</span><br><span class="line">    bp2-&gt;fcn();<span class="comment">// 注意看这个调用，这是个虚调用，但是执行的是Base::fcn版本</span></span><br><span class="line">    bp3-&gt;fcn();</span><br><span class="line">    D1 *d1p = &amp;d1obj;</span><br><span class="line">    D2 *d2p = &amp;d2obj;</span><br><span class="line">    <span class="comment">// bp2-&gt;f2();</span></span><br><span class="line">    d1p-&gt;f2();</span><br><span class="line">    d2p-&gt;f2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="覆盖重载的函数"><a href="#覆盖重载的函数" class="headerlink" title="覆盖重载的函数"></a>覆盖重载的函数</h3><p>成员函数无论是否是虚函数都能被重载</p><p>如果派生类希望所有的重载版本对于它来说都是可见的，那么它就<strong>需要覆盖所有的版本，或者一个也不覆盖</strong>（因为如果只覆盖其中一个或几个，那么剩余的基类版本将被隐藏起来，不可访问）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/28/CoLEN8mxFh1KW5n.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>解决方案是：</p><ul><li><strong>为重载的成员提供一条using声明语句</strong>，它只需要指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以<strong>把该函数的所有重载版本实例添加到派生类作用域中</strong></li></ul><p>这样我们就无需覆盖基类中的每一个重载版本了，派生类只需要定义其特有的函数就可以了，而不用为继承而来的其他函数重新定义</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/29/2ZzSd4GhLKgOMqB.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>基类函数的每个实例在派生类中必须都是可访问的，如果有任意一个同名实例是private，则using声明语句将出错（protected是允许的，因为基类protected实例在派生类中可访问）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/29/2et6QdkF8JnuZI4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个<strong>虚析构函数</strong>；如果指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除的对象的动态类型不符的情况，因此我们可以通过在基类中将析构函数定义为虚函数以确保执行正确的析构函数版本</p><p><strong>析构函数的析构属性能够被继承</strong>，无论派生类的析构函数是自己定义的还是编译器合成的</p><blockquote><p>C++三法则：如果需要析构函数，则一定需要拷贝构造函数和赋值操作符</p><p>如何理解这句话，首先，从“如果需要析构函数”这里我们知道，类中必然<strong>出现了指针类型的成员</strong>（<strong>否则不需要我们写析构函数，默认的析构函数就可以用了</strong>），所以，我们需要自己写析构函数来释放给指针所分配的内存来防止内存泄露，那么为什么说“一定需要拷贝构造函数和赋值操作符”呢，原因还是这样：类中出现了指针类型的成员。有指针类型的成员，我们必须防止浅拷贝问题，所以，一定需要拷贝构造函数和赋值操作符，这两个函数是防止浅拷贝问题所必须的</p><p>来源：<a href="https://blog.csdn.net/u010025211/article/details/48028571" target="_blank" rel="noopener">https://blog.csdn.net/u010025211/article/details/48028571</a></p></blockquote><p>但是对于基类来说，它总是需要一个析构函数，并且<strong>定义为虚函数，函数体为空</strong>，因此我们无法确定基类是否还需要赋值运算符或者拷贝构造函数</p><h4 id="虚析构函数将阻止合成移动操作"><a href="#虚析构函数将阻止合成移动操作" class="headerlink" title="虚析构函数将阻止合成移动操作"></a>虚析构函数将阻止合成移动操作</h4><p>基类需要一个虚析构函数导致：</p><ul><li>如果一个类定义了析构函数，即使是=default合成的版本，编译器也不会为这个类合成移动操作</li></ul><h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><h2 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h2><p>多重继承的派生类继承了<strong>所有父类的属性</strong></p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><ul><li>关键字class对应的默认访问说明符是private，关键字struct对应的是public</li><li>多重继承的派生列表只能包含已经被定义过的类，而且这些类不能是final的</li><li>派生列表中，同一个基类只能出现一次</li></ul><h4 id="多重继承的派生类从每个基类中继承状态"><a href="#多重继承的派生类从每个基类中继承状态" class="headerlink" title="多重继承的派生类从每个基类中继承状态"></a>多重继承的派生类从每个基类中继承状态</h4><p>多重继承关系中，派生类的对象包含有每个基类的子对象，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span>:</span> <span class="keyword">public</span> ZooAnimal &#123;...&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span>:</span> <span class="keyword">public</span> Bear, <span class="keyword">public</span> Endangered &#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/GgkZVWIScfHp3xd.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="派生类构造函数初始化所有基类"><a href="#派生类构造函数初始化所有基类" class="headerlink" title="派生类构造函数初始化所有基类"></a>派生类构造函数初始化所有基类</h4><p>构造一个派生类的对象将同时构造并初始化它的所有基类子对象，多重继承的派生类的构造函数初始值只能初始化<strong>它的直接基类</strong>（例如Panda的直接基类是Bear和Endangered）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/hyInO1iSfWBeQxG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>基类的构造顺序与<strong>派生列表中基类的出现顺序</strong>保持一致，而与派生类构造函数初始值列表中的基类顺序无关</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/WQIKwVPa67NtE2v.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/vNV8IH3zrX4Jjla.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="继承的构造函数与多重继承"><a href="#继承的构造函数与多重继承" class="headerlink" title="继承的构造函数与多重继承"></a>继承的构造函数与多重继承</h4><p>C++11中允许派生类继承多个基类的构造函数，但是如果从多个基类中继承了相同的构造函数（形参列表完全相同），那么程序将报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base1() = <span class="keyword">default</span>;</span><br><span class="line">    Base1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);</span><br><span class="line">    Base1(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base2() = <span class="keyword">default</span>;</span><br><span class="line">    Base2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);</span><br><span class="line">    Base2(<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D1 d;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tempCodeRunnerFile.cpp:20:18: error: ‘D1::D1(const string&amp;)’ inherited from ‘Base2’</span><br><span class="line">     using Base2::Base2;</span><br><span class="line">                  ^~~~~</span><br><span class="line">tempCodeRunnerFile.cpp:19:18: error: conflicts with version inherited from ‘Base1’</span><br><span class="line">     using Base1::Base1;</span><br></pre></td></tr></table></figure><p>此时必须在派生类中<strong>定义这个冲突构造函数的派生类自己的版本</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span>:</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1;</span><br><span class="line">    <span class="keyword">using</span> Base2::Base2;</span><br><span class="line">    D1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)&#123;&#125;</span><br><span class="line">    D1() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：前面版本的D1之所以只对<code>D1::D1(const string&amp;)</code>报错，是因为D1中没有定义自己版本的构造函数，编译器为D1合成了默认的构造函数，<strong>覆盖了从Base1和Base2继承过来的冲突的默认版本的构造函数</strong>；但是现在这个版本定义了自己的<code>D1(const std::string &amp;){}</code>来解决冲突，导致编译器不会为D1合成默认构造函数，因此也需要为D1显式定义默认构造函数</p><h4 id="析构函数与多重继承"><a href="#析构函数与多重继承" class="headerlink" title="析构函数与多重继承"></a>析构函数与多重继承</h4><p>析构函数的调用顺序与构造函数相反：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure><h4 id="多重继承的派生类的拷贝与移动操作"><a href="#多重继承的派生类的拷贝与移动操作" class="headerlink" title="多重继承的派生类的拷贝与移动操作"></a>多重继承的派生类的拷贝与移动操作</h4><ul><li>多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或者赋值操作</li><li><strong>只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作</strong></li></ul><p>例如Panda调用合成版本的拷贝构造函数，首先调用Bear的拷贝构造函数拷贝Bear子对象部分，而Bear又会在执行之前调用呢ZooAnimal的拷贝构造函数拷贝ZooAnimal子对象部分，Bear子对象部分拷贝完成后，又会调用Endangered拷贝构造函数拷贝Endangered子对象部分，最后才调用Panda的合成构造函数拷贝Panda部分</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/gJ7axq3sVvUAQhj.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="类型转换与多个基类"><a href="#类型转换与多个基类" class="headerlink" title="类型转换与多个基类"></a>类型转换与多个基类</h3><p>派生类有多个基类时，如果存在多个以基类为参数的重载函数，那么编译器会报错，因为<strong>编译器不会在派生类向基类的几种转换中进行比较和选择</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Panda.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Bear.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Endangered.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ZooAnimal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Endangered &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Panda p;</span><br><span class="line">    func(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译报错，程序有二义性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Test01.cpp: In function ‘int main(int, const char**)’:</span><br><span class="line">Test01.cpp:<span class="number">15</span>:<span class="number">11</span>: error: call of overloaded ‘func(Panda&amp;)’ is ambiguous</span><br><span class="line">     func(p);</span><br><span class="line">           ^</span><br><span class="line">Test01.cpp:<span class="number">6</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br><span class="line">Test01.cpp:<span class="number">8</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(Endangered &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Endangered &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br><span class="line">Test01.cpp:<span class="number">10</span>:<span class="number">6</span>: note: candidate: <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal&amp;)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span>; &#125;</span><br><span class="line">      ^~~~</span><br></pre></td></tr></table></figure><p>注意：这个只限于直接基类为参数的重载，比如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Panda.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Bear.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Endangered.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ZooAnimal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Bear &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(Bear &amp;)"</span> &lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void func(Endangered &amp;) &#123; cout &lt;&lt; "func(Endangered &amp;) &lt;&lt; endl;"; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(ZooAnimal &amp;)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"func(ZooAnimal &amp;)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Panda p;</span><br><span class="line">    func(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承关系是ZooAnimal -&gt; Bear -&gt; Panda，输出结果是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">func(Bear &amp;)</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure><p>即会调用继承链上最近的那个重载版本</p><h4 id="基于指针类型或引用类型的查找"><a href="#基于指针类型或引用类型的查找" class="headerlink" title="基于指针类型或引用类型的查找"></a>基于指针类型或引用类型的查找</h4><p>通过基类指针来引用派生类对象时，如果析构函数是非虚函数，那么delete时无法调用派生类对象的析构函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooAnimal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal(<span class="comment">/* args */</span>);</span><br><span class="line">    ~ZooAnimal();</span><br><span class="line">&#125;;</span><br><span class="line">... ...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Panda p;</span></span><br><span class="line">    ZooAnimal *z_ptr = <span class="keyword">new</span> Panda();</span><br><span class="line">    <span class="comment">// func(p);</span></span><br><span class="line">    <span class="keyword">delete</span> z_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~ZooAnimal()</span><br><span class="line">    </span><br><span class="line">====================================================================</span><br><span class="line">====================================================================</span><br><span class="line">    </span><br><span class="line">class ZooAnimal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ZooAnimal(<span class="comment">/* args */</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~ZooAnimal();</span><br><span class="line">&#125;;</span><br><span class="line">... ...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Panda p;</span></span><br><span class="line">    ZooAnimal *z_ptr = <span class="keyword">new</span> Panda();</span><br><span class="line">    <span class="comment">// func(p);</span></span><br><span class="line">    <span class="keyword">delete</span> z_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">ZooAnimal()</span><br><span class="line">Bear()</span><br><span class="line">Endangered()</span><br><span class="line">Panda()</span><br><span class="line">~Panda()</span><br><span class="line">~Endangered()</span><br><span class="line">~Bear()</span><br><span class="line">~ZooAnimal()</span><br></pre></td></tr></table></figure><p>在基类和派生类的析构函数都是虚函数时，无论使用哪个基类的指针来引用派生类对象，调用析构函数时，<strong>都是按照调用派生类对象析构函数的顺序执行</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> ~MI() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~MI()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 *pb1 = <span class="keyword">new</span> MI;</span><br><span class="line">    Base2 *pb2 = <span class="keyword">new</span> MI;</span><br><span class="line">    D1 *pd1 = <span class="keyword">new</span> MI;</span><br><span class="line">    D2 *pd2 = <span class="keyword">new</span> MI;</span><br><span class="line">    <span class="keyword">delete</span> pb2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pd2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line"></span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br><span class="line"></span><br><span class="line">~MI()</span><br><span class="line">~D2()</span><br><span class="line">~Base2()</span><br><span class="line">~D1()</span><br><span class="line">~Base1()</span><br></pre></td></tr></table></figure><h3 id="多重继承下的类作用域"><a href="#多重继承下的类作用域" class="headerlink" title="多重继承下的类作用域"></a>多重继承下的类作用域</h3><p>单继承与多继承时的不同：</p><ul><li>单继承时，派生类的作用域嵌套在直接基类和间接基类的作用域中，查找过程<strong>沿着继承体系自底向上</strong>进行，直到找到所需的<strong>名字</strong>；派生类的名字将隐藏基类的<strong>同名成员</strong></li><li>多继承时，相同的查找过程将<strong>在所有直接基类中同时进行</strong>，如果<strong>名字</strong>在多个基类中都被找到，则对该名字的使用将具有二义性</li></ul><p>注意一点是，上面强调的是<strong>名字</strong>，即使派生类继承的两个函数形参列表不同也可能产生错误，因为它是<strong>按名字查找</strong>，<strong>先查找名字后进行类型检查</strong>，当编译器在两个作用域中同时发现了同名成员将直接报告一个调用二义性的错误</p><p>对一个派生类来说，从多个基类中分别继承同名的成员是完全合法的，只不过<strong>在使用这个名字时必须明确指出它的版本（这个如下面代码所示）</strong>；也就是说，派生仅是产生了潜在的二义性，只要没有调用就不会产生二义性（可以通过编译）；要想避免潜在的二义性，最好的办法是<strong>在派生类中为该函数定义一个新版本</strong>，或者<strong>通过using来显式使用确定的基类版本</strong>（例如using ZooAnimal::max_weight，或者using Endangered::max_weight）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created by steve_chph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Base2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D1()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~D2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~D2()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~MI() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"~MI()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="comment">// using D1::func1;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base1 *pb1 = <span class="keyword">new</span> MI;</span><br><span class="line">    Base2 *pb2 = <span class="keyword">new</span> MI;</span><br><span class="line">    D1 *pd1 = <span class="keyword">new</span> MI;</span><br><span class="line">    D2 *pd2 = <span class="keyword">new</span> MI;</span><br><span class="line">    <span class="keyword">delete</span> pb2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pb1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> pd2;</span><br><span class="line">    MI mi;</span><br><span class="line">    mi.D1::func1();<span class="comment">// 显式指定使用的名字的版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虽然派生列表中同一个基类只能出现一次，但是派生类可以多次继承同一个类；派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类</p><p>默认情况下，派生类中含有继承链上每个类对应的字部分，如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/SRzq3O6imcCPptu.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从图中可以看到，B1(base)和B2(base)中包含的A(base)是两个不同子部分（从x值不同可以看出，并且A的构造函数也调用了两次）</p><p>有时候要实现多次出现的同一个基类的共享，可以使用<strong>虚继承</strong>：虚继承的目的是令某个类作出声明，承诺愿意共享它的基类（共享的基类子对象称为<strong>虚基类</strong>），这样不论虚基类在继承体系中出现了多少次，<strong>在派生类中都只包含唯一一个共享的虚基类子对象</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/MRUSntrFqzxQeLJ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从上图可以看出此时A基类子对象只有一个，A只调用了一次构造函数</p><p>虚基类的缺点：必须在虚派生的真实需求出现之前就已经完成了虚派生的操作；在实际编程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题，它不会影响派生类本身，只会影响从制定了虚基类的派生类章进一步派生出来的类：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/26/gxDu6ZH7o28FTmY.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>例如Bear声明ZooAnimal为虚继承不会对Bear自身造成影响，但会对Panda造成影响</p><h4 id="使用虚基类"><a href="#使用虚基类" class="headerlink" title="使用虚基类"></a>使用虚基类</h4><p>指定虚基类的方式是在派生列表中添加关键字virtual，其中virtual和访问修饰符如public的顺序随意</p><p>virtual说明符表明了一种愿望：<strong>在后续的派生类中共享虚基类的同一份实例</strong></p><h4 id="虚基类成员的可见性"><a href="#虚基类成员的可见性" class="headerlink" title="虚基类成员的可见性"></a>虚基类成员的可见性</h4><ul><li>在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并且不会产生二义性</li><li>如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员</li><li>如果成员被多于一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本</li></ul><p>例如有如下继承关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> B&#123;...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>如果在D的对象中使用x，则有三种可能性：</p><ul><li><p>D1、D2都没有x的定义，此时x被解析为<strong>B的成员</strong>，此时不存在二义性</p></li><li><p>D1和D2只有其中一个有x的定义，此时依然没有二义性，派生类（D1或者D2）的x比共享虚基类B的x优先级更高（如下代码所示）</p><p><img src="https://i.loli.net/2019/11/27/gKDkOyYmW6idbsT.png" alt></p></li><li><p>D1、D2中均有x的定义，直接访问x将产生二义性</p></li></ul><p>解决这种二义性的最好方法是<strong>在派生类中为成员自定义新的实例</strong></p><h3 id="构造函数与虚继承"><a href="#构造函数与虚继承" class="headerlink" title="构造函数与虚继承"></a>构造函数与虚继承</h3><p>在虚派生中，虚基类是由最底层的派生类初始化的</p><h4 id="虚继承的对象的构造方式"><a href="#虚继承的对象的构造方式" class="headerlink" title="虚继承的对象的构造方式"></a>虚继承的对象的构造方式</h4><p>含有虚基类的对象的构造顺序与一般的顺序稍有区别：</p><ul><li>首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分</li><li>接下来按照直接基类在派生列表中出现的次序依次对其进行初始化</li></ul><p>也就是说：<strong>虚基类总是先于非虚基类构造，与他们在继承体系中的次序和位置无关</strong>；如下代码所示，B处于派生列表的第一个，但是虚基类A先于B进行初始化：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/HWQES617izRGBba.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>但是如果有多个虚基类的时候，虚基类的构造顺序则与派生列表的顺序有关，如下面代码所示，派生列表中B1是第一个直接基类，B1虚继承了A2，因此A2先于A1执行初始化：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/LkzYxlKp8vyaVme.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="构造函数与虚构函数的次序"><a href="#构造函数与虚构函数的次序" class="headerlink" title="构造函数与虚构函数的次序"></a>构造函数与虚构函数的次序</h4><p>一个类可以有多个虚基类，这些虚的子对象按照它们在派生列表中出现的顺序依次从左向右构造：<strong>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类；如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类</strong></p><p>对于如下的继承体系：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/MWCjRQivtZoUBY6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>它们的构造顺序如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/cj6vYmDgnwN8fAr.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>合成的拷贝和移动构造函数按照上面完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值；和往常一样，<strong>对象的销毁顺序与构造顺序正好相反</strong>：首先销毁TeddyBear，最后销毁ZooAnimal部分</p><p>最后来一个例子：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/uKTDBqH8k71PjLv.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>因为Class不是虚基类，因此<code>new Final</code>对象中含有多份Class的子对象部分，当使用Class类型指针绑定到<code>new Final</code>对象时，会造成Class基类的二义性，即控制台报错的：<code>ex18_29.cpp:15:21: error: ‘Class’ is an ambiguous base of ‘Final’</code></p><p>接下来我们修改一下，将其中一个Class申明为虚继承，另一个依然为普通继承：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/27/IXnykHGUbo2MhDq.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可以看到，Class还是存在二义性：<code>ex18_29.cpp:15:21: error: ‘Class’ is an ambiguous base of ‘Final’</code></p><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-面向对象之继承&quot;&gt;&lt;a href=&quot;#C-面向对象之继承&quot; class=&quot;headerlink&quot; title=&quot;C++面向对象之继承&quot;&gt;&lt;/a&gt;C++面向对象之继承&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考书籍：《Primer C++, 5th》&lt;/p&gt;

      
    
    </summary>
    
      <category term="C++" scheme="http://QQ876684433.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://QQ876684433.github.io/tags/C/"/>
    
      <category term="继承" scheme="http://QQ876684433.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="面向对象" scheme="http://QQ876684433.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-进程管理</title>
    <link href="http://QQ876684433.github.io/2019/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://QQ876684433.github.io/2019/11/17/操作系统-进程管理/</id>
    <published>2019-11-17T03:18:33.000Z</published>
    <updated>2019-11-17T14:35:03.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li></ul></blockquote><h2 id="进程定义和属性"><a href="#进程定义和属性" class="headerlink" title="进程定义和属性"></a>进程定义和属性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>从原理角度看：进程是支持程序执行的一种系统机制，它对处理器上运行程序的活动规律进行抽象</li><li>从实现角度看：进程是一种数据结构，用来准确地刻画运行程序的状态和系统动态变化状况</li></ul><p>操作系统有两个重要的特性：<strong>程序的并发性</strong>和<strong>资源的共享性</strong>。进程的概念既能描述程序的并发执行，又能共享系统的资源</p><ul><li><p>程序的并发性</p><p><img src="https://i.loli.net/2019/11/17/ZKvWsaEm7UnCDlS.png" alt></p><p><img src="https://i.loli.net/2019/11/17/Nf6P3UL12ESwJdV.png" alt></p><p>正因为“程序”自身这种静态的概念无法刻画程序的并发性，因此需要引入“进程”来描述系统内部程序的并发执行，提高资源利用率</p></li><li><p>资源的共享性</p><ul><li>“可再入”程序：能够被多个程序同时调用的程序</li><li>“可再用”程序：在备用过程中可以有自身修改，在调用它的程序退出之前不允许其他程序来调用</li></ul><p>“可再入”程序是纯代码，在执行过程中不被修改，调用它的各应用程序提供工作区，因此它可以被多个应用程序调用</p></li></ul><p>进程是既能描述程序的并发执行，又能共享系统资源的一个基本单位，当然操作系统也要为引入进程而付出<strong>（进程占用的）空间</strong>和<strong>（调度进程的）时间</strong>代价</p><p><strong>进程的定义</strong>：<u>进程是具有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位</u></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/QZayghxfTnXqtsw.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="进程的属性"><a href="#进程的属性" class="headerlink" title="进程的属性"></a>进程的属性</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/4P2OSBkyueYQmaR.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/KsPmo4Qn3SlJLCG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="进程的状态和转换"><a href="#进程的状态和转换" class="headerlink" title="进程的状态和转换"></a>进程的状态和转换</h3><h4 id="三态模型"><a href="#三态模型" class="headerlink" title="三态模型"></a>三态模型</h4><p>进程是活动的且有状态变化，状态及其转换体现进程的动态性，进程在执行过程中有三种状态：</p><ul><li><p><strong>运行态（running）</strong></p><p>进程占有处理器正在运行的状态</p></li><li><p><strong>就绪态（ready）</strong></p><p>进程具备运行条件，等待系统分配处理器以便运行的状态</p></li><li><p><strong>等待态（wait）</strong></p><p>阻塞态（blocked）或睡眠态（sleep），指进程不具备运行条件，正在等待某个时间完成的状态</p></li></ul><p>处于运行态的进程个数不能大于处理器的个数，处于就绪态和等待态的进程可能有多个（非运行态进程的划分的主要依据是<strong>不能运行的原因</strong>）</p><p><strong>CPU只会从就绪态队列选择进程来执行，因此等待态队列的进程是被暂时性剥夺了获得CPU的机会</strong></p><h6 id="三态模型的状态转换"><a href="#三态模型的状态转换" class="headerlink" title="三态模型的状态转换"></a>三态模型的状态转换</h6><ul><li>进程在创建后处于就绪态</li><li>运行态进程因出现等待事件或者等待信号而进入等待态</li><li>当等待事件发生或者等待信号到达后，等待态进程变成就绪态</li><li>处理器的调度会引起运行态和就绪态进程之间的切换</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/8OiGTFmI4pnJVME.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="七态模型"><a href="#七态模型" class="headerlink" title="七态模型"></a>七态模型</h4><ul><li><p><strong>新建态（new）</strong></p><p>新建态对应于进程被创建时的状态，尚未进入就绪队列（有时候根据系统性能要求或内存容量限制推迟新建态被调度执行）</p><p>创建进程要通过两个步骤：</p><ul><li>先为新进程分配所需资源和建立必要的管理信息</li><li>然后设置该进程为就绪态，并等待被调度执行</li></ul></li><li><p><strong>终止态（exit）</strong></p><p>进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态，<strong>处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失</strong></p><p>进程终止要通过两个步骤：</p><ul><li>先等待操作系统或相关进程进行善后处理（如抽取信息）</li><li>然后回收占用的资源并被系统删除</li></ul></li></ul><p>进程挂起的原因：（1）由于不断创建进程，当系统资源尤其是内存资源已经不能满足进程运行要求时，必须把某些进程<strong>挂起（suspend）</strong>，对换到磁盘对换区中，释放它占有的某些资源，<strong>暂时不参与低级调度</strong>，起到平滑系统负荷的目的；（2）也可能系统出现故障，需要暂时挂起一些进程，以便故障消除后再解除挂起并恢复进程运行；（3）用户调试程序过程中，可以请求挂起进程，以便进行某种检查和修改</p><ul><li><p><strong>挂起就绪态（ready suspend）</strong></p><p>进程具备运行条件，但目前在外存中，只有当它被对换到内存中才能被调度执行</p></li><li><p><strong>挂起等待态（blocked suspend）</strong></p><p>进程正在等待某一事件发生且进程在外存中</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/rq1eoyvYDEAOR78.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>挂起进程等同于不在内存中的进程，因此挂起进程不参与低级调度直到它们被对换进内存</p><p>挂起进程的特征：</p><ul><li>该进程不能被立即执行</li><li>该进程可能会等待事件或者等待信号，但是所等待的事件或者信号是独立于挂起条件的，事件结束并不能导致进程具备执行条件</li><li>该进程进入挂起状态是由于<strong>操作系统、父进程或者进程自身</strong>阻止它的运行</li><li>结束进程挂起状态的命令只能通过<strong>操作系统或父进程</strong>发出</li></ul><h2 id="进程描述和组成"><a href="#进程描述和组成" class="headerlink" title="进程描述和组成"></a>进程描述和组成</h2><h3 id="进程映像"><a href="#进程映像" class="headerlink" title="进程映像"></a>进程映像</h3><blockquote><p>参考资料：<a href="http://www.tldp.org/LDP/LG/issue23/flower/psimage.html" target="_blank" rel="noopener">http://www.tldp.org/LDP/LG/issue23/flower/psimage.html</a></p></blockquote><p>程序和数据是进程必需的组成部分，用来刻画静态特征；还需要一种称为<strong>进程控制块的数据结构</strong>来刻画进程的动态特征，描述进程状态、占用资源状况、记录调度信息等。由于进程状态不断发生变化，<strong>某时刻进程的内容及其状态集合称为进程映像（process image）</strong>，包括如下要素：</p><ul><li><p>进程控制块</p><p>每个进程捆绑一个，用来存储进程的标志信息、现场信息和控制信息。进程创建时建立进程控制块，进程撤销时回收进程控制块，它与进程一一对应</p></li><li><p>进程程序块</p><p>被进程执行的程序，规定进程一次运行所应完成的功能；这部分是可以被不同的进程共享的</p></li><li><p>进程核心栈</p><p>每个进程捆绑一个，进程<strong>在内核态工作时</strong>使用，用来保存中断/异常现场，保存函数调用的参数、局部变量和返回地址等</p><p><img src="https://i.loli.net/2019/11/17/tylHdTwJ7FGCs8X.png" alt></p><blockquote><p><strong>内核栈:</strong></p><p>系统栈（也叫核心栈、内核栈）是内存中属于操作系统空间的一块区域，其主要用途为：</p><pre><code>(1)保存中断现场，对于嵌套中断，被中断程序的现场信息依次压入系统栈，中断返回时逆序弹出；(2)保存操作系统子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。</code></pre><p>用户栈是用户进程空间中的一块区域，用于保存用户进程的子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。</p><p>那么为什么不直接用一个栈，何必浪费那么多的空间呢？？原因有二：</p><p>​      （1）如果只用系统栈。系统栈一般大小有限，如果中断有16个优先级，那么系统栈一般大小为15（只需保存15个低优先级的中断，另一个高优先级中断处理 程序处于运行），但用户程序子程序调用次数可能很多，那样15次子程序调用以后的子程序调用的参数、返回值、返回点以及子程序(函数)的局部变量就不能被 保存，用户程序也就无法正常运行了</p><p>​     （2）如果只用用户栈。我们知道系统程序需要在某种保护下运行，而用户栈在用户空间（即cpu处于用户态，而cpu处于核心态时是受保护的），不能提供相应的保护措施（或相当困难）</p><p>来源：<a href="https://www.cnblogs.com/yysblog/archive/2012/11/05/2755226.html" target="_blank" rel="noopener">https://www.cnblogs.com/yysblog/archive/2012/11/05/2755226.html</a></p></blockquote></li><li><p>进程数据块</p><p>进程的私有地址空间，存放各种私有数据，用户栈也在数据块中开辟，用于在函数调用时存放栈帧、局部变量和返回地址等参数</p><blockquote><p>May be distinguished as initialised variables including external global and static variables, uninitialised variables (known as a bss area on Unix derivative systems). Data blocks are not shared between processes by default.</p><p>可区分为初始化变量（包括外部全局变量和静态变量）和非初始化变量(在Unix派生系统中称为bss区域)；默认情况下，进程之间不共享数据块</p></blockquote></li></ul><h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>进程在系统中存在及活动除了本身映像外，还需要环境支撑，如硬件寄存器、程序状态字寄存器、支持动态地址转换的页表和相关的核心数据结构。在操作系统中，进程物理实体和支持进程运行的环境合称<strong>进程上下文（process context）</strong>，进程在其当前上下文运行，<strong>当系统调度新进程占有处理器时，新老进程随之发生上下文切换</strong>。进程上下文由三部分组成：</p><ul><li><p>用户级上下文（user level context）</p><p>由程序块（可执行的机器指令序列）、数据块（进程可访问的信息）、共享内存区（进程通信使用的内存区）、用户栈（存放函数调用过程中的信息）组成，它们占用进程的虚存空间。对换至磁盘的分段或页面仍然是用户级上下文的组成部分</p></li><li><p>寄存器上下文（register context）</p><p>由处理器状态寄存器（进程当前状态）、指令计数器（下一条该执行的指令地址）、栈指针（指向用户栈或核心栈当前地址）、通用寄存器等组成。当进程不处于运行态时，处理器状态信息保存在寄存器上下文中</p></li><li><p>系统级上下文（system level context）</p><p>由进程控制块（进程的状态）、内存管理信息（进程页表或段表）、核心栈（进程内核态运行时的工作区）等操作系统管理进程所需要的信息组成</p></li></ul><p>Linux系统的进程上下文：</p><ul><li>用户级上下文：text、data、shared memory和user stack等</li><li>寄存器上下文：general register、program counter、EFLAGS、ESP等</li><li>系统级上下文：task_struct、mm_struct、vm_area_struct、pgd、pmd、pte和kernel stack等</li></ul><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>每个进程有且仅有一个进程控制块（Process Control Block，PCB），或称进程控制符（process descriptor），它是<strong>进程存在的唯一标识</strong>，是操作系统用来记录和刻画进程状态及环境信息的数据结构，是进程动态特征的汇集，也是操作系统掌握进程的唯一资料结构和管理进程的主要依据；进程控制块包括进程执行时的情况，以及进程让出处理器之后所处的状态、断点等信息，一般来说PCB包含以下三类信息：</p><ul><li><p>标识信息</p><p>标识信息用于唯一地标识一个进程，分为<strong>用户使用的外部标识符</strong>和<strong>系统使用的内部标识符</strong>。系统中所有进程都被赋予唯一的、内部使用的数值型进程号（0~32768的正整数），操作系统内核函数可通过进程号来引用PCB。常用的标识信息包括<strong>进程标识ID、进程组标识ID、用户进程名、用户组名</strong>等</p></li><li><p>现场信息</p><p>现场信息用于保留进程在运行时存放在处理器现场中的各种信息，包括<strong>通用寄存器内容、控制寄存器内容、栈指针、程序状态字</strong>等。进程在让出处理器时，必须将此时的现场信息保存到它的PCB中，而当此进程恢复运行时也应恢复处理器现场</p></li><li><p>控制信息</p><p>控制信息用于管理和调度进程，包括进程调度的相关信息、进程组成信息、进程间的族系信息、进程间通信信息、进程段/页表和进程映像在外存中的地址、CPU的占用和使用信息、进程特权信息、资源清单、文件传输和I/O信息</p><p><img src="https://i.loli.net/2019/11/17/BwXHlipEeq8VdtI.png" alt></p></li></ul><h3 id="进程队列及其管理"><a href="#进程队列及其管理" class="headerlink" title="进程队列及其管理"></a>进程队列及其管理</h3><p>进程的主要特征主要由PCB来刻画，为了便于对进程进行管理和调度，常常将进程的PCB通过某种方式组织起来，<strong>一般来说，把处于同一状态的所有进程的PCB链接在一起的数据结构称为进程队列（process queue）</strong>，简称队列。有两种队列组织方式，链接方式和索引方式：</p><ul><li><p>链接方式</p><p>对同一状态进程的PCB，通过PCB中的链接指针将其链接成队列</p><p><img src="https://i.loli.net/2019/11/17/ayw9N1PrnbBsWCY.png" alt></p><p><img src="/home/steve/.config/Typora/typora-user-images/1573992590492.png" alt="1573992590492"></p><p>不同状态的进程可以排成不同队列，如：</p><ul><li><p>运行队列</p><p>通常只有一个进程</p></li><li><p>就绪队列</p><p>可按照优先级或者FCFS的原则排队，也可按照进程优先级的高低分成多个就绪队列</p></li><li><p>等待队列</p><p>通常有多个，对应不同的等待状态，如等待I/O操作完成、等待信号量等</p></li></ul><p>此外，还可以将空闲PCB结构链接成自由队列以便使用</p><p>当发生某个事件使进程状态发生转换时，此进程就要退出所在队列而排入另一个队列中去。处理器调度中<strong>负责进程入队和出队工作的功能模块称为队列管理模块</strong>，其任务是<strong>对进程的PCB重新排队并修改其状态和响应链接结构</strong></p></li><li><p>索引方式</p><p>索引方式利用索引表记录不同状态进程的PCB地址或在PCB表中的编号，系统建立若干索引表，如<strong>就绪索引表、等待索引表、空闲索引表</strong>等。状态相同进程的PCB组织在同一张索引表中，每个索引表的表目中存放PCB地址或在PCB表中的编号，<strong>各索引表在内存中的起始地址放在内核专用指针单元中</strong></p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/sqfQYLmhcWi8bzj.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="进程上下文切换与处理器状态转换"><a href="#进程上下文切换与处理器状态转换" class="headerlink" title="进程上下文切换与处理器状态转换"></a>进程上下文切换与处理器状态转换</h2><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>中断和异常是激活操作系统的仅有方法，它暂停当前运行进程的执行，把处理器转换至内核态，内核获得处理器控制权之后，如果需要就可以实现进程上下文切换，所以<strong>进程切换必定在内核态而非用户态发生</strong>。</p><p>内核在处理中断事件或系统调用过程中可能会导致被阻塞的高优先级进程变为就绪态（等待事件发生或在等待信号到达），或在<strong>处理时钟中断事件期间</strong>发现运行进程的时间片耗尽，或当前运行进程执行阻塞型I/O指令等，均有可能引发内核实施进程上下文切换。</p><p>执行上下文切换时，保存老进程的上下文并装入新进程的上下文，以便新进程运行。</p><p>实现进程上下文切换的步骤：</p><ul><li>保存被中断进程的<strong>处理器现场信息</strong></li><li>修改被中断进程<strong>PCB的有关信息</strong>，如进程状态等</li><li>把被中断进程的PCB加入相关队列</li><li>选择占用处理器运行的另一进程</li><li>修改被选中进程<strong>PCB的有关信息</strong>，如改为就绪态</li><li>设置被选中进程的<strong>地址空间</strong>，恢复<strong>存储管理信息</strong></li><li>根据被选中进程的上下文信息恢复<strong>处理器现场</strong></li></ul><h3 id="进程上下文切换时机"><a href="#进程上下文切换时机" class="headerlink" title="进程上下文切换时机"></a>进程上下文切换时机</h3><p><strong>进程调度和切换</strong>是操作系统内核程序，内核处理过程中发现满足调度条件便可请求重新调度</p><p>原则上，发生请求重新调度事件、执行调度程序和实施进程上下文切换工作应该连续发生，但是实际上由于种种原因不能连续完成，内核中不能立即进行调度和切换的情况有：</p><ul><li><p>内核正在处理中断的过程中</p><p><img src="https://i.loli.net/2019/11/17/nzVjeEgH9GFsLc5.png" alt></p></li><li><p>进程运行在内核临界区中</p><p><img src="https://i.loli.net/2019/11/17/1gqJG4L2RBe6ONl.png" alt></p></li><li><p>内核处在需要屏蔽中断的原子操作中</p></li></ul><p>在上述情况中产生引起调度条件而不能马上进行调度和切换，系统采用<strong>置请求调度标志</strong>延迟到敏感性操作完成后才进行。Linux在进程task_struct设计<strong>重调度标志need_resched</strong>，当需要进程重调度时先置调度标志位，在调度时机来临时判别标志位是否为1，以决定要否进行调度。<strong>Linux调度时机</strong>分为：</p><ul><li><p>主动调度</p><p>调用schedule()函数来释放CPU引起新一轮调度，通常发生在当前进程状态被改变，如执行了read()、write()、exit()等系统调用，导致进程终止、进程阻塞等</p></li><li><p>被动调度</p><p>发生了引起调度的条件，通常发生在新进程产生、某个进程优先级改变、进程被唤醒、进程时间片用完等。这时仅置进程TIF_NEED_RESCHED调度标志。调度标志设置有如下情况：</p><ul><li>时钟中断中调用函数scheduler_tick()，它负责查看当前进程（实时进程除外）的时间片是否耗尽，如果是，则设置重调度标志</li><li>函数try_to_wake_up()将阻塞的进程唤醒，把它加入运行队列中，如果其优先级比当前正在运行的进程优先级高，则设置重调度标志。此外，设置应用程序优先级参数nice值、创建新进程、SMP负载均衡时都有可能使高优先级进程进入就绪状态，也都可能设置重调度标志</li><li>执行sched_setscheduler()（设置调度策略）、sched_yield()（暂时让出处理器）、pause()（暂停）等系统调用时，均要设置重调度标志</li></ul><p>每当<strong>中断处理和系统调用处理结束返回</strong>时，在ret_from_sys_call代码段中会主动测试调度标志，若置位则调用schedule()函数</p></li></ul><h3 id="处理器状态转换"><a href="#处理器状态转换" class="headerlink" title="处理器状态转换"></a>处理器状态转换</h3><p>与进程上下文切换有关的是<strong>处理器状态转换（又称处理器模式转换），从用户态到内核态或从内核态到用户态是处理器的状态转换</strong>，此时仍在同一个进程中运行</p><p>当发生中断或系统调用时暂停当前正在运行的进程，把处理器状态从用户态转换到内核态，执行操作系统服务例程，这是一次<strong>状态转换</strong>，此时进程仍在自己的上下文中执行，仅处理器状态发生变化，<strong>内核在被中断进程的上下文中进行处理</strong></p><p>处理器状态转换步骤：</p><ul><li>保存被中断进程的处理器现场信息</li><li>处理器从用户态转换到内核态，以便执行系统服务例程或中断处理程序</li><li>如果处理中断，可根据所规定的中断级别设置中断屏蔽位</li><li>根据系统调用号或中断号，从<strong>系统调用表</strong>或<strong>中断入口地址表</strong>中找到系统服务例程或中断处理程序的地址</li></ul><p>处理器状态转换不同于进程上下文切换，在大多数情况下，状态转换不一定引起上下文切换，在完成系统调用服务或中断处理之后，可通过逆向处理器状态转换来恢复被中断进程运行</p><p>处理器执行进程在任何时刻必处于以下4个活动范围内：</p><ul><li>用户空间中，处于进程上下文，应用进程在用户态下运行，使用用户栈</li><li>内核空间中，处于进程上下文，内核代表进程在内核下运行，使用核心栈</li><li>内核空间中，处于中断上下文，与任何进程无关，中断服务例程在内核态下处理特定中断</li><li>内核空间中，内核线程（无用户地址空间的进程）运行于内核态</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/4QDebchVMPXakgE.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/vKOf8LkMIpWFmaZ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="Linux中进程上下文切换与处理器状态转换"><a href="#Linux中进程上下文切换与处理器状态转换" class="headerlink" title="Linux中进程上下文切换与处理器状态转换"></a>Linux中进程上下文切换与处理器状态转换</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/17/1YOJRzWAfsHgc6k.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="进程控制和管理"><a href="#进程控制和管理" class="headerlink" title="进程控制和管理"></a>进程控制和管理</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="进程管理" scheme="http://QQ876684433.github.io/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>linux下制作ext4文件系统镜像</title>
    <link href="http://QQ876684433.github.io/2019/11/07/linux%E4%B8%8B%E5%88%B6%E4%BD%9Cext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F/"/>
    <id>http://QQ876684433.github.io/2019/11/07/linux下制作ext4文件系统镜像/</id>
    <published>2019-11-07T15:47:51.000Z</published>
    <updated>2019-11-07T15:52:13.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux下制作ext4文件系统镜像"><a href="#linux下制作ext4文件系统镜像" class="headerlink" title="linux下制作ext4文件系统镜像"></a>linux下制作ext4文件系统镜像</h1><blockquote><p>由于网上的资料基本上都是一样的，大家抄来抄去，找不到最初的原作者，所以也没法在这里给出原文作者，但是声明一下，以下内容是转载自网络的</p></blockquote><p><strong>步骤如下</strong>：</p><ol><li><p>生成一个空的2MiB文件</p><p><code>dd if=/dev/zero of=rootfs.ext4 bs=1024 count=2048</code> (指定每一块大小为1024字节，一共又2048块，那么就是2048 * 1024 B = 2MiB)</p></li><li><p>对生成的文件进行格式化</p><p><code>mkfs.ext4 rootfs.ext4</code></p></li><li><p>挂载此空镜像</p><p><code>mount -o loop rootfs.ext4 /mnt</code></p></li><li><p>向挂载好的文件系统中写入需要加入的文件</p><p><code>cp everyfile /mnt</code></p></li><li><p>卸载根文件系统(意味着镜像已经制作完成)</p><p><code>umount /mnt</code></p></li><li><p>将镜像写入sd卡的某个分区中</p><p><code>dd if=rootfs.ext4 of=/dev/mmcblk0p3</code></p></li><li><p>此时挂载一下sd卡的某分区即可在发现刚才复制进去的文件</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux下制作ext4文件系统镜像&quot;&gt;&lt;a href=&quot;#linux下制作ext4文件系统镜像&quot; class=&quot;headerlink&quot; title=&quot;linux下制作ext4文件系统镜像&quot;&gt;&lt;/a&gt;linux下制作ext4文件系统镜像&lt;/h1&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="linux" scheme="http://QQ876684433.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://QQ876684433.github.io/tags/linux/"/>
    
      <category term="ext4" scheme="http://QQ876684433.github.io/tags/ext4/"/>
    
  </entry>
  
  <entry>
    <title>NASM学习记录</title>
    <link href="http://QQ876684433.github.io/2019/11/07/NASM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>http://QQ876684433.github.io/2019/11/07/NASM学习记录/</id>
    <published>2019-11-07T06:34:04.000Z</published>
    <updated>2019-11-23T08:56:55.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NASM学习记录"><a href="#NASM学习记录" class="headerlink" title="NASM学习记录"></a>NASM学习记录</h1><h2 id="零散知识点"><a href="#零散知识点" class="headerlink" title="零散知识点"></a>零散知识点</h2><h3 id="NASM汇编程序中的宏定义"><a href="#NASM汇编程序中的宏定义" class="headerlink" title="NASM汇编程序中的宏定义"></a>NASM汇编程序中的宏定义</h3><p>NASM汇编程序中的宏定义的格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%macro 宏名 参数名列表 </span><br><span class="line">宏体</span><br><span class="line">%endmacro</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%macro Descriptor 3</span><br><span class="line">dw %2 &amp; 0FFFFh </span><br><span class="line">dw %1 &amp; 0FFFFh </span><br><span class="line">db (%1 &gt;&gt; 16) &amp; 0FFh </span><br><span class="line">dw ((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh) </span><br><span class="line">db (%1 &gt;&gt; 24) &amp; 0FFh </span><br><span class="line">%endmacro ; 共 8 字节</span><br></pre></td></tr></table></figure><p>这个宏定义了操作系统中描述符的格式，宏名为：Descriptor 。使用时只需定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Descriptor 参数1, 参数2, 参数3</span><br></pre></td></tr></table></figure><p>即可。其中宏定义中的%1代表参数1，%2代表参数2，%3代表参数3</p><h3 id="EQU指令"><a href="#EQU指令" class="headerlink" title="EQU指令"></a>EQU指令</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/liukun321/article/details/5549023" target="_blank" rel="noopener">https://blog.csdn.net/liukun321/article/details/5549023</a></p></blockquote><p>有时，一个表达式在程序中会多次出现，重复书写可能较为繁杂，易出错。另一方面。如果要对该表达式进行变动，那么必须在程序中找到每一个表达式，一一做出修改，稍有不慎，就会遗漏，引出麻烦。利用EQU伪指令，就可以避免这些问题的发生。</p><p>$$<br>格式：&lt;符号名&gt; EQU &lt;表达式&gt;<br>$$<br>　　该伪指令的含义是为EQU后面的&lt;表达式&gt;起一个叫做&lt;符号名&gt;的名字。这样一来，程序中凡是需要用到该表达式的地方，就都可以用这个名字代替了。这里，&lt;表达式&gt;可以是任何有效的数据，可以是能够算出值的表达式，也可以是有效的助记符等。</p><p>　　例 <code>COUNT EQU 256</code></p><p>　　表示赋予数256一个名字，叫做COUNT。</p><p>　　<code>VAR1 EQU COUNT-2</code></p><p>　　表示赋予表达式COUNT-2一个名字，叫做VAR1。如果有<code>COUNT EQU 256</code>在先，那么由于COUNT是数值256，所以VAR1就代表数值254。</p><p>　　<code>PH EQU PUSH</code></p><p>　　表示赋予PUSH一个名字PH。由于PUSH是汇编语言的一个助记符，因此，在程序中书写<code>PH AX</code>，就相当于 <code>PUSH AX</code>。</p><h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令="></a>伪指令=</h4><p>　　与EQU伪指令类似的是等号伪指令“=”。它们的区别是：由EQU伪指令定义后的符号名是不能重复再定义的，而“=”伪指令中定义的符号名可重复定义。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EMP=7</span><br><span class="line"></span><br><span class="line">┋</span><br><span class="line"></span><br><span class="line">EMP=EMP+2</span><br></pre></td></tr></table></figure><p>　　这表示，开始把符号名EMP定义为是数值7，后来把符号名EMP重新定义为代表数值9。但是不能写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EMP EQU 7</span><br><span class="line"></span><br><span class="line">┋</span><br><span class="line"></span><br><span class="line">EMP EQU EMP+2</span><br></pre></td></tr></table></figure><h3 id="LGDT指令"><a href="#LGDT指令" class="headerlink" title="LGDT指令"></a>LGDT指令</h3><blockquote><p>原文：<a href="http://www.hgy413.com/hgydocs/IA32/instruct32_hh/vc155.htm" target="_blank" rel="noopener">http://www.hgy413.com/hgydocs/IA32/instruct32_hh/vc155.htm</a></p></blockquote><p>LGDT/LIDT - 用于加载全局/中断描述符表格寄存器</p><table><thead><tr><th>操作码</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>0F 01 /2</td><td>LGDT <strong>m16&amp;32</strong></td><td>将 <strong>m</strong> 加载到 GDTR</td></tr><tr><td>0F 01 /3</td><td>LIDT <strong>m16&amp;32</strong></td><td>将 <strong>m</strong> 加载到 IDTR</td></tr></tbody></table><ul><li><p>将源操作数中的值加载到全局描述符表格寄存器 (GDTR) 或中断描述符表格寄存器 (IDTR)。源操作数指定 6 字节内存位置，它包含全局描述符表格 (GDT) 或中断描述符表格 (IDT) 的基址（线性地址）与限制（表格大小，以字节计）。如果操作数大小属性是 32 位，则将 16 位限制（6 字节数据操作数的 2 个低位字节）与 32 位基址（数据操作数的 4 个高位字节）加载到寄存器。如果操作数大小属性是 16 位，则加载 16 位限制（2 个低位字节）与 24 位基址（第三、四、五字节）。这里，不使用操作数的高位字节，GDTR 或 IDTR 中基址的高位字节用零填充。</p></li><li><p>LGDT 与 LIDT 指令仅用在操作系统软件中；它们不用在应用程序中。在保护模式中，它们是仅有的能够直接加载线性地址（即，不是段相对地址）与限制的指令。它们通常在实地址模式中执行，以便处理器在切换到保护模式之前进行初始化。</p></li></ul><h3 id="CLD指令"><a href="#CLD指令" class="headerlink" title="CLD指令"></a>CLD指令</h3><blockquote><p>来源：<a href="https://c9x.me/x86/html/file_module_x86_id_29.html" target="_blank" rel="noopener">https://c9x.me/x86/html/file_module_x86_id_29.html</a></p></blockquote><p>CLD指令主要是用来清除EFLAGS寄存器中的DF标志位，即DF = 0，对其他标志位无影响</p><h4 id="DF标志-DF-flag"><a href="#DF标志-DF-flag" class="headerlink" title="DF标志(DF flag)"></a>DF标志(DF flag)</h4><p>这个方向标志(位于EFLAGS寄存器的第10位)控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），<strong>清除该标志则使得串指令自动递增</strong>。STD以及CLD指令分别用于设置以及清除DF标志。</p><blockquote><p>When the DF flag is set to 0, string operations increment the index registers (ESI and/or EDI).</p></blockquote><p>即DF = 0时，字符串操作会自动递增索引寄存器ESI和/或EDI</p><h3 id="LODS指令"><a href="#LODS指令" class="headerlink" title="LODS指令"></a>LODS指令</h3><blockquote><p>来源：<a href="https://baike.baidu.com/item/LODS" target="_blank" rel="noopener">https://baike.baidu.com/item/LODS</a></p></blockquote><p>汇编语言串装入指令（load string），规定源操作数为(DS:SI)，目的操作数隐含为AL（字节）或AX（字）寄存器。三种指令都用于<strong>将目的操作数的内容取到AL或AX寄存器</strong>，字节还是字操作由寻址方式确定，并根据寻址方式自动修改SI的内容</p><ul><li>LODS SRC 语法格式： LODS SI ；DST隐含为AL（字节）或AX（字）</li><li>LODSB ；字节操作，DST隐含为AL，SRC隐含为SI</li><li>LODSW ；字操作， DST隐含为AX，SRC隐含为SI</li></ul><p>注意：不影响标志位，一般不带重复前缀</p><p>执行的操作：</p><ul><li><p>（AL）←（DS:SI），（SI）←（SI）±1(字节)</p></li><li><p>（AX）←（DS:SI），（SI）←（SI）±2(字)</p></li></ul><h3 id="控制寄存器cr0"><a href="#控制寄存器cr0" class="headerlink" title="控制寄存器cr0"></a>控制寄存器cr0</h3><blockquote><p>来源：</p><ul><li><a href="https://en.wikipedia.org/wiki/Control_register" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Control_register</a></li><li><a href="https://baike.baidu.com/item/控制寄存器" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8</a></li></ul></blockquote><p>控制寄存器（CR0～CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性。<strong>CR0中含有控制处理器操作模式和状态的系统控制标志</strong>；CR1保留不用；CR2含有导致页错误的线性地址；CR3中含有页目录表物理内存基地址，因此该寄存器也被称为页目录基地址寄存器PDBR（Page-Directory Base address Register）</p><blockquote><p>CR0 has various control flags that modify the basic operation of the processor.</p></blockquote><table><thead><tr><th align="center">Bit</th><th align="center">Name</th><th align="center">Full Name</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">PE</td><td align="center">Protected Mode Enable</td><td align="center">If 1, system is in <a href="https://en.wikipedia.org/wiki/Protected_mode" target="_blank" rel="noopener">protected mode</a>, else system is in <a href="https://en.wikipedia.org/wiki/Real_mode" target="_blank" rel="noopener">real mode</a></td></tr><tr><td align="center">1</td><td align="center">MP</td><td align="center">Monitor co-processor</td><td align="center">Controls interaction of WAIT/FWAIT instructions with TS flag in CR0</td></tr><tr><td align="center">2</td><td align="center">EM</td><td align="center">Emulation</td><td align="center">If set, no x87 <a href="https://en.wikipedia.org/wiki/Floating-point_unit" target="_blank" rel="noopener">floating-point unit</a> present, if clear, x87 FPU present</td></tr><tr><td align="center">3</td><td align="center">TS</td><td align="center">Task switched</td><td align="center">Allows saving x87 task context upon a task switch only after x87 instruction used</td></tr><tr><td align="center">4</td><td align="center">ET</td><td align="center">Extension type</td><td align="center">On the 386, it allowed to specify whether the external math coprocessor was an <a href="https://en.wikipedia.org/wiki/80287" target="_blank" rel="noopener">80287</a> or <a href="https://en.wikipedia.org/wiki/80387" target="_blank" rel="noopener">80387</a></td></tr><tr><td align="center">5</td><td align="center">NE</td><td align="center">Numeric error</td><td align="center">Enable internal <a href="https://en.wikipedia.org/wiki/X87" target="_blank" rel="noopener">x87</a> floating point error reporting when set, else enables PC style x87 error detection</td></tr><tr><td align="center">16</td><td align="center">WP</td><td align="center">Write protect</td><td align="center">When set, the CPU can’t write to read-only pages when privilege level is 0</td></tr><tr><td align="center">18</td><td align="center">AM</td><td align="center">Alignment mask</td><td align="center">Alignment check enabled if AM set, AC flag (in <a href="https://en.wikipedia.org/wiki/FLAGS_register" target="_blank" rel="noopener">EFLAGS</a> register) set, and privilege level is 3</td></tr><tr><td align="center">29</td><td align="center">NW</td><td align="center">Not-write through</td><td align="center">Globally enables/disable <a href="https://en.wikipedia.org/wiki/Write_through_cache" target="_blank" rel="noopener">write-through caching</a></td></tr><tr><td align="center">30</td><td align="center">CD</td><td align="center"><a href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank" rel="noopener">Cache</a> disable</td><td align="center">Globally enables/disable the memory cache</td></tr><tr><td align="center">31</td><td align="center">PG</td><td align="center">Paging</td><td align="center">If 1, enable <a href="https://en.wikipedia.org/wiki/Paging" target="_blank" rel="noopener">paging</a> and use the <a href="https://en.wikipedia.org/wiki/Control_register#CR3" target="_blank" rel="noopener">§ CR3</a> register, else disable paging.</td></tr></tbody></table><p>要注意的是其中的两个标志位：</p><ul><li><p>PE</p><p>CR0的位0是启用保护（Protection Enable）标志。<strong>当设置该位时即开启了保护模式；当复位时即进入实地址模式</strong>。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位</p></li><li><p>PG</p><p>CR0的位31是分页（Paging）标志。<strong>当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于物理地址</strong>。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位</p></li></ul><h3 id="retf指令"><a href="#retf指令" class="headerlink" title="retf指令"></a>retf指令</h3><blockquote><p>原文链接：<a href="https://blog.csdn.net/ZCMUCZX/article/details/80216145" target="_blank" rel="noopener">https://blog.csdn.net/ZCMUCZX/article/details/80216145</a></p></blockquote><p><strong>关于ret指令和retf指令</strong></p><p>ret指令是用栈中的数据，修改IP的内容，从而实现了近转移(就是只修改IP)<br>retf指令是用栈中的数据，修改CS和IP的内容，从而实现了远转移(就是修改了CS和IP)<br>当CPU执行指令ret的时候，会进行下面的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、(IP)= ((ss *16)+(sp))</span><br><span class="line">2、(sp)=(sp)+2</span><br></pre></td></tr></table></figure><p>当CPU执行指令retf的时候相当于进行了下面的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、(IP)= ((ss *16)+(sp))</span><br><span class="line">2、(sp)=(sp)+2</span><br><span class="line">3、(CS)=((ss *16)+(sp))</span><br><span class="line">4、(sp)=(sp)+2</span><br></pre></td></tr></table></figure><p>其实就相当于CPU在执行ret指令的时候就是在执行下面的汇编语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></table></figure><p>CPU在执行retf指令的时候其实就是在执行下面的汇编语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure><h3 id="stosb-stosw-stosd指令"><a href="#stosb-stosw-stosd指令" class="headerlink" title="stosb, stosw, stosd指令"></a>stosb, stosw, stosd指令</h3><p>stosb, stosw, stosd这三个指令把al/ax/eax的内容存储到edi指向的内存单元中，同时edi的值根据方向标志的值增加或者减少</p><h3 id="LTR指令"><a href="#LTR指令" class="headerlink" title="LTR指令"></a>LTR指令</h3><p>LTR - 加载任务寄存器：</p><ul><li>将源操作数加载到任务寄存器的段选择器字段。源操作数（通用寄存器或内存位置）包含指向<strong>任务状态段 (TSS)</strong> 的段选择器。段选择器加载到任务寄存器之后，处理器使用段选择器在全局描述符表格 (GDT) 中确定 TSS 的段描述符的位置。接着，它将 TSS 的段限制与基址从段描述符加载到任务寄存器。任务寄存器指向的任务标记为忙，但不发生任务切换</li><li>提供的 LTR 指令用于操作系统软件；不应该在应用程序中使用它。它只能在 CPL 为 0 时在保护模式中执行。它常用在初始化代码，建立要执行的第一个任务</li><li>操作数大小属性不影响此指令。</li></ul><h3 id="DIV指令"><a href="#DIV指令" class="headerlink" title="DIV指令"></a>DIV指令</h3><p>指令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DIV reg8/mem8</span><br><span class="line">DIV reg16/mem16</span><br><span class="line">DIV reg32/mem32</span><br></pre></td></tr></table></figure><p>div指令只有一个操作数，即除数，被除数保存在AX（或者DX:AX，EDX:EAX）中，计算的结果商保存在AL（或者AX，EAX），余数保存在AH（或者DX，EDX），如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/11/22/gNSh8V4yFOPjXUx.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="MUL指令"><a href="#MUL指令" class="headerlink" title="MUL指令"></a>MUL指令</h3><p>MUL: 无符号乘</p><p>影响 OF、CF 标志位<br>指令格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MUL r/m  参数是乘数</span><br></pre></td></tr></table></figure><ul><li>如果参数是 r8/m8,   将把  AL 做乘数, 结果放在 AX</li><li>如果参数是 r16/m16, 将把 AX 做乘数, 结果放在 EAX</li><li>如果参数是 r32/m32, 将把 EAX 做乘数, 结果放在 EDX:EAX</li></ul><h3 id="cmp和test的区别"><a href="#cmp和test的区别" class="headerlink" title="cmp和test的区别"></a>cmp和test的区别</h3><p>test逻辑与运算结果为零,就把ZF(零标志)置1;<br>cmp 算术减法运算结果为零,就把ZF(零标志)置1.</p><h3 id="in和out端口指令"><a href="#in和out端口指令" class="headerlink" title="in和out端口指令"></a>in和out端口指令</h3><ul><li>in：从端口读取数据</li><li>out：把数据写入端口</li></ul><p>0-255时，8位端口用al，16位端口用ax</p><p>256-65535时，用dx</p><p>传输的时候需要先进入地址端口，再传输数据；比如70h为地址端口，71h为数据端口，读取2号单元的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,2h</span><br><span class="line">out 70h,al</span><br><span class="line">in al,71h</span><br></pre></td></tr></table></figure><h3 id="rep预处理指令"><a href="#rep预处理指令" class="headerlink" title="%rep预处理指令"></a>%rep预处理指令</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%rep 128</span><br><span class="line">GateSelectorCode32, SpuriousHandler, 0, DA_386IGate</span><br><span class="line">%endrep</span><br></pre></td></tr></table></figure><p>指令的作用是让<code>Gate    SelectorCode32, SpuriousHandler, 0, DA_386IGate</code>重复执行128次</p><h3 id="MOVZX指令"><a href="#MOVZX指令" class="headerlink" title="MOVZX指令"></a>MOVZX指令</h3><p>movzx一般用于将较小值拷贝到较大值中</p><h3 id="SGDT-SIDT指令"><a href="#SGDT-SIDT指令" class="headerlink" title="SGDT/SIDT指令"></a>SGDT/SIDT指令</h3><p><strong>将全局描述符表格寄存器 (GDTR) 或中断描述符表格寄存器 (IDTR) 中的内容存储到目标操作数</strong>。目标操作数是指定 6 字节内存位置。如果操作数大小属性为 32 位，则寄存器的 16 位限制字段存储到内存位置的 2 个低位字节，32 位基址存储到 4 个高位字节。如果操作数大小属性为 16 位，则限制字段存储在 2 个低位字节，24 位基址存储在第三、四及五字节，第六字节使用 0 填充。</p><p>SGDT 与 SIDT 指令仅在操作系统软件中有用；不过它们也可以在应用程序中使用，而不会导致生成异常。</p><h3 id="hlt指令"><a href="#hlt指令" class="headerlink" title="hlt指令"></a>hlt指令</h3><ul><li><p>使程序停止运行，处理器进入暂停状态，不执行任何操作，不影响标志。当RESET线上有复位信号、CPU响应非屏蔽中断、CPU响应可屏蔽中断3种情况之一时，CPU脱离暂停状态，执行HLT的下一条指令</p><p> 如果hlt指令之前，做了cli，那可屏蔽中断不能唤醒cpu</p></li><li><p>hlt是“只能在实方式和ring0执行的指令”，要区别于“IO敏感指令”。通过设置IOPI或IO许可位图，可以让ring1乃至ring3执行“IO敏感指令”，但“只能在实方式和ring0执行的指令”是规定死的</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NASM学习记录&quot;&gt;&lt;a href=&quot;#NASM学习记录&quot; class=&quot;headerlink&quot; title=&quot;NASM学习记录&quot;&gt;&lt;/a&gt;NASM学习记录&lt;/h1&gt;&lt;h2 id=&quot;零散知识点&quot;&gt;&lt;a href=&quot;#零散知识点&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="汇编" scheme="http://QQ876684433.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
      <category term="汇编" scheme="http://QQ876684433.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="NASM" scheme="http://QQ876684433.github.io/tags/NASM/"/>
    
  </entry>
  
  <entry>
    <title>使用Oracle嵌入式SQL预处理器Pro*C过程记录</title>
    <link href="http://QQ876684433.github.io/2019/10/24/%E4%BD%BF%E7%94%A8Oracle%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8Pro-C%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <id>http://QQ876684433.github.io/2019/10/24/使用Oracle嵌入式SQL预处理器Pro-C过程记录/</id>
    <published>2019-10-24T08:23:28.000Z</published>
    <updated>2019-10-24T09:13:48.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Oracle嵌入式SQL预处理器Pro-C过程记录"><a href="#使用Oracle嵌入式SQL预处理器Pro-C过程记录" class="headerlink" title="使用Oracle嵌入式SQL预处理器Pro*C过程记录"></a>使用Oracle嵌入式SQL预处理器Pro*C过程记录</h1><p>这玩意儿坑还挺多的，主要还是资料比较少，废话少说，先上参考链接：</p><blockquote><p>参考：</p><ul><li><a href="https://www.cnblogs.com/uriel/p/4275423.html" target="_blank" rel="noopener">https://www.cnblogs.com/uriel/p/4275423.html</a></li><li><a href="https://blog.csdn.net/Leafage_M/article/details/72082011" target="_blank" rel="noopener">https://blog.csdn.net/Leafage_M/article/details/72082011</a></li></ul></blockquote><p>说明：这篇文章主要是记录摸索过程中的关键步骤，以便后面使用的时候有章可循，具体关于Oracle的ESQL以及Pro*C的进阶使用，后面有时间会专门开一系列博客来记录</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在数据库课程学习上，专门有一章是用来讲Oracle嵌入式SQL（ESQL）的，主要是结合C语言来讲解。但是由于课上只是在书面上讲，而且这玩意之前没有听说过，总感觉如果不上手玩一玩的话就不能更加深入理解这玩意儿，所以就决定上手体验一下，从此开启了踩坑之路。</p><p>编程环境：</p><ul><li>Oracle数据库使用的是阿里云的Docker镜像（registry.cn-hangzhou.aliyuncs.com/qida/oracle-xe-11g）</li><li>开发环境是Deepin Linux 15.11</li></ul><h2 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h2><p> Oracle的嵌入式SQL的预编译工具是Pro*C，它的编译过程是这样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pro*C源文件(*.pc) -&gt; C源文件(*.c) -&gt; 目标文件(*.o) -&gt; 可执行文件</span><br></pre></td></tr></table></figure><p>所以首先要安装这个预编译工具，这里可以直接从oracle官网下载：</p><p><a href="https://www.oracle.com/database/technologies/instant-client/precompiler-112010-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/database/technologies/instant-client/precompiler-112010-downloads.html</a></p><p>官网没有提供deb安装包，但是有rpm安装包，只需要通过alien命令来安装即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo alien -i xxxx.rpm</span><br></pre></td></tr></table></figure><p>安装完成后，可以通过命令<code>proc -help</code>查看是否安装成功，proc就是Pro*C预编译器入口命令</p><h2 id="Pro-C头文件和库文件"><a href="#Pro-C头文件和库文件" class="headerlink" title="Pro*C头文件和库文件"></a>Pro*C头文件和库文件</h2><p>原先我想的是直接将Pro<em>C安装到我的主机上，然后将预处理和编译过程都放在本机上完成，然后运行时直接访问docker中的oracle数据库。理论上应该是可行的，但后来我发现一个问题就是，我本机没有安装oracle数据库，自然在开发Pro\</em>.C源程序的时候会找不到相关的<strong>Pro*C头文件和库文件</strong>，就是下面这些：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/FeRg96XzYZMuQmC.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>而从原博客中可以看出，这些头文件和库文件是随着oracle的安装就被安装进去的，这时我想到了，这些头文件和库文件应该是躺在Docker中的oracle容器中的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@989eb62277c6:/u01/app/oracle/product/11.2.0/xe/precomp# tree .</span><br><span class="line">.</span><br><span class="line">|-- admin</span><br><span class="line">|   `-- ottcfg.cfg</span><br><span class="line">`-- lib</span><br><span class="line">    `-- ottclasses.zip</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br><span class="line">root@989eb62277c6:/u01/app/oracle/product/11.2.0/xe/precomp#</span><br></pre></td></tr></table></figure><p>然而实际上是没有的orz，官网的原文是这样说的：</p><blockquote><p>The <code>ORACLE_BASE\ORACLE_HOME\precomp\public</code> directory contains the Pro*C/C++ header files</p><p><a href="https://docs.oracle.com/cd/B19306_01/win.102/b14321/use.htm" target="_blank" rel="noopener">https://docs.oracle.com/cd/B19306_01/win.102/b14321/use.htm</a></p></blockquote><p>估计被精简掉了。。。</p><p>场面一度很焦灼，先摸索一会儿，找到解决方案后再更新orz。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用Oracle嵌入式SQL预处理器Pro-C过程记录&quot;&gt;&lt;a href=&quot;#使用Oracle嵌入式SQL预处理器Pro-C过程记录&quot; class=&quot;headerlink&quot; title=&quot;使用Oracle嵌入式SQL预处理器Pro*C过程记录&quot;&gt;&lt;/a&gt;使用Ora
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Pro*C" scheme="http://QQ876684433.github.io/tags/Pro-C/"/>
    
      <category term="Oracle" scheme="http://QQ876684433.github.io/tags/Oracle/"/>
    
      <category term="嵌入式SQL" scheme="http://QQ876684433.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FSQL/"/>
    
      <category term="Embedded SQL" scheme="http://QQ876684433.github.io/tags/Embedded-SQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-10-24）</title>
    <link href="http://QQ876684433.github.io/2019/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-10-24%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/24/数据库课堂笔记（2019-10-24）/</id>
    <published>2019-10-24T05:51:33.000Z</published>
    <updated>2019-10-24T05:53:08.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-10-24）"><a href="#数据库课堂笔记（2019-10-24）" class="headerlink" title="数据库课堂笔记（2019-10-24）"></a>数据库课堂笔记（2019-10-24）</h2><h3 id="Ch05-Programs-to-Access-a-Database"><a href="#Ch05-Programs-to-Access-a-Database" class="headerlink" title="Ch05 Programs to Access a Database"></a>Ch05 Programs to Access a Database</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>new/delete vs malloc/free</title>
    <link href="http://QQ876684433.github.io/2019/10/24/new_delete%20vs%20malloc_free/"/>
    <id>http://QQ876684433.github.io/2019/10/24/new_delete vs malloc_free/</id>
    <published>2019-10-24T04:08:04.000Z</published>
    <updated>2019-10-24T04:10:25.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new-delete-vs-malloc-free"><a href="#new-delete-vs-malloc-free" class="headerlink" title="new/delete vs malloc/free"></a>new/delete vs malloc/free</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;new-delete-vs-malloc-free&quot;&gt;&lt;a href=&quot;#new-delete-vs-malloc-free&quot; class=&quot;headerlink&quot; title=&quot;new/delete vs malloc/free&quot;&gt;&lt;/a&gt;new/delete 
      
    
    </summary>
    
      <category term="C++" scheme="http://QQ876684433.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://QQ876684433.github.io/tags/C/"/>
    
      <category term="new" scheme="http://QQ876684433.github.io/tags/new/"/>
    
      <category term="delete" scheme="http://QQ876684433.github.io/tags/delete/"/>
    
      <category term="malloc" scheme="http://QQ876684433.github.io/tags/malloc/"/>
    
      <category term="free" scheme="http://QQ876684433.github.io/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-存储管理</title>
    <link href="http://QQ876684433.github.io/2019/10/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://QQ876684433.github.io/2019/10/23/操作系统-存储管理/</id>
    <published>2019-10-23T13:23:37.000Z</published>
    <updated>2019-10-25T02:03:19.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li></ul></blockquote><p>内存空间一般分为两部分：</p><ul><li>系统区：存放操作系统内核程序和数据结构等</li><li>用户区：存放应用程序和数据</li></ul><p>有效的存储管理也是多道程序设计技术的关键支撑，存储管理包含以下功能：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/4QPXOMmnc6V8RBg.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="存储器工作原理"><a href="#存储器工作原理" class="headerlink" title="存储器工作原理"></a>存储器工作原理</h2><h3 id="存储器层次"><a href="#存储器层次" class="headerlink" title="存储器层次"></a>存储器层次</h3><p>目前计算机均采用层次结构的存储子系统，自上至下依次为：寄存器、缓存、内存、磁盘、磁带5层。其中<strong>寄存器、缓存和内存是操作系统存储管理的管辖范畴</strong>；磁盘和磁带属于文件管理和设备管理的管辖对象。</p><h3 id="地址转换与存储保护"><a href="#地址转换与存储保护" class="headerlink" title="地址转换与存储保护"></a>地址转换与存储保护</h3><p>源程序在计算机上运行涉及的过程：</p><ul><li>编译程序或汇编程序处理源程序并生成目标代码（程序）</li><li>链接程序将目标代码链接为一个<strong>可重定位代码（程序）</strong>，此时程序处在<strong>逻辑地址空间</strong>中</li><li>装载程序将可执行代码装入物理地址空间，直到此时程序才能运行</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/jqZwMSNIoas5r3x.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h4><p>程序编译指的是编译程序（compiler）或汇编程序（assembly）的处理生成目标模块（目标代码）。一个程序可以由独立编写的且具有不同功能的多个源程序模块组成，由于模块包含外部引用，即指向<strong>其他模块中的数据或指令地址</strong>，或包含<strong>对库函数的引用</strong>，<strong>编译程序或汇编程序负责记录引用发生的位置</strong>，其处理结果将产生相应的多个目标模块，每个目标模块都附有<strong>供引用使用的内部符号表和外部符号表</strong>。符号表中依次给出<strong>各个符号名及在本目标模块中的名字地址</strong>，在模块<strong>被链接时</strong>进行转换</p><h4 id="程序链接"><a href="#程序链接" class="headerlink" title="程序链接"></a>程序链接</h4><p>链接程序（linker）的作用是<strong>根据目标模块之间的调用和依赖关系，将主模块、被调模块以及所用到的库函数装配和链接成一个完整的可装载执行模块</strong>。</p><p>根据程序链接发生的时刻和链接的方式，程序链接可以分成以下三种方式：</p><ul><li><p>静态链接</p><p>在程序装载到内存和运行之前，就已经将它的所有目标模块及所需要的库函数进行链接和装配成一个<strong>完整的可执行程序</strong>且此后不再拆分</p><blockquote><p>简单来说就是在链接阶段，将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件，该可执行文件可能会比较大</p><ul><li><p>这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行</p></li><li><p>缺点是：文件太大，一个全静态方式生成的简单print文件都有857K。而动态链接生成的一样的可执行文件却只要8.４Ｋ</p></li></ul><p>reference：<a href="https://blog.csdn.net/freestyle4568world/article/details/49817799" target="_blank" rel="noopener">https://blog.csdn.net/freestyle4568world/article/details/49817799</a></p></blockquote><p>可重定位目标程序：</p><p><img src="https://i.loli.net/2019/10/23/sSd2pJmYozEWDj5.png" alt></p></li><li><p>动态链接</p><p>程序在装入内存前并未事先进行程序各目标模块的链接，而是在程序装载时一边装载一遍链接，生成一个可执行程序。</p><ul><li>在装载目标模块时，若发生外部模块调用，将引发外部目标模块的搜索、装载和链接</li><li>同时若发现所需某部目标模块已在内存，可<strong>直接进行链接且无需再次装载，支持目标模块的共享</strong></li></ul></li><li><p>运行时链接</p><p>将某些目标模块或库函数的链接推迟到执行时才进行。在程序执行过程中，若发现被调用模块或库函数尚未链接，先在内存中进行搜索以查看其是否装入内存</p><ul><li>若已装入，则直接将其链接到调用者程序中</li><li>否则进行该模块在外存上的搜索，以及装入内存和进行链接，生成一个可执行程序</li></ul><p>运行时链接的好处：</p><ul><li>避免事先无法知道本次要运行哪些目标模块</li><li>避免程序执行过程中不被调用的某些目标模块在执行前进行链接和装载而引起的开销，提高系统资源利用率和系统效率</li></ul><p>采用运行时链接时，程序执行所需要的库函数所在的部分目标模块是伴随着其被调用才动态进行装载和链接。具体的做法是：<u>不必将程序所需的外部函数代码从系统库中提取出并链入目标模块中，而仅仅是在程序调用处登记调用信息，记录函数名及入口号，形成调用链接；一旦函数库调入内存后，就可以确定所调函数在内存的物理地址</u>。</p></li></ul><h4 id="程序装载"><a href="#程序装载" class="headerlink" title="程序装载"></a>程序装载</h4><p>装载程序（loader）把可执行程序装入内存的方式有三种：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/UlP8L6R12y3XbVC.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>磁盘中的装载模块使用的是逻辑地址，逻辑地址的集合称为进程的<strong>逻辑地址空间</strong>：</p><ul><li>逻辑地址空间可以是一维的，这时逻辑地址限制在从0开始顺序排序的地址空间内</li><li>逻辑地址空间也可以是二维的，这时整个程序被分为若干段，每段都有不同段号，<strong>段内地址从0开始顺序编址</strong></li></ul><p>物理内存从统一的基地址开始顺序编址的存储单元称为物理地址或绝对地址，物理地址的总体构成物理地址空间</p><p><strong>可执行程序逻辑地址转换（绑定）为物理地址的过程称为地址重定位、地址映射或地址转换</strong>，基于程序装入方式的不同，可以区分三种地址重定位：</p><ul><li><p>静态地址重定位</p><p><img src="https://i.loli.net/2019/10/23/yAb246iZNMTedSD.png" alt></p></li><li><p>动态地址重定位</p><p><img src="https://i.loli.net/2019/10/23/fL1H2gUhyRE9CMT.png" alt></p><p><img src="https://i.loli.net/2019/10/23/KgY5IQmcdjeyVsH.png" alt></p></li><li><p>运行时链接地址重定位</p><p><img src="https://i.loli.net/2019/10/23/eQkOVLR5i8HtPh9.png" alt></p></li></ul><p>为了允许程序因对换或空闲区收集而被移动（会导致正在执行的程序在不同时刻处于内存的不同位置），必须使用动态地址重定位。动态地址重定位要借助于<strong>硬件地址转换机制</strong>来实现，<strong>重定位寄存器的内容通常保护在进程控制块中</strong>，每当执行进程上下文切换时，当前运行进程的重定位寄存器中的内容与其他信息被一起保护起来，新进程的重定位寄存器的内容会被恢复，这样进程就在上次中断的位置恢复运行，所使用的是与上次在此位置的同样的内存基地址。</p><p>存储保护涉及防止地址越界和控制正确存取：</p><ul><li><strong>地址越界保护</strong>：无论采用何种地址重定位方式，通常进程运行时产生的所有内存访问地址都应进行检查，确保进程仅访问自己的内存区，以免破坏其他进程的内存区</li><li><strong>信息存取保护</strong>：进程在访问分配给自己的内存区时，要对访问权限进行检查，如允许读、写、执行等，从而确保数据的安全性和完整性，防止有意或无意的误操作而破坏内存信息</li></ul><h2 id="连续存储管理"><a href="#连续存储管理" class="headerlink" title="连续存储管理"></a>连续存储管理</h2><h3 id="固定分区存储管理"><a href="#固定分区存储管理" class="headerlink" title="固定分区存储管理"></a>固定分区存储管理</h3><p>固定分区又称为静态分区模式，基本思想是：内存空间被划分为<strong>数目固定不变的分区，各分区大小不等，每个分区只装入一个作业</strong>，若多个分区中都装有作业，则它们可以并发执行。</p><p>为了说明各分区分配和使用情况，需要设置一张内存分配表，记录内存中划分的分区及其使用情况。<strong>内存分配表指出各分区起始地址和长度</strong>，占用标志用来指示此分区是否被使用，当其值为0时，表明此分区尚未被占用。</p><p>固定分区管理的一项任务是何时及如何把内存空间划分成分区。这项工作通常由系统管理员和操作系统初始化模块协同完成。系统初次启动时，管理员根据当天作业情况把内存划分成大小不等但数目固定的分区。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/vj71eTxgNHQmV4u.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="排队策略"><a href="#排队策略" class="headerlink" title="排队策略"></a>排队策略</h4><p>作业进入固定分区的两种排队策略：</p><ul><li>一是每个分区有单独的作业等待队列，调度程序选中作业后，创建用户进程并将其排入一个<strong>能够装入它的最小分区的进程等待队列尾部</strong>，当此分区空闲时，就装入队首进程执行<ul><li>好处是可以使装入分区浪费的空间最小</li><li>但是如果等待处理的作业大小很不均匀，将导致分区有的空闲而有的忙碌</li></ul></li><li>二是<strong>所有等待处理的作业排成一个等待队列</strong>，每当有分区空闲时，就从队首依次搜索分区长度能够容纳的作业以便装入执行；为了防止小作业占用大分区，也可以搜索<strong>分区长度能够容纳的最大作业</strong>装入执行</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：</p><ul><li>实现简单，对于程序大小和出现频率已知的情形还是比较合适的</li><li>解决了单道程序运行在并发环境下不能与CPU速度匹配的问题</li><li>解决了单道程序运行时内存空间利用率低的问题</li></ul><p>缺点：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/7ctDUWL4kFdGoBe.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="可变分区存储管理"><a href="#可变分区存储管理" class="headerlink" title="可变分区存储管理"></a>可变分区存储管理</h3><h4 id="可变分区内存空间的分配和去配"><a href="#可变分区内存空间的分配和去配" class="headerlink" title="可变分区内存空间的分配和去配"></a>可变分区内存空间的分配和去配</h4><p>可变分区（variable partition）存储管理又称为动态分区模式，按照作业大小来划分分区，但划分的时间、大小、位置都是动态的。系统把作业装入内存时，根据其所需要的内存容量查看是否有足够的空间，若有则按需分割一个分区分配给此作业；若无则令此作业等待资源。</p><p>可变分区能够克服固定分区内存资源浪费的问题，有利于多道程序设计，提高内存资源利用率。</p><p>内存中分区数目和大小随着作业的执行而不断改变，为了方便内存空间的分配和去配，用于管理的数据结构可由两张表组成：<strong>已分配区表</strong>和<strong>未分配区表</strong>。</p><ul><li><p>当装入新作业时，从未分配区表中找出一个足够容纳它的空闲区，将此区分成两部分，一部分用来装入作业，成为已分配区；另一部分仍是空闲区（若有）。</p><p>这时应该从分配区表中找出一个空栏目登记新作业的起始地址、占用长度，同时修改未分配区表中空闲区的长度和起始地址</p></li><li><p>当作业撤离时，已分配区表中的相应状态改为空闲，而将收回的分区登记到未分配区表中，若<strong>有相邻空闲区再将其连接后登记</strong></p></li></ul><p>当一个作业X撤离时的四种情况：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/X1MqKhHCI2Pktmf.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>由于分区数目不定，而且分区表占用了较多的额外空间，采用链表是另一种较好的<strong>空闲区管理</strong>方法：</p><ul><li>通过指针把<strong>所有的空闲区</strong>链接起来，每个空闲区的开头单元存放<strong>本空闲区长度</strong>及<strong>下一个空闲区起始地址指针</strong>，系统设置<strong>指向空闲区链的头指针</strong></li><li>使用时，沿链查找并取一个长度能够满足要求的空闲分区分配给进程，再修改链表</li><li>归还时，把此空闲区链入空闲区链表的相应位置即可</li></ul><p>空闲区链表管理比空闲区表格管理复杂，但是优点是链表自身并不占用存储单元</p><h5 id="可变分区分配算法"><a href="#可变分区分配算法" class="headerlink" title="可变分区分配算法"></a>可变分区分配算法</h5><ul><li><p>最先适应（first fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/ysHQ2ujJPRqnGFA.png" alt></p></li><li><p>下次/邻近适应（next fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/OoZfarJ8cnb7jLz.png" alt></p></li><li><p>最优适应（best fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/X1UnbyGSFuCQwlp.png" alt></p></li><li><p>最坏适应（worst fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/SazlsLRt4kGqNi8.png" alt></p></li><li><p>快速适应（quick fit）分配算法</p><p><img src="https://i.loli.net/2019/10/24/9ND4cXHgiChMtjW.png" alt></p></li></ul><h4 id="地址转换和存储保护"><a href="#地址转换和存储保护" class="headerlink" title="地址转换和存储保护"></a>地址转换和存储保护</h4><ul><li><p>对固定分区采用静态地址重定位，进程运行时使用绝对地址，可由加载程序进行地址越界检查</p></li><li><p>对可变分区则采用动态地址重定位，进程的程序和数据的地址转换由硬件完成，硬件设置两个专用控制寄存器：</p><ul><li>基址寄存器：存放分配给进程使用的分区的起始地址</li><li>限长寄存器：存放分配给进程所占用的连续存储空间的长度</li></ul><p><img src="https://i.loli.net/2019/10/24/F1VD3ClEqyweZsn.png" alt></p><p>多道程序系统中，硬件只需要设置一对基址/限长寄存器：</p><ul><li>进程在执行过程中出现等待事件时，操作系统把基址/限长寄存器的内容随此进程的其他信息（如PSW、通用寄存器等）一起保护起来</li><li>另一个被选中执行的线程，则将其基址/限长值再送入基址/限长寄存器</li></ul><p>在有N个重定位寄存器的机器中，允许每个进程获得N个不同的内存段，并在运行时进行动态地址重定位：</p><ul><li><p>如果每个进程只能占用一个分区，则不允许各个进程之间有公共区域（因为有存取保护机制）</p></li><li><p>提供两对或者多对基址/限长寄存器的机器中，允许一个进程占用两个或者多个分区，这样可以通过规定某对基址/限长寄存器的区域是共享的来实现不同进程之间的共享区域，且进程共享部分取相同的基址/限长值：</p><p><img src="https://i.loli.net/2019/10/24/dUAWKD9CcVY3vtF.png" alt></p></li></ul></li></ul><h3 id="内存不足的存储管理技术"><a href="#内存不足的存储管理技术" class="headerlink" title="内存不足的存储管理技术"></a>内存不足的存储管理技术</h3><blockquote><p>补充：内部碎片和外部碎片</p><p>来源：<a href="https://www.cnblogs.com/zlcxbb/p/5759790.html" target="_blank" rel="noopener">https://www.cnblogs.com/zlcxbb/p/5759790.html</a></p><ul><li><p><strong>internal fragmentation:</strong>when memory allocated to a process is larger than requested memory, the difference between these two numbers is internal fragmentation.</p><p>在内存管理中，<strong>内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间</strong></p></li><li><p><strong>external fragmentation:</strong>External fragments exists when total memory space exists to satisfy a request, but it is not continous. storage is broken into little pieces. </p><p><strong>外部碎片</strong>是指<strong>还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块</strong>。</p></li></ul><p>一般情况下，<strong>固定分区存在内部碎片，可变式分区分配会存在外部碎片</strong>；</p><p><strong>页式虚拟存储系统</strong>存在内部碎片（为了有效的利用内存，使内存产生更少的碎片，要<strong>对内存分页</strong>，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片）</p><p><strong>段式虚拟存储系统</strong>存在外部碎片（为了共享要分段，在段的换入换出时形成外部碎片，比如5K的段换出后，有一个4k的段进来放到原来5k的地方，于是形成1k的外部碎片）</p></blockquote><h4 id="移动技术"><a href="#移动技术" class="headerlink" title="移动技术"></a>移动技术</h4><p>当在未分配分区表中找不到足够大的空闲区来装入新进程时，可采用移动技术把已在内存中的进程分区连接到一起，使分散的空闲区汇集成片，也叫内存紧凑（compact）</p><ul><li>第一种方式是把<strong>所有</strong>当前占用的分区内容移动到内存的一端</li><li>第二种方式是把占用分区内容移动到内存的一端，但是当<strong>产生足够大小的空闲区时就停止移动</strong></li></ul><p>内存中的进程在移动过程中，凡是涉及地址的信息都需要进行修改，例如基址寄存器、地址指针、内存分配表等。那么什么时候进行移动？</p><ul><li>一是进程撤销之后释放分区时，如果它不与空闲区邻接，立即实施移动，于是系统始终保持只有一个空闲区</li><li>二是进程装入分区时，若空闲区的总和够用，但是没有一个空闲区能容纳此进程时实施移动</li></ul><p>移动技术分配内存空间的算法：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/85L24gcDBvHqblZ.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>移动操作也为进程运行过程中<strong>动态扩充内存空间</strong>提供了方便，当进程执行过程中要求增加内存空间时，只需要适当移动邻近的占用分区内容就可以增加其所占有的连续区的长度，<strong>移动后的基址值和经扩大的限长值都要相应修改</strong></p><h4 id="对换技术"><a href="#对换技术" class="headerlink" title="对换技术"></a>对换技术</h4><p>对换技术（swapping）广泛应用于分时系统调度中，以<strong>解决内存容量不足</strong>的问题。如果当前一个或者多个驻留进程都处于阻塞态，此时选择其中一个进程，将其暂时移出内存，腾出空间给其他进程使用，同时把磁盘中的某个进程换入内存，让其投入运行，这种互换称为对换。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/RotUY5bDaXBE94x.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>由于有硬件地址重定位寄存器的支持，对换进来的进程映像被复制到新分配的内存区域并重置定位寄存器的值。</p><p>为了有效实施对换，必须确定以下事情：</p><ul><li><p>首先选择哪个进程换出：通常系统把时间片耗尽或优先级较低的进程换出，因为短时间内它们不会投入运行</p></li><li><p>其次应决定把进程的哪些信息移出去</p><p><img src="https://i.loli.net/2019/10/24/GPdIu2sCtxfQ647.png" alt></p></li><li><p>最后需要确定对换时机</p><ul><li>批处理系统中，当进程要求动态扩充内存空间且得不到满足时可触发对换</li><li>分时系统中，每个时间片结束或执行I/O操作时实施，调度程度启动一个挪出的进程换入，这样轮到它执行时立即可以启动（需要解决对换过程中进程的地址重定位问题）</li></ul></li></ul><p>与移动不同，<strong>对换要访问磁盘</strong>，这是I/O集中型操作，但是系统可以让对换与计算型进程并行工作。换出的进程候选者当<strong>首选被阻塞的进程</strong>，否则就挑选就绪进程，同时需要考虑进程的属性，例如消耗CPU时间、在内存已逗留时间等</p><h4 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h4><p>移动和对换技术解决因多个程序存在而导致内存区不足的问题，这种内存短缺是暂时的；如果程序长度超过物理内存总和，或超出固定分区大小，则出现内存永久性短缺，大进程无法运行，前两种方法无法解决，解决方案是使用覆盖（overlaying）技术。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/24/KaZGpMvTN5iIhOA.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>但是不足之处是，<strong>存储管理工作转给了程序员</strong>，他们必须根据物理内存空间来设计和编写程序。</p><h2 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h2><h3 id="分页存储管理的基本原理"><a href="#分页存储管理的基本原理" class="headerlink" title="分页存储管理的基本原理"></a>分页存储管理的基本原理</h3><p>采用分页存储管理允许程序存放到若干不相邻的空闲块中，既可免除移动信息工作，又可充分利用内存空间，消除动态分区法中的“碎片”问题，从而提高内存空间利用率</p><p>基本概念：</p><ul><li><p>页面：进程<strong>逻辑地址空间</strong>分成<strong>大小相等</strong>的区，每个区称为页面或页，页号从0开始依次编号</p></li><li><p>页框：页框又称为页帧，把<strong>内存物理地址空间</strong>分成<strong>大小相等</strong>的区，其大小与页面大小相等，每个区是一个页框（物理块），块号从0开始依次编号</p></li><li><p>逻辑地址：分页存储器的逻辑地址由<strong>页号</strong>和<strong>页内位移</strong>两部分组成</p><p><img src="https://i.loli.net/2019/10/25/zn2u17CGlWJvyN3.png" alt></p></li><li><p>内存页框表：该表长度取决于内存划分的物理块数，编号可与物理块号一致，页框表的表项给出物理块使用情况（0：空闲，1：占用），有的系统还会增加保护位</p></li><li><p>页表（如下一小节）</p></li></ul><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>在进行内存分配时以页框为单位，进程信息有多少页，那么把它装入内存时就分配多少页框，其中进程的逻辑地址是划分成编号连续的页面的，而装入内存的页框却未必相连。每个</p><p>（1）页面与被分配的页框如何建立联系？</p><p><strong>页表</strong>是操作系统为进程建立的，是程序页面和内存页框的对照表，页表中的每一栏指明程序中的一个页面和分得页框之间的对应关系。</p><p>为了减少系统开销，操作系统在内存中开辟存储区（软件）存放进程页表，另外设置页表寄存器（硬件）来存放当前运行进程的页表起始地址，以加快地址转换速度。</p><p>进程在内存中的每个页框内的地址是连续的，但是页框之间的地址可以不连续。</p><p>（2）逻辑地址（页面）如何转换成物理地址（页框）？</p><p>进程在运行前由系统把它的页表基地址送入页表基址寄存器，运行时借助硬件地址转换机制按页面进行动态地址重定位。</p><p>CPU获得逻辑地址后，由硬件自动按设定的页面尺寸分成<strong>页号p</strong>和<strong>页内位移d</strong>两部分，先从页表基址寄存器找到页表基地址，再用页号p作为索引查页表，得到对应的页框号</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/25/JRcqrm2G6uM7UWT.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>然后计算出要访问的内存单元地址（物理地址），实际上就是页框号和页内位移进行拼接得到物理地址</p><p>（3）如何保证程序正确运行？</p><p>虽然进程存放在若干不连续的页框中，但是在执行过程中总能<strong>按正确的物理地址进行存取</strong>。整个系统<strong>只有一个页表基址寄存器</strong>，只有占用CPU的进程才占有它；多道程序设计中，当某道程序让出处理器时，应同时让出此寄存器供其他进程使用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/25/zIWV6LArS1TgpcR.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="翻译块表（Translation-Look-aside-Buffer，TLB）"><a href="#翻译块表（Translation-Look-aside-Buffer，TLB）" class="headerlink" title="翻译块表（Translation Look-aside Buffer，TLB）"></a>翻译块表（Translation Look-aside Buffer，TLB）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;存储管理&quot;&gt;&lt;a href=&quot;#存储管理&quot; class=&quot;headerlink&quot; title=&quot;存储管理&quot;&gt;&lt;/a&gt;存储管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="存储管理" scheme="http://QQ876684433.github.io/tags/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-10-22）</title>
    <link href="http://QQ876684433.github.io/2019/10/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-10-22%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/10/22/数据库课堂笔记（2019-10-22）/</id>
    <published>2019-10-22T05:52:13.000Z</published>
    <updated>2019-10-23T07:12:45.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-10-22）"><a href="#数据库课堂笔记（2019-10-22）" class="headerlink" title="数据库课堂笔记（2019-10-22）"></a>数据库课堂笔记（2019-10-22）</h2><h3 id="Ch4-Object-Relational-SQL-Oracle"><a href="#Ch4-Object-Relational-SQL-Oracle" class="headerlink" title="Ch4. Object-Relational SQL (Oracle)"></a>Ch4. Object-Relational SQL (Oracle)</h3><h4 id="Object-Types（对象类型）"><a href="#Object-Types（对象类型）" class="headerlink" title="Object Types（对象类型）"></a>Object Types（对象类型）</h4><h5 id="类型的循环嵌套定义"><a href="#类型的循环嵌套定义" class="headerlink" title="类型的循环嵌套定义"></a>类型的循环嵌套定义</h5><p>对象类型(object type)不能嵌套定义， 但 REF 关系可以实现嵌套引用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">type</span> police_officer_t <span class="keyword">as</span> <span class="keyword">object</span></span><br><span class="line">(</span><br><span class="line">    pol_person person_t,</span><br><span class="line">    badge_number <span class="built_in">integer</span>,</span><br><span class="line">    partner <span class="keyword">ref</span> police_officer_t</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="REF-的其它约束"><a href="#REF-的其它约束" class="headerlink" title="REF 的其它约束"></a>REF 的其它约束</h5><ul><li><p>两张表之间的相互REF关系的定义</p><p><img src="https://i.loli.net/2019/10/22/3cR6MzrC4h9Fj2t.png" alt></p></li><li><p>两个具有相互REF关系的表/类型的删除</p><p><img src="https://i.loli.net/2019/10/22/f8vQaitUkF5hMVH.png" alt></p></li><li><p>REF属性数据的加载</p><p><img src="https://i.loli.net/2019/10/22/ojbT5m3XgcLidSN.png" alt></p><p><img src="https://i.loli.net/2019/10/22/5QTBnZmsLpKNqdV.png" alt></p></li></ul><h4 id="Collection-Types（集合类型）"><a href="#Collection-Types（集合类型）" class="headerlink" title="Collection Types（集合类型）"></a>Collection Types（集合类型）</h4><p>集合类型允许我们将多个值（即值的集合）存放到一行记录的某一列中，在Oracle中，集合类型有以下两种：</p><ul><li><p>表类型（Table Types，嵌套表）</p></li><li><p>数组类型（Array Types）</p><p>其中数组类型中存放的元素是具有相同的类型（the element type）的</p></li></ul><h5 id="表类型和嵌套表（Table-Types-and-Nested-Tables）"><a href="#表类型和嵌套表（Table-Types-and-Nested-Tables）" class="headerlink" title="表类型和嵌套表（Table Types and Nested Tables）"></a>表类型和嵌套表（Table Types and Nested Tables）</h5><p>创建一个<strong>表类型（table type）</strong>的方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> dependents_t <span class="keyword">AS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> person_t;</span><br></pre></td></tr></table></figure><p>这样就可以通过表类型（dependents_t）来定义新的表，而dependents_t则形成一个嵌套表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employees (</span><br><span class="line">    eid <span class="built_in">int</span>,</span><br><span class="line">    eperson person_t,</span><br><span class="line">    dependents dependents_t,</span><br><span class="line">    primary <span class="keyword">key</span> (eid)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如上，dependents属性的类型就是一个表类型（dependents_t），它是employees的嵌套表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/22/rXlRbBpLfgZJNEu.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="嵌套表的访问"><a href="#嵌套表的访问" class="headerlink" title="嵌套表的访问"></a>嵌套表的访问</h5><ul><li><p>对嵌套表进行访问时，如果需要对表类型属性进行子查询，那么需要使用<strong>转换函数：table(…)</strong>：</p><p><img src="https://i.loli.net/2019/10/22/ywjF8oRn42peHrc.png" alt></p></li><li><p>嵌套表属性不能直接使用统计函数，比如count(…)等，同样需要使用转换函数table(…)</p><p><img src="https://i.loli.net/2019/10/22/MUkJDqIZuyFw9Ng.png" alt></p></li><li><p>Oracle 数据库没有提供 nested table 的相等比较运算，但是提供了单个对象的相等比较功能</p><p><img src="https://i.loli.net/2019/10/22/VXsY1jQ8m4TPZdf.png" alt></p></li><li><p>Oracle是支持嵌套表与表自身的联接查询的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid, d.ssno</span><br><span class="line"><span class="keyword">from</span> employees e, <span class="keyword">table</span>(e.dependents) d</span><br></pre></td></tr></table></figure></li></ul><h5 id="Oracle的外联接（outer-join）"><a href="#Oracle的外联接（outer-join）" class="headerlink" title="Oracle的外联接（outer join）"></a>Oracle的外联接（outer join）</h5><blockquote><p>参考：<a href="https://www.cnblogs.com/hehaiyang/p/4745897.html" target="_blank" rel="noopener">https://www.cnblogs.com/hehaiyang/p/4745897.html</a></p></blockquote><p>对于外连接， 也可以使用“(+) ”来表示。 关于使用（+）的一些注意事项：</p><ol><li><strong>（+）操作符只能出现在WHERE子句中</strong>，并且不能与OUTER JOIN语法同时使用。</li><li>当使用（+）操作符执行外连接时，如果在WHERE子句中包含有多个条件，则必须在所有条件中都包含（+）操作符。</li><li>（+）操作符只适用于列，而不能用在表达式上。</li><li>（+）操作符不能与OR和IN操作符一起使用。</li><li>（+）操作符只能用于实现左外连接和右外连接，而<strong>不能用于实现完全外连接</strong>。</li></ol><p>用（+）来实现， 这个+号可以这样来理解： <strong>+ 表示补充，即哪个表有加号，这个表就是匹配表</strong>。如果加号写在右表，左表就是全部显示，所以是<strong>左连接</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> t_A a,t_B b <span class="keyword">where</span> a.id=b.id(+);</span><br></pre></td></tr></table></figure><p>如果加号写在左表，右表就是全部显示，所以是<strong>右连接</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> t_A a,t_B b <span class="keyword">where</span> a.id(+)=b.id;</span><br></pre></td></tr></table></figure><p>而对于全外联接，左表和右表都不做限制，所有的记录都显示，两表不足的地方均为NULL。 <strong>全外连接不支持（+）写法</strong>。</p><h5 id="嵌套游标（Nested-Cursors）"><a href="#嵌套游标（Nested-Cursors）" class="headerlink" title="嵌套游标（Nested Cursors）"></a>嵌套游标（Nested Cursors）</h5><p>可以使用嵌套游标来实现对嵌套表的查询，例如对于普通的查询操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid, d.ssno <span class="keyword">as</span> dep_sso</span><br><span class="line"><span class="keyword">from</span> employees e, <span class="keyword">table</span>(e.dependents) d</span><br><span class="line"><span class="keyword">where</span> d.age &lt; <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>可以使用嵌套游标来实现相同的功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.eid,</span><br><span class="line">    <span class="keyword">cursor</span> ( <span class="keyword">select</span> d.ssno <span class="keyword">as</span> dep_ssno</span><br><span class="line">        <span class="keyword">from</span> <span class="keyword">table</span>(e.dependents) d</span><br><span class="line">        <span class="keyword">where</span> d.age &lt; <span class="number">16</span>) dep_tab</span><br><span class="line"><span class="keyword">from</span> employees e;</span><br></pre></td></tr></table></figure><p>另外，嵌套游标也可以用来实现对嵌套表属性的统计功能：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> eid,</span><br><span class="line">    <span class="keyword">cursor</span> ( <span class="keyword">select</span> <span class="keyword">count</span>(*)</span><br><span class="line">    <span class="keyword">from</span> <span class="keyword">table</span>(e.dependents) )</span><br><span class="line"><span class="keyword">from</span> employees e;</span><br></pre></td></tr></table></figure><p>但是似乎cursor是多余的，因为以下两种方式也可以对嵌套表属性进行统计：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/23/3COt2zYwkmI5XRL.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="Array-Types（数组类型）"><a href="#Array-Types（数组类型）" class="headerlink" title="Array Types（数组类型）"></a>Array Types（数组类型）</h4><p>嵌套表类型（Nested Table）和数组类型（VARRAY）的对比：</p><table><thead><tr><th align="center"></th><th align="center">Nested table</th><th align="center">VARRAY</th></tr></thead><tbody><tr><td align="center">成员的排列次序</td><td align="center">无序</td><td align="center">有序</td></tr><tr><td align="center">成员的最大数目</td><td align="center">没有限制</td><td align="center">确定的值</td></tr><tr><td align="center">成员的存储组织</td><td align="center">单独的存储表</td><td align="center">直接存储在原表中</td></tr></tbody></table><p>两者在访问模式上的区别：</p><ul><li>可以对嵌套表属性执行insert操作， 或通过update操作修改其成员的取值</li><li>但对于 VARRAY 属性则不能执行上述的插入或修改操作， 只能通过<strong>update语句修改整个 VARRAY 属性</strong>的取值</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Makefile学习笔记</title>
    <link href="http://QQ876684433.github.io/2019/10/21/Makefile%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://QQ876684433.github.io/2019/10/21/Makefile学习笔记/</id>
    <published>2019-10-21T02:08:59.000Z</published>
    <updated>2019-10-21T02:08:59.036Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统-中断技术</title>
    <link href="http://QQ876684433.github.io/2019/10/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E6%8A%80%E6%9C%AF/"/>
    <id>http://QQ876684433.github.io/2019/10/17/操作系统-中断技术/</id>
    <published>2019-10-17T12:57:02.000Z</published>
    <updated>2019-10-18T07:44:33.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中断技术"><a href="#中断技术" class="headerlink" title="中断技术"></a>中断技术</h1><blockquote><p>参考资料：</p><ul><li>操作系统教程（第5版） - 费翔林 骆斌 编著</li><li>Linux Kernel Teaching - <a href="https://linux-kernel-labs.github.io/master/lectures/interrupts.html" target="_blank" rel="noopener">https://linux-kernel-labs.github.io/master/lectures/interrupts.html</a></li></ul></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​        每当应用程序执行系统调用要求获得操作系统服务、I/O设备报告传输情况，或者产生各种内部和外部事件时，都需要通过中断机制产生中断信号并启动操作系统内核工作，可以说，操作系统是由“<strong>中断驱动</strong>”的。最初中断技术仅作为设备向CPU报告I/O操作情况的一种手段，以免CPU因不断地轮训设备而耗费CPU时间，<strong>中断的出现解决了主机和设备的并行性问题</strong>。</p><p>​        <strong>中断（interrupt）</strong>指的是在程序执行过程中遇到急需处理的事件时，暂时终止现行程序在CPU上的运行，转而执行相应的事件处理程序，待处理完成后再<u>返回断点</u>或<u>调度其他程序执行</u>的过程。</p><p>​        不同的计算机系统中通常有不同的中断源和中断装置，但是它们都有一个共性：中断事件发生后，中断装置能改变处理器内操作的执行顺序。</p><h2 id="中断源分类"><a href="#中断源分类" class="headerlink" title="中断源分类"></a>中断源分类</h2><h3 id="硬中断"><a href="#硬中断" class="headerlink" title="硬中断"></a>硬中断</h3><p>由硬件发出或产生的中断称为硬中断，按照硬中断事件的来源和实现手段，可以将硬中断划分为外中断和内中断</p><h4 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h4><p>又称为<strong>中断</strong>或<strong>异步中断</strong>，是指<strong>来自处理器之外的中断信号</strong>，包括：时钟中断、键盘中断、它机中断、外部设备中断等。外中断又分为</p><ul><li><strong>可屏蔽中断</strong></li><li><strong>不可屏蔽中断</strong></li></ul><p>各个中断具有不同的中断优先级，表示事件的紧急程度，在处理高一级中断时，往往会部分或者全部屏蔽低级中断。</p><h4 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h4><p>又称为<strong>异常（exception）</strong>或<strong>同步中断</strong>，是指<strong>来自处理器内部的中断信号</strong>，通常是由于在程序执行过程中，发现与<strong>当前指令</strong>关联的、不正常的或错误的事件。内中断可被细分为：</p><ul><li>访管中断，由执行系统调用引起</li><li>硬件故障中断，如电源失效、奇偶校验错误、总线超时等</li><li>程序性异常，如非法操作、地址越界、页面故障、调试指令、除数为0和浮点数溢出等</li></ul><p>这些事件都由<strong>异常处理程序</strong>处理，并且通常依赖于执行程序的当前现场。<strong>内中断不能被屏蔽，一旦出现应立即予以响应并进行处理</strong>，而异常处理程序运行时是否屏蔽外部中断或屏蔽哪些中断，可根据异常处理的需要来设定</p><h4 id="中断和异常的区别"><a href="#中断和异常的区别" class="headerlink" title="中断和异常的区别"></a>中断和异常的区别</h4><ul><li><p>中断由与当前运行程序无关的中断信号触发的，系统不能确定中断事件的发生时间，故<strong>中断与CPU是异步的</strong>，CPU对中断的响应完全是被动的。<strong>中断的发生与CPU当前状态无关</strong>，既可以发生在用户态也可以发生在内核态，因为无论是用户态还是内核态，都需要处理外部设备发来的中断请求。一般来说，<strong>中断处理程序所提供的服务不是当前进程所需要的</strong>，如时钟中断、磁盘中断等</p><p>异常是由<strong>CPU控制单元</strong>产生的，源于<strong>现行程序执行指令过程中检测到的例外</strong>（exception）。<strong>异常与CPU是同步的</strong>，允许指令在执行过程期间响应异常，而且允许多次响应异常，大部分异常发生在用户态，而<strong>内核态唯一发生的异常是“缺页异常”</strong></p></li><li><p>“中断”应该被快速处理以便及时响应其他中断信号，所以<strong>中断处理程序处理过程中是不能阻塞的</strong></p><p>“异常”处于被打断的当前进程上下文中，所提供的服务是当前进程所需要的，所以<strong>异常处理程序处理过程中是可以阻塞的</strong></p></li><li><p>中断允许发生嵌套，但异常大多为一重；异常处理过程中可能会发生中断，但是中断处理过程中绝不会被异常打断</p></li></ul><blockquote><p>reference：<a href="https://stackoverflow.com/questions/7295936/what-is-the-difference-between-interrupt-and-exception-context" target="_blank" rel="noopener">https://stackoverflow.com/questions/7295936/what-is-the-difference-between-interrupt-and-exception-context</a></p><p>Interrupts and exceptions both alter the program flow. The difference between the two is that <strong>interrupts are used to handle external events (serial ports, keyboard)</strong> and <strong>exceptions are used to handle instruction faults, (division by zero, undefined opcode).</strong></p><p>Interrupts are handled by the processor after finishing the current instruction. If it finds a signal on its interrupt pin, it will look up the address of the interrupt handler in the interrupt table and pass that routine control. After returning from the interrupt handler routine, it will resume program execution at the instruction after the interrupted instruction.</p><p>Exceptions on the other hand are divided into three kinds. These are <strong>Faults, Traps and Aborts</strong>. Faults are detected and serviced by the processor before the faulting instructions. Traps are serviced after the instruction causing the trap. User defined interrupts go into this category and can be said to be traps; this includes the MS- DOS INT 21h software interrupt, for example. Aborts are used only to signal severe system problems, when operation is no longer possible.</p></blockquote><h3 id="中断和异常的响应及服务"><a href="#中断和异常的响应及服务" class="headerlink" title="中断和异常的响应及服务"></a>中断和异常的响应及服务</h3><p>产生处理器外部中断或者内部异常的时候，CPU都会在<strong>执行完当前指令后</strong>，根据中断源所提供的“中断向量”，在内核中找到响应中断服务例程并调度执行。</p><p>中断向量<strong>由硬件或操作系统预先分配和设置</strong>，系统调用所对应的向量则在访管指令中给出；各种异常向量<strong>在CPU的硬件结构中预先规定</strong>。这样不同情况就因中断向量的不同而区分开来。</p><p>操作系统如何转到中断处理程序和异常处理程序执行呢？</p><ul><li>对于中断，它主要由外部设备、时钟部件或其他计算机发出的（发现中断源并产生中断的硬件称为中断控制器，这些硬件包括中断逻辑线路和中断寄存器）<u>当前指令执行结束后，CPU会检查中断寄存器是否有中断事件发生</u>：<ul><li>若无中断信号或中断信号被屏蔽，则继续执行程序的后续指令</li><li>否则将暂停执行当前程序，转向内核的中断处理程序执行</li></ul></li><li>对于异常，它是在执行指令时，由于指令本身的原因发生的，指令的控制逻辑和实现线路一旦发现异常情况便转向内核的异常处理程序</li></ul><p>这个<u>由硬件对中断和异常事件做出反应的过程</u>称为<strong>中断响应</strong>。目前的计算机都采用软硬件结合（<strong>硬件中断控制器</strong>和<strong>软件中断/异常处理程序</strong>相结合）的方法实现中断/异常处理。中断/异常响应需要执行以下四个步骤：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/10/18/I7Eo5uDZ6jtdcCV.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="中断优先级和多重中断"><a href="#中断优先级和多重中断" class="headerlink" title="中断优先级和多重中断"></a>中断优先级和多重中断</h3><h4 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h4><p>中断装置所预设的中断响应顺序称为中断优先级。例如，同样是设备，可以设定高速设备优先级高，慢速设备优先级低，以提高高速设备的利用率。那么中断系统如何按照预先设定的优先顺序予以响应？可以使用硬件和软件方法</p><ul><li>硬件方法根据排定的优先级顺序做一个硬件链式排队器，当产生高一级中断事件时，应该<strong>屏蔽比它优先级低的所有中断源</strong></li><li>软件方法编写一个查询程序，依据优先级顺序<strong>从高到低进行查询</strong>，一旦发现有中断请求，便转入相应中断事件处理程序入口</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;中断技术&quot;&gt;&lt;a href=&quot;#中断技术&quot; class=&quot;headerlink&quot; title=&quot;中断技术&quot;&gt;&lt;/a&gt;中断技术&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统教程（第5版） - 费翔林 骆斌 编著&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="中断" scheme="http://QQ876684433.github.io/tags/%E4%B8%AD%E6%96%AD/"/>
    
      <category term="操作系统" scheme="http://QQ876684433.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
