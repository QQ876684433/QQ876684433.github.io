<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>至繁归于至简 - chph&#39;s blog</title>
  
  <subtitle>steve_chph personal website</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://QQ876684433.github.io/"/>
  <updated>2019-10-07T11:35:16.592Z</updated>
  <id>http://QQ876684433.github.io/</id>
  
  <author>
    <name>steve_chph</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>股票问题通解-有限状态机</title>
    <link href="http://QQ876684433.github.io/2019/10/02/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E9%80%9A%E8%A7%A3-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://QQ876684433.github.io/2019/10/02/股票问题通解-有限状态机/</id>
    <published>2019-10-02T03:21:30.000Z</published>
    <updated>2019-10-07T11:35:16.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【转载】股票问题通解-有限状态机"><a href="#【转载】股票问题通解-有限状态机" class="headerlink" title="【转载】股票问题通解-有限状态机"></a>【转载】股票问题通解-有限状态机</h1><blockquote><p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/</a><br>来源：力扣（LeetCode）</p></blockquote><p>很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。</p><p>这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。</p><p>先随便抽出一道题，看看别人的解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s1=-prices[<span class="number">0</span>],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.size();++i) &#123;            </span><br><span class="line">        s1 = max(s1, -prices[i]);</span><br><span class="line">        s2 = max(s2, s1+prices[i]);</span><br><span class="line">        s3 = max(s3, s2-prices[i]);</span><br><span class="line">        s4 = max(s4, s3+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">0</span>,s4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。</p><p>本文就来告诉你这个框架，然后带着你一道一道秒杀。</p><p>这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。</p><p>第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。</p><h2 id="一、穷举框架"><a href="#一、穷举框架" class="headerlink" title="一、穷举框架"></a>一、穷举框架</h2><p>首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。</p><p>递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。</p><p>而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp状态<span class="number">1</span>[...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure><p>比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。</p><p>很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dpi[<span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span>]</span><br><span class="line"><span class="number">0</span> &lt;= i &lt;= n<span class="number">-1</span>, <span class="number">1</span> &lt;= k &lt;= K</span><br><span class="line">n 为天数，大 K 为最多交易数</span><br><span class="line">此问题共 n × K × <span class="number">2</span> 种状态，全部穷举就能搞定。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= i &lt; n:</span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= k &lt;= K:</span><br><span class="line">        <span class="keyword">for</span> s in &#123;<span class="number">0</span>, <span class="number">1</span>&#125;:</span><br><span class="line">            dpi[s] = max(buy, sell, rest)</span><br></pre></td></tr></table></figure><p>而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？</p><p>我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p><p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p><h2 id="二、状态转移框架"><a href="#二、状态转移框架" class="headerlink" title="二、状态转移框架"></a>二、状态转移框架</h2><p>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.leetcode-cn.com/c4eb5f0aa4daf7bef4b3b8af95129bb7394ec58e1ba7b191d9104bbd8ff1ccb3-40198bf2f6894018328b250b772b4a17724a983f99ba359b798a289733bffcbc-file_1559885188422-1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">              max(   选择 rest  ,           选择 sell      )</span><br><span class="line"></span><br><span class="line">解释：今天我没有持有股票，有两种可能：</span><br><span class="line">要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；</span><br><span class="line">要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</span><br><span class="line"></span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">              max(   选择 rest  ,           选择 buy         )</span><br><span class="line"></span><br><span class="line">解释：今天我持有着股票，有两种可能：</span><br><span class="line">要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；</span><br><span class="line">要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</span><br></pre></td></tr></table></figure><p>这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。</p><p>现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">-1</span>][k][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 i 是从 <span class="number">0</span> 开始的，所以 i = <span class="number">-1</span> 意味着还没有开始，这时候的利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">解释：因为 k 是从 <span class="number">1</span> 开始的，所以 k = <span class="number">0</span> 意味着根本不允许交易，这时候利润当然是 <span class="number">0</span> 。</span><br><span class="line">dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line">解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</span><br></pre></td></tr></table></figure><p>把上面的状态转移方程总结一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">base <span class="keyword">case</span>：</span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">0</span>] = dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">dp[<span class="number">-1</span>][k][<span class="number">1</span>] = dp[i][<span class="number">0</span>][<span class="number">1</span>] = -infinity</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。</p><h2 id="三、秒杀题目"><a href="#三、秒杀题目" class="headerlink" title="三、秒杀题目"></a>三、秒杀题目</h2><h3 id="第一题，k-1"><a href="#第一题，k-1" class="headerlink" title="第一题，k = 1"></a>第一题，k = 1</h3><p>直接套状态转移方程，根据 base case，可以做一些化简：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>] - prices[i]) </span><br><span class="line">            = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line">解释：k = <span class="number">0</span> 的 base <span class="keyword">case</span>，所以 dp[i<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">现在发现 k 都是 <span class="number">1</span>，不会改变，即 k 对状态转移已经没有影响了。</span><br><span class="line">可以进行进一步化简去掉所有 k：</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i])</span><br></pre></td></tr></table></figure><p>直接写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = prices.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>显然<code>i = 0</code> 时 <code>dp[i-1]</code> 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 解释：</span></span><br><span class="line">        <span class="comment">//   dp[i][0] </span></span><br><span class="line">        <span class="comment">// = max(dp[-1][0], dp[-1][1] + prices[i])</span></span><br><span class="line">        <span class="comment">// = max(0, -infinity + prices[i]) = 0</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">        <span class="comment">//解释：</span></span><br><span class="line">        <span class="comment">//   dp[i][1] </span></span><br><span class="line">        <span class="comment">// = max(dp[-1][1], dp[-1][0] - prices[i])</span></span><br><span class="line">        <span class="comment">// = max(-infinity, 0 - prices[i]) </span></span><br><span class="line">        <span class="comment">// = -prices[i]</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.max(dp[i<span class="number">-1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// k == 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="comment">// base case: dp[-1][0] = 0, dp[-1][1] = -infinity</span></span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        <span class="comment">// dp[i][1] = max(dp[i-1][1], -prices[i])</span></span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。</p><h3 id="第二题，k-infinity"><a href="#第二题，k-infinity" class="headerlink" title="第二题，k = +infinity"></a>第二题，k = +infinity</h3><p>如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">            = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k][<span class="number">0</span>] - prices[i])</span><br><span class="line"></span><br><span class="line">我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：</span><br><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>直接翻译成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_inf</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三题，k-infinity-with-cooldown"><a href="#第三题，k-infinity-with-cooldown" class="headerlink" title="第三题，k = +infinity with cooldown"></a>第三题，k = +infinity with cooldown</h3><p>每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-2</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">解释：第 i 天选择 buy 的时候，要从 i<span class="number">-2</span> 的状态转移，而不是 i<span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><p>翻译成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_cool</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp_pre_0 = <span class="number">0</span>; <span class="comment">// 代表 dp[i-2][0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);</span><br><span class="line">        dp_pre_0 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四题，k-infinity-with-fee"><a href="#第四题，k-infinity-with-fee" class="headerlink" title="第四题，k = +infinity with fee"></a>第四题，k = +infinity with fee</h3><p>每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] - prices[i] - fee)</span><br><span class="line">解释：相当于买入股票的价格升高了。</span><br><span class="line">在第一个式子里减也是一样的，相当于卖出股票的价格减小了。</span><br></pre></td></tr></table></figure><p>在第一个式子里减也是一样的，相当于卖出股票的价格减小了。<br>直接翻译成代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_with_fee</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">int</span> dp_i_0 = <span class="number">0</span>, dp_i_1 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp_i_0;</span><br><span class="line">        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);</span><br><span class="line">        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i_0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第五题，k-2"><a href="#第五题，k-2" class="headerlink" title="第五题，k = 2"></a>第五题，k = 2</h3><p>k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。</p><p>这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原始的动态转移方程，没有可化简的地方</span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123; <span class="comment">/* 处理一下 base case*/</span> &#125;</span><br><span class="line">    dp[i][k][<span class="number">0</span>] = Math.max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][k][<span class="number">1</span>] = Math.max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][k][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>为什么错误？我这不是照着状态转移方程写的吗？</p><p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max_k = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123; </span><br><span class="line">            <span class="comment">/* 处理 base case */</span></span><br><span class="line">            dp[i][k][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][k][<span class="number">1</span>] = -prices[i];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 穷举了 n × max_k × 2 个状态，正确。</span></span><br><span class="line"><span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。</p><p>这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">2</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">2</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxProfit_k_2(<span class="keyword">int</span>[] prices) &#123;</span><br><span class="line">    <span class="keyword">int</span> dp_i10 = <span class="number">0</span>, dp_i11 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> dp_i20 = <span class="number">0</span>, dp_i21 = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">        dp_i20 = Math.max(dp_i20, dp_i21 + price);</span><br><span class="line">        dp_i21 = Math.max(dp_i21, dp_i10 - price);</span><br><span class="line">        dp_i10 = Math.max(dp_i10, dp_i11 + price);</span><br><span class="line">        dp_i11 = Math.max(dp_i11, -price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp_i20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。</p><h3 id="第六题，k-any-integer"><a href="#第六题，k-any-integer" class="headerlink" title="第六题，k = any integer"></a>第六题，k = any integer</h3><p>有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？</p><p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。</p><p>直接把之前的代码重用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit_k_any</span><span class="params">(<span class="keyword">int</span> max_k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (max_k &gt; n / <span class="number">2</span>) </span><br><span class="line">        <span class="keyword">return</span> maxProfit_k_inf(prices);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][max_k + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = max_k; k &gt;= <span class="number">1</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span>) &#123; <span class="comment">/* 处理 base case */</span> &#125;</span><br><span class="line">            dp[i][k][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">0</span>], dp[i<span class="number">-1</span>][k][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][k][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][k][<span class="number">1</span>], dp[i<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>] - prices[i]);     </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][max_k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，6 道题目通过一个状态转移方程全部解决。</p><h2 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h2><p>本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。</p><p>关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？</p><p>具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。</p><p>所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。</p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/" target="_blank" rel="noopener">买卖股票的最佳时机</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">买卖股票的最佳时机 III</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">买卖股票的最佳时机 IV</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">最佳买卖股票时机含冷冻期</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">买卖股票的最佳时机含手续费</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a><strong>推荐阅读</strong></h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia" target="_blank" rel="noopener">动态规划设计方法：归纳思想</a></p><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/" target="_blank" rel="noopener">滑动窗口算法解决一类子串问题</a></p><p><a href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/" target="_blank" rel="noopener">腾讯面试题详解：编辑距离</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;【转载】股票问题通解-有限状态机&quot;&gt;&lt;a href=&quot;#【转载】股票问题通解-有限状态机&quot; class=&quot;headerlink&quot; title=&quot;【转载】股票问题通解-有限状态机&quot;&gt;&lt;/a&gt;【转载】股票问题通解-有限状态机&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;作
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="转载" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-24）</title>
    <link href="http://QQ876684433.github.io/2019/09/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-24%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/24/数据库课堂笔记（2019-09-24）/</id>
    <published>2019-09-24T03:25:09.000Z</published>
    <updated>2019-10-03T06:55:34.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-24）"><a href="#数据库课堂笔记（2019-09-24）" class="headerlink" title="数据库课堂笔记（2019-09-24）"></a>数据库课堂笔记（2019-09-24）</h2><h3 id="Ch3-Basic-SQL-Query-Language"><a href="#Ch3-Basic-SQL-Query-Language" class="headerlink" title="Ch3. Basic SQL Query Language"></a>Ch3. Basic SQL Query Language</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-17）</title>
    <link href="http://QQ876684433.github.io/2019/09/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-17%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/17/数据库课堂笔记（2019-09-17）/</id>
    <published>2019-09-17T03:25:09.000Z</published>
    <updated>2019-10-03T04:12:11.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-17）"><a href="#数据库课堂笔记（2019-09-17）" class="headerlink" title="数据库课堂笔记（2019-09-17）"></a>数据库课堂笔记（2019-09-17）</h2><h3 id="Ch2-The-Relational-Model"><a href="#Ch2-The-Relational-Model" class="headerlink" title="Ch2. The Relational Model"></a>Ch2. The Relational Model</h3><h4 id="操作的相互依赖性（The-Interdependence-of-Operations）"><a href="#操作的相互依赖性（The-Interdependence-of-Operations）" class="headerlink" title="操作的相互依赖性（The Interdependence of Operations）"></a>操作的相互依赖性（The Interdependence of Operations）</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/21/l2A49OG67wMe5jD.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>基本关系集合</strong>：并、差、乘积、选择、投影[、别名]，这可以称为<strong>关系完备（Relationally Complete）</strong>的</p><ul><li><p>交运算</p><p><img src="https://i.loli.net/2019/09/21/CldHe1aWLI5zFDJ.png" alt></p><p><img src="https://i.loli.net/2019/09/21/auDksXGlxCFdyIY.png" alt></p></li><li><p>连接运算</p><p><img src="https://i.loli.net/2019/09/21/24XWvu5Q1tk8jzF.png" alt></p></li><li><p>除法运算</p><p><img src="https://i.loli.net/2019/09/21/ACurzjOJkS7mcix.png" alt></p></li></ul><h4 id="其他的关系运算"><a href="#其他的关系运算" class="headerlink" title="其他的关系运算"></a>其他的关系运算</h4><h5 id="外联接（OUTER-JOIN）"><a href="#外联接（OUTER-JOIN）" class="headerlink" title="外联接（OUTER JOIN）"></a>外联接（OUTER JOIN）</h5><ul><li><p>外联接是左外联接和右外联接的并集</p><p><img src="https://i.loli.net/2019/10/03/peVol82cHMZ4ysa.png" alt></p></li><li><p>联接运算符（JOIN）无法反向重构出原来参与运算的关系表，例如如果通过<code>（R JOIN S）</code>和R反向重构出S：</p><p><img src="https://i.loli.net/2019/10/03/1P5EZy6SbH4pRu2.png" alt></p></li><li><p>外联接与比普通联接运算符的不同在于：针对未参与自然联接的元组u，生成对应的外联接结果元组时<strong>使用null来填充空缺值</strong>。例子如下</p><p><img src="https://i.loli.net/2019/10/03/ZPrlzuNmevRHYQn.png" alt></p></li><li><p>外联接可以通过结果和其中一个关系来反向重构另一个关系：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反向重构关系S： ((R outer join S) where C&lt;&gt;null )[B, C]</span><br></pre></td></tr></table></figure></li></ul><h5 id="θ-联接"><a href="#θ-联接" class="headerlink" title="θ - 联接"></a>θ - 联接</h5><ul><li><p>定义：</p><p><img src="https://i.loli.net/2019/10/03/tCG8UdM74FfW6Bl.png" alt></p><p><img src="https://i.loli.net/2019/10/03/TCv7BsIpiq3w9bf.png" alt></p><p>一个更加通俗理解是这样：</p><p><img src="https://i.loli.net/2019/10/03/YHUPtEWlkiOKDeG.png" alt></p><p>可以把θ联接看成是<strong>带条件查询的笛卡尔乘积</strong></p></li><li><p>自然联接是θ联接中的的θ为”=”的特殊情况，即：</p><p><img src="https://img-blog.csdn.net/20180424203614498" alt></p><p>文字描述：</p><ul><li>要求关系R和关系S必须有相同的属性<strong>组</strong>B(B1, B2, …)</li><li>R和S的属性组B的值完全相同的元组才能够连接</li><li>要在结果中<strong>去掉重复的属性列</strong>（<strong>这些重复列的值完全一样</strong>）</li></ul></li><li><p>例子：</p><p><img src="https://i.loli.net/2019/10/03/XjeydJptFUVkO3E.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://QQ876684433.github.io/2019/09/15/hello-world/"/>
    <id>http://QQ876684433.github.io/2019/09/15/hello-world/</id>
    <published>2019-09-15T05:02:14.666Z</published>
    <updated>2019-09-15T05:02:14.666Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-12）</title>
    <link href="http://QQ876684433.github.io/2019/09/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-12%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/12/数据库课堂笔记（2019-09-12）/</id>
    <published>2019-09-12T03:25:09.000Z</published>
    <updated>2019-09-21T02:50:12.234Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-12）"><a href="#数据库课堂笔记（2019-09-12）" class="headerlink" title="数据库课堂笔记（2019-09-12）"></a>数据库课堂笔记（2019-09-12）</h2><h3 id="Ch2-The-Relational-Model"><a href="#Ch2-The-Relational-Model" class="headerlink" title="Ch2. The Relational Model"></a>Ch2. The Relational Model</h3><h4 id="关系代数（Relational-Algebra）"><a href="#关系代数（Relational-Algebra）" class="headerlink" title="关系代数（Relational Algebra）"></a>关系代数（Relational Algebra）</h4><h5 id="自然关系运算"><a href="#自然关系运算" class="headerlink" title="自然关系运算"></a>自然关系运算</h5><ul><li><p><strong>连接（等值连接，自然连接，JOIN）</strong></p><blockquote><p>其作用是： 根据两个关系中的<strong>同名属性的相等比较</strong>， 来实现两个关系的合并；可以表示为 <code>R join S</code> 或者 <code>R ∞ S</code></p></blockquote><p><img src="https://i.loli.net/2019/09/18/uBaTPweGtvfmRqx.png" alt></p><p>如果R和S的同名属性为B1和B2，那么这里的<code>R ∞ S</code>相当于：<code>((R × S) where R.B1 = S.B1 and R.B2 = S.B2 ) [R.A, R.B1, R.B2, S.C]</code>。注意与<code>R × S</code>的区别：<code>R × S</code>没有进行任何同名属性的比较，只是单纯进行笛卡尔积，并且新的表的表头是原来两个表的表头的拼接。</p><p><img src="https://i.loli.net/2019/09/18/12rtzW58wGhNulb.png" alt></p><blockquote><p>If Head(R) ∩ Head(S) = ∅ , then R ∞ S = R x S<br>If Head(R) = Head(S) , then R ∞ S = R ∩ S<br>If Head(R) is subset of Head(S) , then R ∞ S is subset of S</p></blockquote><p>乘积和连接运算满足交换律和结合律：</p><blockquote><p>1) R x S = S x R<br>2) R ∞ S = S ∞ R</p><p>3) (R x S) x T = R x (S x T)<br>4) (R ∞ S) ∞ T = R ∞ (S ∞ T)</p></blockquote></li><li><p><strong>除法（Division）</strong></p><p><img src="https://i.loli.net/2019/09/21/OEMaNngviY7hzc3.png" alt></p><p>注意T：<strong>the largest possible set</strong></p><p>除法有如下性质：</p><p><img src="https://i.loli.net/2019/09/21/J2BwGknFYygq6HP.png" alt></p><p>使用除法操作的场景：可以使用除法<code>division</code>运算来回答使用<strong>关键词”All、所有”</strong>的问题</p><p><img src="https://i.loli.net/2019/09/21/BP3o17HCT4hvKDr.png" alt></p><p>（1）对PRODUCTS进行投影操作PRODUCTS[pid]的原因：除数的列集合必须是被除数的列集合的子集</p><p>（2）为什么要对ORDERS在cid、pid上进行投影：因为我们最终想要的结果只需要cid的集合，因此其他属性不需要投影，而pid在进行除法运算后就没了</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>152.乘积最大子序列</title>
    <link href="http://QQ876684433.github.io/2019/09/10/152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://QQ876684433.github.io/2019/09/10/152-乘积最大子序列/</id>
    <published>2019-09-10T03:38:00.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-10）</title>
    <link href="http://QQ876684433.github.io/2019/09/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-10%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/10/数据库课堂笔记（2019-09-10）/</id>
    <published>2019-09-10T03:25:09.000Z</published>
    <updated>2019-09-17T14:22:52.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-10）"><a href="#数据库课堂笔记（2019-09-10）" class="headerlink" title="数据库课堂笔记（2019-09-10）"></a>数据库课堂笔记（2019-09-10）</h2><h3 id="Ch2-The-Relational-Model"><a href="#Ch2-The-Relational-Model" class="headerlink" title="Ch2. The Relational Model"></a>Ch2. The Relational Model</h3><h4 id="键、超键和空值（Keys，Superkeys，and-Null-Values）"><a href="#键、超键和空值（Keys，Superkeys，and-Null-Values）" class="headerlink" title="键、超键和空值（Keys，Superkeys，and Null Values）"></a>键、超键和空值（Keys，Superkeys，and Null Values）</h4><h5 id="键（Keys）"><a href="#键（Keys）" class="headerlink" title="键（Keys）"></a>键（Keys）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/oAfCMukbUgwaRxv.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>条件1说明了任意一行u在属性集K上的值是唯一的；<strong>表可能具有不止一个键</strong>；关系规则3保证了所有列的集合可以唯一区分任意两行，因此<strong>关系中至少存在一个键</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/meGc57MyshgdLJ9.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/RzwquBxEKGfOMIn.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="超键（Superkeys）"><a href="#超键（Superkeys）" class="headerlink" title="超键（Superkeys）"></a>超键（Superkeys）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/S3cbnm4Kv1Q9qaG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>属性集是不是键或者超键，取决于“设计者的意图”，有时候某些属性集在特定时刻它满足条件1，但是可能随着时间的改变，很有可能不再满足该条件，这样的属性集不是键或者超键</p><p><strong>空集既不是超键也不是键</strong>，因为属性集为空集时无法唯一确定某一行，因为所有行在空集上的取值都是空集</p><h5 id="候选键和主键（Candidate-Key-amp-Primary-Key）"><a href="#候选键和主键（Candidate-Key-amp-Primary-Key）" class="headerlink" title="候选键和主键（Candidate Key &amp; Primary Key）"></a>候选键和主键（Candidate Key &amp; Primary Key）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/46FHld1hWT7RkrV.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>主键是数据库设计者从候选键中选择出来，用来唯一确定数据表某一行的键</p><p><img src="https://i.loli.net/2019/09/15/igh9kcW6peAYPBF.png" alt></p></li><li><p>它有可能被其他表用来作为<strong>对当前表特定行的引用</strong>来使用</p><p><img src="https://i.loli.net/2019/09/15/KgdHEksYv37O1fA.png" alt></p></li></ul><h5 id="空值（Null-Values）"><a href="#空值（Null-Values）" class="headerlink" title="空值（Null Values）"></a>空值（Null Values）</h5><ul><li><p>空值应该被解释为<strong>未知的或者尚未定义的</strong>，意思是当我们<strong>以后知道更多情况的时候会重新填写该值。</strong></p><blockquote><p>A null value is placed in a field of a table when a specific value is either <strong>unknown or inappropriate</strong>.</p></blockquote></li><li><p>要注意的是：<u>空值和数字0（对于数值属性）或者是空串（对于字符串属性）是不同的</u></p></li><li><p><strong>主键不能包含空值</strong>，因为表的主键是唯一区分表的单独行的，在还没确定主键的值之前，该行是不允许被存储到数据表中的</p><p><img src="https://i.loli.net/2019/09/15/jYNURDvFofVLiq6.png" alt></p><p>实体完整性规则与3NF等价</p></li><li><p><strong>空值无法与任何非空值进行比较</strong>，用属性的非空值作为条件进行查询，永远也无法查询到该属性为空值的所在行</p></li></ul><h4 id="关系代数（Relational-Algebra）"><a href="#关系代数（Relational-Algebra）" class="headerlink" title="关系代数（Relational Algebra）"></a>关系代数（Relational Algebra）</h4><p>关系代数可以看作根据查询结果来生成新表的方法的集合，这些方法称为<strong>关系代数运算</strong>。</p><p>关系代数的运算分为两种类型：</p><ul><li><p><strong>集合论运算</strong>：以行为元素单位进行的集合运算</p><p><img src="https://i.loli.net/2019/09/17/13qwasP9bMj8XuW.png" alt></p></li><li><p><strong>自然关系运算</strong>：基于行的结构的运算</p><p><img src="https://i.loli.net/2019/09/17/orM4PlgVREWiFK9.png" alt></p></li></ul><h5 id="相容表（兼容表）"><a href="#相容表（兼容表）" class="headerlink" title="相容表（兼容表）"></a><strong>相容表（兼容表）</strong></h5><p>当表R和S有相同的表头（表标题），那么表R和表S是相容表，即：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/JmI3rojPadZEAs6.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>相同的表头的含义：相同数量的属性、属性对的域相同、属性对有相同的名字</p><p>ps：关系型数据库中，两列有相同的含义意思是<strong>他们有相同的列名（属性名）</strong>；同时<strong>属性集是无序</strong>的，因此两个数据表的表头中属性顺序不一致，并不影响它们是相容表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/KlgNfBErdzQ1oSk.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="交、并、差"><a href="#交、并、差" class="headerlink" title="交、并、差"></a><strong>交、并、差</strong></h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/3nQBH1dKpTbiy8f.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>并（UNION）和交（INTERACTION）是满足<strong>交换律</strong>和<strong>结合律</strong>的；差（DIFFERENCE）不满足<strong>交换律</strong></p><h5 id="赋值、别名"><a href="#赋值、别名" class="headerlink" title="赋值、别名"></a><strong>赋值、别名</strong></h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/i8kaOMNA1heVzu2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>S为表R的别名，简写为<code>S:=R</code>，通常用于：“关系自身的连接运算”、用来保存计算的“中间结果”。</p><h5 id="乘积运算（R×S）"><a href="#乘积运算（R×S）" class="headerlink" title="乘积运算（R×S）"></a><strong>乘积运算（R×S）</strong></h5><p>乘积运算是基于集合运算中的笛卡尔积的，它可以允许我们建立一个包含两个表中行之间所有可能的相互联系的新表。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/UbSqeLfFAyH1wxO.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/eLwW2dxrtYy5sKk.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>我们可以使用相对较小的表来构造大表，例如1000行的表的积可以有100万行</p><p>当要计算表与自身的乘积时，会存在限定符名重复的问题，例如乘积R×R是不允许的，我们<strong>可以通过使用表的别名来避免</strong>，例如S:=R，那么R与自身的乘积可以表示为：R×S</p><h5 id="自然关系运算"><a href="#自然关系运算" class="headerlink" title="自然关系运算"></a>自然关系运算</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/17/E3XRvUaQdhzOAmi.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>用关系代数表达式回答用自然语言表达的对数据的查询要求，我们称这样的表达式为<strong>关系代数查询</strong>，简称为查询</p><ul><li><p><strong>投影运算（project）</strong></p><p><img src="https://i.loli.net/2019/09/17/u9waNYiOZhQ4ARj.png" alt></p><p><img src="https://i.loli.net/2019/09/17/COaoQDtgiY9Sb8e.png" alt></p><p>投影运算实际上是在表中选择列的运算，运算结果其实是新的表，因此它会<strong>将重复的行删除</strong>，以保证任意两行是不一样的</p></li><li><p><strong>选择运算（selection）</strong></p><p>从给定的表中选择出满足特定准则的行来构成新的表</p><p><img src="https://i.loli.net/2019/09/17/oyprhnLcR7Y2JtQ.png" alt></p><ul><li><p>C是比较表达式，比较符号有：<code>&lt;, &gt;, =, &lt;=, &gt;=, 和&lt;&gt;</code>，其中<code>&lt;&gt;</code>为不等符号，类似于<code>!=</code></p></li><li><p>如果比较的条件中有字符常量，那么要使用引号，例如<code>city=&#39;Dallas&#39;</code>，其中字符常量是按照字典顺序来比较的</p></li><li><p>比较条件可以是复合表达式，例如<code>C AND C&#39;</code>等</p><p><img src="https://i.loli.net/2019/09/17/k7g5TqnPr6dHlFs.png" alt></p></li></ul><p>进行选择运算时要避免<strong>内容依赖</strong>的问题：即对于某个特定时刻表的内容，两个查询结果相同还不足以保证这两个查询表达式是等价的，他们必须要求对于所有可能的表的内容都给出相同的结果</p></li><li><p>关系代数的优先级</p><p><img src="https://i.loli.net/2019/09/17/K2vSMUuGefiLXb6.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>软件系统设计02-质量属性策略</title>
    <link href="http://QQ876684433.github.io/2019/09/09/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A102-%E8%B4%A8%E9%87%8F%E5%B1%9E%E6%80%A7%E7%AD%96%E7%95%A5/"/>
    <id>http://QQ876684433.github.io/2019/09/09/软件系统设计02-质量属性策略/</id>
    <published>2019-09-09T12:37:15.000Z</published>
    <updated>2019-09-21T02:02:20.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件系统设计02-质量属性策略"><a href="#软件系统设计02-质量属性策略" class="headerlink" title="软件系统设计02-质量属性策略"></a>软件系统设计02-质量属性策略</h1><h2 id="第四章-理解质量属性"><a href="#第四章-理解质量属性" class="headerlink" title="第四章 理解质量属性"></a>第四章 理解质量属性</h2><h3 id="质量属性定义"><a href="#质量属性定义" class="headerlink" title="质量属性定义"></a>质量属性定义</h3><p><strong>质量属性（Quality Attribute，QA）</strong>：它是一个系统可度量或者可测试的属性，用来指示系统在多大程度上满足了它的利益相关者的需求</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/Dmh8IoW5f4c2MF3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="架构和需求"><a href="#架构和需求" class="headerlink" title="架构和需求"></a>架构和需求</h3><h4 id="需求的分类"><a href="#需求的分类" class="headerlink" title="需求的分类"></a>需求的分类</h4><ul><li><strong>功能性需求（Functional Requirements）</strong>：描述了系统必须做的事情（必须实现的功能），以及在运行时接受外部刺激时系统应该表现出的行为或者反应</li><li><strong>质量属性需求（Quality Attribute Requirements）</strong>：它是功能性需求或者整个产品的质量或者限定条件——对于功能性需求来说，它描述了系统响应有多快或者在接受错误输入时必须具备多大的弹性等；对于整个系统来说，它描述了产品的部署需要的时间或者对运营成本的限制</li><li><strong>约束（Constraints）</strong>：约束条件是<strong>具有零自由度的设计决策</strong>，即是说它是一个已经做出的设计决策，不能再修改。例如系统使用的编程语言或者要依赖的指定模块等</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/jdH9W4NpQTciDoX.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="不同种类的需求在架构中的体现"><a href="#不同种类的需求在架构中的体现" class="headerlink" title="不同种类的需求在架构中的体现"></a>不同种类的需求在架构中的体现</h4><ul><li>功能性需求：通过整个设计中合适的职责分配来满足</li><li>质量属性需求：通过设计到架构中的各种结构以及填充这些结构的元素的行为和交互来满足</li><li>约束：通过接受设计决策并将其与其他受影响的设计决策进行协调来满足约束条件</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/sAGFdjfNtq1pyU5.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h3><p>功能性需求<strong>不能决定架构</strong>。原因是对于一个给定的功能性需求集合，我们可以有很多不同的方法来将功能性需求划分到不同的架构模块中；事实上，即使我们不划分模块，甚至内部毫无架构结构可言，也依旧有可能将功能性需求实现。</p><p>我们进行架构设计是为了使得系统更加易于理解，以便支持各种各样的<strong>其他目的——即质量属性需求</strong>。</p><p>尽管功能性需求<strong>独立于特定的系统结构</strong>，但是它是通过将系统的职责分配到不同的架构元素中来实现的；虽然职责可以被任意分配到某一个模块中，但是当质量属性占很重要地位的时候，软件架构会约束系统职责的分配。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/1k7jC4bmetfMHdS.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="质量属性考量"><a href="#质量属性考量" class="headerlink" title="质量属性考量"></a>质量属性考量</h3><p>功能性需求和质量属性都不是自身独立的。</p><p>从架构师的角度，系统质量属性会有以下三个问题：</p><ul><li>某个质量属性的定义是不可测试的</li><li>对质量属性的讨论通常侧重于特定问题所属的质量，而且这个问题往往在不同的质量属性范围中有重叠</li><li>每个质量社区都发展出了自己的属性词汇</li></ul><p>前两个问题可以通过才用“质量属性场景”这个工具来区分不同的质量属性；第三个问题可以通过对每一个属性的多个社区词汇进行讨论，寻找出某个质量属性的不通社区词汇之间最本质最基础的概念</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/ARi5bKTxBnFCMLz.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/VNMErefpAtXSTcy.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="质量属性分类"><a href="#质量属性分类" class="headerlink" title="质量属性分类"></a>质量属性分类</h4><ul><li>系统运行时的属性：可用性（Availability）、性能（Performance）、易用性（Usability）等</li><li>系统开发时的属性：可修改性（Modifiability）、可测试性（Testability）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/zIuGqswZ8JO3tvi.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在复杂的系统中，质量属性相互之间不可能是独立开的，一个质量属性的实现对其他质量属性产生或积极或负面的影响，因此在架构设计时需要在这些设计决策之间作出合适的权衡。</p><h3 id="制定质量属性需求"><a href="#制定质量属性需求" class="headerlink" title="制定质量属性需求"></a>制定质量属性需求</h3><p>质量属性需求应当是<strong>明确的和可测试的</strong>。质量属性表达的常用形式包含这些部分：</p><ul><li><strong>刺激（Stimulus）</strong>：到达系统的事件，例如易用性中的用户操作，安全性中的外部攻击，可修改性中的修改需求，可测试性中的某个开发阶段的完成等</li><li><strong>刺激源（Stimulus source）</strong>：不同的刺激源，系统对待和处理的方式会不一样，例如受信任用户和不受信任用户经历的审查是不一样的</li><li><strong>响应（Response）</strong>：对于刺激，系统应当采取的措施，例如在可修改性的场景中，一个修改需求的到达要求开发者将这个修改需求实现、测试并部署所作出的修改</li><li><strong>响应度量（Response measure）</strong>：判断系统的响应是否满足需求，例如性能的度量可以是延迟或者吞吐量，可修改性的度量可以是工作量或者修改、测试和部署修改所需的时间等</li><li><strong>环境（Environment）</strong>：需求的环境是一系列场景发生情况的集合，它充当了刺激的限定词，例如对待代码冻结以发布前后发生的错误，处理的方式是不一样的</li><li><strong>工件（Artifact）</strong>：它是系统中需求适用的部分，不同的问题，它可能影响整个系统，也有可能只影响系统的某一个部分，例如数据库出错和元数据库出错的处理方式是不一样的，用户接口的修改需求和中间件的修改需求所需要的时间也是不一样的，等等</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/09/PYTGwBznM42QHN8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/NZ4BG2OqXTiDuzw.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>质量属性需求可以划分为六个场景，它们可能单独发生，也有可能伴随发生，特别是系统架构设计初期</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/Q8yB2pgMoIGvmDt.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="质量属性场景示例图"><a href="#质量属性场景示例图" class="headerlink" title="质量属性场景示例图"></a>质量属性场景示例图</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/xOyBMiYCUJd1jXz.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/YLOvhojfMnNRxpB.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="通过策略来实现质量属性需求"><a href="#通过策略来实现质量属性需求" class="headerlink" title="通过策略来实现质量属性需求"></a>通过策略来实现质量属性需求</h3><h4 id="架构策略（Architectural-Tactics）"><a href="#架构策略（Architectural-Tactics）" class="headerlink" title="架构策略（Architectural Tactics）"></a>架构策略（Architectural Tactics）</h4><p>架构策略是用来实现需要的质量属性的技术，它是一种设计决策，会影响质量属性响应的实现以及会直接影响系统对某些刺激的响应。<strong>策略赋予一种设计可移植性，将性能传递给另一种设计，并将可集成性传递给第三种设计</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/10/D9BrKmp7Fjqgwfb.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="指导设计决策"><a href="#指导设计决策" class="headerlink" title="指导设计决策"></a>指导设计决策</h3><p><strong>架构是应用设计决策集合的结果</strong>。设计决策可以分为七个类别，在设计架构的时候可以分别从某个设计决策的维度进行设计考量，降低架构设计的复杂度：</p><ul><li><p><strong>职责分配（Allocation of Responsibilities）</strong></p><p>涉及职责分配的决策包括：</p><ul><li>识别重要的职责（基础系统功能、架构基础设施、质量属性的满足）</li><li>决定如何将这些职责分配到运行时和非运行时元素</li></ul><p>制定如上决策的策略有：功能分解、对真实世界对象建模、基于操作的主要模式分组、基于相似的质量属性分组</p><p><img src="https://i.loli.net/2019/09/16/X47xSvL1yr589FV.png" alt></p></li><li><p><strong>协作模型（Coordination Model）</strong></p><p>软件架构中各个元素之间相互交互的设计机制就是协作模型，它包括如下方面：</p><ul><li>识别系统中必须协作或者禁止协作的元素</li><li>确定协作的属性，例如时间线、完成度、正确性和一致性等</li><li>选择实现上面协作属性的通信机制，例如有状态的和无状态的、同步的和异步的、保证交付和不保证交付的，以及与性能相关的属性（吞吐量，延迟等）</li></ul></li><li><p><strong>数据模型（Data Model）</strong></p><p>每个系统必须以某种内部方式表示系统范围内的数据，这就是数据模型。有关数据模型的决策如下：</p><ul><li>选择主要的数据抽象（属性与相应的操作）。它包括数据的创建、初始化、访问、持久化、操作、解释和销毁</li><li>编译一致解释数据所需的元数据</li><li>组织数据，包括数据是否要存储在关系型数据库、对象集合中，或者两者兼有。如果两者兼有，则还得确定两个不同位置之间的映射</li></ul></li><li><p><strong>资源管理（Management of Resource）</strong></p><p>软件架构必须仲裁系统中共享资源的使用，包括硬件资源（CPU、存储、电源、硬件缓冲、系统时钟和I/O端口等）和软件资源（系统锁、软件缓冲、线程池，以及非线程安全的代码），资源管理决策包括如下方面：</p><ul><li>识别必须被管理的资源，确定每种资源的限度</li><li>确定每种资源是由哪个系统元素管理的</li><li>当资源存在竞争时，要确定资源的共享方式以及采取的仲裁策略</li><li>确定各种资源饱和时会造成的影响，例如随着CPU负载的增加，系统的性能会相应地下降；当内存逐渐耗尽，会在某个点开始密集地分页/交换，随之而来的是性能突然下降甚至崩溃</li></ul></li><li><p><strong>架构元素之间的映射（Mapping among Architectural Elements）</strong></p><ul><li><p>不同类型架构之间的映射</p><p>例如开发单元（模块）到执行单元（线程或者进程）的映射</p></li><li><p>软件元素和环境元素之间的映射</p><p>例如进程到特定CPUs的映射</p></li></ul><p>一般有如下比较实用的映射：</p><ul><li><strong>开发模块</strong>与<strong>运行时元素</strong>之间的相互映射，即运行时元素是由每个模块创建出来的，开发模块包含了对应每个运行时元素的代码</li><li><strong>运行时元素</strong>到<strong>处理器</strong>的分配</li><li><strong>数据模型</strong>到<strong>数据存储</strong>的分配</li><li><strong>开发模块和运行时元素</strong>到<strong>交付单元</strong>之间的映射</li></ul></li><li><p><strong>绑定时间决策（结合时间决策，Binding Time Decision）</strong></p><blockquote><p><strong>Binding time</strong> is an important, yet underestimated viewpoint in software architecture and design. It defines the latest time during the software life cycle when something flexible becomes decided and fixed. This heavily impacts the flexibility of a software design and the resulting application. A terminology for describe binding time is established and an analysis is carried out in form of side-by-side comparisons for patterns and mechanisms from the creational, structural, and behavioral domains. These terminology and synoptic comparisons with the binding time considerations can aid software architects and developers in selecting patterns and taking correct architectural decisions for their binding time requirements.</p><p>——Abstract from Paper “<u>Describing binding time in software design patterns</u>”</p></blockquote><p>绑定时间是软件架构和设计中一个重要但却被低估的观点，它定义了软件生命周期中具备灵活性的元素变成确定的和固定的状态时的最迟时间。它会深刻影响软件设计以及最终应用程序的灵活性。</p><p>其他六种决策也都和结合时间决策有关联：</p><ul><li>对于职责分配，可以在构建编译时通过参数化的makefile来选择模块</li><li>对于协作模型的选择，可以设计一个运行时通信协议进行协作</li><li>对于资源管理，可以设计一个机制，使得系统能够允许在运行时接受新的外围设备插入，紧接着识别设备并自动下载安装相应的驱动程序</li><li>对于技术选型，可以构建app store方式来为已经购买app的用户自动下载适合版本的app等</li></ul><p>在制定结合时间决策时，要考虑<strong>实现这种决策的开销</strong>，以及<strong>后续修改这种决策实现的开销</strong>。例如考虑到代码开发完成后有迁移系统平台的可能性，那么就应该在设计时通过一些额外的开销来将自己的开发工作变得平台独立，以便后续的平台移植。</p></li><li><p><strong>技术选择（Choice of Technology）</strong></p><p>技术选择是这七种决策的约束，因此我们必须选择合适的技术来实现这七种决策。技术选型决策包含以下方面：</p><ul><li>确定哪些技术能够实现其他六种决策</li><li>确定是否有合适的开发工具（IDEs，模拟器，测试工具，等等）来支持开发活动</li><li>确定内部人员对技术的熟悉程度，以及外部资源对技术的支持程度（例如课程、手册、示例，以及能够提供紧急情况专业知识的承包商的可用性）</li><li>确定所选技术的副作用，例如技术限制的协作迷行、资源管理等</li><li>确定一个新的技术是否和现有的技术栈兼容</li></ul></li></ul><h2 id="第五章-可用性"><a href="#第五章-可用性" class="headerlink" title="第五章 可用性"></a>第五章 可用性</h2><p><strong>Availability=detect+correct+restart</strong></p><p>当系统提供的服务与相应的服务规格不一致的时候，我们认为该系统失效（Failure）了，这种失效是可以被系统的用户直接观测到的 </p><p><strong>可用性损失期</strong>（从发生故障到发现故障，修复故障，最后到系统重启恢复到故障发生前的状态）由以下方面决定：</p><ul><li>Time to <strong>detect</strong> failure</li><li>Time to <strong>correct</strong> failure </li><li>Time to <strong>restart</strong> application</li></ul><p><strong>单点故障</strong></p><p>单点故障（英语：single point of failure，缩写SPOF）是指系统中一旦失效，就会让整个系统无法运作的部件，换句话说，单点故障即会整体故障。</p><p>高可用性的一些策略：</p><ul><li>消除单点失效（单点故障）</li><li>复制（备份机制，例如checkpoint等）、故障转移（快速恢复）</li><li>自动检测和重启机制</li></ul><p><strong>可恢复性</strong></p><p>在应用程序或系统发生故障后重新建立性能级别并恢复受影响数据的能力</p><p><strong>可用性的计算方式</strong></p><p>可用性可以计算为在<strong>指定时间间隔内</strong>在<strong>指定范围内</strong>提供<strong>指定服务</strong>的<strong>概率</strong>，一般表示为%形式，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/20/4B6Ae2q9hjCuKHE.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>要注意的是，由于系统维护的原因，在计算可用性时不会考虑定期的关机时间。</p><p>根据上面的公式，可以想到的提高可用性的措施：</p><ul><li>缩短系统修复时间</li><li>延长系统两次失败之间的时间间隔</li></ul><p><strong>Outage, Failure, Fault, and Error</strong></p><ul><li>Fault：系统出错或者故障，他是系统失效（failure）的原因，但是此时系统还是可用的</li><li>Failure：系统失效，它是系统状态可以被观测到的特征，往往当系统Failure时，这个系统已经不能为用户提供系统预期的服务了，甚至有可能系统已经宕机了</li><li>Error：是由Fault变成可观测的系统Failure的中间状态</li><li>Outage：指的是系统停机或者停止服务时间，它包括系统失效/出故障这种非正常的情况，也包括定期维护而停止服务的时间；提高可用性就是通过减少系统出错（Fault），从而缩短系统停止服务（Outage）的时间</li></ul><p>为了使系统更加安全和高可用，首先需要对这两方面进行分析：<strong>自己定系统最容易发生错误</strong>，以及<strong>每种错误发生后最有能造成的后果</strong>。为了进行这种分析，可以才用如下方法：</p><ul><li><p><strong>危害分析（Hazard Analysis）</strong></p><p>可以根据严重性来对每种危害进行分类，例如：</p><ul><li><strong>灾难性的（Catastrophic）</strong>：这种失效会导致整个系统直接崩溃，后果最严重</li><li><strong>赌运气的（冒险的，Hazardous）</strong>：这种失效对系统的安全或者性能有很大概率的负面影响</li><li><strong>重大的（Major）</strong>：危害也很重大，但是程度比上面两种稍微轻一些</li><li><strong>轻微的（Minor）</strong>：这种失效是显而易见的，但是危害程度小很多</li><li><strong>没有影响（No Effect）</strong>：这种失效没有任何影响</li></ul></li><li><p><strong>故障树分析（Fault Tree Analysis）</strong></p></li><li><p>失效模式，效果和临界性/危害性分析（Failure Mode, Effects, and Criticality Analysis）</p></li></ul><h3 id="可用性通用场景"><a href="#可用性通用场景" class="headerlink" title="可用性通用场景"></a>可用性通用场景</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/20/aY7wED59RkPS3FO.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><img src="https://i.loli.net/2019/09/20/Li73lgVMjRrfcmG.png" alt></p><h3 id="可用性策略（Tactis-for-Availability）"><a href="#可用性策略（Tactis-for-Availability）" class="headerlink" title="可用性策略（Tactis for Availability）"></a>可用性策略（Tactis for Availability）</h3><p>由于系统出错（Fault）有可能导致系统失效（Failure），因此我们应该采取一些策略来<strong>防止出错（Fault）演变成失效（Failure</strong>），或者至少<strong>限制出错的影响范围然后尽可能修复</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/20/6gajKyc8shDd5Ye.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>（题外话：<u>这些策略有可能以软件基础设施的形式提供（例如中间件工具包），所以架构师的职责之一是选择和使用（而不是实现它）适合的可用性策略以及正确的策略组合</u>）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/20/vRDBag8P3GhYspi.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="错误检测（Detect-Faults）"><a href="#错误检测（Detect-Faults）" class="headerlink" title="错误检测（Detect Faults）"></a>错误检测（Detect Faults）</h4><ul><li><p><strong>Ping/Echo</strong></p><ul><li>它是节点间异步的请求/响应消息对，通常用来确定<strong>可达性</strong>和<strong>往返延迟</strong>，同时echo节点也能够通过ping来确定发出ping的组件是存活的、能够正确响应的 </li><li>通常来说<strong>ping是由监控节点主动发出的</strong>，用来确认某个或者某些节点是可达的以及往返延迟是多少</li><li>Ping/Echo需要预设一个时间阈值，这个阈值用来告诉监控节点：在接收到echo之前，监控节点会等待多长时间，超时之后才会认为被监控的节点已经失效</li></ul></li><li><p><strong>Monitor（监视器）</strong></p><p>监视器是用来监视系统中多个部分健康状况的组件，例如监控：处理器、进程、IO、存储等待</p></li><li><p><strong>HeartBeat（心跳机制）</strong></p><ul><li><p>HeartBeat在系统监视器以及被监视的进程之间周期性地交互消息以检测是否有错误发生</p></li><li><p>例子：</p><p><img src="https://i.loli.net/2019/09/20/PHsiaK7hrEX2jDB.png" alt></p><p>被监控的进程周期性地主动发送心跳消息到监视器以重置watch dog中的计时器，防止计时器超时而使得监视器错误地发出一个错误信号标识被监控的进程失效</p></li><li><p>HeartBeat vs Ping/Echo：区别主要在于负责初始化健康监测机制的组件是谁，监视器还是被监控的组件自身，HeartBeat中是被监控的进程主动发出心跳信号，而Ping/Echo中是监视器主动发出ping信号来监测被监控组件的健康状态</p></li></ul></li><li><p><strong>Timestamp（时间戳）</strong></p><p>主要用于监测<strong>不正确的时间序列</strong>，一般用在分布式消息传递系统中。可以通过<strong>在事件发生时立即将本地时间附加到事件消息中</strong>来实现时间戳机制；如果具体的时间信息不重要的话，可以直接使用序列数字作为时间戳（<u>但这样的话似乎需要一个集中发放序列号的组件？</u>）</p></li><li><p><strong>Sanity Checking（健全检测）</strong></p><p>它通常是用来监测某个特定操作或者某个组件的输出的<strong>有效性或者合理性</strong>，这种策略通常基于系统内部设计、系统的状态或者正在审议中的信息等；它经常在接口中采用，用来检验特定的信息流</p></li><li><p><strong>Condition Monitoring（条件监控）</strong></p><p>它通常是用来监测一个进程或者设备的条件状态、或者验证设计时做出的假设的有效性。例如常见的方法是校验和checksum。但是监控组件自身必须足够简单以避免引入新的软件错误</p></li><li><p><strong>Voting（投票）</strong></p><p>这种策略最常见的实现方式是<strong>三重模块化冗余（triple modular redundancy，TMR）</strong>，使用是三个组件来做同样的事情，每个组件都接受相同的输入，然后将它们的输出转发到<strong>投票逻辑单元（voting logic）</strong>中检验三个输出状态的一致性</p><p>当遇到输出状态不一致的时候，投票器会报告出错状态，但同时它也还需要决定输出结果是什么，一般可以采用<strong>多数人规则（majority rule）</strong>或者<strong>对离散结果取平均</strong>，这些策略都取决于具体的投票逻辑。并且，投票逻辑应该被实现为一个简单、经过严格审查和测试的单例，以降低引入新的错误的概率</p><ul><li>Replication：各个组件是相互之间的克隆，通过相同组件的拷贝可以防止硬件的随机错误，但是不能避免软件或者硬件在设计或者实现上的错误，因为这种策略的各个组件没有差异化的设计</li><li>Functional Redundancy（功能冗余）：这些组件是差异化设计和实现的，但是它们对相同的输入，总是应该给出相同的输出</li><li>Analytic Redundancy（分析冗余）：这种策略中，不仅组件内部的实现是差异化的，他们的输入输出也是差异化的。这种策略的目的是通过使用单独的需求规范来容忍设计规范的错误。在嵌入式系统中，有些输入源可能失效，这时候分析冗余就可以生效了。</li></ul></li><li><p><strong>Exception Detection（异常检测）</strong></p><p>它通常是监测改变了正常执行流的系统条件，可以分为以下几种：</p><ul><li>系统异常（system exception）：不同的处理器硬件架构会有不同的系统异常，例如除零、总线和地址出错、非法程序指令等等</li><li>参数围栏（the parameter fence）：它包括一个先验的数据模式（例如0xDEADBEEF），它被放在一个对象的变长参数的后面，这允许在运行时监测到分配给一个对象的变长参数的内存是否被overwrite</li><li>参数类型（the parameter typing）：使用一个基类来定义函数，例如add、find等，然后派生类使用基类的函数接口，根据自身不同的参数结构来实现不同的功能。使用强类型来构建和解析消息，比简单的把消息看作一串字节，更能够减少出错、提高可用性，当然也会因此使得系统演化变得复杂</li><li>超时（timeout）：当组件没有在时间限制内完成的话，该策略会抛出一个超时异常</li></ul><p><strong>一般来说异常检测策略是在一个进程内部操作的，而ping/echo以及heartbeat时在不同进程键进程操作的</strong></p></li><li><p><strong>Self-test（自检）</strong></p><p>组件可以运行一个进程来监测自身操作的正确性，这个自检进程可以由组件自身初始化，也可以由系统监视器初始化。自检技术包括校验和checksum等</p></li></ul><h4 id="错误恢复（Recover-from-Faults）"><a href="#错误恢复（Recover-from-Faults）" class="headerlink" title="错误恢复（Recover from Faults）"></a>错误恢复（Recover from Faults）</h4><h5 id="预备和恢复策略（Preparation-and-Repair）"><a href="#预备和恢复策略（Preparation-and-Repair）" class="headerlink" title="预备和恢复策略（Preparation and Repair）"></a>预备和恢复策略（Preparation and Repair）</h5><ul><li><p><strong>Active Redundancy（hot spare，主动冗余，热备份）</strong></p><p>它将所有的节点（主动节点和冗余备份节点）配置在一个保护组中，它们并行地接收和处理相同的输入（只会才用主动节点的输出，其他的输出会被舍弃），这样可以使得冗余备份节点和主动节点保持同步的状态，因此它们可以在主动节点失效的时候立刻切换和接管工作。最简单的实现方式是1+1冗余（一个主动节点+一个冗余备份节点）。主动冗余可以用来作为基础设施北湖，例如活跃的网络链路和支援的网络链路一起使用可以提高网络连接的高可用性</p></li><li><p><strong>Passive Redundancy（warm spare，被动冗余，热备用）</strong></p><p>在保护组中只有主动成员才处理输入流量，同时给保护组中的冗余备份节点提供<strong>周期性的状态更新</strong>。当主动节点出错的时候，系统必须确定冗余备份节点的备份状态足够新（即足够接近主动节点出故障时的状态）才能够被作为替补恢复到正常的系统服务体系中，因此恢复的时间可能比主动冗余要慢</p></li><li><p><strong>Spare（cold spare，候补，冷备用）</strong></p><p>这个策略下冗余备份节点在主动节点发生故障前都是不提供服务的，因此当备份节点需要替换到正常系统体系中前，它需要启动一个power-on-reset进程来将自身的状态更新到主动节点出故障前的状态。由于它糟糕的恢复性能，它一般更适用于只有高可靠性需求（而对高可用性需求不高）的系统中</p></li><li><p><strong>Exception Handling（异常处理）</strong></p><p>一旦检测到系统异常，系统必须以某种方式进行处理。异常处理的方式很大程度上取决于所使用的开发环境，从简单的函数返回状态码/错误码，到使用包含了对错误纠正有用的信息的异常类，例如异常的名字、异常源头以及异常的原因，软件可以利用这些信息来掩盖出错，一般来说是<strong>纠正出错的原因</strong>然后<strong>重新尝试操作</strong></p></li><li><p><strong>Rollback（回退）</strong></p></li></ul><ul><li><h5 id="重新引入策略（Reintroduction）"><a href="#重新引入策略（Reintroduction）" class="headerlink" title="重新引入策略（Reintroduction）"></a>重新引入策略（Reintroduction）</h5></li></ul><p>这个部分关注将一个失效（但是已经恢复）的组件引入到正常的系统体系中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件系统设计02-质量属性策略&quot;&gt;&lt;a href=&quot;#软件系统设计02-质量属性策略&quot; class=&quot;headerlink&quot; title=&quot;软件系统设计02-质量属性策略&quot;&gt;&lt;/a&gt;软件系统设计02-质量属性策略&lt;/h1&gt;&lt;h2 id=&quot;第四章-理解质量属性&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件系统设计" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="架构" scheme="http://QQ876684433.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>91.解码方法</title>
    <link href="http://QQ876684433.github.io/2019/09/06/91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>http://QQ876684433.github.io/2019/09/06/91-解码方法/</id>
    <published>2019-09-06T11:29:49.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a>91.解码方法</h1><p>原题目如下：</p><blockquote><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p><p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26</p><p>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p><p>示例 1:</p><p>输入: “12”</p><p>输出: 2</p><p>解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。</p><p>示例 2:</p><p>输入: “226”</p><p>输出: 3</p><p>解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。</p><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/decode-ways著作权归领扣网络所有。" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-ways著作权归领扣网络所有。</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题刚开始做的时候思路是挺清晰的，就是动态规划，从左往右遍历一遍即可。对于一个长度为n的串s，由于编码只有一位数和两位数这两种可能，因此很容易得出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numDecodings(s[<span class="number">1</span>:n]) = numDecodings(s[<span class="number">1</span>:n<span class="number">-1</span>]) + numDecodings(s[<span class="number">1</span>:n<span class="number">-2</span>])</span><br></pre></td></tr></table></figure><p>当然不是直接相加那么简单，这要分情况讨论一下：</p><p>（1）如果s[i]非0（由题可知，0不是合法的编码），s[1:n]一定可以按照在s[1:n-1]的所有解码方式后面加上s[i]来解码</p><p>（2）如果s[i-1]s[i]是合法的编码（<strong>即10&lt;=int(s[i-1]s[i])&lt;=26，大于等于10的是因为01、02等待这种以0开头的两位数不是合法的编码</strong>），那么s[1:n]也一定可以按照在s[1:n-2]的所有解码方式后面加上s[i-1]s[i]来得到</p><p>（3）否则上面两种情况都不符合，那么s[1:n]无论如何也无法进行解码，比如出现连续两个0的情况</p><p>我当时做的时候，因为没有考虑编码串中出现0的情况，所以出现了偏差。另外，由于前面做题的惯性思维，动态规划问题老是想构造数组，后来细细想这道题才发现根本不需要那么大的空间开销，只需要记录dp[i-1]和dp[i-2]即可计算出dp[i]。最终的解决方案如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> s[<span class="number">0</span>]!=<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> prev = <span class="number">1</span>, target = s[<span class="number">0</span>]==<span class="string">'0'</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>  temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]!=<span class="string">'0'</span>) temp = target;</span><br><span class="line">            <span class="comment">// int val = (s[i-1]-'0')*10+(s[i]-'0');</span></span><br><span class="line">            <span class="comment">// if(val&gt;=10&amp;&amp;val&lt;=26) temp+=prev;</span></span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">'1'</span>||s[i<span class="number">-1</span>]==<span class="string">'2'</span>&amp;&amp;(s[i]&lt;=<span class="string">'6'</span>))temp+=prev;</span><br><span class="line">            </span><br><span class="line">            prev = target;</span><br><span class="line">            target = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测评的结果如下，然后我看了一下最高分的解答，思路跟我的差不多，就没必要去优化了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/06/YuE7XgBWSrZz51w.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题解没什么比较新的角度，跟我的想法差不多，就不再赘述</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;91-解码方法&quot;&gt;&lt;a href=&quot;#91-解码方法&quot; class=&quot;headerlink&quot; title=&quot;91.解码方法&quot;&gt;&lt;/a&gt;91.解码方法&lt;/h1&gt;&lt;p&gt;原题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一条包含字母 A-Z 的消息通过以下方式进行了
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>63.不同路径II</title>
    <link href="http://QQ876684433.github.io/2019/09/04/63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/"/>
    <id>http://QQ876684433.github.io/2019/09/04/63-不同路径II/</id>
    <published>2019-09-04T13:20:26.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="63-不同路径II"><a href="#63-不同路径II" class="headerlink" title="63.不同路径II"></a>63.不同路径II</h1><p>原题目如下：</p><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:</p><p>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]</p><p>输出: 2</p><p>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">&gt; 2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-ii</a><br>著作权归领扣网络所有。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题与<a href="https://chph.xyz/2019/09/04/62-不同路径/" target="_blank" rel="noopener">前一道题</a>的区别只在于输入的二维数组增加了障碍物这一限制条件，只要在之前的思路（详见前面的链接）上稍作修改即可，用m和n分别表示输入的数组的行和列，我自己当时的解题思路如下：</p><ul><li>采用自底向上的递推方式，还是采用一位数组来降低空间开销，将dp数组初始化为包含m个元素的数组，然后将最后一个元素设置为1，原因是从最底层走，不考虑障碍物的情况下，只有一条路径能够到达目的地（<em>后来发现出现的问题就是，如果目的地就是障碍物的话，这样是无法AC的，所以在开始推导的最开始直接排除了这种情况<code>if(obstacleGrid[m-1][n-1]==1) return 0;</code>，省事</em>）</li><li>推导的核心公式是<code>dp[j] = dp[j]+dp[j+1];</code>，所以存在边界的问题，因此限定<code>0 ≤ j ≤ m-2</code>，而<code>j = m-1</code>的情况（即最底层）单独判断：如果在点<code>obstacleGrid[m-1][i]</code>遇到障碍物，则将dp数组的最后一个元素设置为0，表示从最底层小于等于点i的开始走，必然无法走到目的地</li><li>如果不是在最底层遇到障碍物（设为点<code>obstacleGrid[j][i]</code>），则只需要将<code>dp[j]</code>设置为0，表示从该点开始走，无法走到目的地，对其他路径的贡献为0</li></ul><p>所以最终的解决方案如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.size(), n = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>]==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; dp(m<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        dp.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[m<span class="number">-1</span>][i]==<span class="number">1</span>)&#123;</span><br><span class="line">                dp[m<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = m<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[j][i]==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = dp[j]+dp[j+<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提交之后，虽然AC了，但是感觉有点不够优雅：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/04/3RYpKZCPfHU4bDE.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><u><em>ps：这里有个坑是大数组的输入，如果使用<code>vector&lt;int&gt;</code>会溢出，改用<code>vector&lt;long&gt;</code>就可以了，这个也是没办法的</em></u></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>学习了leetcode官方的题解后发现自己的思路局限在了自底向上的角度，实际上自顶向下和自底向上最终的 结果是一样的，但使用自顶向下似乎更有助于思考问题。</p><p>最关键的问题还是集中在遇到障碍物时采取的措施上，因为题目没有要求输入数据不能修改，可以直接使用obstacleGrid作为dp数组，达到最优化空间复杂度，这样dp递推方程就变成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>而当<code>obstacleGrid[i][j]</code>是障碍物时，可直接将其置0：</p><blockquote><p>如果这个点有障碍物，设值为 <code>0</code> ，这可以保证不会对后面的路径产生贡献。</p></blockquote><p>这个可以体现在上面的递推方程上。即使是这样，还是避免不了边界条件的处理，这里就不展开了。</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>归根结底，解法不优雅的根源是边界问题的处理，所以也可以通过在原有的数组行列上各添加一维全0的数据，这样就比较优雅了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;63-不同路径II&quot;&gt;&lt;a href=&quot;#63-不同路径II&quot; class=&quot;headerlink&quot; title=&quot;63.不同路径II&quot;&gt;&lt;/a&gt;63.不同路径II&lt;/h1&gt;&lt;p&gt;原题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>62.不同路径</title>
    <link href="http://QQ876684433.github.io/2019/09/04/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
    <id>http://QQ876684433.github.io/2019/09/04/62-不同路径/</id>
    <published>2019-09-04T11:37:53.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h1><p>原题目如下：</p><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>说明：m 和 n 的值均不超过 100。</p><p>示例 1:</p><p>输入: m = 3, n = 2</p><p>输出: 3</p><p>解释:<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向右 -&gt; 向下</li><li>向右 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向右</li></ol><p>示例 2:</p><p>输入: m = 7, n = 3</p><p>输出: 28</p><p>来源：力扣（LeetCode）</p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题一看就是很典型的动态规划问题，一般来说都可以从填表入手，动态规划方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>所以可以从初始状态开始（即finish处开始）推导填表，最后得到的就是问题的解。举个简单的例子，m=7，n=3（其实m和n是可以互换的对结果没有影响）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/04/VC6Ub3IFT95xPNg.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这样就可以通过一个二维数组来解决问题。一般来说二维数组开销太大，而且往往都能够通过压缩成一维数组来解决，因为<code>dp[i][j]</code>计算出来之后，<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>的值就不再需要了，所以最终的解答如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(m, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">                dp[j] = dp[j]+dp[j<span class="number">-1</span>];</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一次AC，惊喜满满：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/04/BDZc7A9of1GuiNS.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题解给出的方案和我的差不多，这里就没必要展开了，但是里面提供了一个数学角度的解决方案：</p><blockquote><p>思路：排列组合</p><p>因为机器到底右下角，向下几步，向右几步都是固定的，</p><p>比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。</p><p>所以有 C_{m+n-2}^{m-1}C<br>m+n−2<br>m−1</p><p>作者：powcai</p><p>链接：<a href="https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/</a></p><p>来源：力扣（LeetCode）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;62-不同路径&quot;&gt;&lt;a href=&quot;#62-不同路径&quot; class=&quot;headerlink&quot; title=&quot;62.不同路径&quot;&gt;&lt;/a&gt;62.不同路径&lt;/h1&gt;&lt;p&gt;原题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个机器人位于一个 m x n 网格的左上角 
      
    
    </summary>
    
      <category term="算法" scheme="http://QQ876684433.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://QQ876684433.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="leetcode" scheme="http://QQ876684433.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>数据库课堂笔记（2019-09-03）</title>
    <link href="http://QQ876684433.github.io/2019/09/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0%EF%BC%882019-09-03%EF%BC%89/"/>
    <id>http://QQ876684433.github.io/2019/09/03/数据库课堂笔记（2019-09-03）/</id>
    <published>2019-09-03T11:53:37.000Z</published>
    <updated>2019-09-15T05:02:14.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库课堂笔记"><a href="#数据库课堂笔记" class="headerlink" title="数据库课堂笔记"></a>数据库课堂笔记</h1><blockquote><p>参考资料：</p><ul><li>南大软件学院课程《数据管理基础》课程资料</li><li>《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著</li><li>《数据库系统概论》第五版 - 王珊 萨师煊 著</li><li>《数据库系统概念》</li></ul></blockquote><h2 id="数据库课堂笔记（2019-09-03）"><a href="#数据库课堂笔记（2019-09-03）" class="headerlink" title="数据库课堂笔记（2019-09-03）"></a>数据库课堂笔记（2019-09-03）</h2><h3 id="Ch1-Introduction"><a href="#Ch1-Introduction" class="headerlink" title="Ch1. Introduction"></a>Ch1. Introduction</h3><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li><p>数据库管理系统（DataBase Management System，DBMS）</p><p>Connolly and Begg define Database Management System (DBMS) as a “<strong>software system that enables users to define, create, maintain and control access to the database</strong>“. … <strong>The core functionality is the storage, retrieval and update of data</strong>.</p><blockquote><p>The <a href="https://en.wikipedia.org/wiki/Database#Database_management_system" target="_blank" rel="noopener">database management system</a> (DBMS) is the <a href="https://en.wikipedia.org/wiki/Software" target="_blank" rel="noopener">software</a> that interacts with <a href="https://en.wikipedia.org/wiki/End_user" target="_blank" rel="noopener">end users</a>, applications, and the database itself to capture and analyze the data.</p><p>—— from wikipedia</p></blockquote><p>简单理解就是，数据库管理系统是终端用户、应用程序同数据库本身交互的软件</p></li><li><p>数据库（Database）</p><blockquote><p>A <strong>database</strong> is an organized collection of <a href="https://en.wikipedia.org/wiki/Data_(computing)" target="_blank" rel="noopener">data</a>, generally stored and accessed electronically from a computer system. Where databases are more complex they are often developed using formal <a href="https://en.wikipedia.org/wiki/Database#Design_and_modeling" target="_blank" rel="noopener">design and modeling</a> techniques.</p><p>—— from wikipedia</p></blockquote><p>简单理解就是，数据库是一个有组织的数据集合</p></li><li><p>数据库用户（DataBase User）</p><ul><li><p>最终用户——交互式用户</p><ul><li>临时用户——用SQL访问DBMS的用户</li><li>初级用户——通过菜单访问DBMS的用户</li></ul></li><li><p>应用程序员——编写菜单程序的程序员</p></li><li><p>数据库管理员（Database Administrator，DBA）——管理DBMS的专家</p><p><img src="https://i.loli.net/2019/09/03/EOwYuHP6gxaQci4.png" alt></p></li></ul></li></ul><h3 id="数据库系统的架构"><a href="#数据库系统的架构" class="headerlink" title="数据库系统的架构"></a>数据库系统的架构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/03/LPcK7sEfn54vDgG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>主要有<strong>两层C/S架构</strong>和<strong>三层B/S架构</strong>两种：</p><ul><li><p>两层C/S架构：数据库和DBMS运行在数据库服务器，数据库应用程序运行在客户机中，两者之间通过局域网实现数据访问（<em>但是更多的时候， 数据库服务器及其应用程序可能分布在距</em><br><em>离遥远的不同地方，这是得使用三层B/S架构来解决</em>）</p><p><img src="https://i.loli.net/2019/09/03/mv7GcaV85YwBzZp.png" alt></p></li><li><p>三层B/S架构：数据库和DBMS运行在数据库服务器中，<br>数据库应用程序运行在应用服务器（也称“Web服务器”）<br>中， 用户客户端只需要安装常用的浏览器， 负责接收用户<br>输入和结果展示</p><p><img src="https://i.loli.net/2019/09/03/NUSipYC8havWjgk.png" alt></p></li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>数据模型（data model）是对现实世界数据特征的抽象，它是数据库系统的核心和基础。根据应用的不同目的可以划分为两大类：第一类是概念模型，第二类是逻辑模型和物理模型。</p><ul><li>概念模型：按用户的观点来对数据和信息进行建模，主要用于数据库设计</li><li>逻辑模型：按计算机系统的观点对数据建模，主要用于数据库管理系统的实现</li><li>物理模型：对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法</li></ul><h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><ul><li>实体（entity）：客观存在并可互相区别的事物</li><li>属性（attribute）：实体所具有的某一特性</li><li>码（key）：唯一标识实体的属性集</li><li>实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体</li><li>实体集（entity set）：同一类型实体的集合</li><li>联系（relationship）：实体之间的联系通常是指不同实体集之间的联系，具有一对一、一对多和多对多等多种类型</li></ul><p>概念模型的表示方法：实体-联系方法（Entity-Relationship approach），E-R方法也称为E-R模型</p><p>数据模型的组成要素：</p><ul><li>数据结构：数据库的组成对象以及对象之间的联系</li><li>数据操作：对数据库汇总各种对象的实例运行执行的操作的集合，包括操作以及有关的操作规则</li><li>数据的完整性约束条件：一组完整性规则</li></ul><h4 id="常见的数据模型"><a href="#常见的数据模型" class="headerlink" title="常见的数据模型"></a>常见的数据模型</h4><h5 id="层次数据模型（Hierarchical-Data-Model-）"><a href="#层次数据模型（Hierarchical-Data-Model-）" class="headerlink" title="层次数据模型（Hierarchical Data Model ）"></a>层次数据模型（Hierarchical Data Model ）</h5><p>满足两个条件：</p><ul><li>有且只有一个结点没有双亲结点，这个结点称为根结点</li><li>根以外的其他结点有且只有一个双亲结点</li></ul><p>层次模型中，每个结点表示一个记录类型，记录类型之间的联系用结点之间的有向边表示，这种联系是父子之间的一对多的联系，可以看做有向树结构</p><h5 id="网状数据模型（Network-Data-Model）"><a href="#网状数据模型（Network-Data-Model）" class="headerlink" title="网状数据模型（Network Data Model）"></a>网状数据模型（Network Data Model）</h5><p>满足两个条件：</p><ul><li>允许一个以上的结点无双亲</li><li>一个结点可以有多于一个的双亲</li></ul><p>层次模型中子女结点与双亲结点的关系是唯一的，在网状模型中，这种关系可以不唯一</p><h5 id="关系模型（Relational-Model）"><a href="#关系模型（Relational-Model）" class="headerlink" title="关系模型（Relational Model）"></a>关系模型（Relational Model）</h5><p>从用户的观点看，关系模型由一组关系组成，每个关系的数据结构都是一张规范化的二维表：</p><ul><li>关系：一个关系对应通常说的一张表</li><li>元组：表中的一行即为一个元组</li><li>属性：表中的一列即为一个属性</li><li>码：也称为码键，它是表中的某个属性组，可以唯一确定一个元组</li><li>域：域是一组具有相同数据类型的值集合，属性的取值范围来自某个域</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述，通常表示为<code>关系名(属性1，属性2，属性3，...，属性n)</code></li></ul><h5 id="面向对象模型（Object-Oriented-Model）"><a href="#面向对象模型（Object-Oriented-Model）" class="headerlink" title="面向对象模型（Object-Oriented Model）"></a>面向对象模型（Object-Oriented Model）</h5><h5 id="对象关系模型（Object-Relational-Model）"><a href="#对象关系模型（Object-Relational-Model）" class="headerlink" title="对象关系模型（Object-Relational Model）"></a>对象关系模型（Object-Relational Model）</h5><h3 id="Ch2-The-Relational-Model"><a href="#Ch2-The-Relational-Model" class="headerlink" title="Ch2. The Relational Model"></a>Ch2. The Relational Model</h3><h4 id="CAP数据库"><a href="#CAP数据库" class="headerlink" title="CAP数据库"></a>CAP数据库</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/iuv9bsDBzYrlxfH.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/iWSvPMBGA8Ugund.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/zhZUMOiyYNAvbCG.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/HjTJYBkUtcneDRm.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h4><ul><li><p><strong>数据模型（Data Model）</strong>：也称为数据库模型</p><ul><li>它是一组描述如何用计算机化的信息表示现实世界中的数据的定义</li><li>也描述了<strong>访问</strong>和<strong>更新</strong>这些信息的操作类型</li></ul></li><li><p><strong>数据库（Database）</strong>：<strong>表（Table）</strong>，或者说<strong>关系（Relation）</strong>的集合</p></li><li><p><strong>表的标题（Table Heading）</strong>：表的<strong>列名（Column Name）</strong>集合，又称为<strong>模式（Scheme）</strong></p><p><img src="https://i.loli.net/2019/09/06/I9yhKi46BRAufOP.png" alt></p></li><li><p>表的<strong>行（Row）</strong>集合：也就是<strong>元组（Tuple）</strong>的集合，称为表的内容，表的行数称为表的基数</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/06/FP2NDfJ3zABGlWc.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="数据库各部分的命名"><a href="#数据库各部分的命名" class="headerlink" title="数据库各部分的命名"></a>数据库各部分的命名</h4><p>由于数据库的行是经常改变的，而列通常来说不会改变，一般推荐数据库用户使用列来进行数据库查询</p><h5 id="程序数据独立性（Program-Data-Independence-）"><a href="#程序数据独立性（Program-Data-Independence-）" class="headerlink" title="程序数据独立性（Program-Data Independence ）"></a>程序数据独立性（Program-Data Independence ）</h5><blockquote><p>when asked to make up a query to answer a<br>question, query must still answer the<br>question even if all the data changes.</p></blockquote><p>查询语句和表的数据无关，二者是相互独立的，即使数据库中的表数据改变了，原有的查询依然能够执行（但是查询结果可能发生了改变）</p><h5 id="域类型（Column-type，也称-Domain和-Datatype）"><a href="#域类型（Column-type，也称-Domain和-Datatype）" class="headerlink" title="域类型（Column type，也称 Domain和 Datatype）"></a>域类型（Column type，也称 Domain和 Datatype）</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/06/4NQEAOFYoPzXt8a.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>大多数商业数据库系统都不支持有枚举集组成的类型（如city，month等），它体现了数据库的<strong>完整性约束（Integrity）</strong></p><blockquote><p><strong>域完整性（Domain Integrity）</strong><br>域完整性是指保证指定列的数据具有正确的数据类型、格式和有效的数据范围。</p></blockquote></li><li><p><strong>particular type</strong></p><p>例子：Domain(city in CUSTOMERS) vs<br>Domain(city in AGENTS) ?</p><p><img src="https://i.loli.net/2019/09/06/3IUhzBc2NtJkwag.png" alt></p><p><img src="https://i.loli.net/2019/09/06/2RnTzvfjHdbMVZA.png" alt></p></li></ul><h5 id="关系代数（Relational-Algebra-）"><a href="#关系代数（Relational-Algebra-）" class="headerlink" title="关系代数（Relational Algebra ）"></a>关系代数（Relational Algebra ）</h5><p>数据表中的列的域类似于大多数编程语言中的枚举类型</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/06/zF83mwJsyaNvYHM.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/06/xueCP3KHmVn4cIr.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h5><p>数学上的笛卡尔积定义：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/11/XHPZu8mCs9biJfL.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>但是数据表的关系——即行的集合并没有包含数据表所有列的笛卡尔积中的所有元素，一般来说有如下关系：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/11/O9k6jhLcb1sXWPz.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="关系规则"><a href="#关系规则" class="headerlink" title="关系规则"></a>关系规则</h4><p><strong>数据库范式（Database Normalization）</strong>：一张数据表的表结构所符合的某种设计标准的级别。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。</p><p>数据库三大范式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/11/ov6eLOjT4EaNVci.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="第一范式（1NF）：First-Normal-Form-Rule"><a href="#第一范式（1NF）：First-Normal-Form-Rule" class="headerlink" title="第一范式（1NF）：First Normal Form Rule"></a>第一范式（1NF）：First Normal Form Rule</h5><p>数据表的列不允许有多值属性（重复的域）或者属性具有内部结构，也就是说要求列属性是原子的。</p><blockquote><p>columns that have multi-valued attributes (repeating fields) or have any internal structure (record) are not permitted</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/11/DCoqxLYdlN8Wcmj.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>以这个数据表为例，<code>name</code>具有内部结构，<code>enrollment</code>是多值属性（重复的域）（<em>实际上enrollment也具有内部结构</em>）</p><p>它有两方面的含义：</p><ul><li><p>多值属性（重复的域）意思是某个属性的取值是某些元素的列表或者集合，例如第一行中的enrollment属性取值是((101, No), (108, Yes))，它是元素(cno, major)的列表或集合，解决方法有三种：</p><ul><li>将多值属性拆分成多个属性 -&gt;（<strong>浪费空间并使得查询变得困难</strong>）</li><li>将具有多值属性的行（元组），按照多值属性的值集合拆分成多个行（元组）来表示，新的元组不再包含多值属性，这些元组在该属性的取值的集合等于原多值属性取值 -&gt; （<strong>包含大量冗余数据，浪费空间</strong>）</li><li>将多值属性和其他属性分拆到两个不同的表中，通过表的join运算来获得原数据表 -&gt;（<strong>最常用的操作</strong>）</li></ul></li><li><p>内部结构意思是某个属性的取值不是原子的，或者是不是基本类型，例如name属性具有内部结构(name.Iname, name.fname)，解决方法是：</p><p><img src="https://i.loli.net/2019/09/11/IHocynCRgkUAuMe.png" alt></p></li></ul><p><em>ps：第一范式规则被对象-关系数据库系统的数据表打破，这些表是非第一范式（NFNF）。</em></p><h5 id="第二范式（2NF）：Access-Rows-by-Content-Only-Rule"><a href="#第二范式（2NF）：Access-Rows-by-Content-Only-Rule" class="headerlink" title="第二范式（2NF）：Access Rows by Content Only Rule"></a>第二范式（2NF）：Access Rows by Content Only Rule</h5><p>只能基于内容存取行的规则，说明我们只可以通过行的内容即每一行中所存在的属性值来检索列</p><blockquote><p>can only retrieve rows by their content, the attribute values that exist in each row.</p></blockquote><p>它暗示了：</p><ul><li><p>行是无序的：即使用行号来访问数据表中指定行是无意义的</p><p><img src="https://i.loli.net/2019/09/15/2YerOAFicub759g.png" alt></p></li><li><p><strong>列是无序的</strong>：2NF中没有指明需要根据一定的属性次序来访问指定行</p></li></ul><p><em>ps：大多数的关系型数据库产品打破了这条规则，允许用户通过RID-row ID来访问行；而且新的对象-关系数据库产品有<code>refs</code>语法允许某一行上列值指向另一行。</em></p><h5 id="第三范式（3NF）：The-Unique-Row-Rule"><a href="#第三范式（3NF）：The-Unique-Row-Rule" class="headerlink" title="第三范式（3NF）：The Unique Row Rule"></a>第三范式（3NF）：The Unique Row Rule</h5><p>行唯一性规则，它要求关系中任何两个元组的值在同一时刻不能是完全相同的，也就是说<strong>关系是元组的无序集合</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/njuJqea9ZcNTSfA.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/09/15/TbAfJF4jM5exQk6.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库课堂笔记&quot;&gt;&lt;a href=&quot;#数据库课堂笔记&quot; class=&quot;headerlink&quot; title=&quot;数据库课堂笔记&quot;&gt;&lt;/a&gt;数据库课堂笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;南大软件学院课程《数据管理基础》课程
      
    
    </summary>
    
      <category term="数据库" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据库" scheme="http://QQ876684433.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C-深入理解ConcurrentHashMap原理</title>
    <link href="http://QQ876684433.github.io/2019/08/09/J-U-C-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ConcurrentHashMap%E5%8E%9F%E7%90%86/"/>
    <id>http://QQ876684433.github.io/2019/08/09/J-U-C-深入理解ConcurrentHashMap原理/</id>
    <published>2019-08-09T04:21:56.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解红黑树</title>
    <link href="http://QQ876684433.github.io/2019/08/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://QQ876684433.github.io/2019/08/09/深入理解红黑树/</id>
    <published>2019-08-09T04:20:24.000Z</published>
    <updated>2019-09-15T05:02:14.666Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java NIO学习笔记</title>
    <link href="http://QQ876684433.github.io/2019/07/25/Java%20NIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://QQ876684433.github.io/2019/07/25/Java NIO学习笔记/</id>
    <published>2019-07-25T12:51:09.000Z</published>
    <updated>2019-09-15T05:02:14.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO学习笔记"><a href="#Java-NIO学习笔记" class="headerlink" title="Java NIO学习笔记"></a>Java NIO学习笔记</h1><blockquote><p>参考资料：<a href="https://nio.hacktons.cn/java-nio-tutorial.html" target="_blank" rel="noopener">https://nio.hacktons.cn/java-nio-tutorial.html</a></p><p>本文是上述有关Java NIO资料的学习笔记</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-NIO学习笔记&quot;&gt;&lt;a href=&quot;#Java-NIO学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Java NIO学习笔记&quot;&gt;&lt;/a&gt;Java NIO学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="笔记" scheme="http://QQ876684433.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="NIO" scheme="http://QQ876684433.github.io/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统基础</title>
    <link href="http://QQ876684433.github.io/2019/07/25/Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>http://QQ876684433.github.io/2019/07/25/Linux系统基础/</id>
    <published>2019-07-25T01:34:24.000Z</published>
    <updated>2019-09-15T05:02:14.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux系统基础"><a href="#Linux系统基础" class="headerlink" title="Linux系统基础"></a>Linux系统基础</h1><blockquote><p>此文章是根据南大软院曾老师的《Linux系统基础》课程ppt的学习笔记整理</p></blockquote><p><strong>推荐：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a> ，关于Linux命令大全的实用网站</strong></p><h2 id="认识Linux系统"><a href="#认识Linux系统" class="headerlink" title="认识Linux系统"></a>认识Linux系统</h2><h3 id="Linux系统的组成"><a href="#Linux系统的组成" class="headerlink" title="Linux系统的组成"></a>Linux系统的组成</h3><p>Linux系统一般有4个主要部分：内核、Shell、文件系统 和 应用程序</p><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>内核是操作系统的核心，Linux内核的主要模块包括：存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等几个部分</p><h4 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h4><p>Shell是系统的用户界面，提供了<strong>用户</strong>与<strong>内核</strong>进行交互操作的一种接口，它接收用户输入的命令并把它送入内核去执行</p><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>文件系统是文件存放在磁盘等存储设备上的组织方法，Linux系统能支持多种目前流行的文件系统，如ext3、 ext4、 FAT、 FAT32、VFAT和ISO9660等</p><h4 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h4><p>包括文本编辑器、编程语言、 X Window、办公软件、 Internet工具和数据库等的程序集</p><h3 id="Linux系统与Windows系统的比较"><a href="#Linux系统与Windows系统的比较" class="headerlink" title="Linux系统与Windows系统的比较"></a>Linux系统与Windows系统的比较</h3><h4 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h4><ul><li><p>多用户操作系统</p><blockquote><p>​    这里补充一点，摘录自<a href="https://blog.csdn.net/yangkuiwu/article/details/53224239" target="_blank" rel="noopener">https://blog.csdn.net/yangkuiwu/article/details/53224239</a></p><p>​    1.<strong>单用户、多用户</strong>。根据在同一时间使用计算机用户的多少，操作系统可分为单用户操作系统和多用户操作系统。单用户操作系统是指一台计算机在同一时间只能由一个用户使用，*<u>一个用户独自享用系统的全部硬件和软件资源</u>，*而如果在同一时间允许多个用户同时使用计算机，则称为多用户操作系统。</p><p>​    2.<strong>单任务、多任务</strong>。用户在同一时间可以运行多个应用程序（每个应用程序被称作一个任务），则这样的操作系统被称为多任务操作系统。如果一个用户在同一时间只能运行一个应用程序，则对应的操作系统称为单任务操作系统。</p><p>​    现代操作系统一般属于多用户、多任务的操作系统，也就是说，同一台机器可以为多个用户建立各自的账户，也允许拥有这些账户的用户同时登录这台计算机，每个账号可以同时运行多个程序。</p><p>​    多个用户能够同时访问和使用同一台计算机，其中的一个用户具有管理所有这些用户账户和整个计算机的资源的权限，在Windows上，这个具有管理其他用户和计算机资源的用户一般叫administrator，而在Linux上一般叫做root。</p><p>​    个人计算机操作系统早期一般都是单用户操作系统，其主要特点是在某一时间为单个用户服务。早期的DOS操作系统是单用户单任务操作系统，Windows XP则是单用户多任务操作系统。Linux、UNIX是多用户多任务操作系统。现在常用的Windows操作系统都是多用户、多任务的操作系统，使用最广泛的win7，win10都是多用户，多任务操作系统。</p></blockquote></li><li><p>支持多种文件系统</p></li><li><p>支持多种端口和设备</p></li><li><p>支持联网功能</p></li><li><p>服务</p></li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/25/5d390b6c0f41545469.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>总结一下，Linux独有的特点如下：</p><ul><li>定位于网络操作系统，Linux的系统配置文件和数据都以文本为基础</li><li>可选图形化界面</li><li>Linux系统不使用文件扩展名来识别文件的类型，而是使用文件的头内容来识别其类型</li><li>除了Linux内核，其他软件的安装、启动、停止和重新配置都不用重新引导系统（即不需要重启）</li><li>Linux系统下的命令、文件和口令等都区分大小写</li></ul><h3 id="Linux版本"><a href="#Linux版本" class="headerlink" title="Linux版本"></a>Linux版本</h3><p>Linux的版本号分为两部分，即<strong>内核版本</strong>与<strong>发行版本</strong></p><h4 id="Linux内核版本"><a href="#Linux内核版本" class="headerlink" title="Linux内核版本"></a>Linux内核版本</h4><p>内核版本号由3个数字组成： r.x.y</p><ul><li>r：目前发布的内核主版本。</li><li>x：偶数表示稳定版本；奇数表示开发版本。</li><li>y：错误修补的次数。</li></ul><h4 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a>Linux发行版本</h4><p>一些组织和厂家，将Linux系统的内核、应用软件和文档包装起来，并提供一些系统安装界面、系统配置设定管理工具，就构成了Linux发行版本最著名的便是<strong>Red Hat公司开发的Red Hat系列</strong>以及<strong>社区组织开发的Debian系列发行版本</strong></p><h2 id="Linux系统的安装与删除"><a href="#Linux系统的安装与删除" class="headerlink" title="Linux系统的安装与删除"></a>Linux系统的安装与删除</h2><h3 id="Linux系统下硬盘的基本知识"><a href="#Linux系统下硬盘的基本知识" class="headerlink" title="Linux系统下硬盘的基本知识"></a>Linux系统下硬盘的基本知识</h3><h4 id="分区命名方案"><a href="#分区命名方案" class="headerlink" title="分区命名方案"></a>分区命名方案</h4><p>Linux系统使用<strong>字母和数字的组合</strong>来指代硬盘分区，命名方案是<strong>基于文件</strong>的，文件名的格式为/dev/xxyN</p><ul><li>/dev/：这是Linux系统下<strong>所有设备文件</strong>所在的目录名。</li><li>xx：分区名的前两个字母表示分区所在设备的类型，通常是hd（ IDE硬盘）或sd（ SCSI硬盘）。</li><li>y：这个字母表示分区<strong>所在的设备</strong>。</li><li>N：最后的数字N代表分区。</li></ul><p>例如：/dev/sda1表示这个分区在sd类型的设备上，如果有多个sd类型设备，那么该分区是在编号为a的设备上的分区1中</p><h4 id="磁盘分区和挂载目录"><a href="#磁盘分区和挂载目录" class="headerlink" title="磁盘分区和挂载目录"></a>磁盘分区和挂载目录</h4><p>分区是Linux系统上一组文件和目录的存储区，它通过挂载来实现，<strong>挂载</strong>是<strong>将分区关联到某一目录的过程</strong>，挂载分区使起始于这个指定目录（通称为挂载目录）的存储区能够被使用</p><ul><li>/boot分区：用来存放与Linux系统启动有关的程序，比如启动引导装载程序等</li><li>/usr分区：用来存放Linux系统中的应用程序</li><li>/var分区：用来存放Linux系统中经常变化的数据以及日志文件</li><li>/分区： Linux系统的根目录，所有的目录都挂在这个目录下面</li><li>SWAP分区：实现虚拟内存</li><li>/home分区：存放普通用户的数据，是普通用户的宿主目录</li></ul><h2 id="Linux字符界面操作"><a href="#Linux字符界面操作" class="headerlink" title="Linux字符界面操作"></a>Linux字符界面操作</h2><p>命令行界面可以通过字符界面、图形界面下的终端以及虚拟控制台等多种方式进入</p><h3 id="字符界面"><a href="#字符界面" class="headerlink" title="字符界面"></a>字符界面</h3><p>很多Linux发行版系统启动默认进入的是图形化界面，可以通过如下指令修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf</span><br></pre></td></tr></table></figure><p>重启后生效，默认进入字符界面，进入字符界面后，超级用户登录后提示符是“ #”，而其他用户登录后提示符是“ $”</p><h3 id="虚拟控制台"><a href="#虚拟控制台" class="headerlink" title="虚拟控制台"></a>虚拟控制台</h3><p>Linux系统提供了虚拟控制台的访问方式使得允许多个用户同时登录，还允许用户进行多次登录</p><ul><li>在<strong>字符界面</strong>下，虚拟控制台的切换可以通过按下[Alt+ F1]~ [Alt+ F6]键来实现</li><li>在<strong>图形界面</strong>下，可以使用[Ctrl+Alt+F2]~[Ctrl+Alt+F6]键切换不同的字符虚拟控制台，再使用[Ctrl+Alt+F1]可以切换回图形界面</li></ul><h3 id="关闭和重启系统"><a href="#关闭和重启系统" class="headerlink" title="关闭和重启系统"></a>关闭和重启系统</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><blockquote><p>参考原文：<a href="https://blog.csdn.net/xmc281141947/article/details/61191212" target="_blank" rel="noopener">https://blog.csdn.net/xmc281141947/article/details/61191212</a> </p></blockquote><p>在Linux中可以用Shutdown命令实现自动定时关机的功能，它在Linux系统关闭之前给系统上的所有登录用户提示一条警告信息</p><p>命令语法：shutdown [选项] [时间] [警告信息]</p><ul><li>-h 关闭计算机</li><li>-r 重启计算机</li><li>-c 取消正在等待的shutdown命令</li></ul><p><strong>精确时间</strong>的格式是hh:mm，表示小时和分钟。<br><strong>时间段（延迟）</strong>由“+” 和“分钟数”表示。<br>系统执行该命令后会自动进行数据同步的工作。时间部分如果是<code>now</code>，则上述命令则立即执行，否则延迟默认60s或者设定的时间</p><p>具体例子：</p><p>1、Shutdown -r now 关机后重启</p><p>2、Shutdown -h now 关机后不重启</p><p>3、Shutdown -r +11 11分钟后重启</p><p>4、Shutdown -r 11:00 11点钟重启</p><p>5、Shutdown -h +11 11分钟后关机</p><p>6、Shutdown -h 11:00 11点钟关机</p><h4 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h4><p>“ halt” 命令就是调用“ shutdown<br>–h”命令执行关闭系统，它是立即执行</p><h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><p>“reboot”命令就是调用“shutdown -r”命令来重启系统，它是立即执行</p><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p>“ init” 命令是所有进程的祖先，它的进程号始终为“ 1” ，所以发送“ TERM” 信号给“ init” 会终止所有的用户进程和守护进程等。“ shutdown” 命令就是使用这种机制。“init”定义了7个运行级别：</p><ul><li>0    Halt    Shuts down the system.</li><li>1    Single-user mode    Mode for administrative tasks.（注意这里，说明系统返回的shell有root权限）</li><li>2    Multi-user mode    Does not configure network interfaces and does not export networks services.</li><li>3    Multi-user mode with networking    Starts the system normally.</li><li><u>4    Not used/user-definable    For special purposes.</u></li><li>5    Start the system normally with appropriate display manager (with GUI)    Same as runlevel 3 + display manager.</li><li>6    Reboot    Reboots the system.</li></ul><h3 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h3><p>Linux系统的运行级别由列在/etc/rc.d/rc&lt;x&gt;.d目录中的服务来定义，其中&lt;x&gt;是代表运行级别的符号，七种运行级别的定义如下：</p><ul><li>0：停止运行，所有进程中止，关闭系统。</li><li>1：单用户模式，用于维护系统，只有少数进程运行。</li><li>2：多用户模式，除了NFS服务没有启动外，其他和运行级别3一样。</li><li><strong>3：完整的多用户模式，进入Linux系统的字符界面。</strong></li><li>4：没有使用（可由用户定义）。</li><li><strong>5：完整的多用户模式（带有基于X Window的图形界面）。</strong></li><li>6：重新引导计算机。</li></ul><p>可以在使用<code>runlevel</code>命令查看当前的运行级别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~$ runlevel </span><br><span class="line">N 5</span><br></pre></td></tr></table></figure><p>表示当前运行级别是5，N表示没有上一次运行级别</p><h3 id="其他一些常用命令"><a href="#其他一些常用命令" class="headerlink" title="其他一些常用命令"></a>其他一些常用命令</h3><h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p>获取shell命令的帮助手册，命令语法：man [选项] [命令名称]</p><h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><p>可以通过help来获取shell命令的用法，命令语法：[命令] ––help</p><h4 id="which-whereis-locate-find"><a href="#which-whereis-locate-find" class="headerlink" title="which, whereis, locate, find"></a>which, whereis, locate, find</h4><blockquote><p>来源：<a href="https://zhuanlan.zhihu.com/p/35727707" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35727707</a></p></blockquote><ul><li><strong>which</strong>：常用于查找<strong>可直接执行的命令</strong>。只能查找可执行文件，该命令基本<strong>只在$PATH路径中搜索</strong>，查找范围最小，查找速度快。<strong>默认只返回第一个匹配的文件路径</strong>，通过选项 <em>-a</em> 可以返回所有匹配结果。</li><li><strong>whereis</strong>：不只可以查找命令，其他文件类型都可以（man中说只能查命令、源文件和man文件，实际测试可以查大多数文件）。在$PATH路径基础上增加了一些系统目录的查找，查找范围比which稍大，查找速度快。<u>可以通过 <em>-b</em> 选项，限定只搜索二进制文件</u>。</li><li><strong>locate</strong>：超快速查找任意文件。它会<strong>从linux内置的索引数据库查找文件的路径</strong>，索引速度超快。刚刚新建的文件可能需要一定时间才能加入该索引数据库，可以通过执行updatedb命令来强制更新一次索引，这样确保不会遗漏文件。该命令通常会返回大量匹配项，可以<strong>使用 <em>-r</em> 选项通过正则表达式来精确匹配</strong>。</li><li><strong>find</strong>：直接搜索整个文件目录，<strong>默认直接从根目录开始搜索</strong>，建议在以上命令都无法解决问题时才用它，功能最强大但速度超慢。除非你指定一个很小的搜索范围。通过 <em>-name</em> 选项指定要查找的文件名，支持通配符。</li></ul><h3 id="Shell基础"><a href="#Shell基础" class="headerlink" title="Shell基础"></a>Shell基础</h3><p>通俗地讲，Shell就是位于内核和操作者之间的一层使用者界面。一个Shell命令可能含有一些可选项和参数，其一般格式为：[Shell命令] [可选项] [参数]。目前流行的Shell有sh， csh， ksh， tcsh<br>和bash等。</p><h4 id="开始使用bash"><a href="#开始使用bash" class="headerlink" title="开始使用bash"></a>开始使用bash</h4><p>Shell命令可分为如下两大类：</p><p>（1） bash内置的命令</p><p>（2）应用程序</p><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/25/5d39652fb49c266836.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="特殊字符和引号"><a href="#特殊字符和引号" class="headerlink" title="特殊字符和引号"></a>特殊字符和引号</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/25/5d3964b167a0847483.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="常用控制组合键"><a href="#常用控制组合键" class="headerlink" title="常用控制组合键"></a>常用控制组合键</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/25/5d39656a7607c78493.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>说明：</p><ul><li>&amp; 使命令在后台运行，不阻塞当前控制台</li><li>CTRL+Z停止进程并放入后台</li><li>jobs 显示当前暂停的进程</li><li>bg %N 使第N个任务在后台运行（%前有空格）（<u>好像也会阻塞控制台？不太懂，在Ubuntu17.10上测试就是，bg执行后，控制台也被占用，但可以使用Ctr+S和Ctr+Q来暂停和恢复屏幕输出</u>）</li><li>fg %N 使第N个任务在前台运行，阻塞当前控制台</li><li>默认bg，fg不带%N时表示对最后一个进程操作！</li><li>Ctr+U是清空当前输入的命令行</li></ul><p>补充：</p><ul><li>控制台可以使用Ctr+Shift+C/V来执行复制粘贴功能</li></ul><h3 id="Shell实用功能"><a href="#Shell实用功能" class="headerlink" title="Shell实用功能"></a>Shell实用功能</h3><h4 id="命令的排列"><a href="#命令的排列" class="headerlink" title="命令的排列"></a>命令的排列</h4><p>如果希望一次执行多个命令， Shell允许在不同的命令之间，放上特殊的排列字符</p><ul><li><p>使用“; ”</p><p>使用“; ”命令时先执行命令1，不管命令1是否出错，接下来就执行命令2。<strong>命令语法：命令1; 命令2</strong></p></li><li><p>使用“ &amp;&amp;”</p><p>使用“ &amp;&amp;”命令时<strong>只有当命令1正确运行完毕</strong>后，才能执行命令2。<strong>命令语法：命令1&amp;&amp;命令2</strong></p></li></ul><h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p>有两种方式：</p><ul><li>命令1 $(命令2)</li><li>命令1 `命令2`</li></ul><p>意思是将命令2的输出结果与命令1拼接成新的命令执行，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pidof less //查看less的进程号，假如为4163</span><br><span class="line">kill -9 4163</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kill -9 $(pidof less)</span><br><span class="line">// 或者</span><br><span class="line">kill -9 `pidof less`</span><br></pre></td></tr></table></figure><h4 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h4><p>alias命令用来设置指令的别名。我们可以使用该命令可以将一些较长的命令进行简化。使用alias时，用户必须使用单引号<code>&#39;&#39;</code>将原来的命令引起来，防止特殊字符导致错误。命令语法：</p><p><strong>alias [别名]＝[需要定义别名的命令]</strong></p><p>alias命令的作用<strong>只局限于该次登入的操作</strong>。若要每次登入都能够使用这些命令别名，则可将相应的alias命令存放到bash的初始化文件<code>/etc/bashrc</code>中。</p><p>要删除一个别名，可以使用 <a href="http://man.linuxde.net/unalias" target="_blank" rel="noopener">unalias</a> 命令，如 unalias l。</p><h4 id="文件名匹配和输出重定向"><a href="#文件名匹配和输出重定向" class="headerlink" title="文件名匹配和输出重定向"></a>文件名匹配和输出重定向</h4><h5 id="文件名匹配"><a href="#文件名匹配" class="headerlink" title="文件名匹配"></a>文件名匹配</h5><ul><li>“*” 可匹配任意一个或多个字符</li><li>“?” 可以匹配任意一个字符</li></ul><h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><p>管道可以将某个命令的输出信息当作某个命令的输入，由管道符号“|” 来标识，命令语法：</p><p><strong>[命令1]|[ 命令2]|[ 命令3]</strong></p><p>例如：<code>alias tr=&#39;cd / &amp;&amp; tree | more &amp;&amp; cd ~&#39;</code>，就是将tree的输出内容作为more的输入，more的作用是将输出内容分页显示</p><h5 id="重定向文件"><a href="#重定向文件" class="headerlink" title="重定向文件"></a>重定向文件</h5><p>重定向有5种方式，分别是：输出重定向、输入重定向、错误重定向、追加重定向以及同时实现输出和错误的重定向</p><ul><li><p>输出重定向</p><p>将command命令的输出保存到文件file中，如果存在相同的文件，则<strong>覆盖file文件中的内容</strong>。</p><p><strong>命令语法：command &gt; file</strong></p><p>可以实用echo和输出重定向来创建文本文件：<code>echo hello &gt; hello.txt</code>，即创建文件hello.txt并写入内容“hello”</p></li><li><p>输入重定向</p><p>将文件file的内容作为command命令的输入。</p><p><strong>命令语法：command &lt; file</strong></p></li><li><p>错误重定向</p><p>将command命令执行的出错信息输出到文件file中。</p><p><strong>命令语法：command 2&gt; file</strong></p></li><li><p>追加重定向</p><p>将command命令执行的输出添加到已存在的文件file中。</p><p><strong>命令语法：command &gt;&gt; file</strong></p><p>补充：错误重定向和追加重定向可以组合使用，command 2&gt;&gt; file表示command的错误信息追加到file末尾</p></li><li><p>同时实现输出和错误的重定向</p><p>可以同时实现输出重定向和错误重定向的功能。</p><p><strong>命令语法：command &amp;&gt; file</strong></p><p>补充：同理，该命令可以和追加重定向组合使用，command &amp;&gt;&gt; file表示command的输出和错误信息追加到file末尾</p></li></ul><h3 id="vi编辑器基本使用"><a href="#vi编辑器基本使用" class="headerlink" title="vi编辑器基本使用"></a>vi编辑器基本使用</h3><h4 id="vim和vi的区别"><a href="#vim和vi的区别" class="headerlink" title="vim和vi的区别"></a>vim和vi的区别</h4><blockquote><p>摘录自：<a href="https://blog.csdn.net/allenlinrui/article/details/7269481" target="_blank" rel="noopener">https://blog.csdn.net/allenlinrui/article/details/7269481</a> </p></blockquote><p>简单来说一下vi和vim的区别与联系</p><p>首先，它们都是多模式编辑器，但vim是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性。总的来说，vim比vi更具优势的地方在于：</p><ul><li><p>多级撤消</p><p>在vi的命令模式里，<strong>按 u只能撤消上次命令，而在vim里可以无限制的撤消</strong>，几乎等同于windows下的ctrl+z了</p></li><li><p>多操作系统支持</p><p>vi只能运行于unix中，而vim不仅可以运行于unix,还有windows ,mac等操作系统上</p></li><li><p>语法加亮</p><p>作为一名程序员，我觉得这个效果用处最大了- vim可以对代码进行多颜色的语法加亮</p></li><li><p>可视化操作</p><p>因为vim不仅可以在终端运行，也可以运行于x window、 mac os、 windows， 所以说他“可视化”</p></li><li><p>对vi的完全兼容</p><p>某些情况下，vim可以完全被当成vi来使用</p></li></ul><h4 id="vi的工作模式"><a href="#vi的工作模式" class="headerlink" title="vi的工作模式"></a>vi的工作模式</h4><p>vi编辑器有3种基本工作模式，分别是命令行模式、插入模式和末行模式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/26/5d3a5d5e57a2f97173.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>命令行模式：控制屏幕光标的移动，字符、字或行的删除，移动、复制某区域，该模式下是不能输入文本数据的</li><li>插入模式：只有在插入模式下，才可以做文字输入，按“ Esc” 键可回到命令行模式</li><li>末行模式：将文件保存或退出vi编辑器，也可以设置编辑环境，如寻找字符串、列出行号等</li></ul><h4 id="vi基本操作"><a href="#vi基本操作" class="headerlink" title="vi基本操作"></a>vi基本操作</h4><h5 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h5><ul><li>按“ i” ：从光标当前位置开始输入文件</li><li>按“ I” ：在光标所在行的行首插入</li><li>按“ a” ：从目前光标所在位置的下一个位置开始输入文字</li><li>按“ A” ：在光标所在行的行末插入</li><li>按“ o” ：在光标所在的行的下面插入一行，从行首开始输入文字</li><li>按“ O” ：在光标所在的行的上面插入一行</li><li>按“ s” ：删除光标位置的一个字符，然后进入插入模式</li><li>按“ S” ：删除光标所在的行，然后进入插入模式</li></ul><h5 id="从插入模式切换为命令行模式"><a href="#从插入模式切换为命令行模式" class="headerlink" title="从插入模式切换为命令行模式"></a>从插入模式切换为命令行模式</h5><p>从插入模式切换为命令行模式只需按“ Esc” 键</p><h5 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h5><p>可以使用键盘的方向键移动光标，也可以使用vi定义的移动命令：<strong>h、j、k、l分别表示←、↓、↑、→移动一格</strong>。如果需要翻页：</p><ul><li>按[Ctrl+b]：屏幕往前移动一页（back）</li><li>按[Ctrl+f]：屏幕往后移动一页（front）</li><li>按[Ctrl+u]：屏幕往前移动半页（up）</li><li>按[Ctrl+d]：屏幕往后移动半页（down）</li></ul><p>其他的：</p><ul><li>按“ G” ：移动到文本的最后一行</li><li>按“ $” ：移动到光标所在行的行尾（助记：正则表达式的$）</li><li>按“ ^” 或数字“ 0”：移动到光标所在行的行首（助记：正则表达式的^）</li><li>按“ w” ：光标跳到下个字的开头</li><li>按“ e” ：光标跳到下个字的字尾</li><li>按“ b” ：光标回到上个字的开头</li></ul><p>解释：”e”和”b”的“下个字”和“上个字”的含义是当前光标停在某个字上，即当前字；而“w”的“下个字”真的就是下一个字，不是当前光标停留的字。举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word----</span><br><span class="line">↑</span><br></pre></td></tr></table></figure><p>箭头指向的是当前光标位置，如果按”w”，那么结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">word----</span><br><span class="line">    ↑</span><br><span class="line">// 因为当前字是word，那么对"w"来说，下一个字就是"----"，因此光标指向"-"</span><br></pre></td></tr></table></figure><p>而如果按的是”e”，那么结果将是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">word----</span><br><span class="line">   ↑</span><br><span class="line">// 因为当前字是word，那么对"e"来说，下一个字就是"word"，因此光标指向"d"</span><br></pre></td></tr></table></figure><h5 id="删除文字"><a href="#删除文字" class="headerlink" title="删除文字"></a>删除文字</h5><ul><li>“ x” ：每按一次，删除光标所在位置的一个字符</li><li>“ nx” ：例如， “ 6x” 表示删除光标所在位置开始的6个字符<u>（包括当前位置的字符）</u></li><li>“ X” ：大写的X，每按一次，删除光标所在位置的前面一个字符</li><li>“ nX”：例如， “ 20X”表示删除光标所在位置前面20个字符<u>（不包括当前位置的字符）</u></li><li>“ dd” ：删除光标所在行</li><li>“ ndd”：从光标所在行开始删除n行。例如， “ 4dd” 表示删除从光标所在行开始的4行字符<u>（包括当前行）</u></li><li>”dG“：删除当前后之后的全部行<u>（包括当前行）</u></li></ul><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><ul><li>“ yw” ：将光标所在之处到字尾的字符复制到缓冲区中（复制的是一个字的内容）</li><li>“ nyw” ：复制n个字到缓冲区<u>（包括当前字）</u></li><li>“ yy” ：复制光标所在行到缓冲区</li><li>“nyy” ：例如， “6yy” 表示复制从光标所在行开始的6行字符</li><li>“p” ：将缓冲区内的内容写到光标所在的<strong>后一个位置</strong>（原ppt这里错了，这里写的才是正确的）</li><li>”P“：将缓冲区内的内容写到光标所在的前一个位置</li></ul><p><strong>解释：”p“后一个位置有两种含义，如果复制的是字，那么写在光标所在位置的后面；如果复制的是行内容，那么写在光标所在行的下一行</strong>；”P“同理，替换成上一个位置或者上一行</p><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><ul><li>“ r” ：替换光标所在处的字符</li><li>“ R” ：替换光标所到之处的字符，直到按下“ Esc” 键为止</li></ul><h5 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h5><ul><li>“ u” ：如果误执行一个命令，可以马上按下“ u” ，回到上一个操作。</li><li>按多次“ u” 可以执行多次撤销</li></ul><p>补充：vi兼容模式下，多次”u“并不能多次撤销，原因是后一次”u“会把上一次”u“当做操作来撤销，即撤销”撤销操作“，所以”uu“会恢复原样</p><h5 id="跳至指定行"><a href="#跳至指定行" class="headerlink" title="跳至指定行"></a>跳至指定行</h5><ul><li>[Ctrl+g]：列出光标所在行的行号</li><li>“nG” ：例如， “ 15G” ，表示移动光标至该文本的第15行行首</li></ul><h5 id="存盘退出"><a href="#存盘退出" class="headerlink" title="存盘退出"></a>存盘退出</h5><ul><li>“ZZ” ：存盘退出</li></ul><h5 id="不保存退出"><a href="#不保存退出" class="headerlink" title="不保存退出"></a>不保存退出</h5><ul><li>“ZQ” ：不存盘退出</li></ul><h4 id="末行模式操作"><a href="#末行模式操作" class="headerlink" title="末行模式操作"></a>末行模式操作</h4><p>在使用末行模式之前，先按“ Esc”键确定已经处于命令行模式后，再按冒号“:”<br>即可进入末行模式</p><h5 id="列出行号"><a href="#列出行号" class="headerlink" title="列出行号"></a>列出行号</h5><p>“set nu” ：在文件中的每一行前面列出行号</p><h5 id="取消列出行号"><a href="#取消列出行号" class="headerlink" title="取消列出行号"></a>取消列出行号</h5><p>“set nonu” ：取消文件中的每一行前面列出的行号</p><h5 id="跳到文件中的某一行"><a href="#跳到文件中的某一行" class="headerlink" title="跳到文件中的某一行"></a>跳到文件中的某一行</h5><p>“n”：输入行号n后回车，光标会跳转到文本的指定行——第n行的行首</p><h5 id="查找字符"><a href="#查找字符" class="headerlink" title="查找字符"></a>查找字符</h5><ul><li>“/关键字”：向后查找关键字，可以按n往后查找下一个匹配的关键字</li><li>“?关键字”：向前查找关键字，可以按n往前查找下一个匹配的关键字</li></ul><h5 id="运行Shell命令"><a href="#运行Shell命令" class="headerlink" title="运行Shell命令"></a>运行Shell命令</h5><p>“!命令” ：运行Shell命令</p><h5 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h5><ul><li>“s /a/b” ：将光标所在行第一个a替换为b</li><li>“s /a/b/g” ：将光标所在行所有的a替换为b</li></ul><h5 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h5><p>“w” ：在冒号后输入字母“w” 就可以将文件保存起来</p><h5 id="退出vi"><a href="#退出vi" class="headerlink" title="退出vi"></a>退出vi</h5><ul><li>“q” ：按“q” 即退出vi，如果无法离开vi，可以在“q” 后跟一个“!” 强制符离开vi</li><li>“wq” ：一般建议离开时，搭配“w” 一起使用，这样在退出的时候还可以保存文件</li></ul><h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>Linux系统中<strong>以目录的形式挂载文件系统</strong>，其目录结构是一个<strong>分层的树形结构</strong>。链接是一种在共享文件和访问它的用户的若干目录项之间建立联系的方法， Linux系统中包括<strong>硬链接和软链接</strong>两种方式</p><h3 id="Linux文件"><a href="#Linux文件" class="headerlink" title="Linux文件"></a>Linux文件</h3><p>如果一个文件没有扩展名，或者与它的扩展名不相符时，可以使用file命令查看该文件的类型，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~$ file db.json </span><br><span class="line">db.json: UTF-8 Unicode text, with very long lines, with no line terminators</span><br><span class="line">steve@ubuntu-17-10:~$ file _config.yml </span><br><span class="line">_config.yml: UTF-8 Unicode text</span><br><span class="line">steve@ubuntu-17-10:~$ file package-lock.json </span><br><span class="line">package-lock.json: ASCII text</span><br></pre></td></tr></table></figure><h3 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h3><p>Linux文件类型常见的有：普通文件、目录文件、字符设备文件、块设备文件和符号链接文件等，可以用<code>ls -lh</code>命令查看某个文件的属性</p><ul><li><p>普通文件</p><p>类似“ -rw-r–r–”的属性符号，其<strong>属性第一个符号是“ -”</strong>，这样的文件在Linux系统中就是普通文件</p></li><li><p>目录文件（<strong>d</strong>irectory）</p><p>类似“ drwxr-xr-x”的属性符号，其<strong>属性第一个符号是“ d”</strong>，这样的文件在Linux系统中就是目录文件</p></li><li><p>设备文件</p><p>Linux系统下的/dev目录中有大量的设备文件</p><ul><li><p>块设备文件（<strong>b</strong>lock）</p><p>块设备的主要特点是可以随机读写，而最常见的块设备就是磁盘，如/dev/hda1、/dev/sda2等</p><p>类似“ brw-rw—-”的属性符号，其<strong>属性第一个符号是“ b”</strong>，这样的文件在Linux系统中就是块设备文件</p></li><li><p>字符设备文件（<strong>c</strong>haracter）</p><p>最常见的字符设备文件是打印机和终端，可以接收字符流。 /dev/null是一个非常有用的字符设备文件，送入这个设备的所有内容都被忽略</p><p>类似“ crw-r—–”的属性符号，其<strong>属性第一个符号是“ c”</strong>，这样的文件在Linux系统中就是字符设备文件</p></li></ul></li><li><p>管道文件（<strong>p</strong>ipe）</p><p>管道文件有时候也被叫做FIFO文件（ FIFO是先进先出的意思），管道文件就是从一头流入，从另一头流出</p><p>类似“ prw——-”的属性符号，其<strong>属性第一个符号是“ p”</strong>，这样的文件在Linux系统中就是管道文件</p></li><li><p>链接文件（<strong>l</strong>ink）</p><p>链接文件有点类似于Windows系统中的快捷方式，链接有两种方式：软链接和硬链接</p><ul><li><p>软链接文件</p><p>软链接（也叫符号链接），文件<strong>用户数据块中存放的内容是另一文件的路径名的指向</strong>。软链接就是一个普通文件，只是数据块内容有点特殊。<strong>软链接可对文件或目录创建</strong>。删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接就变成了死链接</p><p>类似“ lrwxrwxrwx”的属性符号，其<strong>属性第一个符号是“ l”</strong>，这样的文件在Linux系统中就是软链接文件</p></li><li><p>硬链接文件</p><p>硬链接就是同一个文件使用了多个别名（他们<strong>有共同的 inode</strong>）。由于<strong>硬链接是有着相同inode</strong><br><strong>号仅文件名不同的文件</strong>，因此，删除一个硬链接文件并不影响其他有相同 inode 号的文件。硬链接<strong>不能对目录进行创建，只可对文件创建</strong></p><p>用“ ls -l”命令查看某个文件的属性，可以看到<strong>第二列的文件硬链接数大于1</strong> ，这样的文件在Linux系统中就是硬链接文件</p></li></ul></li></ul><h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p>Linux系统都有根文件系统，它包含<strong>系统引导和使其他文件系统得以挂载所必要的文件</strong>，根文件系统需要有<strong>单用户状态所必须的足够的内容</strong>，还应该包括<strong>修复损坏系统、恢复备份等工具</strong>。</p><p>Linux系统的目录结构是分层的树形结构，都是挂载在根文件系统“ /” 下</p><h3 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h3><ul><li><p>pwd：显示当前用户所处的工作目录的绝对路径</p></li><li><p>cd：更改工作目录路径，工作目录路径可以使用绝对或相对路径名，绝对路径从/（根）开始，然后循序到所需的目录下；相对路径从当前目录开始</p><p><strong>命令语法：cd [目录名]</strong></p></li><li><p>ls：对于目录而言将列出其中的所有子目录与文件信息；对于文件而言将输出其文件名以及所要求的其他信息</p><p><strong>命令语法：ls [选项] [目录或是文件]</strong></p><p>ls命令显示的详细信息：</p><p><img src="https://i.loli.net/2019/07/26/5d3ab0c1d837547899.png" alt="ls命令显示的详细信息"></p></li><li><p>touch：创建空文件以及更改文件或目录的时间，其中时间格式为MMDDHHmm</p><p><strong>命令语法：touch [-acfm] [-d &lt;日期时间&gt;] [-r &lt;参考 文件或目录&gt;] [-t &lt;日期时间&gt;] [文件]</strong></p></li><li><p>mkdir：在Linux系统中创建目录，其默认权限为rwxr-xr-x（ 755）</p><p><strong>命令语法：mkdir [选项] [目录名]</strong></p><p>-m 可以在创建目录时设置其权限，例如mkdir -m 777 newdir，其权限是rwxrwxrwx（ 777）</p></li><li><p>rmdir：删除空目录</p><p><strong>命令语法：rmdir [选项] [目录名]</strong></p><p>-p或–parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除</p></li><li><p>cp：复制文件和目录到其他目录中</p><p><strong>命令语法：cp [选项] [源文件或目录] [目标文件或目录]</strong></p></li><li><p>mv：对<u>文件和目录更改名称</u>以及移动文件和目录的路径</p><p><strong>命令语法：mv [选项] [源文件或目录] [目标文件或目录]</strong></p></li><li><p>rm：删除系统中的文件或目录</p><p><strong>命令语法：rm [选项] [文件或目录]</strong></p><p>-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；-f：强制删除文件或目录；-i：在删除文件之前提示信息</p></li><li><p>wc：统计指定文件中的行数、单词数或字节数，并将统计结果显示输出到屏幕</p><p><strong>命令语法：wc [选项] [文件]</strong></p><p>选项部分可以有-lwc，即将行数、单词数和字节数都显示出来</p></li></ul><h3 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h3><p>在Linux系统中，内核为每一个新创建的文件分配一个inode（索引节点）号，文件属性保存在索引节点里，在访问文件时，索引节点被复制到内存里，从而实现文件的快速访问</p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>硬链接是一个指针，指向文件索引节点，系统并不为它重新分配inode，可以用ln命令来建立硬链接。硬链接节省空间，也是Linux系统整合文件系统的传统方式。硬链接文件有两个限制：</p><p>（ 1）不允许给目录创建硬链接</p><p>（ 2）只有在同一文件系统中的文件之间才能创建链接</p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><p>软链接又称为符号链接，这个文件包含了另一个文件的路径名</p><h4 id="硬链接和软链接的区别"><a href="#硬链接和软链接的区别" class="headerlink" title="硬链接和软链接的区别"></a>硬链接和软链接的区别</h4><p><strong>硬链接记录的是目标的inode</strong>，<strong>软链接记录的是目标的路径</strong>。<strong>软链接就像是快捷方式，而硬链接就像是备份</strong>。软链接可以做跨分区的链接，而硬链接由于inode的缘故，只能在本分区中做链接。所以，软链接的使用频率要高得多</p><h4 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h4><p>ln命令可以创建链接文件（包括软链接文件和硬链接文件）</p><p><strong>命令语法：ln [选项] [源文件名] [链接文件名]</strong>，默认创建的是硬链接，加上-s后创建的是软链接</p><p>使用rm删除源文件后，硬链接文件依然能打开，而软链接变成死链接</p><h2 id="Linux常用操作命令"><a href="#Linux常用操作命令" class="headerlink" title="Linux常用操作命令"></a>Linux常用操作命令</h2><p><em>这部分挺琐碎的，直接参考<a href="http://man.linuxde.net/即可" target="_blank" rel="noopener">http://man.linuxde.net/即可</a> ，关于Linux命令大全的实用网站</em></p><h3 id="文本显示和处理"><a href="#文本显示和处理" class="headerlink" title="文本显示和处理"></a>文本显示和处理</h3><p>cat，more，less，head，tail，sort，uniq，cut，comm以及diff等</p><h3 id="文件和命令查找"><a href="#文件和命令查找" class="headerlink" title="文件和命令查找"></a>文件和命令查找</h3><p>grep，find，locate，whereis，file，whatis以及which等</p><h3 id="系统信息显示"><a href="#系统信息显示" class="headerlink" title="系统信息显示"></a>系统信息显示</h3><p>uname， hostname， dmesg， cal以及date等</p><h3 id="信息交流"><a href="#信息交流" class="headerlink" title="信息交流"></a>信息交流</h3><p>echo， mesg， wall以及write等</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>clear， sync， uptime以及last等</p><h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h3><p>Shell程序由开头部分、注释部分以及语句执行部分组成</p><h4 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h4><p>Shell程序必须以下面的行开始（必须放在文件的第一行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br></pre></td></tr></table></figure><p>符号“ #!” 用来告诉系统它后面的参数是<strong>用来执行该文件的程序</strong>，在这个例子中使用/bin/bash来执行程序。当编辑好脚本时，如果要执行该脚本，还必须<strong>使其可执行</strong>（即赋予可执行权限）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x [文件名]</span><br></pre></td></tr></table></figure><p>如果不设置可执行权限的话，可以手动受用bash命令告诉系统它是一个可执行的脚本，这样也可以执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash file.sh</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>以“ #” 开头的句子表示注释，直到这一行的结束</p><h4 id="执行部分"><a href="#执行部分" class="headerlink" title="执行部分"></a>执行部分</h4><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">filename:welcome</span></span><br><span class="line">first()</span><br><span class="line">&#123;</span><br><span class="line">echo "=========================================="</span><br><span class="line">echo "Hello! Everyone! Welcome to the Linux world."</span><br><span class="line">echo "=========================================="</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">second()</span><br><span class="line">&#123;</span><br><span class="line">echo "******************************************"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">first</span><br><span class="line">second</span><br><span class="line">second</span><br><span class="line">first</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">==========================================</span><br><span class="line">Hello! Everyone! Welcome to the Linux world.</span><br><span class="line">==========================================</span><br><span class="line">******************************************</span><br><span class="line">******************************************</span><br><span class="line">==========================================</span><br><span class="line">Hello! Everyone! Welcome to the Linux world.</span><br><span class="line">==========================================</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>对Shell来讲，<strong>所有变量的取值都是一个字符</strong>， Shell程序采用“ $var” 的形式来引用名为var的变量的值</p><h4 id="Shell定义的环境变量"><a href="#Shell定义的环境变量" class="headerlink" title="Shell定义的环境变量"></a>Shell定义的环境变量</h4><p>Shell在开始执行时就已经定义了一些与系统的工作环境有关的变量，用户还可以重新定义这些变量，常见的环境变量如下：</p><ul><li>HOME：用于保存用户宿主目录的完全路径名</li><li>PATH：默认命令搜索路径</li><li>TERM：终端的类型</li><li>UID：当前用户的识别号</li><li>PWD：当前工作目录的绝对路径名</li><li>PS1： 用户平时的提示符</li><li>PS2： 第一行没输完，等待第二行输入的提示符</li></ul><h4 id="用户定义的变量"><a href="#用户定义的变量" class="headerlink" title="用户定义的变量"></a>用户定义的变量</h4><p>语法规则：<code>变量名=变量值</code></p><p>在定义变量时，<strong>变量名前不应加符号“ $”</strong> ；在引用变量的内容时，则应<strong>在变量名前加符号“ $”或“ ${变量名}”</strong> 。在给变量<strong>赋值时，等号两边一定不能留空格</strong>，若<strong>变量中本身就包含了空格，则整个字符串都要用双引号括起来</strong>。在编写Shell程序时，为了使变量名和命令名相区别，<strong>建议所有的变量名都用大写字母来表示</strong>。</p><p>有时需要在说明一个变量并对它设置为一个特定值后就不再改变它的值时，可以用下面的命令来保证一个变量的只读性：<code>readonly 变量名</code>。</p><p>在任何时候创建的变量都<strong>只是当前Shell的局部变量</strong>，所以不能被Shell运行的其他命令或Shell程序所利用，而export命令可以将一个局部变量提供给Shell命令使用，其格式是：<code>export 变量名</code>。也可以在给变量赋值的同时使用export命令：<code>export 变量名=变量值</code>。</p><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>位置参数是一种在调用Shell程序的命令行中按照各自的位置决定的变量，<strong>是在程序名之后输入的参数</strong>。位置参数之间用空格分隔，Shell取第一个位置参数替换程序文件中的$1，第二个替换$2，依次类推。<strong>$0是一个特殊的变量，它的内容是当前这个Shell程序的文件名</strong>，所以， $0不是一个位置参数，在显示当前所有的位置参数时是不包括$0的</p><h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>预定义变量和环境变量相类似，也是在Shell一开始时就定义了的变量。所不同的是，用户只能根据Shell的定义来使用这些变量，所有预定义变量都是<strong>由符号“ $” 和另一个符号组成</strong>的。常见的预定义变量如下：</p><ul><li>$#：位置参数的数量</li><li>$*：所有位置参数的内容</li><li>$?：命令执行后返回的状态</li><li>$$：当前进程的进程号</li><li>$!：后台运行的最后一个进程号</li><li>$0：当前执行的进程名。</li></ul><h4 id="参数置换的变量"><a href="#参数置换的变量" class="headerlink" title="参数置换的变量"></a>参数置换的变量</h4><p>Shell提供了参数置换功能以便用户可以根据不同的条件来给变量赋不同的值，下面Variable是变量名， value代表一个具体的值：</p><ul><li>${variable:-value}: 如果变量variable存在，则返回variable的值，否则返回值value</li><li>${variable:=value}: 如果变量variable存在，则返回variable的值，否则，先将值value赋给变量variable，然后返回值value</li><li>${variable:+value}: 如果变量variable存在，则返回value的值，否则返回空值</li><li>${variable:?value}: 如果变量variable存在，则返回variable的值，否则将value送到标准错误输出显示并退出shell程序，这里value通常为一个错误提示消息</li><li>${variable:offset[:length]}:其中offset和length为整数数字，中括号代表可选部分。此引用方式表示返回从变量variable的第(offset+1)个字符开始的、长度为length的子串。如果中括号内的部分省略，则返回其后的所有子串</li></ul><h3 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h3><p>首先要注意的是，<strong>这些表达式符号前后都需要有空格</strong>，否则会出错</p><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>测试字符串是否相等，长度是否为零，字符串是否为NULL：</p><ul><li>=：比较两个字符串是否相同，相同则为“是” （结果显示0）</li><li>!=：比较两个字符串是否相同，不同则为“是”（结果显示0）</li><li>-n：比较字符串的长度是否大于0，如果大于0则为“是” （结果显示0）</li><li>-z：比较字符串的<strong>长度是否等于0</strong>，如果等于0则为“是” （结果显示0）</li></ul><p>补充：</p><ul><li><p>直接测试时，控制台是不会有输出结果的，需要使用<code>$?</code>来获取输出结果</p></li><li><p>如果变量字符串含有空格，需要使用双引号，否则会出错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ str1="ab cd"</span><br><span class="line">steve@ubuntu-17-10:~/$ test $str1 = ab</span><br><span class="line">bash: test: 参数太多</span><br><span class="line">steve@ubuntu-17-10:~/$ test "$str1" = ab</span><br><span class="line">steve@ubuntu-17-10:~/$ echo $?</span><br><span class="line">1</span><br><span class="line">steve@ubuntu-17-10:~/$ test "$str1" = ab cd</span><br><span class="line">bash: test: 参数太多</span><br><span class="line">steve@ubuntu-17-10:~/$ test "$str1" = "ab cd"</span><br><span class="line">steve@ubuntu-17-10:~/$ echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure></li></ul><h4 id="数字比较"><a href="#数字比较" class="headerlink" title="数字比较"></a>数字比较</h4><p>test语句不使用<code>&gt;?</code> 类似的符号来表达大小的比较，而是用参数来表示：</p><ul><li>-eq：相等</li><li>-ge：大于等于</li><li>-le：小于等于</li><li>-ne：不等于</li><li>-gt：大于</li><li>-lt：小于</li></ul><h4 id="逻辑测试"><a href="#逻辑测试" class="headerlink" title="逻辑测试"></a>逻辑测试</h4><ul><li>!：与一个逻辑值相反的逻辑值</li><li>-a与（ and）：两个逻辑值都为“是” 返回值才为“是” ，反之为“否”</li><li>-o或（ or）：两个逻辑值有一个为“是” ，返回值就为“是” </li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@PC-LINUX ~]# test -r empty -a -s empty</span><br><span class="line">[root@PC-LINUX ~]# echo $?</span><br><span class="line">1</span><br><span class="line">// 结果显示1表示文件empty存在且只读以及长度为非0是不对的</span><br></pre></td></tr></table></figure><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>文件测试表达式通常是为了测试文件的文件操作逻辑：</p><ul><li>-d：对象存在且为目录，则返回值为“是” </li><li>-f：对象存在且为文件，则返回值为“是” </li><li>-L：对象存在且为符号连接，则返回值为“是” </li><li>-r：对象存在且可读，则返回值为“ 是”</li><li>-s：对象存在且<strong>长度非0</strong>，则返回值为“是” </li><li>-w：对象存在且可写，则返回值为“是” </li><li>-x：对象存在且可执行，则返回值为“是” </li><li>!：测试条件的否定</li></ul><h3 id="Shell程序的执行和跟踪"><a href="#Shell程序的执行和跟踪" class="headerlink" title="Shell程序的执行和跟踪"></a>Shell程序的执行和跟踪</h3><h4 id="Shell程序的执行和调试"><a href="#Shell程序的执行和调试" class="headerlink" title="Shell程序的执行和调试"></a>Shell程序的执行和调试</h4><p>程序的第一行一般为<code>#!/bin/bash</code> ，其中“ #” 表示该行是注释，感叹号“ ！ ” 表示Shell运行感叹号之后的命令<strong>并用文档的其余部分作为输入</strong>，也就是运行/bin/bash并让/bin/bash去执行Shell程序的内容</p><h5 id="Shell程序的执行"><a href="#Shell程序的执行" class="headerlink" title="Shell程序的执行"></a>Shell程序的执行</h5><p>有如下三种方式运行shell程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ vim exe.sh</span><br><span class="line">steve@ubuntu-17-10:~/$ bash &lt; exe.sh </span><br><span class="line">hello world</span><br><span class="line">steve@ubuntu-17-10:~/$ bash exe.sh </span><br><span class="line">hello world</span><br><span class="line">steve@ubuntu-17-10:~/$ chmod u+x exe.sh </span><br><span class="line">steve@ubuntu-17-10:~/$ ./exe.sh </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p><u>发现一个问题：使用<code>bash &lt; exe.sh</code>运行程序时，read指令好像不生效，控制台不会等待标准输入，具体原因还不知道</u></p><h5 id="Shell程序的调试"><a href="#Shell程序的调试" class="headerlink" title="Shell程序的调试"></a>Shell程序的调试</h5><p>调用bash的形式是：<code>bash [选项] [Shell程序文件名]</code></p><ul><li>-v：当读入Shell输入行时，把它们显示出来（输出的命令是<strong>未经执行的源程序命令</strong>）</li><li>-x：执行命令时把命令和它们的参数显示出来（输出的命令是<strong>解释后实际执行的命令</strong>）</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ vim exe.sh ; cat exe.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "shell file name is $0"</span><br><span class="line">echo "hello world"</span><br><span class="line">echo $1</span><br><span class="line">echo $2</span><br><span class="line">steve@ubuntu-17-10:~/$ bash -x exe.sh a b</span><br><span class="line">+ echo 'shell file name is exe.sh'</span><br><span class="line">shell file name is exe.sh</span><br><span class="line">+ echo 'hello world'</span><br><span class="line">hello world</span><br><span class="line">+ echo a</span><br><span class="line">a</span><br><span class="line">+ echo b</span><br><span class="line">b</span><br><span class="line">steve@ubuntu-17-10:~/$ bash -v exe.sh a b</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "shell file name is $0"</span><br><span class="line">shell file name is exe.sh</span><br><span class="line">echo "hello world"</span><br><span class="line">hello world</span><br><span class="line">echo $1</span><br><span class="line">a</span><br><span class="line">echo $2</span><br><span class="line">b</span><br></pre></td></tr></table></figure><h3 id="Shell流程控制语句"><a href="#Shell流程控制语句" class="headerlink" title="Shell流程控制语句"></a>Shell流程控制语句</h3><p>与传统语言不同的是， Shell用于指定条件值的不是布尔运算式，而是命令和字符串</p><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><h5 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h5><blockquote><p>可以参考：<a href="https://blog.csdn.net/doiido/article/details/43966819" target="_blank" rel="noopener">https://blog.csdn.net/doiido/article/details/43966819</a></p></blockquote><p>Shell程序中的条件分支有如下两种方式：</p><ul><li><p>if-then语句</p><p>语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ 命令行1 ];then</span><br><span class="line">命令行2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>需要注意的是，在 <strong>‘[‘后面</strong> 和 <strong>‘]’前面</strong> 都必须要有空格，不然会出错，例如要<code>[ $a=a ]</code></p></li><li><p>if-then-else语句</p><p>语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ 命令行1 ]</span><br><span class="line">then</span><br><span class="line">命令行2</span><br><span class="line">else</span><br><span class="line">命令行3</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul><h5 id="case条件语句"><a href="#case条件语句" class="headerlink" title="case条件语句"></a>case条件语句</h5><p>Shell通过计算字符串string的值，将其结果依次与运算式exp-1和exp-2等进行比较，直到找到一个匹配的运算式为止。如果找到了匹配项，则执行它下面的命令直到遇到一对分号<code>;;</code>为止，语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">case string in</span><br><span class="line">exp-1)</span><br><span class="line">若干个命令行1</span><br><span class="line">;;</span><br><span class="line">exp-2)</span><br><span class="line">若干个命令行2</span><br><span class="line">;;</span><br><span class="line">……</span><br><span class="line">*)</span><br><span class="line">其他命令行</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>在case运算式中也可以使用Shell的通配符（ <code>*</code> ， <code>?</code> ， <code>[]</code>）。通常用<code>*</code>作为case命令的最后运算式以便在前面找不到任何相应的匹配项时执行“其他命令行” 的命令，样例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ cat menu.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo _</span><br><span class="line">echo "1 Restore"</span><br><span class="line">echo "2 Backup"</span><br><span class="line">echo "3 Unload"</span><br><span class="line">echo </span><br><span class="line">echo -n "Enter Choice: "</span><br><span class="line">read CHOICE</span><br><span class="line">case "$CHOICE" in</span><br><span class="line">1) echo "Restore";;</span><br><span class="line">2) echo "Backup";;</span><br><span class="line">3) echo "Unload";;</span><br><span class="line">*) echo "Sorry $CHOICE is not a valid choice."</span><br><span class="line">exit 1</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><h5 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量名 [in数值列表]</span><br><span class="line">do</span><br><span class="line">若干个命令行</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>如果变量名是var，则在in之后给出的数值将顺序替换循环命令列表中的“ $var” </li><li>如果省略了in，则变量var的取值将是位置参数</li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ vim mm.sh ; cat mm.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">for ab in 1 2 3 4</span><br><span class="line">do</span><br><span class="line">echo $ab</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ bash mm.sh </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>求和示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/$ cat qqq.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">sum=0</span><br><span class="line">for INT in $*;do</span><br><span class="line">sum=`expr $sum + $INT`</span><br><span class="line">done </span><br><span class="line">echo $sum</span><br><span class="line">steve@ubuntu-17-10:~/$ bash qqq.sh 1 2 3 4 </span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>要注意，原ppt中expr指令使用的是单引号<code>&#39;&#39;</code>括起来的，这样不对，应该使用反单引号``才能执行后面的加法计算</p><h5 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h5><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while</span><br><span class="line">若干个命令行1</span><br><span class="line">do</span><br><span class="line">若干个命令行2</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>只要while的“若干个命令行1” 中<strong>最后一个命令的返回状态为真</strong>， while循环就继续执行“ do…done” 之间的“ 若干个命令行2”，示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/桌面$ cat zx.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">int=1</span><br><span class="line">while [ $int -le 5 ]; do</span><br><span class="line">sq=`expr $int \* $int`</span><br><span class="line">echo $sq</span><br><span class="line">int=`expr $int + 1`</span><br><span class="line">done</span><br><span class="line">echo "Job completed!"</span><br><span class="line">steve@ubuntu-17-10:~/桌面$ bash zx.sh </span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br><span class="line">25</span><br><span class="line">Job completed!</span><br></pre></td></tr></table></figure><h5 id="until循环语句"><a href="#until循环语句" class="headerlink" title="until循环语句"></a>until循环语句</h5><p>语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">until</span><br><span class="line">若干个命令行1</span><br><span class="line">do</span><br><span class="line">若干个命令行2</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>until循环和while循环的区别在于：<strong>while循环在条件为真时继续执行循环，而until则是在条件为假时继续执行循环</strong>。Shell还提供了true和false两条命令用于创建无限循环结构，它们的返回状态分别是总为0或总为非0</p><h5 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h5><p>用法和传统C语言中的用法无异</p><h5 id="source语句"><a href="#source语句" class="headerlink" title="source语句"></a>source语句</h5><p>source命令用法：<code>source FileName</code></p><p>作用：在<strong>当前bash环境下</strong>读取并执行FileName中的命令。</p><p>注：该命令<strong>通常用命令“ .”来替代</strong>。如： source .bash_rc 与 . .bash_rc 是等效的。</p><p>source命令与shell scripts的区别是， <strong>source在当前bash环境下执行命令</strong>，而<strong>scripts是启动一个子shell来执行命令</strong>。这样如果把设置环境变量（或alias等等）的命令写进scripts中，就只会影响子shell,无法改变当前的BASH,所以<strong>通过文件设置环境变量时，要用source 命令。</strong></p><p>source命令(从 C Shell 而来)是bash shell的内置命令。点命令(从Bourne Shell而来) 是source的另一名称。 <strong>source(或点)命令通常用于重新执行刚修改的初始化文档</strong>，如 .bash_profile 和<br>.profile 等等。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>所有函数在使用前必须定义</strong>。函数的调用，只需要使用函数名就可以调用已经定义好的函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义：</span></span><br><span class="line">[function] 函数名()</span><br><span class="line">&#123;</span><br><span class="line">命令</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 引用：</span></span><br><span class="line">函数名 [ 参数1 参数2 ...参数n ]</span><br></pre></td></tr></table></figure><p>在函数中得到函数返回值可以使用以下两种方法：</p><ul><li>在函数末尾加return，从函数中返回，用最后的<strong>命令状态</strong>决定返回值（<code>$?</code>）</li><li>返回一个数值，如0或1。格式如： return 0或者return 1</li></ul><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/桌面$ cat func.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">function func()&#123;</span><br><span class="line">echo "hello"</span><br><span class="line">echo "world"</span><br><span class="line">&#125;</span><br><span class="line">func</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">steve@ubuntu-17-10:~/桌面$ bash func.sh </span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>说明获取的是<strong>命令状态</strong>而不是命令的输出值</p><h2 id="用户和组群账户管理"><a href="#用户和组群账户管理" class="headerlink" title="用户和组群账户管理"></a>用户和组群账户管理</h2><h3 id="用户账户管理"><a href="#用户账户管理" class="headerlink" title="用户账户管理"></a>用户账户管理</h3><h4 id="Linux用户账户概述"><a href="#Linux用户账户概述" class="headerlink" title="Linux用户账户概述"></a>Linux用户账户概述</h4><p>用户在Linux系统中是分角色的，用户的角色是通过UID（用户ID号）来标识的，每个用户的UID都是不同的。在Linux系统中主要有<strong>root用户、虚拟用户和普通用户</strong>这3类用户。</p><ul><li><p>root用户</p><p>root用户是Linux系统的内置用户，在系统中的权限最高，也被称之为超级管理用户。在系统中的每个文件、目录和进程都归属于某一个用户，没有用户许可，<strong>除root用户外</strong>的其它普通用户无法进行操作</p></li><li><p>虚拟用户</p><p>这类用户也被称为伪用户或假用户，<strong>这类用户不具有登录系统的能力</strong>，但却是系统运行不可缺少的用户，比如bin， daemon， adm，ftp以及mail等用户账户，这类用户都是Linux系统的<strong>内置用户</strong></p></li><li><p>普通用户</p><p>这类用户是由系统管理员创建，并且能登录Linux系统。只能操作自己目录内的文件，权限有限</p></li></ul><h4 id="Linux用户账户配置文件"><a href="#Linux用户账户配置文件" class="headerlink" title="Linux用户账户配置文件"></a>Linux用户账户配置文件</h4><p>用户管理主要是<strong>通过修改用户配置文件完成</strong>的，使用用户管理控制工具的最终目的也是为了修改用户配置文件。</p><h5 id="etc-passwd文件"><a href="#etc-passwd文件" class="headerlink" title="/etc/passwd文件"></a>/etc/passwd文件</h5><p>/etc/passwd是系统识别用户的一个文件，Linux系统中所有的用户都记录在该文件中。<strong>任何用户</strong>都可以读取该文件内容，在/etc/passwd文件中，<strong>每一行表示的是一个用户账户信息</strong>，<strong>一行有7个段位，每个段位用“:”分隔</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/29/5d3ea1207389631335.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>每个用户都对应一个唯一的UID，Linux的用户UID值是非负整数， root的UID是0，拥有系统最高权限。UID的唯一性关系到系统的安全，比如在/etc/passwd文件中把用户zhangsan的UID改为0后， zhangsan这个用户会被确认为root用户。</p><p><strong>UID是确认用户权限的标识，用户登录系统所处的角色是通过UID来实现的，而不是用户名</strong>。</p><h5 id="etc-shadow文件"><a href="#etc-shadow文件" class="headerlink" title="/etc/shadow文件"></a>/etc/shadow文件</h5><p>/etc/shadow文件是/etc/passwd文件的影子文件，这个文件并不是由/etc/passwd文件产生，这两个文件是<strong>对应互补</strong>的。/etc/shadow文件内容包括<strong>用户及被加密的口令</strong>及<strong>其他/etc/passwd不能包括的信息，比如用户账户的有效期限</strong>等。/etc/shadow文件的内容包括9个段位，每个段位之间用“ :”分隔：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/29/5d3ea44904bdc53896.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="字符界面下用户账户的设置"><a href="#字符界面下用户账户的设置" class="headerlink" title="字符界面下用户账户的设置"></a>字符界面下用户账户的设置</h4><h5 id="创建新账户"><a href="#创建新账户" class="headerlink" title="创建新账户"></a>创建新账户</h5><p>创建用户账户就是在系统中创建一个新账户，然后为新账户分配<u>用户UID、用户组群、主目录和登录Shell</u>等资源，新创建的用户账户<strong>默认是被锁定的，无法使用</strong>，需要<strong>使用passwd命令设置密码</strong>以后才能使用。使用useradd命令可以在Linux系统下创建用户账户。</p><h5 id="修改账户"><a href="#修改账户" class="headerlink" title="修改账户"></a>修改账户</h5><p>使用usermod命令能更改用户的Shell类型、所属的用户组群、用户口令的有效期，还能更改用户的登录名</p><h5 id="删除用户账户"><a href="#删除用户账户" class="headerlink" title="删除用户账户"></a>删除用户账户</h5><p>使用userdel命令可以在Linux系统下删除用户账户：<code>userdel [-r][用户名]</code>，其中-r是指在删除该用户的同时一起删除主目录</p><h3 id="组群账户管理"><a href="#组群账户管理" class="headerlink" title="组群账户管理"></a>组群账户管理</h3><h4 id="Linux组群账户配置文件"><a href="#Linux组群账户配置文件" class="headerlink" title="Linux组群账户配置文件"></a>Linux组群账户配置文件</h4><p>/etc/gshadow是/etc/group的加密信息文件</p><h5 id="etc-group文件"><a href="#etc-group文件" class="headerlink" title="/etc/group文件"></a>/etc/group文件</h5><p>/etc/group文件的内容包括用户组群名、用户组群口令、 GID及该用户组群所包含的用户，每个用户组群都有一条记录。一行有4个段位，每个段位用“:” 分隔。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/29/5d3eae591ea3b22405.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>组群GID和UID类似，是一个从0开始的非负整数， <strong>GID为0的组群是root组群</strong>。Fedora 17系统会预留1000个GID号给系统虚拟用户组群使用，创建的新组群GID是从1000开始的。</p><h5 id="etc-gshadow文件"><a href="#etc-gshadow文件" class="headerlink" title="/etc/gshadow文件"></a>/etc/gshadow文件</h5><p>/etc/gshadow文件是/etc/group的加密文件，比如<strong>用户组群管理口令</strong>就是存放在这个文件中。/etc/gshadow文件中每个用户组群都有一条记录。一行有4个段位，每个段位之间用“ :”分隔。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/29/5d3eb098a186369791.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h4 id="字符界面下组群账户的设置"><a href="#字符界面下组群账户的设置" class="headerlink" title="字符界面下组群账户的设置"></a>字符界面下组群账户的设置</h4><p>在Linux系统字符界面下创建、修改以及删除组群账户主要使用groupadd，groupmod<br>和groupdel这3个命令。</p><h5 id="创建组群账户"><a href="#创建组群账户" class="headerlink" title="创建组群账户"></a>创建组群账户</h5><p>命令语法：<code>groupadd [-g gid [-o]] [-f] [组群名]</code></p><p>默认创建的是用户群组，即默认分配的GID大于等于1000，可以通过-g指定GID；-r选项可以创建系统群组，即默认分配的GID小于1000</p><h5 id="修改组群账户"><a href="#修改组群账户" class="headerlink" title="修改组群账户"></a>修改组群账户</h5><p>命令语法：<code>groupmod [-g &lt;组群识别码&gt; &lt;-o&gt;][-n &lt;新组群名称&gt;] [组群名称]</code></p><h5 id="删除组群账户"><a href="#删除组群账户" class="headerlink" title="删除组群账户"></a>删除组群账户</h5><p>命令语法：<code>groupdel [组群名称]</code></p><h3 id="账户相关文件或目录"><a href="#账户相关文件或目录" class="headerlink" title="账户相关文件或目录"></a>账户相关文件或目录</h3><h4 id="etc-skel目录"><a href="#etc-skel目录" class="headerlink" title="/etc/skel目录"></a>/etc/skel目录</h4><p>/etc/skel目录是存放用户启动文件的目录，这个目录由root用户管理，当管理员创建新用户时，这个目录下的文件会自动复制到新创建的用户的主目录下。/etc/skel目录下的文件都是隐藏文件，也就是类似“ .file” 格式的，可以通过添加、修改和删除/etc/skel目录下的文件，来为用户提供一个统一、标准和默认的用户环境。</p><h4 id="etc-login-defs配置文件"><a href="#etc-login-defs配置文件" class="headerlink" title="/etc/login.defs配置文件"></a>/etc/login.defs配置文件</h4><p>/etc/login.defs文件规定了<strong>创建新用户时的一些默认设置</strong>，比如创建用户时是否需要主目录、 UID和GID的范围、用户账户口令的期限等，这个文件可以通过root用户来修改</p><h4 id="etc-default-useradd文件"><a href="#etc-default-useradd文件" class="headerlink" title="/etc/default/useradd文件"></a>/etc/default/useradd文件</h4><p>/etc/default/useradd文件是在使用useradd命令创建用户账户时的规则文件</p><h3 id="用户和组群维护命令"><a href="#用户和组群维护命令" class="headerlink" title="用户和组群维护命令"></a>用户和组群维护命令</h3><h4 id="账户维护命令"><a href="#账户维护命令" class="headerlink" title="账户维护命令"></a>账户维护命令</h4><h5 id="passwd命令"><a href="#passwd命令" class="headerlink" title="passwd命令"></a>passwd命令</h5><p>使用passwd命令可以设置或修改用户的口令，普通用户和超级权限用户都可以运行passwd。<strong>普通用户只能更改自己的用户口令</strong>，root用户可以设置或修改任何用户的口令。如果passwd命令后面<strong>不接任何选项或用户名，则表示修改当前用户的口令</strong>。</p><p>命令语法：<code>passwd [选项] [用户名]</code></p><p>可以使用-l选项来锁住某个用户的口令，这样该用户就无法登录，但是可以从其他用户中通过su切换到被锁定的用户，被锁定的用户口令前面有<code>!</code>标识（Ubuntu系统，其他系统可能会有差异，比如Fedora17系统上是双感叹号<code>!!</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test:!$6$N8tiFTQb$ViLVGgYXVKoOIdIcoXVfmug5tOfzwIVoeKia4uY6Wtw6n0sIEs1uTf9Ff6DI1.iOPX6/jzs.CDus8h.x6AonJ.:18106:0:99999:7:::</span><br></pre></td></tr></table></figure><p>可以使用-u选项来解锁某用户的口令；-d是直接删除某用户的口令，使其无法登录系统。</p><h5 id="gpasswd命令"><a href="#gpasswd命令" class="headerlink" title="gpasswd命令"></a>gpasswd命令</h5><p>使用gpasswd命令可以设置一个组群的组群密码，或是在组群中添加、删除用户。</p><p>命令语法：<code>gpasswd [-r|-R][组群名]</code> <code>gpasswd [选项][用户名][组群名]</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux系统基础&quot;&gt;&lt;a href=&quot;#Linux系统基础&quot; class=&quot;headerlink&quot; title=&quot;Linux系统基础&quot;&gt;&lt;/a&gt;Linux系统基础&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;此文章是根据南大软院曾老师的《Linux系统基础》课程pp
      
    
    </summary>
    
      <category term="linux" scheme="http://QQ876684433.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://QQ876684433.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Java分布式应用知识点</title>
    <link href="http://QQ876684433.github.io/2019/07/24/Java%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://QQ876684433.github.io/2019/07/24/Java分布式应用知识点/</id>
    <published>2019-07-24T15:10:12.000Z</published>
    <updated>2019-09-15T05:02:14.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java分布式应用知识点"><a href="#Java分布式应用知识点" class="headerlink" title="Java分布式应用知识点"></a>Java分布式应用知识点</h1><h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><blockquote><p>来源：问题<a href="https://www.zhihu.com/question/22764869下的回答" target="_blank" rel="noopener">https://www.zhihu.com/question/22764869下的回答</a></p><p>知乎用户——by <a href="https://www.zhihu.com/people/yongxinge" target="_blank" rel="noopener">用心阁</a> 软件工程师</p></blockquote><ul><li><p>网络通讯，网络是分布式的基础，对分布式的理解建立在对网络的理解上，包括：</p></li><li><ul><li>OSI模型的7层</li><li>TCP/IP，DNS，NAT</li><li>HTTP，SPDY/HTTP2</li><li>Telnet</li></ul></li><li><p>网络编程，是通过程序在多个主机之间通信。包括：</p></li><li><ul><li><p>Socket</p></li><li><p>多线程</p></li><li><p>非阻塞IO</p></li><li><p>网络框架</p></li><li><ul><li>Netty</li><li>Mina</li><li>ZeroMQ</li></ul></li></ul></li><li><p>操作系统的网络部分</p></li><li><p>RPC，Socket使用不是很方便，很多分布式应用是基于RPC的，包括：</p></li><li><ul><li><p>同步RPC</p></li><li><p>异步RPC</p></li><li><p>主要的一些RPC协议</p></li><li><ul><li>RMI</li><li>Rest API</li><li>Thrift</li></ul></li></ul></li><li><p>集群，分布式计算离不开集群。集群就是多台主机被当作一个系统</p></li><li><ul><li><p>集群类型</p></li><li><ul><li>高可用，如主机备机切换，冷备，热备，双活</li><li>伸缩性，如Web服务器集群，数据库服务器的Sharding</li><li>并行计算，如网格，大数据</li></ul></li><li><p>集群相关技术，包括：</p></li><li><ul><li><p>高可用性，保证服务一直能够被访问，延长MTBF，缩短MTTR</p></li><li><ul><li>冗余的设备</li><li>多副本，为了避免单点失效</li></ul></li><li><p>负载均衡，如何将大量工作负载分配到多个主机上，最大化吞吐量，最小化平均响应时间，最大化资源利用率。</p></li><li><p>伸缩性（横向），能够添加计算机和设备来应对增长的计算压力</p></li><li><p>分片（Sharding），把数据分成多个数据集，由多个服务器来分别处理。</p></li><li><ul><li>自动分片</li></ul></li><li><p>容错性，当硬件或软件发生故障，能够继续运转</p></li><li><p>故障检测，以及故障预测</p></li><li><ul><li>心跳包</li><li>告警</li><li>性能预警</li></ul></li><li><p>故障转移，当出现错误，如何解决，为了高可用性和容错性</p></li><li><p>分布式一致性，在分布式环境中如何维持状态的一致性，严格一致性，还是最终一致性</p></li><li><p>集群状态协调，如Zookeeper，etcd等。</p></li><li><ul><li>分布式锁，在分布式环境中如何进行加锁</li><li>选主，当Master宕机，如何选择出新的Master，协议如Raft</li></ul></li><li><p>一致性哈希，如何将数据分布到集群中的多个主机。</p></li><li><p>分布式事务，保证在多台服务器上完成的操作符合事务的ACID属性。</p></li></ul></li></ul></li><li><p>安全，网络通常需要保证安全。</p></li><li><ul><li><p>身份认证，如何验证人或机器是他们声明的身份</p></li><li><ul><li>基于用户名/口令</li><li>基于数字证书</li></ul></li><li><p>私密性，如何防止窃听和嗅探</p></li><li><ul><li>对称加密</li><li>非对称加密</li></ul></li><li><p>完整性，如何保证数据不被篡改</p></li><li><ul><li>安全散列</li><li>消息认证码（MAC）</li></ul></li><li><p>不可否认性</p></li><li><ul><li>基于数字证书的数字签名和验签</li><li>基于密钥的散列，如HMAC</li></ul></li></ul></li><li><p>互联网站的基本架构</p></li><li><ul><li>页面缓存</li><li>负载均衡器，如HAProxy,Nginx</li><li>分布式缓存，如Memcache，Redis</li><li>消息队列，如ActiveMQ，Kafka</li></ul></li><li><p>分布式框架</p></li><li><ul><li><p>关系型数据库（Sharding，主从同步）</p></li><li><p>NoSQL</p></li><li><ul><li>HBase，基于HDFS和Zookeeper的NoSQL</li><li>Cassandra，无主集群</li></ul></li><li><p>大数据</p></li><li><ul><li>HDFS，分布式文件系统</li><li>MapReduce，将数据处理任务拆分为多个工作，通过集群来完成。</li><li>Spark，提供分布式的数据集抽象</li></ul></li></ul></li></ul><h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><ul><li>大型分布式网站架构设计与实践</li><li>大型网站技术架构：核心原理与案例分析</li><li>大型网站系统与Java中间件实践</li><li>分布式Java应用：基础与实践</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java分布式应用知识点&quot;&gt;&lt;a href=&quot;#Java分布式应用知识点&quot; class=&quot;headerlink&quot; title=&quot;Java分布式应用知识点&quot;&gt;&lt;/a&gt;Java分布式应用知识点&lt;/h1&gt;&lt;h2 id=&quot;相关知识点&quot;&gt;&lt;a href=&quot;#相关知识点&quot; c
      
    
    </summary>
    
      <category term="分布式" scheme="http://QQ876684433.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="分布式" scheme="http://QQ876684433.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>精读Servlet源码-javax.servlet.ServletContext</title>
    <link href="http://QQ876684433.github.io/2019/07/19/%E7%B2%BE%E8%AF%BBServlet%E6%BA%90%E7%A0%81-javax-servlet-ServletContext/"/>
    <id>http://QQ876684433.github.io/2019/07/19/精读Servlet源码-javax-servlet-ServletContext/</id>
    <published>2019-07-19T02:27:59.000Z</published>
    <updated>2019-09-15T05:02:14.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精读Servlet源码-javax-servlet-ServletContext"><a href="#精读Servlet源码-javax-servlet-ServletContext" class="headerlink" title="精读Servlet源码-javax.servlet.ServletContext"></a>精读Servlet源码-javax.servlet.ServletContext</h1><blockquote><p>参考：</p><p><a href="https://www.cnblogs.com/smyhvae/p/4140877.html" target="_blank" rel="noopener">https://www.cnblogs.com/smyhvae/p/4140877.html</a></p><p><a href="https://blog.csdn.net/gavin_john/article/details/51399425" target="_blank" rel="noopener">https://blog.csdn.net/gavin_john/article/details/51399425</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;精读Servlet源码-javax-servlet-ServletContext&quot;&gt;&lt;a href=&quot;#精读Servlet源码-javax-servlet-ServletContext&quot; class=&quot;headerlink&quot; title=&quot;精读Servlet源码-
      
    
    </summary>
    
      <category term="源码" scheme="http://QQ876684433.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="servlet" scheme="http://QQ876684433.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>精读Servlet源码-javax.servlet.ServletConfig</title>
    <link href="http://QQ876684433.github.io/2019/07/19/%E7%B2%BE%E8%AF%BBServlet%E6%BA%90%E7%A0%81-javax-servlet-ServletConfig/"/>
    <id>http://QQ876684433.github.io/2019/07/19/精读Servlet源码-javax-servlet-ServletConfig/</id>
    <published>2019-07-19T01:43:08.000Z</published>
    <updated>2019-09-15T05:02:14.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="精读Servlet源码-javax-servlet-ServletConfig"><a href="#精读Servlet源码-javax-servlet-ServletConfig" class="headerlink" title="精读Servlet源码-javax.servlet.ServletConfig"></a>精读Servlet源码-javax.servlet.ServletConfig</h1><blockquote><p>参考：<a href="https://www.cnblogs.com/smyhvae/p/4140877.html" target="_blank" rel="noopener">https://www.cnblogs.com/smyhvae/p/4140877.html</a></p></blockquote><p><code>ServletConfig</code>的实例是servlet容器在初始化一个servlet时传递到<code>init()</code>方法的对象，它携带了一个servlet的相关配置以及初始化参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A servlet configuration object used by a servlet container</span></span><br><span class="line"><span class="comment"> * to pass information to a servlet during initialization. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="各个接口方法的说明"><a href="#各个接口方法的说明" class="headerlink" title="各个接口方法的说明"></a>各个接口方法的说明</h2><h3 id="getServletName"><a href="#getServletName" class="headerlink" title="getServletName"></a>getServletName</h3><p>返回servlet实例的名称，它可能是在web服务器中由服务器管理者提供的，如果servlet没有被注册到服务中，那么它将返回servlet实例的类名。</p><h3 id="getServletContext"><a href="#getServletContext" class="headerlink" title="getServletContext"></a>getServletContext</h3><p><code>getServletContext</code>返回<code>ServletContext</code>实例的引用，WEB容器在启动时，它会为<strong>每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用</strong>，并且保存在<code>ServletConfig</code>实例中并传递给对应的servlet，通过它可以允许调用者与servlet容器进行交互。</p><h3 id="getInitParameter"><a href="#getInitParameter" class="headerlink" title="getInitParameter"></a>getInitParameter</h3><p>初始化参数在<code>ServletConfig</code>中是以键值对方式存储的，<code>getInitParameter()</code>可以通过给定的参数名字获取对应的参数值，键和值都是以字符串的形式存储；如果对应的参数名字不存在，则返回null。</p><h3 id="getInitParameterNames"><a href="#getInitParameterNames" class="headerlink" title="getInitParameterNames"></a>getInitParameterNames</h3><p>获取所有的初始化参数，以Enumeration类型返回；如果没有，则返回一个空的Enumeration。Enumeration类似于迭代器，Enumeration接口中定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素。</p><h2 id="追根溯源：ServletConfig-vs-ServletContext"><a href="#追根溯源：ServletConfig-vs-ServletContext" class="headerlink" title="追根溯源：ServletConfig vs ServletContext"></a>追根溯源：ServletConfig vs ServletContext</h2><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>从更本质上来看，<code>ServletConfig</code>实际上代表的是当前Servlet在web.xml中的配置信息，在Servlet的配置文件中，可以使用&lt;servlet&gt;标签下的一个或多个&lt;init-param&gt;标签为servlet配置一些初始化参数。&lt;init-param&gt;标签是<strong>为某一个单独的servlet加配置信息，这种配置信息在其他的Servlet中是无法访问到的</strong>。</p><p>当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，程序员通过ServletConfig对象就可以得到当前servlet的初始化参数信息。</p><p>这样做的好处是：如果将数据库信息、编码方式等配置信息放在web.xml中，如果以后数据库的用户名、密码改变了，则<strong>直接很方便地修改web.xml就行了，避免了直接修改源代码的麻烦</strong>。</p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>WEB容器在启动时，它会为<strong>每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用</strong>。</p><p>ServletConfig对象中维护了ServletContext对象的引用，它是由servlet容器提供的，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。</p><p>由于一个WEB应用中的<strong>所有Servlet共享同一个ServletContext对象</strong>，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为<strong>context域对象</strong>。</p><p><u><em>对ServletContext更深入的研究请移步：精读Servlet源码-javax.servlet.ServletContext</em></u></p><h2 id="ServletConfig实例"><a href="#ServletConfig实例" class="headerlink" title="ServletConfig实例"></a>ServletConfig实例</h2><h3 id="编写Servlet"><a href="#编写Servlet" class="headerlink" title="编写Servlet"></a>编写Servlet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletConfigDemo</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletConfig servletConfig = <span class="keyword">this</span>.getServletConfig();</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        resp.setContentType(<span class="string">"text/plain"</span>);</span><br><span class="line"></span><br><span class="line">        String servletName = servletConfig.getServletName();</span><br><span class="line">        out.println(<span class="string">"Servlet name: "</span> + servletName);</span><br><span class="line"></span><br><span class="line">        String username = servletConfig.getInitParameter(<span class="string">"username"</span>);</span><br><span class="line">        String password = servletConfig.getInitParameter(<span class="string">"password"</span>);</span><br><span class="line">        out.println(<span class="string">"=================servletConfig.getInitParameter================"</span>);</span><br><span class="line">        out.println(<span class="string">"username: "</span> + username);</span><br><span class="line">        out.println(<span class="string">"password: "</span> + password);</span><br><span class="line"></span><br><span class="line">        out.println(<span class="string">"=================servletConfig.getInitParameterNames================"</span>);</span><br><span class="line">        Enumeration&lt;String&gt; params = servletConfig.getInitParameterNames();</span><br><span class="line">        <span class="keyword">while</span> (params.hasMoreElements()) &#123;</span><br><span class="line">            String name = params.nextElement();</span><br><span class="line">            out.println(name + <span class="string">": "</span> + servletConfig.getInitParameter(name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletConfigDemo-xxxx<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>servlet.ServletConfigDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>steve_chph<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>password<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>mypassword123456<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>value1<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>name2<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>value2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletConfigDemo-xxxx<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/ServletConfigDemo<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/07/19/5d312f57b095347163.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;精读Servlet源码-javax-servlet-ServletConfig&quot;&gt;&lt;a href=&quot;#精读Servlet源码-javax-servlet-ServletConfig&quot; class=&quot;headerlink&quot; title=&quot;精读Servlet源码-ja
      
    
    </summary>
    
      <category term="源码" scheme="http://QQ876684433.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="servlet" scheme="http://QQ876684433.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>精读Servlet源码-javax.servlet.http.HttpServlet</title>
    <link href="http://QQ876684433.github.io/2019/07/18/%E7%B2%BE%E8%AF%BBServlet%E6%BA%90%E7%A0%81-javax-servlet-http-HttpServlet/"/>
    <id>http://QQ876684433.github.io/2019/07/18/精读Servlet源码-javax-servlet-http-HttpServlet/</id>
    <published>2019-07-18T11:57:50.000Z</published>
    <updated>2019-09-15T05:02:14.670Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="源码" scheme="http://QQ876684433.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Java" scheme="http://QQ876684433.github.io/tags/Java/"/>
    
      <category term="servlet" scheme="http://QQ876684433.github.io/tags/servlet/"/>
    
  </entry>
  
</feed>
