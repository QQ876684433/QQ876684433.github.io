{"meta":{"title":"至繁归于至简 - chph's blog","subtitle":"steve_chph personal website","description":"the blog website of steve_chph, steve_chph的个人博客网站","author":"steve_chph","url":"http://QQ876684433.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-07-14T12:26:19.000Z","updated":"2019-09-15T04:40:38.608Z","comments":false,"path":"categories/index.html","permalink":"http://QQ876684433.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-14T12:26:10.000Z","updated":"2019-09-15T04:40:38.608Z","comments":false,"path":"tags/index.html","permalink":"http://QQ876684433.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-09-15T04:40:38.604Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/09/15/hello-world/","link":"","permalink":"http://QQ876684433.github.io/2019/09/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"152.乘积最大子序列","slug":"152-乘积最大子序列","date":"2019-09-10T03:38:00.000Z","updated":"2019-09-15T04:40:38.600Z","comments":true,"path":"2019/09/10/152-乘积最大子序列/","link":"","permalink":"http://QQ876684433.github.io/2019/09/10/152-乘积最大子序列/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数据库课堂笔记（2019-09-10）","slug":"数据库课堂笔记（2019-09-10）","date":"2019-09-10T03:25:09.000Z","updated":"2019-09-15T04:42:45.108Z","comments":true,"path":"2019/09/10/数据库课堂笔记（2019-09-10）/","link":"","permalink":"http://QQ876684433.github.io/2019/09/10/数据库课堂笔记（2019-09-10）/","excerpt":"","text":"数据库课堂笔记 参考资料： 南大软件学院课程《数据管理基础》课程资料 《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著 《数据库系统概论》第五版 - 王珊 萨师煊 著 《数据库系统概念》 数据库课堂笔记（2019-09-10）Ch2. The Relational Model键、超键和空值（Keys，Superkeys，and Null Values）键（Keys） 条件1说明了任意一行u在属性集K上的值是唯一的；表可能具有不止一个键；关系规则3保证了所有列的集合可以唯一区分任意两行，因此关系中至少存在一个键 超键（Superkeys） 属性集是不是键或者超键，取决于“设计者的意图”，有时候某些属性集在特定时刻它满足条件1，但是可能随着时间的改变，很有可能不再满足该条件，这样的属性集不是键或者超键 空集既不是超键也不是键，因为属性集为空集时无法唯一确定某一行，因为所有行在空集上的取值都是空集 候选键和主键（Candidate Key &amp; Primary Key） 主键是数据库设计者从候选键中选择出来，用来唯一确定数据表某一行的键 它有可能被其他表用来作为对当前表特定行的引用来使用 空值（Null Values）","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"},{"name":"笔记","slug":"数据库/笔记","permalink":"http://QQ876684433.github.io/categories/数据库/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/tags/数据库/"}]},{"title":"软件系统设计02-质量属性策略","slug":"软件系统设计02-质量属性策略","date":"2019-09-09T12:37:15.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/09/09/软件系统设计02-质量属性策略/","link":"","permalink":"http://QQ876684433.github.io/2019/09/09/软件系统设计02-质量属性策略/","excerpt":"","text":"软件系统设计02-质量属性策略第四章 理解质量属性质量属性定义质量属性（Quality Attribute，QA）：它是一个系统可度量或者可测试的属性，用来指示系统在多大程度上满足了它的利益相关者的需求 架构和需求需求的分类 功能性需求（Functional Requirements）：描述了系统必须做的事情（必须实现的功能），以及在运行时接受外部刺激时系统应该表现出的行为或者反应 质量属性需求（Quality Attribute Requirements）：它是功能性需求或者整个产品的质量或者限定条件——对于功能性需求来说，它描述了系统响应有多快或者在接受错误输入时必须具备多大的弹性等；对于整个系统来说，它描述了产品的部署需要的时间或者对运营成本的限制 约束（Constraints）：约束条件是具有零自由度的设计决策，即是说它是一个已经做出的设计决策，不能再修改。例如系统使用的编程语言或者要依赖的指定模块等 不同种类的需求在架构中的体现 功能性需求：通过整个设计中合适的职责分配来满足 质量属性需求：通过设计到架构中的各种结构以及填充这些结构的元素的行为和交互来满足 约束：通过接受设计决策并将其与其他受影响的设计决策进行协调来满足约束条件 功能性需求功能性需求不能决定架构。原因是对于一个给定的功能性需求集合，我们可以有很多不同的方法来将功能性需求划分到不同的架构模块中；事实上，即使我们不划分模块，甚至内部毫无架构结构可言，也依旧有可能将功能性需求实现。 我们进行架构设计是为了使得系统更加易于理解，以便支持各种各样的其他目的——即质量属性需求。 尽管功能性需求独立于特定的系统结构，但是它是通过将系统的职责分配到不同的架构元素中来实现的；虽然职责可以被任意分配到某一个模块中，但是当质量属性占很重要地位的时候，软件架构会约束系统职责的分配。 质量属性考量功能性需求和质量属性都不是自身独立的。 从架构师的角度，系统质量属性会有以下三个问题： 某个质量属性的定义是不可测试的 对质量属性的讨论通常侧重于特定问题所属的质量，而且这个问题往往在不同的质量属性范围中有重叠 每个质量社区都发展出了自己的属性词汇 前两个问题可以通过才用“质量属性场景”这个工具来区分不同的质量属性；第三个问题可以通过对每一个属性的多个社区词汇进行讨论，寻找出某个质量属性的不通社区词汇之间最本质最基础的概念 质量属性分类 系统运行时的属性：可用性（Availability）、性能（Performance）、易用性（Usability）等 系统开发时的属性：可修改性（Modifiability）、可测试性（Testability） 在复杂的系统中，质量属性相互之间不可能是独立开的，一个质量属性的实现对其他质量属性产生或积极或负面的影响，因此在架构设计时需要在这些设计决策之间作出合适的权衡。 制定质量属性需求质量属性需求应当是明确的和可测试的。质量属性表达的常用形式包含这些部分： 刺激（Stimulus）：到达系统的事件，例如易用性中的用户操作，安全性中的外部攻击，可修改性中的修改需求，可测试性中的某个开发阶段的完成等 刺激源（Stimulus source）：不同的刺激源，系统对待和处理的方式会不一样，例如受信任用户和不受信任用户经历的审查是不一样的 响应（Response）：对于刺激，系统应当采取的措施，例如在可修改性的场景中，一个修改需求的到达要求开发者将这个修改需求实现、测试并部署所作出的修改 响应度量（Response measure）：判断系统的响应是否满足需求，例如性能的度量可以是延迟或者吞吐量，可修改性的度量可以是工作量或者修改、测试和部署修改所需的时间等 环境（Environment）：需求的环境是一系列场景发生情况的集合，它充当了刺激的限定词，例如对待代码冻结以发布前后发生的错误，处理的方式是不一样的 工件（Artifact）：它是系统中需求适用的部分，不同的问题，它可能影响整个系统，也有可能只影响系统的某一个部分，例如数据库出错和元数据库出错的处理方式是不一样的，用户接口的修改需求和中间件的修改需求所需要的时间也是不一样的，等等 质量属性需求可以划分为六个场景，它们可能单独发生，也有可能伴随发生，特别是系统架构设计初期 质量属性场景示例图 通过策略来实现质量属性需求架构策略（Architectural Tactics）架构策略是用来实现需要的质量属性的技术，它是一种设计决策，会影响质量属性响应的实现以及会直接影响系统对某些刺激的响应。策略赋予一种设计可移植性，将性能传递给另一种设计，并将可集成性传递给第三种设计。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"},{"name":"软件系统设计","slug":"笔记/软件系统设计","permalink":"http://QQ876684433.github.io/categories/笔记/软件系统设计/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://QQ876684433.github.io/tags/架构/"}]},{"title":"91.解码方法","slug":"91-解码方法","date":"2019-09-06T11:29:49.000Z","updated":"2019-09-15T04:40:38.600Z","comments":true,"path":"2019/09/06/91-解码方法/","link":"","permalink":"http://QQ876684433.github.io/2019/09/06/91-解码方法/","excerpt":"","text":"91.解码方法原题目如下： 一条包含字母 A-Z 的消息通过以下方式进行了编码： ‘A’ -&gt; 1‘B’ -&gt; 2…‘Z’ -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 输入: “12” 输出: 2 解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。 示例 2: 输入: “226” 输出: 3 解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/decode-ways著作权归领扣网络所有。 解题思路这道题刚开始做的时候思路是挺清晰的，就是动态规划，从左往右遍历一遍即可。对于一个长度为n的串s，由于编码只有一位数和两位数这两种可能，因此很容易得出 1numDecodings(s[1:n]) = numDecodings(s[1:n-1]) + numDecodings(s[1:n-2]) 当然不是直接相加那么简单，这要分情况讨论一下： （1）如果s[i]非0（由题可知，0不是合法的编码），s[1:n]一定可以按照在s[1:n-1]的所有解码方式后面加上s[i]来解码 （2）如果s[i-1]s[i]是合法的编码（即10&lt;=int(s[i-1]s[i])&lt;=26，大于等于10的是因为01、02等待这种以0开头的两位数不是合法的编码），那么s[1:n]也一定可以按照在s[1:n-2]的所有解码方式后面加上s[i-1]s[i]来得到 （3）否则上面两种情况都不符合，那么s[1:n]无论如何也无法进行解码，比如出现连续两个0的情况 我当时做的时候，因为没有考虑编码串中出现0的情况，所以出现了偏差。另外，由于前面做题的惯性思维，动态规划问题老是想构造数组，后来细细想这道题才发现根本不需要那么大的空间开销，只需要记录dp[i-1]和dp[i-2]即可计算出dp[i]。最终的解决方案如下： 1234567891011121314151617181920class Solution &#123;public: int numDecodings(string s) &#123; int n = s.size(); if(s.empty()) return 0; if(n==1) return s[0]!='0'; unsigned long long prev = 1, target = s[0]=='0'?0:1; for(int i = 1;i&lt;n;i++)&#123; unsigned long long temp = 0; if(s[i]!='0') temp = target; // int val = (s[i-1]-'0')*10+(s[i]-'0'); // if(val&gt;=10&amp;&amp;val&lt;=26) temp+=prev; if(s[i-1]=='1'||s[i-1]=='2'&amp;&amp;(s[i]&lt;='6'))temp+=prev; prev = target; target = temp; &#125; return target; &#125;&#125;; 测评的结果如下，然后我看了一下最高分的解答，思路跟我的差不多，就没必要去优化了 题解题解没什么比较新的角度，跟我的想法差不多，就不再赘述","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"63.不同路径II","slug":"63-不同路径II","date":"2019-09-04T13:20:26.000Z","updated":"2019-09-15T04:40:38.600Z","comments":true,"path":"2019/09/04/63-不同路径II/","link":"","permalink":"http://QQ876684433.github.io/2019/09/04/63-不同路径II/","excerpt":"","text":"63.不同路径II原题目如下： 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1: 输入:[ [0,0,0], [0,1,0], [0,0,0]] 输出: 2 解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径： 123&gt; 1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下&gt; 2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右&gt; 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-paths-ii著作权归领扣网络所有。 解题思路这道题与前一道题的区别只在于输入的二维数组增加了障碍物这一限制条件，只要在之前的思路（详见前面的链接）上稍作修改即可，用m和n分别表示输入的数组的行和列，我自己当时的解题思路如下： 采用自底向上的递推方式，还是采用一位数组来降低空间开销，将dp数组初始化为包含m个元素的数组，然后将最后一个元素设置为1，原因是从最底层走，不考虑障碍物的情况下，只有一条路径能够到达目的地（后来发现出现的问题就是，如果目的地就是障碍物的话，这样是无法AC的，所以在开始推导的最开始直接排除了这种情况if(obstacleGrid[m-1][n-1]==1) return 0;，省事） 推导的核心公式是dp[j] = dp[j]+dp[j+1];，所以存在边界的问题，因此限定0 ≤ j ≤ m-2，而j = m-1的情况（即最底层）单独判断：如果在点obstacleGrid[m-1][i]遇到障碍物，则将dp数组的最后一个元素设置为0，表示从最底层小于等于点i的开始走，必然无法走到目的地 如果不是在最底层遇到障碍物（设为点obstacleGrid[j][i]），则只需要将dp[j]设置为0，表示从该点开始走，无法走到目的地，对其他路径的贡献为0 所以最终的解决方案如下： 12345678910111213141516171819202122class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); if(obstacleGrid[m-1][n-1]==1) return 0; vector&lt;long&gt; dp(m-1, 0); dp.push_back(1); for(int i = n-1;i&gt;=0;i--)&#123; if(obstacleGrid[m-1][i]==1)&#123; dp[m-1] = 0; &#125; for(int j = m-2;j&gt;=0;j--)&#123; if(obstacleGrid[j][i]==0)&#123; dp[j] = dp[j]+dp[j+1]; &#125;else&#123; dp[j] = 0; &#125; &#125; &#125; return dp[0]; &#125;&#125;; 提交之后，虽然AC了，但是感觉有点不够优雅： ps：这里有个坑是大数组的输入，如果使用vector&lt;int&gt;会溢出，改用vector&lt;long&gt;就可以了，这个也是没办法的 题解思路一学习了leetcode官方的题解后发现自己的思路局限在了自底向上的角度，实际上自顶向下和自底向上最终的 结果是一样的，但使用自顶向下似乎更有助于思考问题。 最关键的问题还是集中在遇到障碍物时采取的措施上，因为题目没有要求输入数据不能修改，可以直接使用obstacleGrid作为dp数组，达到最优化空间复杂度，这样dp递推方程就变成了： 1obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]; 而当obstacleGrid[i][j]是障碍物时，可直接将其置0： 如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。 这个可以体现在上面的递推方程上。即使是这样，还是避免不了边界条件的处理，这里就不展开了。 思路二归根结底，解法不优雅的根源是边界问题的处理，所以也可以通过在原有的数组行列上各添加一维全0的数据，这样就比较优雅了。","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"62.不同路径","slug":"62-不同路径","date":"2019-09-04T11:37:53.000Z","updated":"2019-09-15T04:40:38.600Z","comments":true,"path":"2019/09/04/62-不同路径/","link":"","permalink":"http://QQ876684433.github.io/2019/09/04/62-不同路径/","excerpt":"","text":"62.不同路径原题目如下： 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 输入: m = 3, n = 2 输出: 3 解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右 示例 2: 输入: m = 7, n = 3 输出: 28 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-paths 解题思路这道题一看就是很典型的动态规划问题，一般来说都可以从填表入手，动态规划方程： 1dp[i][j] = dp[i-1][j] + dp[i][j-1] 所以可以从初始状态开始（即finish处开始）推导填表，最后得到的就是问题的解。举个简单的例子，m=7，n=3（其实m和n是可以互换的对结果没有影响）： 这样就可以通过一个二维数组来解决问题。一般来说二维数组开销太大，而且往往都能够通过压缩成一维数组来解决，因为dp[i][j]计算出来之后，dp[i-1][j]和dp[i][j-1]的值就不再需要了，所以最终的解答如下： 123456789101112class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;int&gt; dp(m, 1); for(int i = 1;i&lt;n;i++)&#123; for(int j = 1;j&lt;m;j++)&#123; dp[j] = dp[j]+dp[j-1]; &#125; &#125; return dp[m-1]; &#125;&#125;; 一次AC，惊喜满满： 题解题解给出的方案和我的差不多，这里就没必要展开了，但是里面提供了一个数学角度的解决方案： 思路：排列组合 因为机器到底右下角，向下几步，向右几步都是固定的， 比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。 所以有 C_{m+n-2}^{m-1}Cm+n−2m−1 作者：powcai 链接：https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/ 来源：力扣（LeetCode）","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"数据库课堂笔记（2019-09-03）","slug":"数据库课堂笔记（2019-09-03）","date":"2019-09-03T11:53:37.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/09/03/数据库课堂笔记（2019-09-03）/","link":"","permalink":"http://QQ876684433.github.io/2019/09/03/数据库课堂笔记（2019-09-03）/","excerpt":"","text":"数据库课堂笔记 参考资料： 南大软件学院课程《数据管理基础》课程资料 《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著 《数据库系统概论》第五版 - 王珊 萨师煊 著 《数据库系统概念》 数据库课堂笔记（2019-09-03）Ch1. Introduction术语 数据库管理系统（DataBase Management System，DBMS） Connolly and Begg define Database Management System (DBMS) as a “software system that enables users to define, create, maintain and control access to the database“. … The core functionality is the storage, retrieval and update of data. The database management system (DBMS) is the software that interacts with end users, applications, and the database itself to capture and analyze the data. —— from wikipedia 简单理解就是，数据库管理系统是终端用户、应用程序同数据库本身交互的软件 数据库（Database） A database is an organized collection of data, generally stored and accessed electronically from a computer system. Where databases are more complex they are often developed using formal design and modeling techniques. —— from wikipedia 简单理解就是，数据库是一个有组织的数据集合 数据库用户（DataBase User） 最终用户——交互式用户 临时用户——用SQL访问DBMS的用户 初级用户——通过菜单访问DBMS的用户 应用程序员——编写菜单程序的程序员 数据库管理员（Database Administrator，DBA）——管理DBMS的专家 数据库系统的架构 主要有两层C/S架构和三层B/S架构两种： 两层C/S架构：数据库和DBMS运行在数据库服务器，数据库应用程序运行在客户机中，两者之间通过局域网实现数据访问（但是更多的时候， 数据库服务器及其应用程序可能分布在距离遥远的不同地方，这是得使用三层B/S架构来解决） 三层B/S架构：数据库和DBMS运行在数据库服务器中，数据库应用程序运行在应用服务器（也称“Web服务器”）中， 用户客户端只需要安装常用的浏览器， 负责接收用户输入和结果展示 数据模型数据模型（data model）是对现实世界数据特征的抽象，它是数据库系统的核心和基础。根据应用的不同目的可以划分为两大类：第一类是概念模型，第二类是逻辑模型和物理模型。 概念模型：按用户的观点来对数据和信息进行建模，主要用于数据库设计 逻辑模型：按计算机系统的观点对数据建模，主要用于数据库管理系统的实现 物理模型：对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法 概念模型 实体（entity）：客观存在并可互相区别的事物 属性（attribute）：实体所具有的某一特性 码（key）：唯一标识实体的属性集 实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体 实体集（entity set）：同一类型实体的集合 联系（relationship）：实体之间的联系通常是指不同实体集之间的联系，具有一对一、一对多和多对多等多种类型 概念模型的表示方法：实体-联系方法（Entity-Relationship approach），E-R方法也称为E-R模型 数据模型的组成要素： 数据结构：数据库的组成对象以及对象之间的联系 数据操作：对数据库汇总各种对象的实例运行执行的操作的集合，包括操作以及有关的操作规则 数据的完整性约束条件：一组完整性规则 常见的数据模型层次数据模型（Hierarchical Data Model ）满足两个条件： 有且只有一个结点没有双亲结点，这个结点称为根结点 根以外的其他结点有且只有一个双亲结点 层次模型中，每个结点表示一个记录类型，记录类型之间的联系用结点之间的有向边表示，这种联系是父子之间的一对多的联系，可以看做有向树结构 网状数据模型（Network Data Model）满足两个条件： 允许一个以上的结点无双亲 一个结点可以有多于一个的双亲 层次模型中子女结点与双亲结点的关系是唯一的，在网状模型中，这种关系可以不唯一 关系模型（Relational Model）从用户的观点看，关系模型由一组关系组成，每个关系的数据结构都是一张规范化的二维表： 关系：一个关系对应通常说的一张表 元组：表中的一行即为一个元组 属性：表中的一列即为一个属性 码：也称为码键，它是表中的某个属性组，可以唯一确定一个元组 域：域是一组具有相同数据类型的值集合，属性的取值范围来自某个域 分量：元组中的一个属性值 关系模式：对关系的描述，通常表示为关系名(属性1，属性2，属性3，...，属性n) 面向对象模型（Object-Oriented Model）对象关系模型（Object-Relational Model）Ch2. The Relational ModelCAP数据库 术语 数据模型（Data Model）：也称为数据库模型 它是一组描述如何用计算机化的信息表示现实世界中的数据的定义 也描述了访问和更新这些信息的操作类型 数据库（Database）：表（Table），或者说关系（Relation）的集合 表的标题（Table Heading）：表的列名（Column Name）集合，又称为模式（Scheme） 表的行（Row）集合：也就是元组（Tuple）的集合，称为表的内容，表的行数称为表的基数 数据库各部分的命名由于数据库的行是经常改变的，而列通常来说不会改变，一般推荐数据库用户使用列来进行数据库查询 程序数据独立性（Program-Data Independence ） when asked to make up a query to answer aquestion, query must still answer thequestion even if all the data changes. 查询语句和表的数据无关，二者是相互独立的，即使数据库中的表数据改变了，原有的查询依然能够执行（但是查询结果可能发生了改变） 域类型（Column type，也称 Domain和 Datatype） 大多数商业数据库系统都不支持有枚举集组成的类型（如city，month等），它体现了数据库的完整性约束（Integrity） 域完整性（Domain Integrity）域完整性是指保证指定列的数据具有正确的数据类型、格式和有效的数据范围。 particular type 例子：Domain(city in CUSTOMERS) vsDomain(city in AGENTS) ? 关系代数（Relational Algebra ）数据表中的列的域类似于大多数编程语言中的枚举类型 笛卡尔积数学上的笛卡尔积定义： 但是数据表的关系——即行的集合并没有包含数据表所有列的笛卡尔积中的所有元素，一般来说有如下关系： 关系规则数据库范式（Database Normalization）：一张数据表的表结构所符合的某种设计标准的级别。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。 数据库三大范式： 第一范式（1NF）：First Normal Form Rule数据表的列不允许有多值属性（重复的域）或者属性具有内部结构，也就是说要求列属性是原子的。 columns that have multi-valued attributes (repeating fields) or have any internal structure (record) are not permitted 以这个数据表为例，name具有内部结构，enrollment是多值属性（重复的域）（实际上enrollment也具有内部结构） 它有两方面的含义： 多值属性（重复的域）意思是某个属性的取值是某些元素的列表或者集合，例如第一行中的enrollment属性取值是((101, No), (108, Yes))，它是元素(cno, major)的列表或集合，解决方法有三种： 将多值属性拆分成多个属性 -&gt;（浪费空间并使得查询变得困难） 将具有多值属性的行（元组），按照多值属性的值集合拆分成多个行（元组）来表示，新的元组不再包含多值属性，这些元组在该属性的取值的集合等于原多值属性取值 -&gt; （包含大量冗余数据，浪费空间） 将多值属性和其他属性分拆到两个不同的表中，通过表的join运算来获得原数据表 -&gt;（最常用的操作） 内部结构意思是某个属性的取值不是原子的，或者是不是基本类型，例如name属性具有内部结构(name.Iname, name.fname)，解决方法是： ps：第一范式规则被对象-关系数据库系统的数据表打破，这些表是非第一范式（NFNF）。 第二范式（2NF）：Access Rows by Content Only Rule只能基于内容存取行的规则，说明我们只可以通过行的内容即每一行中所存在的属性值来检索列 can only retrieve rows by their content, the attribute values that exist in each row. 它暗示了： 行是无序的：即使用行号来访问数据表中指定行是无意义的 列是无序的：2NF中没有指明需要根据一定的属性次序来访问指定行 ps：大多数的关系型数据库产品打破了这条规则，允许用户通过RID-row ID来访问行；而且新的对象-关系数据库产品有refs语法允许某一行上列值指向另一行。 第三范式（3NF）：The Unique Row Rule行唯一性规则，它要求关系中任何两个元组的值在同一时刻不能是完全相同的，也就是说关系是元组的无序集合","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"},{"name":"笔记","slug":"数据库/笔记","permalink":"http://QQ876684433.github.io/categories/数据库/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/tags/数据库/"}]},{"title":"J.U.C-深入理解ConcurrentHashMap原理","slug":"J-U-C-深入理解ConcurrentHashMap原理","date":"2019-08-09T04:21:56.000Z","updated":"2019-09-15T04:40:38.600Z","comments":true,"path":"2019/08/09/J-U-C-深入理解ConcurrentHashMap原理/","link":"","permalink":"http://QQ876684433.github.io/2019/08/09/J-U-C-深入理解ConcurrentHashMap原理/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"深入理解红黑树","slug":"深入理解红黑树","date":"2019-08-09T04:20:24.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/08/09/深入理解红黑树/","link":"","permalink":"http://QQ876684433.github.io/2019/08/09/深入理解红黑树/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java NIO学习笔记","slug":"Java NIO学习笔记","date":"2019-07-25T12:51:09.000Z","updated":"2019-09-15T04:40:38.600Z","comments":true,"path":"2019/07/25/Java NIO学习笔记/","link":"","permalink":"http://QQ876684433.github.io/2019/07/25/Java NIO学习笔记/","excerpt":"","text":"Java NIO学习笔记 参考资料：https://nio.hacktons.cn/java-nio-tutorial.html 本文是上述有关Java NIO资料的学习笔记","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"NIO","slug":"NIO","permalink":"http://QQ876684433.github.io/tags/NIO/"}]},{"title":"Linux系统基础","slug":"Linux系统基础","date":"2019-07-25T01:34:24.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/25/Linux系统基础/","link":"","permalink":"http://QQ876684433.github.io/2019/07/25/Linux系统基础/","excerpt":"","text":"Linux系统基础 此文章是根据南大软院曾老师的《Linux系统基础》课程ppt的学习笔记整理 推荐：http://man.linuxde.net/ ，关于Linux命令大全的实用网站 认识Linux系统Linux系统的组成Linux系统一般有4个主要部分：内核、Shell、文件系统 和 应用程序 内核内核是操作系统的核心，Linux内核的主要模块包括：存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等几个部分 shellShell是系统的用户界面，提供了用户与内核进行交互操作的一种接口，它接收用户输入的命令并把它送入内核去执行 文件系统文件系统是文件存放在磁盘等存储设备上的组织方法，Linux系统能支持多种目前流行的文件系统，如ext3、 ext4、 FAT、 FAT32、VFAT和ISO9660等 应用程序包括文本编辑器、编程语言、 X Window、办公软件、 Internet工具和数据库等的程序集 Linux系统与Windows系统的比较共性 多用户操作系统 ​ 这里补充一点，摘录自https://blog.csdn.net/yangkuiwu/article/details/53224239 ​ 1.单用户、多用户。根据在同一时间使用计算机用户的多少，操作系统可分为单用户操作系统和多用户操作系统。单用户操作系统是指一台计算机在同一时间只能由一个用户使用，*一个用户独自享用系统的全部硬件和软件资源，*而如果在同一时间允许多个用户同时使用计算机，则称为多用户操作系统。 ​ 2.单任务、多任务。用户在同一时间可以运行多个应用程序（每个应用程序被称作一个任务），则这样的操作系统被称为多任务操作系统。如果一个用户在同一时间只能运行一个应用程序，则对应的操作系统称为单任务操作系统。 ​ 现代操作系统一般属于多用户、多任务的操作系统，也就是说，同一台机器可以为多个用户建立各自的账户，也允许拥有这些账户的用户同时登录这台计算机，每个账号可以同时运行多个程序。 ​ 多个用户能够同时访问和使用同一台计算机，其中的一个用户具有管理所有这些用户账户和整个计算机的资源的权限，在Windows上，这个具有管理其他用户和计算机资源的用户一般叫administrator，而在Linux上一般叫做root。 ​ 个人计算机操作系统早期一般都是单用户操作系统，其主要特点是在某一时间为单个用户服务。早期的DOS操作系统是单用户单任务操作系统，Windows XP则是单用户多任务操作系统。Linux、UNIX是多用户多任务操作系统。现在常用的Windows操作系统都是多用户、多任务的操作系统，使用最广泛的win7，win10都是多用户，多任务操作系统。 支持多种文件系统 支持多种端口和设备 支持联网功能 服务 区别 总结一下，Linux独有的特点如下： 定位于网络操作系统，Linux的系统配置文件和数据都以文本为基础 可选图形化界面 Linux系统不使用文件扩展名来识别文件的类型，而是使用文件的头内容来识别其类型 除了Linux内核，其他软件的安装、启动、停止和重新配置都不用重新引导系统（即不需要重启） Linux系统下的命令、文件和口令等都区分大小写 Linux版本Linux的版本号分为两部分，即内核版本与发行版本 Linux内核版本内核版本号由3个数字组成： r.x.y r：目前发布的内核主版本。 x：偶数表示稳定版本；奇数表示开发版本。 y：错误修补的次数。 Linux发行版本一些组织和厂家，将Linux系统的内核、应用软件和文档包装起来，并提供一些系统安装界面、系统配置设定管理工具，就构成了Linux发行版本最著名的便是Red Hat公司开发的Red Hat系列以及社区组织开发的Debian系列发行版本 Linux系统的安装与删除Linux系统下硬盘的基本知识分区命名方案Linux系统使用字母和数字的组合来指代硬盘分区，命名方案是基于文件的，文件名的格式为/dev/xxyN /dev/：这是Linux系统下所有设备文件所在的目录名。 xx：分区名的前两个字母表示分区所在设备的类型，通常是hd（ IDE硬盘）或sd（ SCSI硬盘）。 y：这个字母表示分区所在的设备。 N：最后的数字N代表分区。 例如：/dev/sda1表示这个分区在sd类型的设备上，如果有多个sd类型设备，那么该分区是在编号为a的设备上的分区1中 磁盘分区和挂载目录分区是Linux系统上一组文件和目录的存储区，它通过挂载来实现，挂载是将分区关联到某一目录的过程，挂载分区使起始于这个指定目录（通称为挂载目录）的存储区能够被使用 /boot分区：用来存放与Linux系统启动有关的程序，比如启动引导装载程序等 /usr分区：用来存放Linux系统中的应用程序 /var分区：用来存放Linux系统中经常变化的数据以及日志文件 /分区： Linux系统的根目录，所有的目录都挂在这个目录下面 SWAP分区：实现虚拟内存 /home分区：存放普通用户的数据，是普通用户的宿主目录 Linux字符界面操作命令行界面可以通过字符界面、图形界面下的终端以及虚拟控制台等多种方式进入 字符界面很多Linux发行版系统启动默认进入的是图形化界面，可以通过如下指令修改： 1ln -sf 重启后生效，默认进入字符界面，进入字符界面后，超级用户登录后提示符是“ #”，而其他用户登录后提示符是“ $” 虚拟控制台Linux系统提供了虚拟控制台的访问方式使得允许多个用户同时登录，还允许用户进行多次登录 在字符界面下，虚拟控制台的切换可以通过按下[Alt+ F1]~ [Alt+ F6]键来实现 在图形界面下，可以使用[Ctrl+Alt+F2]~[Ctrl+Alt+F6]键切换不同的字符虚拟控制台，再使用[Ctrl+Alt+F1]可以切换回图形界面 关闭和重启系统shutdown 参考原文：https://blog.csdn.net/xmc281141947/article/details/61191212 在Linux中可以用Shutdown命令实现自动定时关机的功能，它在Linux系统关闭之前给系统上的所有登录用户提示一条警告信息 命令语法：shutdown [选项] [时间] [警告信息] -h 关闭计算机 -r 重启计算机 -c 取消正在等待的shutdown命令 精确时间的格式是hh:mm，表示小时和分钟。时间段（延迟）由“+” 和“分钟数”表示。系统执行该命令后会自动进行数据同步的工作。时间部分如果是now，则上述命令则立即执行，否则延迟默认60s或者设定的时间 具体例子： 1、Shutdown -r now 关机后重启 2、Shutdown -h now 关机后不重启 3、Shutdown -r +11 11分钟后重启 4、Shutdown -r 11:00 11点钟重启 5、Shutdown -h +11 11分钟后关机 6、Shutdown -h 11:00 11点钟关机 halt“ halt” 命令就是调用“ shutdown–h”命令执行关闭系统，它是立即执行 reboot“reboot”命令就是调用“shutdown -r”命令来重启系统，它是立即执行 init“ init” 命令是所有进程的祖先，它的进程号始终为“ 1” ，所以发送“ TERM” 信号给“ init” 会终止所有的用户进程和守护进程等。“ shutdown” 命令就是使用这种机制。“init”定义了7个运行级别： 0 Halt Shuts down the system. 1 Single-user mode Mode for administrative tasks.（注意这里，说明系统返回的shell有root权限） 2 Multi-user mode Does not configure network interfaces and does not export networks services. 3 Multi-user mode with networking Starts the system normally. 4 Not used/user-definable For special purposes. 5 Start the system normally with appropriate display manager (with GUI) Same as runlevel 3 + display manager. 6 Reboot Reboots the system. 系统运行级别Linux系统的运行级别由列在/etc/rc.d/rc&lt;x&gt;.d目录中的服务来定义，其中&lt;x&gt;是代表运行级别的符号，七种运行级别的定义如下： 0：停止运行，所有进程中止，关闭系统。 1：单用户模式，用于维护系统，只有少数进程运行。 2：多用户模式，除了NFS服务没有启动外，其他和运行级别3一样。 3：完整的多用户模式，进入Linux系统的字符界面。 4：没有使用（可由用户定义）。 5：完整的多用户模式（带有基于X Window的图形界面）。 6：重新引导计算机。 可以在使用runlevel命令查看当前的运行级别 12steve@ubuntu-17-10:~$ runlevel N 5 表示当前运行级别是5，N表示没有上一次运行级别 其他一些常用命令man获取shell命令的帮助手册，命令语法：man [选项] [命令名称] help可以通过help来获取shell命令的用法，命令语法：[命令] ––help which, whereis, locate, find 来源：https://zhuanlan.zhihu.com/p/35727707 which：常用于查找可直接执行的命令。只能查找可执行文件，该命令基本只在$PATH路径中搜索，查找范围最小，查找速度快。默认只返回第一个匹配的文件路径，通过选项 -a 可以返回所有匹配结果。 whereis：不只可以查找命令，其他文件类型都可以（man中说只能查命令、源文件和man文件，实际测试可以查大多数文件）。在$PATH路径基础上增加了一些系统目录的查找，查找范围比which稍大，查找速度快。可以通过 -b 选项，限定只搜索二进制文件。 locate：超快速查找任意文件。它会从linux内置的索引数据库查找文件的路径，索引速度超快。刚刚新建的文件可能需要一定时间才能加入该索引数据库，可以通过执行updatedb命令来强制更新一次索引，这样确保不会遗漏文件。该命令通常会返回大量匹配项，可以使用 -r 选项通过正则表达式来精确匹配。 find：直接搜索整个文件目录，默认直接从根目录开始搜索，建议在以上命令都无法解决问题时才用它，功能最强大但速度超慢。除非你指定一个很小的搜索范围。通过 -name 选项指定要查找的文件名，支持通配符。 Shell基础通俗地讲，Shell就是位于内核和操作者之间的一层使用者界面。一个Shell命令可能含有一些可选项和参数，其一般格式为：[Shell命令] [可选项] [参数]。目前流行的Shell有sh， csh， ksh， tcsh和bash等。 开始使用bashShell命令可分为如下两大类： （1） bash内置的命令 （2）应用程序 通配符 特殊字符和引号 常用控制组合键 说明： &amp; 使命令在后台运行，不阻塞当前控制台 CTRL+Z停止进程并放入后台 jobs 显示当前暂停的进程 bg %N 使第N个任务在后台运行（%前有空格）（好像也会阻塞控制台？不太懂，在Ubuntu17.10上测试就是，bg执行后，控制台也被占用，但可以使用Ctr+S和Ctr+Q来暂停和恢复屏幕输出） fg %N 使第N个任务在前台运行，阻塞当前控制台 默认bg，fg不带%N时表示对最后一个进程操作！ Ctr+U是清空当前输入的命令行 补充： 控制台可以使用Ctr+Shift+C/V来执行复制粘贴功能 Shell实用功能命令的排列如果希望一次执行多个命令， Shell允许在不同的命令之间，放上特殊的排列字符 使用“; ” 使用“; ”命令时先执行命令1，不管命令1是否出错，接下来就执行命令2。命令语法：命令1; 命令2 使用“ &amp;&amp;” 使用“ &amp;&amp;”命令时只有当命令1正确运行完毕后，才能执行命令2。命令语法：命令1&amp;&amp;命令2 命令替换有两种方式： 命令1 $(命令2) 命令1 `命令2` 意思是将命令2的输出结果与命令1拼接成新的命令执行，例如： 12pidof less //查看less的进程号，假如为4163kill -9 4163 等价于 123kill -9 $(pidof less)// 或者kill -9 `pidof less` 命令别名alias命令用来设置指令的别名。我们可以使用该命令可以将一些较长的命令进行简化。使用alias时，用户必须使用单引号&#39;&#39;将原来的命令引起来，防止特殊字符导致错误。命令语法： alias [别名]＝[需要定义别名的命令] alias命令的作用只局限于该次登入的操作。若要每次登入都能够使用这些命令别名，则可将相应的alias命令存放到bash的初始化文件/etc/bashrc中。 要删除一个别名，可以使用 unalias 命令，如 unalias l。 文件名匹配和输出重定向文件名匹配 “*” 可匹配任意一个或多个字符 “?” 可以匹配任意一个字符 管道管道可以将某个命令的输出信息当作某个命令的输入，由管道符号“|” 来标识，命令语法： [命令1]|[ 命令2]|[ 命令3] 例如：alias tr=&#39;cd / &amp;&amp; tree | more &amp;&amp; cd ~&#39;，就是将tree的输出内容作为more的输入，more的作用是将输出内容分页显示 重定向文件重定向有5种方式，分别是：输出重定向、输入重定向、错误重定向、追加重定向以及同时实现输出和错误的重定向 输出重定向 将command命令的输出保存到文件file中，如果存在相同的文件，则覆盖file文件中的内容。 命令语法：command &gt; file 可以实用echo和输出重定向来创建文本文件：echo hello &gt; hello.txt，即创建文件hello.txt并写入内容“hello” 输入重定向 将文件file的内容作为command命令的输入。 命令语法：command &lt; file 错误重定向 将command命令执行的出错信息输出到文件file中。 命令语法：command 2&gt; file 追加重定向 将command命令执行的输出添加到已存在的文件file中。 命令语法：command &gt;&gt; file 补充：错误重定向和追加重定向可以组合使用，command 2&gt;&gt; file表示command的错误信息追加到file末尾 同时实现输出和错误的重定向 可以同时实现输出重定向和错误重定向的功能。 命令语法：command &amp;&gt; file 补充：同理，该命令可以和追加重定向组合使用，command &amp;&gt;&gt; file表示command的输出和错误信息追加到file末尾 vi编辑器基本使用vim和vi的区别 摘录自：https://blog.csdn.net/allenlinrui/article/details/7269481 简单来说一下vi和vim的区别与联系 首先，它们都是多模式编辑器，但vim是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性。总的来说，vim比vi更具优势的地方在于： 多级撤消 在vi的命令模式里，按 u只能撤消上次命令，而在vim里可以无限制的撤消，几乎等同于windows下的ctrl+z了 多操作系统支持 vi只能运行于unix中，而vim不仅可以运行于unix,还有windows ,mac等操作系统上 语法加亮 作为一名程序员，我觉得这个效果用处最大了- vim可以对代码进行多颜色的语法加亮 可视化操作 因为vim不仅可以在终端运行，也可以运行于x window、 mac os、 windows， 所以说他“可视化” 对vi的完全兼容 某些情况下，vim可以完全被当成vi来使用 vi的工作模式vi编辑器有3种基本工作模式，分别是命令行模式、插入模式和末行模式 命令行模式：控制屏幕光标的移动，字符、字或行的删除，移动、复制某区域，该模式下是不能输入文本数据的 插入模式：只有在插入模式下，才可以做文字输入，按“ Esc” 键可回到命令行模式 末行模式：将文件保存或退出vi编辑器，也可以设置编辑环境，如寻找字符串、列出行号等 vi基本操作进入插入模式 按“ i” ：从光标当前位置开始输入文件 按“ I” ：在光标所在行的行首插入 按“ a” ：从目前光标所在位置的下一个位置开始输入文字 按“ A” ：在光标所在行的行末插入 按“ o” ：在光标所在的行的下面插入一行，从行首开始输入文字 按“ O” ：在光标所在的行的上面插入一行 按“ s” ：删除光标位置的一个字符，然后进入插入模式 按“ S” ：删除光标所在的行，然后进入插入模式 从插入模式切换为命令行模式从插入模式切换为命令行模式只需按“ Esc” 键 移动光标可以使用键盘的方向键移动光标，也可以使用vi定义的移动命令：h、j、k、l分别表示←、↓、↑、→移动一格。如果需要翻页： 按[Ctrl+b]：屏幕往前移动一页（back） 按[Ctrl+f]：屏幕往后移动一页（front） 按[Ctrl+u]：屏幕往前移动半页（up） 按[Ctrl+d]：屏幕往后移动半页（down） 其他的： 按“ G” ：移动到文本的最后一行 按“ $” ：移动到光标所在行的行尾（助记：正则表达式的$） 按“ ^” 或数字“ 0”：移动到光标所在行的行首（助记：正则表达式的^） 按“ w” ：光标跳到下个字的开头 按“ e” ：光标跳到下个字的字尾 按“ b” ：光标回到上个字的开头 解释：”e”和”b”的“下个字”和“上个字”的含义是当前光标停在某个字上，即当前字；而“w”的“下个字”真的就是下一个字，不是当前光标停留的字。举个例子： 12word----↑ 箭头指向的是当前光标位置，如果按”w”，那么结果是： 123word---- ↑// 因为当前字是word，那么对\"w\"来说，下一个字就是\"----\"，因此光标指向\"-\" 而如果按的是”e”，那么结果将是： 123word---- ↑// 因为当前字是word，那么对\"e\"来说，下一个字就是\"word\"，因此光标指向\"d\" 删除文字 “ x” ：每按一次，删除光标所在位置的一个字符 “ nx” ：例如， “ 6x” 表示删除光标所在位置开始的6个字符（包括当前位置的字符） “ X” ：大写的X，每按一次，删除光标所在位置的前面一个字符 “ nX”：例如， “ 20X”表示删除光标所在位置前面20个字符（不包括当前位置的字符） “ dd” ：删除光标所在行 “ ndd”：从光标所在行开始删除n行。例如， “ 4dd” 表示删除从光标所在行开始的4行字符（包括当前行） ”dG“：删除当前后之后的全部行（包括当前行） 复制 “ yw” ：将光标所在之处到字尾的字符复制到缓冲区中（复制的是一个字的内容） “ nyw” ：复制n个字到缓冲区（包括当前字） “ yy” ：复制光标所在行到缓冲区 “nyy” ：例如， “6yy” 表示复制从光标所在行开始的6行字符 “p” ：将缓冲区内的内容写到光标所在的后一个位置（原ppt这里错了，这里写的才是正确的） ”P“：将缓冲区内的内容写到光标所在的前一个位置 解释：”p“后一个位置有两种含义，如果复制的是字，那么写在光标所在位置的后面；如果复制的是行内容，那么写在光标所在行的下一行；”P“同理，替换成上一个位置或者上一行 替换 “ r” ：替换光标所在处的字符 “ R” ：替换光标所到之处的字符，直到按下“ Esc” 键为止 撤销 “ u” ：如果误执行一个命令，可以马上按下“ u” ，回到上一个操作。 按多次“ u” 可以执行多次撤销 补充：vi兼容模式下，多次”u“并不能多次撤销，原因是后一次”u“会把上一次”u“当做操作来撤销，即撤销”撤销操作“，所以”uu“会恢复原样 跳至指定行 [Ctrl+g]：列出光标所在行的行号 “nG” ：例如， “ 15G” ，表示移动光标至该文本的第15行行首 存盘退出 “ZZ” ：存盘退出 不保存退出 “ZQ” ：不存盘退出 末行模式操作在使用末行模式之前，先按“ Esc”键确定已经处于命令行模式后，再按冒号“:”即可进入末行模式 列出行号“set nu” ：在文件中的每一行前面列出行号 取消列出行号“set nonu” ：取消文件中的每一行前面列出的行号 跳到文件中的某一行“n”：输入行号n后回车，光标会跳转到文本的指定行——第n行的行首 查找字符 “/关键字”：向后查找关键字，可以按n往后查找下一个匹配的关键字 “?关键字”：向前查找关键字，可以按n往前查找下一个匹配的关键字 运行Shell命令“!命令” ：运行Shell命令 替换字符 “s /a/b” ：将光标所在行第一个a替换为b “s /a/b/g” ：将光标所在行所有的a替换为b 保存文件“w” ：在冒号后输入字母“w” 就可以将文件保存起来 退出vi “q” ：按“q” 即退出vi，如果无法离开vi，可以在“q” 后跟一个“!” 强制符离开vi “wq” ：一般建议离开时，搭配“w” 一起使用，这样在退出的时候还可以保存文件 文件和目录Linux系统中以目录的形式挂载文件系统，其目录结构是一个分层的树形结构。链接是一种在共享文件和访问它的用户的若干目录项之间建立联系的方法， Linux系统中包括硬链接和软链接两种方式 Linux文件如果一个文件没有扩展名，或者与它的扩展名不相符时，可以使用file命令查看该文件的类型，例如： 123456steve@ubuntu-17-10:~$ file db.json db.json: UTF-8 Unicode text, with very long lines, with no line terminatorssteve@ubuntu-17-10:~$ file _config.yml _config.yml: UTF-8 Unicode textsteve@ubuntu-17-10:~$ file package-lock.json package-lock.json: ASCII text Linux文件类型Linux文件类型常见的有：普通文件、目录文件、字符设备文件、块设备文件和符号链接文件等，可以用ls -lh命令查看某个文件的属性 普通文件 类似“ -rw-r–r–”的属性符号，其属性第一个符号是“ -”，这样的文件在Linux系统中就是普通文件 目录文件（directory） 类似“ drwxr-xr-x”的属性符号，其属性第一个符号是“ d”，这样的文件在Linux系统中就是目录文件 设备文件 Linux系统下的/dev目录中有大量的设备文件 块设备文件（block） 块设备的主要特点是可以随机读写，而最常见的块设备就是磁盘，如/dev/hda1、/dev/sda2等 类似“ brw-rw—-”的属性符号，其属性第一个符号是“ b”，这样的文件在Linux系统中就是块设备文件 字符设备文件（character） 最常见的字符设备文件是打印机和终端，可以接收字符流。 /dev/null是一个非常有用的字符设备文件，送入这个设备的所有内容都被忽略 类似“ crw-r—–”的属性符号，其属性第一个符号是“ c”，这样的文件在Linux系统中就是字符设备文件 管道文件（pipe） 管道文件有时候也被叫做FIFO文件（ FIFO是先进先出的意思），管道文件就是从一头流入，从另一头流出 类似“ prw——-”的属性符号，其属性第一个符号是“ p”，这样的文件在Linux系统中就是管道文件 链接文件（link） 链接文件有点类似于Windows系统中的快捷方式，链接有两种方式：软链接和硬链接 软链接文件 软链接（也叫符号链接），文件用户数据块中存放的内容是另一文件的路径名的指向。软链接就是一个普通文件，只是数据块内容有点特殊。软链接可对文件或目录创建。删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接就变成了死链接 类似“ lrwxrwxrwx”的属性符号，其属性第一个符号是“ l”，这样的文件在Linux系统中就是软链接文件 硬链接文件 硬链接就是同一个文件使用了多个别名（他们有共同的 inode）。由于硬链接是有着相同inode号仅文件名不同的文件，因此，删除一个硬链接文件并不影响其他有相同 inode 号的文件。硬链接不能对目录进行创建，只可对文件创建 用“ ls -l”命令查看某个文件的属性，可以看到第二列的文件硬链接数大于1 ，这样的文件在Linux系统中就是硬链接文件 Linux目录结构Linux系统都有根文件系统，它包含系统引导和使其他文件系统得以挂载所必要的文件，根文件系统需要有单用户状态所必须的足够的内容，还应该包括修复损坏系统、恢复备份等工具。 Linux系统的目录结构是分层的树形结构，都是挂载在根文件系统“ /” 下 文件和目录操作 pwd：显示当前用户所处的工作目录的绝对路径 cd：更改工作目录路径，工作目录路径可以使用绝对或相对路径名，绝对路径从/（根）开始，然后循序到所需的目录下；相对路径从当前目录开始 命令语法：cd [目录名] ls：对于目录而言将列出其中的所有子目录与文件信息；对于文件而言将输出其文件名以及所要求的其他信息 命令语法：ls [选项] [目录或是文件] ls命令显示的详细信息： touch：创建空文件以及更改文件或目录的时间，其中时间格式为MMDDHHmm 命令语法：touch [-acfm] [-d &lt;日期时间&gt;] [-r &lt;参考 文件或目录&gt;] [-t &lt;日期时间&gt;] [文件] mkdir：在Linux系统中创建目录，其默认权限为rwxr-xr-x（ 755） 命令语法：mkdir [选项] [目录名] -m 可以在创建目录时设置其权限，例如mkdir -m 777 newdir，其权限是rwxrwxrwx（ 777） rmdir：删除空目录 命令语法：rmdir [选项] [目录名] -p或–parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除 cp：复制文件和目录到其他目录中 命令语法：cp [选项] [源文件或目录] [目标文件或目录] mv：对文件和目录更改名称以及移动文件和目录的路径 命令语法：mv [选项] [源文件或目录] [目标文件或目录] rm：删除系统中的文件或目录 命令语法：rm [选项] [文件或目录] -r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；-f：强制删除文件或目录；-i：在删除文件之前提示信息 wc：统计指定文件中的行数、单词数或字节数，并将统计结果显示输出到屏幕 命令语法：wc [选项] [文件] 选项部分可以有-lwc，即将行数、单词数和字节数都显示出来 链接文件在Linux系统中，内核为每一个新创建的文件分配一个inode（索引节点）号，文件属性保存在索引节点里，在访问文件时，索引节点被复制到内存里，从而实现文件的快速访问 硬链接硬链接是一个指针，指向文件索引节点，系统并不为它重新分配inode，可以用ln命令来建立硬链接。硬链接节省空间，也是Linux系统整合文件系统的传统方式。硬链接文件有两个限制： （ 1）不允许给目录创建硬链接 （ 2）只有在同一文件系统中的文件之间才能创建链接 软链接软链接又称为符号链接，这个文件包含了另一个文件的路径名 硬链接和软链接的区别硬链接记录的是目标的inode，软链接记录的是目标的路径。软链接就像是快捷方式，而硬链接就像是备份。软链接可以做跨分区的链接，而硬链接由于inode的缘故，只能在本分区中做链接。所以，软链接的使用频率要高得多 创建链接ln命令可以创建链接文件（包括软链接文件和硬链接文件） 命令语法：ln [选项] [源文件名] [链接文件名]，默认创建的是硬链接，加上-s后创建的是软链接 使用rm删除源文件后，硬链接文件依然能打开，而软链接变成死链接 Linux常用操作命令这部分挺琐碎的，直接参考http://man.linuxde.net/即可 ，关于Linux命令大全的实用网站 文本显示和处理cat，more，less，head，tail，sort，uniq，cut，comm以及diff等 文件和命令查找grep，find，locate，whereis，file，whatis以及which等 系统信息显示uname， hostname， dmesg， cal以及date等 信息交流echo， mesg， wall以及write等 其他命令clear， sync， uptime以及last等 Shell编程语法基础Shell程序由开头部分、注释部分以及语句执行部分组成 开头Shell程序必须以下面的行开始（必须放在文件的第一行） 1#!/bin/bash 符号“ #!” 用来告诉系统它后面的参数是用来执行该文件的程序，在这个例子中使用/bin/bash来执行程序。当编辑好脚本时，如果要执行该脚本，还必须使其可执行（即赋予可执行权限）： 1chmod u+x [文件名] 如果不设置可执行权限的话，可以手动受用bash命令告诉系统它是一个可执行的脚本，这样也可以执行： 1bash file.sh 注释以“ #” 开头的句子表示注释，直到这一行的结束 执行部分例子： 123456789101112131415161718#!/bin/bash#filename:welcomefirst()&#123;echo \"==========================================\"echo \"Hello! Everyone! Welcome to the Linux world.\"echo \"==========================================\"&#125;second()&#123;echo \"******************************************\"&#125;firstsecondsecondfirst 输出： 12345678==========================================Hello! Everyone! Welcome to the Linux world.==========================================************************************************************************************==========================================Hello! Everyone! Welcome to the Linux world.========================================== 变量对Shell来讲，所有变量的取值都是一个字符， Shell程序采用“ $var” 的形式来引用名为var的变量的值 Shell定义的环境变量Shell在开始执行时就已经定义了一些与系统的工作环境有关的变量，用户还可以重新定义这些变量，常见的环境变量如下： HOME：用于保存用户宿主目录的完全路径名 PATH：默认命令搜索路径 TERM：终端的类型 UID：当前用户的识别号 PWD：当前工作目录的绝对路径名 PS1： 用户平时的提示符 PS2： 第一行没输完，等待第二行输入的提示符 用户定义的变量语法规则：变量名=变量值 在定义变量时，变量名前不应加符号“ $” ；在引用变量的内容时，则应在变量名前加符号“ $”或“ ${变量名}” 。在给变量赋值时，等号两边一定不能留空格，若变量中本身就包含了空格，则整个字符串都要用双引号括起来。在编写Shell程序时，为了使变量名和命令名相区别，建议所有的变量名都用大写字母来表示。 有时需要在说明一个变量并对它设置为一个特定值后就不再改变它的值时，可以用下面的命令来保证一个变量的只读性：readonly 变量名。 在任何时候创建的变量都只是当前Shell的局部变量，所以不能被Shell运行的其他命令或Shell程序所利用，而export命令可以将一个局部变量提供给Shell命令使用，其格式是：export 变量名。也可以在给变量赋值的同时使用export命令：export 变量名=变量值。 位置参数位置参数是一种在调用Shell程序的命令行中按照各自的位置决定的变量，是在程序名之后输入的参数。位置参数之间用空格分隔，Shell取第一个位置参数替换程序文件中的$1，第二个替换$2，依次类推。$0是一个特殊的变量，它的内容是当前这个Shell程序的文件名，所以， $0不是一个位置参数，在显示当前所有的位置参数时是不包括$0的 预定义变量预定义变量和环境变量相类似，也是在Shell一开始时就定义了的变量。所不同的是，用户只能根据Shell的定义来使用这些变量，所有预定义变量都是由符号“ $” 和另一个符号组成的。常见的预定义变量如下： $#：位置参数的数量 $*：所有位置参数的内容 $?：命令执行后返回的状态 $$：当前进程的进程号 $!：后台运行的最后一个进程号 $0：当前执行的进程名。 参数置换的变量Shell提供了参数置换功能以便用户可以根据不同的条件来给变量赋不同的值，下面Variable是变量名， value代表一个具体的值： ${variable:-value}: 如果变量variable存在，则返回variable的值，否则返回值value ${variable:=value}: 如果变量variable存在，则返回variable的值，否则，先将值value赋给变量variable，然后返回值value ${variable:+value}: 如果变量variable存在，则返回value的值，否则返回空值 ${variable:?value}: 如果变量variable存在，则返回variable的值，否则将value送到标准错误输出显示并退出shell程序，这里value通常为一个错误提示消息 ${variable:offset[:length]}:其中offset和length为整数数字，中括号代表可选部分。此引用方式表示返回从变量variable的第(offset+1)个字符开始的、长度为length的子串。如果中括号内的部分省略，则返回其后的所有子串 变量表达式首先要注意的是，这些表达式符号前后都需要有空格，否则会出错 字符串比较测试字符串是否相等，长度是否为零，字符串是否为NULL： =：比较两个字符串是否相同，相同则为“是” （结果显示0） !=：比较两个字符串是否相同，不同则为“是”（结果显示0） -n：比较字符串的长度是否大于0，如果大于0则为“是” （结果显示0） -z：比较字符串的长度是否等于0，如果等于0则为“是” （结果显示0） 补充： 直接测试时，控制台是不会有输出结果的，需要使用$?来获取输出结果 如果变量字符串含有空格，需要使用双引号，否则会出错 1234567891011steve@ubuntu-17-10:~/$ str1=\"ab cd\"steve@ubuntu-17-10:~/$ test $str1 = abbash: test: 参数太多steve@ubuntu-17-10:~/$ test \"$str1\" = absteve@ubuntu-17-10:~/$ echo $?1steve@ubuntu-17-10:~/$ test \"$str1\" = ab cdbash: test: 参数太多steve@ubuntu-17-10:~/$ test \"$str1\" = \"ab cd\"steve@ubuntu-17-10:~/$ echo $?0 数字比较test语句不使用&gt;? 类似的符号来表达大小的比较，而是用参数来表示： -eq：相等 -ge：大于等于 -le：小于等于 -ne：不等于 -gt：大于 -lt：小于 逻辑测试 !：与一个逻辑值相反的逻辑值 -a与（ and）：两个逻辑值都为“是” 返回值才为“是” ，反之为“否” -o或（ or）：两个逻辑值有一个为“是” ，返回值就为“是” 例子： 1234[root@PC-LINUX ~]# test -r empty -a -s empty[root@PC-LINUX ~]# echo $?1// 结果显示1表示文件empty存在且只读以及长度为非0是不对的 文件操作文件测试表达式通常是为了测试文件的文件操作逻辑： -d：对象存在且为目录，则返回值为“是” -f：对象存在且为文件，则返回值为“是” -L：对象存在且为符号连接，则返回值为“是” -r：对象存在且可读，则返回值为“ 是” -s：对象存在且长度非0，则返回值为“是” -w：对象存在且可写，则返回值为“是” -x：对象存在且可执行，则返回值为“是” !：测试条件的否定 Shell程序的执行和跟踪Shell程序的执行和调试程序的第一行一般为#!/bin/bash ，其中“ #” 表示该行是注释，感叹号“ ！ ” 表示Shell运行感叹号之后的命令并用文档的其余部分作为输入，也就是运行/bin/bash并让/bin/bash去执行Shell程序的内容 Shell程序的执行有如下三种方式运行shell程序： 12345678steve@ubuntu-17-10:~/$ vim exe.shsteve@ubuntu-17-10:~/$ bash &lt; exe.sh hello worldsteve@ubuntu-17-10:~/$ bash exe.sh hello worldsteve@ubuntu-17-10:~/$ chmod u+x exe.sh steve@ubuntu-17-10:~/$ ./exe.sh hello world 发现一个问题：使用bash &lt; exe.sh运行程序时，read指令好像不生效，控制台不会等待标准输入，具体原因还不知道 Shell程序的调试调用bash的形式是：bash [选项] [Shell程序文件名] -v：当读入Shell输入行时，把它们显示出来（输出的命令是未经执行的源程序命令） -x：执行命令时把命令和它们的参数显示出来（输出的命令是解释后实际执行的命令） 示例： 12345678910111213141516171819202122232425steve@ubuntu-17-10:~/$ vim exe.sh ; cat exe.sh #!/bin/bashecho \"shell file name is $0\"echo \"hello world\"echo $1echo $2steve@ubuntu-17-10:~/$ bash -x exe.sh a b+ echo 'shell file name is exe.sh'shell file name is exe.sh+ echo 'hello world'hello world+ echo aa+ echo bbsteve@ubuntu-17-10:~/$ bash -v exe.sh a b#!/bin/bashecho \"shell file name is $0\"shell file name is exe.shecho \"hello world\"hello worldecho $1aecho $2b Shell流程控制语句与传统语言不同的是， Shell用于指定条件值的不是布尔运算式，而是命令和字符串 条件判断if条件语句 可以参考：https://blog.csdn.net/doiido/article/details/43966819 Shell程序中的条件分支有如下两种方式： if-then语句 语法如下： 123if [ 命令行1 ];then 命令行2fi 需要注意的是，在 ‘[‘后面 和 ‘]’前面 都必须要有空格，不然会出错，例如要[ $a=a ] if-then-else语句 语法如下： 123456if [ 命令行1 ]then 命令行2else 命令行3fi case条件语句Shell通过计算字符串string的值，将其结果依次与运算式exp-1和exp-2等进行比较，直到找到一个匹配的运算式为止。如果找到了匹配项，则执行它下面的命令直到遇到一对分号;;为止，语法格式： 1234567891011case string inexp-1) 若干个命令行1;;exp-2) 若干个命令行2;;……*) 其他命令行esac 在case运算式中也可以使用Shell的通配符（ * ， ? ， []）。通常用*作为case命令的最后运算式以便在前面找不到任何相应的匹配项时执行“其他命令行” 的命令，样例： 12345678910111213141516steve@ubuntu-17-10:~/$ cat menu.sh #!/bin/bashecho _echo \"1 Restore\"echo \"2 Backup\"echo \"3 Unload\"echo echo -n \"Enter Choice: \"read CHOICEcase \"$CHOICE\" in1) echo \"Restore\";;2) echo \"Backup\";;3) echo \"Unload\";;*) echo \"Sorry $CHOICE is not a valid choice.\"exit 1esac 循环控制for循环语句1234for 变量名 [in数值列表]do 若干个命令行done 如果变量名是var，则在in之后给出的数值将顺序替换循环命令列表中的“ $var” 如果省略了in，则变量var的取值将是位置参数 例子： 123456steve@ubuntu-17-10:~/$ vim mm.sh ; cat mm.sh#!/bin/bash for ab in 1 2 3 4do echo $abdone 输出： 12345steve@ubuntu-17-10:~/$ bash mm.sh 1234 求和示例： 123456789steve@ubuntu-17-10:~/$ cat qqq.sh #!/bin/bash sum=0for INT in $*;do sum=`expr $sum + $INT`done echo $sumsteve@ubuntu-17-10:~/$ bash qqq.sh 1 2 3 4 10 要注意，原ppt中expr指令使用的是单引号&#39;&#39;括起来的，这样不对，应该使用反单引号``才能执行后面的加法计算 while循环语句语法格式： 12345while 若干个命令行1do 若干个命令行2done 只要while的“若干个命令行1” 中最后一个命令的返回状态为真， while循环就继续执行“ do…done” 之间的“ 若干个命令行2”，示例： 12345678910111213141516steve@ubuntu-17-10:~/桌面$ cat zx.sh #!/bin/bash int=1while [ $int -le 5 ]; do sq=`expr $int \\* $int` echo $sq int=`expr $int + 1`doneecho \"Job completed!\"steve@ubuntu-17-10:~/桌面$ bash zx.sh 1491625Job completed! until循环语句语法格式： 12345until 若干个命令行1do 若干个命令行2done until循环和while循环的区别在于：while循环在条件为真时继续执行循环，而until则是在条件为假时继续执行循环。Shell还提供了true和false两条命令用于创建无限循环结构，它们的返回状态分别是总为0或总为非0 break和continue语句用法和传统C语言中的用法无异 source语句source命令用法：source FileName 作用：在当前bash环境下读取并执行FileName中的命令。 注：该命令通常用命令“ .”来替代。如： source .bash_rc 与 . .bash_rc 是等效的。 source命令与shell scripts的区别是， source在当前bash环境下执行命令，而scripts是启动一个子shell来执行命令。这样如果把设置环境变量（或alias等等）的命令写进scripts中，就只会影响子shell,无法改变当前的BASH,所以通过文件设置环境变量时，要用source 命令。 source命令(从 C Shell 而来)是bash shell的内置命令。点命令(从Bourne Shell而来) 是source的另一名称。 source(或点)命令通常用于重新执行刚修改的初始化文档，如 .bash_profile 和.profile 等等。 函数所有函数在使用前必须定义。函数的调用，只需要使用函数名就可以调用已经定义好的函数。 1234567# 定义：[function] 函数名()&#123; 命令&#125;# 引用：函数名 [ 参数1 参数2 ...参数n ] 在函数中得到函数返回值可以使用以下两种方法： 在函数末尾加return，从函数中返回，用最后的命令状态决定返回值（$?） 返回一个数值，如0或1。格式如： return 0或者return 1 示例： 12345678steve@ubuntu-17-10:~/桌面$ cat func.sh #!/bin/bash function func()&#123; echo \"hello\" echo \"world\"&#125;funcecho $? 输出： 1234steve@ubuntu-17-10:~/桌面$ bash func.sh helloworld0 说明获取的是命令状态而不是命令的输出值 用户和组群账户管理用户账户管理Linux用户账户概述用户在Linux系统中是分角色的，用户的角色是通过UID（用户ID号）来标识的，每个用户的UID都是不同的。在Linux系统中主要有root用户、虚拟用户和普通用户这3类用户。 root用户 root用户是Linux系统的内置用户，在系统中的权限最高，也被称之为超级管理用户。在系统中的每个文件、目录和进程都归属于某一个用户，没有用户许可，除root用户外的其它普通用户无法进行操作 虚拟用户 这类用户也被称为伪用户或假用户，这类用户不具有登录系统的能力，但却是系统运行不可缺少的用户，比如bin， daemon， adm，ftp以及mail等用户账户，这类用户都是Linux系统的内置用户 普通用户 这类用户是由系统管理员创建，并且能登录Linux系统。只能操作自己目录内的文件，权限有限 Linux用户账户配置文件用户管理主要是通过修改用户配置文件完成的，使用用户管理控制工具的最终目的也是为了修改用户配置文件。 /etc/passwd文件/etc/passwd是系统识别用户的一个文件，Linux系统中所有的用户都记录在该文件中。任何用户都可以读取该文件内容，在/etc/passwd文件中，每一行表示的是一个用户账户信息，一行有7个段位，每个段位用“:”分隔。 每个用户都对应一个唯一的UID，Linux的用户UID值是非负整数， root的UID是0，拥有系统最高权限。UID的唯一性关系到系统的安全，比如在/etc/passwd文件中把用户zhangsan的UID改为0后， zhangsan这个用户会被确认为root用户。 UID是确认用户权限的标识，用户登录系统所处的角色是通过UID来实现的，而不是用户名。 /etc/shadow文件/etc/shadow文件是/etc/passwd文件的影子文件，这个文件并不是由/etc/passwd文件产生，这两个文件是对应互补的。/etc/shadow文件内容包括用户及被加密的口令及其他/etc/passwd不能包括的信息，比如用户账户的有效期限等。/etc/shadow文件的内容包括9个段位，每个段位之间用“ :”分隔： 字符界面下用户账户的设置创建新账户创建用户账户就是在系统中创建一个新账户，然后为新账户分配用户UID、用户组群、主目录和登录Shell等资源，新创建的用户账户默认是被锁定的，无法使用，需要使用passwd命令设置密码以后才能使用。使用useradd命令可以在Linux系统下创建用户账户。 修改账户使用usermod命令能更改用户的Shell类型、所属的用户组群、用户口令的有效期，还能更改用户的登录名 删除用户账户使用userdel命令可以在Linux系统下删除用户账户：userdel [-r][用户名]，其中-r是指在删除该用户的同时一起删除主目录 组群账户管理Linux组群账户配置文件/etc/gshadow是/etc/group的加密信息文件 /etc/group文件/etc/group文件的内容包括用户组群名、用户组群口令、 GID及该用户组群所包含的用户，每个用户组群都有一条记录。一行有4个段位，每个段位用“:” 分隔。 组群GID和UID类似，是一个从0开始的非负整数， GID为0的组群是root组群。Fedora 17系统会预留1000个GID号给系统虚拟用户组群使用，创建的新组群GID是从1000开始的。 /etc/gshadow文件/etc/gshadow文件是/etc/group的加密文件，比如用户组群管理口令就是存放在这个文件中。/etc/gshadow文件中每个用户组群都有一条记录。一行有4个段位，每个段位之间用“ :”分隔。 字符界面下组群账户的设置在Linux系统字符界面下创建、修改以及删除组群账户主要使用groupadd，groupmod和groupdel这3个命令。 创建组群账户命令语法：groupadd [-g gid [-o]] [-f] [组群名] 默认创建的是用户群组，即默认分配的GID大于等于1000，可以通过-g指定GID；-r选项可以创建系统群组，即默认分配的GID小于1000 修改组群账户命令语法：groupmod [-g &lt;组群识别码&gt; &lt;-o&gt;] [-n &lt;新组群名称&gt;] [组群名称] 删除组群账户命令语法：groupdel [组群名称] 账户相关文件或目录/etc/skel目录/etc/skel目录是存放用户启动文件的目录，这个目录由root用户管理，当管理员创建新用户时，这个目录下的文件会自动复制到新创建的用户的主目录下。/etc/skel目录下的文件都是隐藏文件，也就是类似“ .file” 格式的，可以通过添加、修改和删除/etc/skel目录下的文件，来为用户提供一个统一、标准和默认的用户环境。 /etc/login.defs配置文件/etc/login.defs文件规定了创建新用户时的一些默认设置，比如创建用户时是否需要主目录、 UID和GID的范围、用户账户口令的期限等，这个文件可以通过root用户来修改 /etc/default/useradd文件/etc/default/useradd文件是在使用useradd命令创建用户账户时的规则文件 用户和组群维护命令账户维护命令passwd命令使用passwd命令可以设置或修改用户的口令，普通用户和超级权限用户都可以运行passwd。普通用户只能更改自己的用户口令，root用户可以设置或修改任何用户的口令。如果passwd命令后面不接任何选项或用户名，则表示修改当前用户的口令。 命令语法：passwd [选项] [用户名] 可以使用-l选项来锁住某个用户的口令，这样该用户就无法登录，但是可以从其他用户中通过su切换到被锁定的用户，被锁定的用户口令前面有!标识（Ubuntu系统，其他系统可能会有差异，比如Fedora17系统上是双感叹号!!）： 1test:!$6$N8tiFTQb$ViLVGgYXVKoOIdIcoXVfmug5tOfzwIVoeKia4uY6Wtw6n0sIEs1uTf9Ff6DI1.iOPX6/jzs.CDus8h.x6AonJ.:18106:0:99999:7::: 可以使用-u选项来解锁某用户的口令；-d是直接删除某用户的口令，使其无法登录系统。 gpasswd命令使用gpasswd命令可以设置一个组群的组群密码，或是在组群中添加、删除用户。 命令语法：gpasswd [-r|-R][组群名] gpasswd [选项][用户名][组群名]","categories":[{"name":"linux","slug":"linux","permalink":"http://QQ876684433.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://QQ876684433.github.io/tags/linux/"}]},{"title":"Java分布式应用知识点","slug":"Java分布式应用知识点","date":"2019-07-24T15:10:12.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/24/Java分布式应用知识点/","link":"","permalink":"http://QQ876684433.github.io/2019/07/24/Java分布式应用知识点/","excerpt":"","text":"Java分布式应用知识点相关知识点 来源：问题https://www.zhihu.com/question/22764869下的回答 知乎用户——by 用心阁 软件工程师 网络通讯，网络是分布式的基础，对分布式的理解建立在对网络的理解上，包括： OSI模型的7层 TCP/IP，DNS，NAT HTTP，SPDY/HTTP2 Telnet 网络编程，是通过程序在多个主机之间通信。包括： Socket 多线程 非阻塞IO 网络框架 Netty Mina ZeroMQ 操作系统的网络部分 RPC，Socket使用不是很方便，很多分布式应用是基于RPC的，包括： 同步RPC 异步RPC 主要的一些RPC协议 RMI Rest API Thrift 集群，分布式计算离不开集群。集群就是多台主机被当作一个系统 集群类型 高可用，如主机备机切换，冷备，热备，双活 伸缩性，如Web服务器集群，数据库服务器的Sharding 并行计算，如网格，大数据 集群相关技术，包括： 高可用性，保证服务一直能够被访问，延长MTBF，缩短MTTR 冗余的设备 多副本，为了避免单点失效 负载均衡，如何将大量工作负载分配到多个主机上，最大化吞吐量，最小化平均响应时间，最大化资源利用率。 伸缩性（横向），能够添加计算机和设备来应对增长的计算压力 分片（Sharding），把数据分成多个数据集，由多个服务器来分别处理。 自动分片 容错性，当硬件或软件发生故障，能够继续运转 故障检测，以及故障预测 心跳包 告警 性能预警 故障转移，当出现错误，如何解决，为了高可用性和容错性 分布式一致性，在分布式环境中如何维持状态的一致性，严格一致性，还是最终一致性 集群状态协调，如Zookeeper，etcd等。 分布式锁，在分布式环境中如何进行加锁 选主，当Master宕机，如何选择出新的Master，协议如Raft 一致性哈希，如何将数据分布到集群中的多个主机。 分布式事务，保证在多台服务器上完成的操作符合事务的ACID属性。 安全，网络通常需要保证安全。 身份认证，如何验证人或机器是他们声明的身份 基于用户名/口令 基于数字证书 私密性，如何防止窃听和嗅探 对称加密 非对称加密 完整性，如何保证数据不被篡改 安全散列 消息认证码（MAC） 不可否认性 基于数字证书的数字签名和验签 基于密钥的散列，如HMAC 互联网站的基本架构 页面缓存 负载均衡器，如HAProxy,Nginx 分布式缓存，如Memcache，Redis 消息队列，如ActiveMQ，Kafka 分布式框架 关系型数据库（Sharding，主从同步） NoSQL HBase，基于HDFS和Zookeeper的NoSQL Cassandra，无主集群 大数据 HDFS，分布式文件系统 MapReduce，将数据处理任务拆分为多个工作，通过集群来完成。 Spark，提供分布式的数据集抽象 书籍推荐 大型分布式网站架构设计与实践 大型网站技术架构：核心原理与案例分析 大型网站系统与Java中间件实践 分布式Java应用：基础与实践","categories":[{"name":"分布式","slug":"分布式","permalink":"http://QQ876684433.github.io/categories/分布式/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"分布式","slug":"分布式","permalink":"http://QQ876684433.github.io/tags/分布式/"}]},{"title":"精读Servlet源码-javax.servlet.ServletContext","slug":"精读Servlet源码-javax-servlet-ServletContext","date":"2019-07-19T02:27:59.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/07/19/精读Servlet源码-javax-servlet-ServletContext/","link":"","permalink":"http://QQ876684433.github.io/2019/07/19/精读Servlet源码-javax-servlet-ServletContext/","excerpt":"","text":"精读Servlet源码-javax.servlet.ServletContext 参考： https://www.cnblogs.com/smyhvae/p/4140877.html https://blog.csdn.net/gavin_john/article/details/51399425","categories":[{"name":"源码","slug":"源码","permalink":"http://QQ876684433.github.io/categories/源码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"servlet","slug":"servlet","permalink":"http://QQ876684433.github.io/tags/servlet/"}]},{"title":"精读Servlet源码-javax.servlet.ServletConfig","slug":"精读Servlet源码-javax-servlet-ServletConfig","date":"2019-07-19T01:43:08.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/07/19/精读Servlet源码-javax-servlet-ServletConfig/","link":"","permalink":"http://QQ876684433.github.io/2019/07/19/精读Servlet源码-javax-servlet-ServletConfig/","excerpt":"","text":"精读Servlet源码-javax.servlet.ServletConfig 参考：https://www.cnblogs.com/smyhvae/p/4140877.html ServletConfig的实例是servlet容器在初始化一个servlet时传递到init()方法的对象，它携带了一个servlet的相关配置以及初始化参数。 12345678910111213141516171819package javax.servlet;import java.util.Enumeration;/** * A servlet configuration object used by a servlet container * to pass information to a servlet during initialization. */ public interface ServletConfig &#123; public String getServletName(); public ServletContext getServletContext(); public String getInitParameter(String name); public Enumeration&lt;String&gt; getInitParameterNames();&#125; 各个接口方法的说明getServletName返回servlet实例的名称，它可能是在web服务器中由服务器管理者提供的，如果servlet没有被注册到服务中，那么它将返回servlet实例的类名。 getServletContextgetServletContext返回ServletContext实例的引用，WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用，并且保存在ServletConfig实例中并传递给对应的servlet，通过它可以允许调用者与servlet容器进行交互。 getInitParameter初始化参数在ServletConfig中是以键值对方式存储的，getInitParameter()可以通过给定的参数名字获取对应的参数值，键和值都是以字符串的形式存储；如果对应的参数名字不存在，则返回null。 getInitParameterNames获取所有的初始化参数，以Enumeration类型返回；如果没有，则返回一个空的Enumeration。Enumeration类似于迭代器，Enumeration接口中定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素。 追根溯源：ServletConfig vs ServletContextServletConfig从更本质上来看，ServletConfig实际上代表的是当前Servlet在web.xml中的配置信息，在Servlet的配置文件中，可以使用&lt;servlet&gt;标签下的一个或多个&lt;init-param&gt;标签为servlet配置一些初始化参数。&lt;init-param&gt;标签是为某一个单独的servlet加配置信息，这种配置信息在其他的Servlet中是无法访问到的。 当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，程序员通过ServletConfig对象就可以得到当前servlet的初始化参数信息。 这样做的好处是：如果将数据库信息、编码方式等配置信息放在web.xml中，如果以后数据库的用户名、密码改变了，则直接很方便地修改web.xml就行了，避免了直接修改源代码的麻烦。 ServletContextWEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。 ServletConfig对象中维护了ServletContext对象的引用，它是由servlet容器提供的，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。 由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。 对ServletContext更深入的研究请移步：精读Servlet源码-javax.servlet.ServletContext ServletConfig实例编写Servlet123456789101112131415161718192021222324252627282930313233343536373839404142434445package servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Enumeration;public class ServletConfigDemo extends HttpServlet &#123; @Override public void init() throws ServletException &#123; super.init(); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletConfig servletConfig = this.getServletConfig(); PrintWriter out = resp.getWriter(); resp.setContentType(\"text/plain\"); String servletName = servletConfig.getServletName(); out.println(\"Servlet name: \" + servletName); String username = servletConfig.getInitParameter(\"username\"); String password = servletConfig.getInitParameter(\"password\"); out.println(\"=================servletConfig.getInitParameter================\"); out.println(\"username: \" + username); out.println(\"password: \" + password); out.println(\"=================servletConfig.getInitParameterNames================\"); Enumeration&lt;String&gt; params = servletConfig.getInitParameterNames(); while (params.hasMoreElements()) &#123; String name = params.nextElement(); out.println(name + \": \" + servletConfig.getInitParameter(name)); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 配置web.xml12345678910111213141516171819202122232425&lt;servlet&gt; &lt;servlet-name&gt;ServletConfigDemo-xxxx&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.ServletConfigDemo&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;steve_chph&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;mypassword123456&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;name1&lt;/param-name&gt; &lt;param-value&gt;value1&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;name2&lt;/param-name&gt; &lt;param-value&gt;value2&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletConfigDemo-xxxx&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletConfigDemo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 输出结果","categories":[{"name":"源码","slug":"源码","permalink":"http://QQ876684433.github.io/categories/源码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"servlet","slug":"servlet","permalink":"http://QQ876684433.github.io/tags/servlet/"}]},{"title":"精读Servlet源码-javax.servlet.http.HttpServlet","slug":"精读Servlet源码-javax-servlet-http-HttpServlet","date":"2019-07-18T11:57:50.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/07/18/精读Servlet源码-javax-servlet-http-HttpServlet/","link":"","permalink":"http://QQ876684433.github.io/2019/07/18/精读Servlet源码-javax-servlet-http-HttpServlet/","excerpt":"","text":"","categories":[{"name":"源码","slug":"源码","permalink":"http://QQ876684433.github.io/categories/源码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"servlet","slug":"servlet","permalink":"http://QQ876684433.github.io/tags/servlet/"}]},{"title":"精读Servlet源码-javax.servlet.GenericServlet","slug":"精读Servlet源码-javax-servlet-GenericServlet","date":"2019-07-18T11:57:19.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/07/18/精读Servlet源码-javax-servlet-GenericServlet/","link":"","permalink":"http://QQ876684433.github.io/2019/07/18/精读Servlet源码-javax-servlet-GenericServlet/","excerpt":"","text":"精读Servlet源码-javax.servlet.GenericServletGenericServlet定义了通用的、协议独立的servlet，HTTP协议版的servlet即HttpServlet直接继承了GenericServlet；GenericServlet实现了Servlet和ServletConfig接口，它提供了Servlet接口生命周期方法的简单实现版本（init和destroy），同时对ServletConfig的接口方法作进一步的封装。 ServletConfig作为GenericServlet的私有属性保存，它是在servlet在初始化时init()方法中传递进来的，这样就能在servlet的各个生命周期方法中以及servlet容器中访问到servlet配置及初始化参数。 1234567891011public abstract class GenericServlet implements Servlet, ServletConfig, java.io.Serializable&#123; private static final String LSTRING_FILE = \"javax.servlet.LocalStrings\"; private static ResourceBundle lStrings = ResourceBundle.getBundle(LSTRING_FILE); private transient ServletConfig config; ... ...&#125; 各个方法的说明构造函数因为servlet的初始化工作是由init()完成的，所以在构造函数里什么也不做。 1public GenericServlet() &#123; &#125; Servlet接口方法initGenericServlet除了实现Servlet接口的init()方法外，还提供了一个无参的init()方法： void init(ServletConfig config) 由servlet容器调用，它将ServletConfig实例传递进来，init()的工作是将ServletConfig保存起来以备后用，然后再调用无参的init()来完成开发者自定义的初始化过程 void init() 提供给开发者重写init()的便利方式，开发者可以根据需要在init()中完成servlet的初始化工作 理论上，在开发servlet时重写任何一个init()都是可行的，区别在于如果重写的是带参数的init()，需要手动调用super(config);以将参数ServletConfig保存在servlet内部；如果重写的是无参的init()，那么就没有必要手动调用父类中对应的方法，因为servlet容器始终调用的是带参数的init()，带参数的init()随后又会调用无参的init()，如果开发者重写了无参的init()，那么也能完成自定义的servlet初始化工作。 一般来说推荐重写无参的init()，这样可以避免由于忘记调用super(config);而带来的不必要的麻烦。 12345678public void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init();&#125;public void init() throws ServletException &#123;&#125; service抽象方法，GenericServlet没有提供任何实现，意味着任何一个具体子类必须实现service()方法以完成相应的业务逻辑。 1public abstract void service(ServletRequest req, ServletResponse res)throws ServletException, IOException; destroy实现了一个空方法，由servlet容器调用，开发者可以根据需要重写该方法来完成servlet卸载前的相关资源清理工作。 1public void destroy() &#123;&#125; getServletInfo这是留给开发者自定义的方法，它的作用是用来返回servlet的相关信息比如：作者、版本和版权信息等等；GenericServlet中默认是返回一个空的字符串，因为具体的返回值是由实际的开发者决定的，但是有一个约定是：返回值应该是普通文本而不是标记文本（例如HTML、XML等等）。 1public String getServletInfo() &#123;return \"\"; &#125; getServletConfig返回servlet保存的ServletConfig引用。 1public ServletConfig getServletConfig() &#123;return config; &#125; ServletConfig接口方法这些接口方法实际上只是对ServletConfig的接口方法作了进一步的封装，实际上的工作是由servlet容器传递到init()方法的ServletConfig实例完成的。 123456789101112131415161718192021222324252627282930313233343536373839public String getInitParameter(String name) &#123; ServletConfig sc = getServletConfig(); if (sc == null) &#123; throw new IllegalStateException( lStrings.getString(\"err.servlet_config_not_initialized\")); &#125; return sc.getInitParameter(name);&#125;public Enumeration&lt;String&gt; getInitParameterNames() &#123; ServletConfig sc = getServletConfig(); if (sc == null) &#123; throw new IllegalStateException( lStrings.getString(\"err.servlet_config_not_initialized\")); &#125; return sc.getInitParameterNames();&#125; public ServletContext getServletContext() &#123; ServletConfig sc = getServletConfig(); if (sc == null) &#123; throw new IllegalStateException( lStrings.getString(\"err.servlet_config_not_initialized\")); &#125; return sc.getServletContext();&#125;public String getServletName() &#123; ServletConfig sc = getServletConfig(); if (sc == null) &#123; throw new IllegalStateException( lStrings.getString(\"err.servlet_config_not_initialized\")); &#125; return sc.getServletName();&#125; 扩展方法log这个方法是对getServletContext().log(...)方法的进一步封装，用来向ServletContext输出servlet运行时的日志信息： void log(String msg) 正常运行的日志信息，以对应的servlet名称作为日志信息前缀 void log(String message, Throwable t) 运行时异常的日志信息，信息内容还包含了异常的调用栈追踪信息，以对应的servlet名称作为日志信息前缀 1234567public void log(String msg) &#123; getServletContext().log(getServletName() + \": \"+ msg);&#125;public void log(String message, Throwable t) &#123; getServletContext().log(getServletName() + \": \" + message, t);&#125;","categories":[{"name":"源码","slug":"源码","permalink":"http://QQ876684433.github.io/categories/源码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"servlet","slug":"servlet","permalink":"http://QQ876684433.github.io/tags/servlet/"}]},{"title":"精读Servlet源码-javax.servlet.Servlet","slug":"精读Servlet源码-javax-servlet-Servlet","date":"2019-07-18T08:41:32.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/07/18/精读Servlet源码-javax-servlet-Servlet/","link":"","permalink":"http://QQ876684433.github.io/2019/07/18/精读Servlet源码-javax-servlet-Servlet/","excerpt":"","text":"精读Servlet源码-javax.servlet.Servletservlet是运行在Web服务器上面的Java应用程序，Servlet接口类是servlet最核心的一个类，它定义了所有的servlet应该实现的方法，即servlet的生命周期方法，这些声明周期方法是由Web容器比如tomcat来调用的；同时也定义了获取一个servlet配置参数或者信息的方法。 GenericServlet类实现了Servlet类，定义了一个通用的、协议无关的servlet；而HttpServlet类继承了GenericServlet类，定义了HTTP协议下的servlet，它是抽象类，开发者必须继承HttpServlet并实现所有的抽象方法来创建具体的http servlet应用，它们的依赖关系如图： 123456789101112public interface Servlet &#123; public void init(ServletConfig config) throws ServletException; public ServletConfig getServletConfig(); public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; public String getServletInfo(); public void destroy();&#125; 各个接口方法的说明initinit()方法是用来指示一个servlet将被加载到web服务器的服务中，这个方法是在servlet初始化完成之后立即调用的，只有init()被调用并成功返回后，这个servlet才能接受、处理并响应客户端的请求。 当inti()调用过程中发生以下情况时，servlet是不会被加载到服务里面的： init()抛出ServletException异常 init()方法在Web服务器设定的时间内没有返回，即执行超时 一个servlet的init()方法只会在初始化时会且只会被调用一次，它接受ServletConfig类型的参数，ServletConfig包含了servlet的配置和初始化参数，这些参数可以作用域Servlet的整个生命周期，init()方法可以使用这些参数完成相关的初始化工作。 service只有当init()成功调用并将servlet加载进服务中时，service()才能被servlet容器调用用来处理客户端的请求。一般servlet应用都是运行在多线程的servlet容器中，可以并行处理多个客户端请求，servlet每当接收到一个请求时都会产生一个新的线程来处理和该请求，因此就会出现多个servlet 同时访问相同的共享资源（如文件、内存资源等）的情况，这时要注意处理好线程同步的问题。 service()方法由容器调用，service() 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以开发者不用对 service() 方法做任何动作，只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。 它接受两个参数：ServletRequest和ServletResponse，分别对应客户端的请求和servlet对该请求作出的响应。 destroy在servlet被从容器中卸载之前调用，它可以用来清除该servlet占用的资源（例如关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动等）。 destroy()方法仅当该servlet所有的service方法都成功返回之后、或者执行时间超时才能调用，而且destroy()方法一旦调用完成，这个servlet的service()就放就不会被调用了，而且servlet 对象被标记为垃圾回收，会等待JVM回收。 getServletConfig该方法返回一个ServletConfig对象，这个对象恰好是servlet容器初始化servlet时传入init()方法的ServletConfig对象，因此在实现Servlet接口的时候要求init()方法能够将参数ServletConfig对象保存在servlet实例内部，而这个功能已经在Servlet接口实现类GenericServlet中实现了： 12345678public ServletConfig getServletConfig() &#123; return config;&#125;public void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init();&#125; getServletInfo这是留给开发者自定义的方法，它的作用是用来返回servlet的相关信息比如：作者、版本和版权信息等等；这个方法在Servlet接口实现类GenericServlet中默认是返回一个空的字符串，具体的返回值是由实际的开发者决定的，但是有一个约定是：返回值应该是普通文本而不是标记文本（例如HTML、XML等等） 123public String getServletInfo() &#123; return \"\";&#125; Servlet生命周期架构图典型的 Servlet 生命周期方案： 第一个到达服务器的 HTTP 请求被委派到 Servlet 容器 Servlet 容器在调用 service() 方法之前加载 Servlet 然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法","categories":[{"name":"源码","slug":"源码","permalink":"http://QQ876684433.github.io/categories/源码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"servlet","slug":"servlet","permalink":"http://QQ876684433.github.io/tags/servlet/"}]},{"title":"JavaWeb敲门砖-servlet概览","slug":"JavaWeb敲门砖-servlet概览","date":"2019-07-18T07:50:49.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/18/JavaWeb敲门砖-servlet概览/","link":"","permalink":"http://QQ876684433.github.io/2019/07/18/JavaWeb敲门砖-servlet概览/","excerpt":"","text":"JavaWeb敲门砖-Servlet概览Servlet生命周期 来源：https://www.runoob.com/servlet/servlet-life-cycle.html Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 Servlet实例编写Servlet类开发web应用时，通常是继承HttpServlet类来编写自己的Servlet应用，用以处理客户端的HTTP请求。 1234567891011121314151617181920212223242526272829package servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class HelloWorld extends HttpServlet &#123; private String message; @Override public void init() throws ServletException &#123; message = \"Hello World!\"; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(\"text/html\"); PrintWriter pw = resp.getWriter(); pw.println(\"&lt;h1&gt;\"+message+\"&lt;/h1&gt;\"); &#125; @Override public void destroy() &#123; System.out.println(\"end of servlet\"); &#125;&#125; 编译Servlet如果直接javac编译.java文件，会出现依赖问题，因为servlet默认不是标准jdk自带的： 123456789101112import javax.servlet.ServletException; ^HelloWorld.java:4: 错误: 程序包javax.servlet.http不存在import javax.servlet.http.HttpServlet; ^HelloWorld.java:5: 错误: 程序包javax.servlet.http不存在import javax.servlet.http.HttpServletRequest; ^HelloWorld.java:6: 错误: 程序包javax.servlet.http不存在import javax.servlet.http.HttpServletResponse; ^...... 为了方便解决依赖问题，建议使用maven来编译整个项目，然后再在target/classes下面找到需要的class文件： 部署Servlet进入在tomcat目录，在webapps/下面建立项目结构 1234567webapps└── serv ├── index.html* └── WEB-INF ├── classes │ └── HelloWorld.class └── web.xml 其中index.html是可选的，在这里我们只是为了测试我们的servlet，因此可以不用建立这个文件。然后将我们之前编译好的HelloWorld.class复制到classes下，然后编写web.xml文件： 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\" version=\"2.4\"&gt; &lt;display-name&gt;Welcome to my first jsp &lt;/display-name&gt; &lt;description&gt; Welcome to my jsp &lt;/description&gt; &lt;servlet&gt; &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 保存后启动tomcat服务器bin/startup.sh，访问”http://localhost:8080/serv/HelloWorld&quot;就可以了。。。 。。。。。。 wtf？为什么报错了？ 别急，往下看 注意事项如果你细心的话可以发现，我们的HelloWorld类是在servlet包下面的，但是我们的classes结构和web.xml描述是这样的： 1234WEB-INF ├── classes │ └── HelloWorld.class // 看这里 └── web.xml 123456789&lt;servlet&gt; &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; // 看这里&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 但是实际上HelloWorld这个类的完整类名是servlet.HelloWorld，很显然跟我们的配置不匹配，所以我们需要修改： 12345webapps/serv/WEB-INF/├── classes│ └── servlet // 看这里│ └── HelloWorld.class // 看这里└── web.xml 123456789&lt;servlet&gt; &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.HelloWorld&lt;/servlet-class&gt; // 看这里&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 保存后重启tomcat，然后再次访问页面： 这很舒服了！ servlet配置为了让Servlet能响应用户请求，还必须将Servlet配置在web应用中，配置Servlet需要修改web.xml文件。从Servlet3.0开始，配置Servlet有两种方式： 在Servlet类中使用@WebServlet Annotation进行配置。 在web.xml文件中进行配置。 这里面我们用的是web.xml配置的方式。这里只介绍一下最核心的部分，更详细的内容可以参考：https://blog.csdn.net/believejava/article/details/43229361 &lt;servlet&gt;定义一个servlet，它必须含有&lt;servlet-name&gt;和&lt;servlet-class&gt; &lt;servlet-name&gt;：用来定义servlet的名称，该名称在整个应用中必须是惟一的 &lt;servlet-class&gt;：用来指定servlet的完全限定的名称，例如我们定义的servlet全限定名为servlet.HelloWorld &lt;servlet-mapping&gt;用来定义servlet与请求url的匹配规则，它含有&lt;servlet-name&gt;和&lt;url-pattern&gt; &lt;servlet-name&gt;：Servlet的名字，唯一性和一致性，与&lt;servlet&gt;元素中声明的名字一致 &lt;url-pattern&gt;：指定相对于Servlet的URL的路径。该路径相对于web应用程序上下文的根路径，例如我们上面定义了应用的根路径是/serv，那么最后我们访问该servlet的url就是：http://localhost:8080/serv/&lt;url-pattern&gt;。&lt;servlet-mapping&gt;将URL模式映射到某个Servlet，即该Servlet处理的URL","categories":[{"name":"后端","slug":"后端","permalink":"http://QQ876684433.github.io/categories/后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"servlet","slug":"servlet","permalink":"http://QQ876684433.github.io/tags/servlet/"}]},{"title":"由String的构造方法引申出来的java字符编码","slug":"由String的构造方法引申出来的java字符编码","date":"2019-07-17T01:39:40.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/07/17/由String的构造方法引申出来的java字符编码/","link":"","permalink":"http://QQ876684433.github.io/2019/07/17/由String的构造方法引申出来的java字符编码/","excerpt":"","text":"由String的构造方法引申出来的java字符编码 作者：挟天子以令诸侯 出处：http://www.cnblogs.com/gdayq/本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 在String类的constructors中，有一个constructor是将int数组类型转化为字符串： 123int[] num = &#123;48,49,50,51,52&#125;;String numStr = new String(num,0,4);System.out.println(numStr); 输出结果是： 0123 这个constructor的作用是将int数组中每一位上的数字转化为在Unicode编码中对应的字符。现在来看看它是怎么转化的。 源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public String(int[] codePoints, int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; codePoints.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; final int end = offset + count; // Pass 1: Compute precise size of char[] int n = count; for (int i = offset; i &lt; end; i++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) continue; else if (Character.isValidCodePoint(c)) n++; else throw new IllegalArgumentException(Integer.toString(c)); &#125; // Pass 2: Allocate and fill in char[] final char[] v = new char[n]; for (int i = offset, j = 0; i &lt; end; i++, j++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) v[j] = (char) c; else Character.toSurrogates(c, v, j++); &#125; this.value = v; this.count = n; this.offset = 0; &#125;&#125; 代码很简单，但是用到了Character类的三个方法： 123Character.isBmpCodePoint(c)Character.isValidCodePoint(c)Character.toSurrogates(c, v, j++) 先来看看第一个方法isBmpCodePoint()： 1234567public static boolean isBmpCodePoint(int codePoint) &#123; return codePoint &gt;&gt;&gt; 16 == 0; // Optimized form of: // codePoint &gt;= MIN_VALUE &amp;&amp; codePoint &lt;= MAX_VALUE // We consistently use logical shift (&gt;&gt;&gt;) to facilitate // additional runtime optimizations.&#125; &gt;&gt;&gt;是移位运算符，codePoint &gt;&gt;&gt; 16 的意思是将codePoint变量无符号右移16位，然后判断是否等于0，这个是在判断什么呢？根据字面意思理解is bmp code point,是否是bmp代码点，也是不明白，然后就去search了一下，于是就引申出了两个概念—-代码点与代码单元。 说到代码点与代码单元，就得先说说Unicode编码的基本概念了。 1、Unicode的基本概念1）编码字符集 编码字符集是一个字符集，它为每一个字符分配一个唯一数字。Unicode 标准的核心是一个编码字符集，字母“A”的编码为0041和字符“€”的编码为20AC。Unicode标准始终使用十六进制数字，而且在书写时在前面加上前缀“U+”，所以“A”的编码书写为“U+0041”。说白了，就是在编码字符集中，每一个字符都有一个自己的一个唯一的ID。 2）代码点与代码单元 Unicode 代码点 U+0041 U+00DF U+6771 U+10400 表示字形 UTF-32 代码单元 00000041 000000DF 00006771 00010400 UTF-16 代码单元 0041 00DF 6771 D801DC00 UTF-8 代码单元 41 C39F E69DB1 F0909080 网摘：“代码点（Code Point）就是指Unicode中为字符分配的编号，一个字符只占一个代码点，例如我们说到字符“汉”，它的代码点是U+6C49.代码单元（Code Unit）则是针对编码方法而言，它指的是编码方法中对一个字符编码以后所占的最小存储单元。例如UTF-8中，代码单元是一个字节，因为一个字符可以被编码为1个，2个或者3个4个字节；在UTF-16中，代码单元变成了两个字节（就是一个char），因为一个字符可以被编码为1个或2个char（你找不到比一个char还小的UTF-16编码的字符，嘿嘿）。说得再罗嗦一点，一个字符，仅仅对应一个代码点，但却可能有多个代码单元（即可能被编码为2个char）。” 说白了，代码点：就是字符所对应的那个“ID”。代码单元：指的是在各种不同的编码方式中（UTF-8,UTF-16），对一个字符编码以后所占的最小存储单元。 3）增补字符 16 位编码的所有 65536 个字符并不能完全表示全世界所有正在使用或曾经使用的字符。于是，Unicode 标准已扩展到包含多达 1112064 个字符。那些超出原来的16 位限制的字符被称作增补字符。 Java的char类型是固定16bits(两个字节)的。代码点在U+0000 — U+FFFF之内到是可以用一个char完整的表示出一个字符。但代码点在U+FFFF之外的，一个char无论如何无法表示一个完整字符。这样用char类型来获取字符串中的那些代码点在U+FFFF之外的字符就会出现问题。 于是，有了增补字符。增补字符是代码点在 U+10000 至 U+10FFFF 范围之间的字符，也就是那些使用原始的 Unicode 的 16 位设计无法表示的字符。从 U+0000 至 U+FFFF 之间的字符集有时候被称为基本多语言面（BMP UBasic Multilingual Plane ）。Unicode的代码点可以分成17个代码级别。第一个代码级别称为基本的多语言级别，代码点从U+0000到U+FFFF，其中包括了经典的Unicode代码，其余的16个附加级别，代码点从U+10000到U+10FFFF，其中包括了一些增补字符。因此，每一个 Unicode 字符要么属于 BMP，要么属于增补字符。 2、基于Unicode的具体编码格式 网摘： UTF-32 即将每一个 Unicode 代码点表示为相同值的32位整数。很明显，它是内部处理最方便的表达方式，但是，如果作为一般字符串表达方式，则要消耗更多的内存。 UTF-16 使用一个或两个未分配的16位代码单元的序列对 Unicode 代码点进行编码。假设U是一个代码点，也就是Unicode编码表中一个字符所对应的Unicode值: (1) 如果在BMP级别中，那么16bits(一个代码单元)就足够表示出字符的Unicode值。 (2)如果U+10FFFF&gt;U&gt;=U+10000，也就是处于增补字符级别中。UTF-16用2个16位来表示出了，并且正好将每个16位都控制在替代区域U+D800-U+DFFF（其中\\uD800-\\uDBFF为高代理项 范围，\\uDC00- \\uDFFF为低代理项 范围） 中。 也就是说，在UTF-16中，增补字符的表示方式是由两个代码单元来表示的，原因就是一个代码单元放不下它。那么在java中是如何处理这些增补字符的呢？ java的处理方式是这样的：对于增补字符U（U+10FFFF&gt;U&gt;=U+10000）。首先，分别初始化2个16位无符号的整数 —— W1和W2。其中W1=110110xxxxxxxxxx（0xD800-0xDBFF）,W2 = 110111xxxxxxxxxx(0xDC00-OxDFFF)。然后，将Unicode的高10位分配给W1的低10位，将Unicode 的低10位分配给W2的低10位。这样就可以将20bits的代码点U拆成两个16bits的代码单元。而且这两个代码点正好落在替代区域U+D800-U+DFFF中。 UTF-16表示的增补字符怎样才能被正确的识别为增补字符，而不是两个普通的字符呢？答案是通过看它的第一个char是不是在高代理范围内，第二个char是不是在低代理范围内来决定，这也意味着，高代理和低代理所占的共2048个码位（从0xD800到0xDFFF）是不能分配给其他字符的。 Unicode的编号中，U+D800到U+DFFF是否有字符分配？答案是也没有！这么做的目的是希望基本多语言面中的字符和一个char型的UTF-16编码的字符能够一一对应。（这里就不写代码验证了） java具体的是怎么来拆分增补字符的呢？看一个例子：通过两个代码点U+11001,U+1D56B（使用4个字节表示的代码点）以U+1D56B来说 0x1D56B= 0001 1101 01-01 0110 1011 将0x1D56B的高10位0001 1101 01分配给W1的低10位组合成110110 0001 1101 01=0xD875 将0x1D56B的低10位01 0110 1011分配给W2的低10位组合成110111 01 0110 1011=0xDD6B 这样代码点U+1D56B采用UTF-16编码方式，用2个连续的代码单元U+D875和U+DD6B表示出了 12345678910int[] codePoints = &#123;0x11001,0x1d56b&#125;; //增补字符 String s = new String(codePoints,0,2); System.out.println(\"s: \" + s); System.out.println(\"s.length: \" + s.length()); //4,说明length()是按代码单元计算的 System.out.println(\"s.charAt(0): \" + Integer.toHexString((int)s.charAt(0)));//输出结果表明增补字符并非简单地把两个代码单元拆开 System.out.println(\"s.charAt(1): \" + Integer.toHexString((int)s.charAt(1)));System.out.println(\"s.charAt(2): \" + Integer.toHexString((int)s.charAt(2)));System.out.println(\"s.charAt(3): \" + Integer.toHexString((int)s.charAt(3)));System.out.println(\"s.codePointAt(0):\" + Integer.toHexString(s.codePointAt(0))); 输出结果是： 1234567s: ??s.length: 4s.charAt(0): d804s.charAt(1): dc01s.charAt(2): d835s.charAt(3): dd6bs.codePointAt(0):11001 可以看到 字符串的长度为4，说明length()是按代码单元计算的，然后我们看看U+1D56B的拆分结果： s.charAt(2): d835s.charAt(3): dd6b 与我们计算的 U+D875 U+DD6B 有出入，该代理代码点不一样，带着这个疑问，我们去看看java代码是如何转化的: 1234567891011121314151617181920212223242526272829303132333435[java.lang.String] for (int i = offset, j = 0; i &lt; end; i++, j++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) //判断是不是BMP级别 v[j] = (char) c; else Character.toSurrogates(c, v, j++);//给出高低代理项&#125;[java.lang.Character]static void toSurrogates(int codePoint, char[] dst, int index) &#123; // We write elements \"backwards\" to guarantee all-or-nothing dst[index+1] = lowSurrogate(codePoint);//给出低代理项 dst[index] = highSurrogate(codePoint);//给出高代理项&#125; [java.lang.Character] public static final char MIN_LOW_SURROGATE = '\\uDC00';//低代理项最小值public static char lowSurrogate(int codePoint) &#123; return (char) ((codePoint &amp; 0x3ff) + MIN_LOW_SURROGATE);&#125; [java.lang.Character] public static final char MIN_HIGH_SURROGATE = '\\uD800';//高代理项最小值public static final int MIN_SUPPLEMENTARY_CODE_POINT = 0x010000;//增补字符最小代码点public static char highSurrogate(int codePoint) &#123; return (char) ((codePoint &gt;&gt;&gt; 10) + (MIN_HIGH_SURROGATE - (MIN_SUPPLEMENTARY_CODE_POINT &gt;&gt;&gt; 10)));&#125; 可以看出低代理项与计算方式一样，所以计算出的结果一致，但是高代理项在移位10bit，加上最小高代理项后，又减去了增值字符最小代码点的移位10bit后的值，其实这就相当于，对于增补字符U+1D56B，其操作是对 U+0D56B进行的操作。这里还没有确定为什么会减去这个位，有待考证！ UTF-8：网摘： 使用一至四个字节的序列对编码 Unicode 代码点进行编码。U+0000 至 U+007F 使用一个字节编码，U+0080 至 U+07FF 使用两个字节，U+0800 至 U+FFFF 使用三个字节，而 U+10000 至 U+10FFFF 使用四个字节。UTF-8 设计原理为：字节值 0x00 至 0x7F 始终表示代码点 U+0000 至 U+007F（Basic Latin 字符子集，它对应 ASCII 字符集）。这些字节值永远不会表示其他代码点，这一特性使 UTF-8 可以很方便地在软件中将特殊的含义赋予某些 ASCII 字符。 以下是Unicode和UTF-8之间的转换关系表： U-00000000 - U-0000007F： 0xxxxxxx U-00000080 - U-000007FF： 110xxxxx 10xxxxxx U-00000800 - U-0000FFFF： 1110xxxx 10xxxxxx 10xxxxxx U-00010000 - U-001FFFFF： 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx U-00200000 - U-03FFFFFF： 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx U-04000000 - U-7FFFFFFF： 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 可以看到： （1）如果一个字节以10开头，一定不是首字节，需要向前查找。 （2）在一个首字节中，如果以0开头，表示是一个ASCII字符，而开头的连续的1的个数也表示了这个字符的字节数。如1110xxxx表示这个字符由三个字节组成。 下面来看一个使用各种编码对字符进行编码的例子，如下： img 分析到这里，结合源码，可以看出： Java 以 UTF-16 作为内存的字符存储格式。 参考： http://blog.csdn.net/u010411264/article/details/45258629http://blog.csdn.net/cumtwyc/article/details/45080679http://blog.csdn.net/mazhimazh/article/details/17708001","categories":[{"name":"转载","slug":"转载","permalink":"http://QQ876684433.github.io/categories/转载/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"}]},{"title":"深入剖析Java序列化与反序列化机制","slug":"深入剖析Java序列化与反序列化机制","date":"2019-07-16T15:10:08.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/07/16/深入剖析Java序列化与反序列化机制/","link":"","permalink":"http://QQ876684433.github.io/2019/07/16/深入剖析Java序列化与反序列化机制/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"精读Java源码-String类","slug":"精读Java源码-String类","date":"2019-07-16T12:59:00.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/07/16/精读Java源码-String类/","link":"","permalink":"http://QQ876684433.github.io/2019/07/16/精读Java源码-String类/","excerpt":"","text":"精读Java源码 - String类 基于jdk1.8 推荐资料： https://www.kaelli.com/33.html http://cmsblogs.com/?p=5256 http://cmsblogs.com/?p=5258 类定义public没什么好说的，final修饰符则决定了String类是不可继承的且对象是不可变的，你无法自己写一个继承自String的类，而String对象的不可变性也是大家耳熟能详的。 实现了java.io.Serializable、Comparable和CharSequence共3个接口： Serializable是用来保证String可以序列化和反序列化的。 Comparable的compareTo(String str)方法则是实现String的对比排序的。 CharSequence的length()方法用来返回字符串长度，charAt(int index)则可以获取到给定位置的单个字符，subSequence(int start, int end)则提供了截取子字符串的功能，toString()方法对于String来说就是返回它自己了 重要属性123456789101112131415161718192021/** The value is used for character storage. */private final char value[];/** Cache the hash code for the string */private int hash; // Default to 0/** use serialVersionUID from JDK 1.0.2 for interoperability */private static final long serialVersionUID = -6849794470754667710L;/** * Class String is special cased within the Serialization Stream Protocol. */private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];/** * A Comparator that orders &#123;@code String&#125; objects as by * &#123;@code compareToIgnoreCase&#125;. This comparator is serializable. */public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator(); value 用于存储字符串对象的值，在jdk1.8里面是char数组，在后面的版本中改成了byte数组；被final修饰说明它是不可变的 hash 为字符串对象的哈希值，默认值为0 serialPersistentFields 看定义，它是一个私有的、静态的、不可改变的ObjectStreamField数组，实际上在JDK源码里有很多类都有这样一个属性，这些类的共同点是都实现了java.io.Serializable接口。在默认情况下一个实现了Serializable接口的类，所有的非 transient 非 static 修饰的字段都会被序列化，但如果还定义了serialPersistentFields字段，则只有serialPersistentFields里添加的字段才会被序列化。当一个字段用transient修饰，但又位于serialPersistentFields数组里时，它依然会被序列化——说明serialPersistentFields的作用优先级是比transient高的。 在String类里，serialPersistentFields是一个容量为0的空数组，显然String的字段都不会被序列化 CASE_INSENSITIVE_ORDER 表示用于排序的比较器 构造函数排除@Deprecated的构造函数，String类提供的构造函数主要有以下几类： 无参构造函数 123public String() &#123; this.value = \"\".value;&#125; 从原有字符串构造新的字符串 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; 直接对参数里的原字符串进行浅拷贝构造新的字符串，由于String类是final的，而且内部的value也是final的，所以字符序列在不同的String实例中共享不会带来任何副作用 通过字符数组构造字符串 1234567891011121314151617181920212223public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125;public String(char value[], int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= value.length) &#123; this.value = \"\".value; return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; this.value = Arrays.copyOfRange(value, offset, offset+count);&#125; 这个也没什么好讲的，它直接对参数里的字节数组进行了拷贝，这样的目的是使得外部的字节数组更改之后不会对字符串的字符序列造成影响。offset &gt; value.length - count的处理是为了防止offset+count的int类型溢出 通过整型数组构造字符串 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public String(int[] codePoints, int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= codePoints.length) &#123; this.value = \"\".value; return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; codePoints.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; //=============================分割线============================ final int end = offset + count; // Pass 1: Compute precise size of char[] int n = count; for (int i = offset; i &lt; end; i++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) continue; else if (Character.isValidCodePoint(c)) n++; else throw new IllegalArgumentException(Integer.toString(c)); &#125; // Pass 2: Allocate and fill in char[] final char[] v = new char[n]; for (int i = offset, j = 0; i &lt; end; i++, j++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) v[j] = (char)c; else Character.toSurrogates(c, v, j++); &#125; this.value = v;&#125; 分割线上部分没什么好讲的，就是常规的参数边界检查，下半部分有点意思，它涉及到了代码点和代码单元的知识以及Java对Unicode字符集的处理方法，具体的可以参考：https://chph.xyz/2019/07/17/%E7%94%B1String%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%B3%E5%87%BA%E6%9D%A5%E7%9A%84java%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/#%E7%94%B1String%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%B3%E5%87%BA%E6%9D%A5%E7%9A%84java%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81 通俗来讲，它的处理分为两个阶段： （1）计算int数组转成char数组后的精确长度，之所以两者不同，是因为Java采用了UTF-16字符编码，而Unicode代码点在不同的编码中的代码单元是不同的，UTF-16的字符编码由基本多语言面（BMP UBasic Multilingual Plane ）和增补字符（Supplementary Character）两部分组成，前者占用一个char，后者占用两个char，因此在遍历int数组时，Character.isBmpCodePoint(c)用来判断c是否是BMP，如果是，则长度不变，如果不是，而且它是有效的代码点Character.isValidCodePoint(c)，那么就要在原来int数组的长度是加一n++ （2）计算出char数组的长度后，就可以分配空间并填充该空间了，道理类似，如果是BMP，则直接将int转为char，否则的话就要使用Character.toSurrogates(c, v, j++)来转换 12345static void toSurrogates(int codePoint, char[] dst, int index) &#123; // We write elements \"backwards\" to guarantee all-or-nothing dst[index+1] = lowSurrogate(codePoint); dst[index] = highSurrogate(codePoint);&#125; 这个涉及到增补字符的高代理项和低代理项的转换，具体的原理在上面的链接里有提到了，这里不再深究，留待精读Character源码时再研究 最后将填充完成的char数组赋值给新的String实例的value即可 通过字节数组构造字符串 1234567891011121314151617181920212223242526272829303132public String(byte bytes[], int offset, int length, String charsetName) throws UnsupportedEncodingException &#123; if (charsetName == null) throw new NullPointerException(\"charsetName\"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charsetName, bytes, offset, length);&#125;public String(byte bytes[], int offset, int length, Charset charset) &#123; if (charset == null) throw new NullPointerException(\"charset\"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charset, bytes, offset, length);&#125;public String(byte bytes[], String charsetName) throws UnsupportedEncodingException &#123; this(bytes, 0, bytes.length, charsetName);&#125;public String(byte bytes[], Charset charset) &#123; this(bytes, 0, bytes.length, charset);&#125;public String(byte bytes[], int offset, int length) &#123; checkBounds(bytes, offset, length); this.value = StringCoding.decode(bytes, offset, length);&#125;public String(byte bytes[]) &#123; this(bytes, 0, bytes.length);&#125; 这几个构造函数的功能类似，根据给定的字符编码，调用StringCoding.decode来对字节数组进行解码来构造字符串，如果不提供字符编码的话，StringCoding.decode内部会调用String csn = Charset.defaultCharset().name();来使用Java默认的字符串编码来解码。 内部类CaseInsensitiveComparatorCaseInsensitiveComparator是String类内部一个大小写不敏感的字符串比较器，被String类内部的方法compareToIgnoreCase使用 12345678910111213141516171819202122232425262728293031private static class CaseInsensitiveComparator implements Comparator&lt;String&gt;, java.io.Serializable &#123; // use serialVersionUID from JDK 1.2.2 for interoperability private static final long serialVersionUID = 8575799808933029326L; public int compare(String s1, String s2) &#123; int n1 = s1.length(); int n2 = s2.length(); int min = Math.min(n1, n2); for (int i = 0; i &lt; min; i++) &#123; char c1 = s1.charAt(i); char c2 = s2.charAt(i); if (c1 != c2) &#123; c1 = Character.toUpperCase(c1); c2 = Character.toUpperCase(c2); if (c1 != c2) &#123; c1 = Character.toLowerCase(c1); c2 = Character.toLowerCase(c2); if (c1 != c2) &#123; // No overflow because of numeric promotion return c1 - c2; &#125; &#125; &#125; &#125; return n1 - n2; &#125; /** Replaces the de-serialized object. */ private Object readResolve() &#123; return CASE_INSENSITIVE_ORDER; &#125;&#125; compareTo方法的主要思路是，循环遍历比较两个字符串长度匹配的部分，如果该部分忽略大小写后相等，那么比较的结果就是两者长度的比较，按照字典序，结果就是长度小的靠前。 长度匹配部分的比较比较有意思，它有三次判断：直接比较、转成大写字母比较、转成小写字母比较。这么做的原因和regionMatches方法的处理方式大致相同，因为对有些语言比如格鲁吉亚字母（Georgian alphabet），它的大小写转换规则有点特殊：大写不等还不一定不等，还需要转小写 比如 ქართული დამწერლობა。因此在退出比较之前还要再次转换成小写字母进行最后一次检查。 关于readResolve，我在stackoverflow找到的解释如下： readResolve is used for replacing the object read from the stream. The only use I’ve ever seen for this is enforcing singletons; when an object is read, replace it with the singleton instance. This ensures that nobody can create another instance by serializing and deserializing the singleton. The readResolve method is called when ObjectInputStream has read an object from the stream and is preparing to return it to the caller. ObjectInputStream checks whether the class of the object defines the readResolve method. If the method is defined, the readResolve method is called to allow the object in the stream to designate the object to be returned. The object returned should be of a type that is compatible with all uses. If it is not compatible, a ClassCastException will be thrown when the type mismatch is discovered. Item 90, Effective Java, 3rd Ed covers readResolve and writeReplace for serial proxies - their main use. The examples do not write out readObject and writeObject methods because they are using default serialisation to read and write fields. readResolve is called after readObject has returned (conversely writeReplace is called before writeObject and probably on a different object). The object the method returns replaces thisobject returned to the user of ObjectInputStream.readObject and any further back references to the object in the stream. Both readResolve and writeReplace may return objects of the same or different types. Returning the same type is useful in some cases where fields must be final and either backward compatibility is required or values must copied and/or validated. Use of readResolve does not enforce the singleton property. …… 源于：https://stackoverflow.com/questions/1168348/java-serialization-readobject-vs-readresolve/24459741 按照我的理解来讲就是当ObjectInputStream读到一个对象时，会检查这个对象的类是否定义了readResolve方法，如果定义了该方法，那么会将该方法的返回值作为对象返回，而不是返回ObjectInputStream在流中读到的对象，这样就可以强制实现单例模式。但是如果流中读到的对象和readResolve方法返回的对象类型不兼容，那么就会抛出ClassCastException。 主要方法regionMatchesregionMatches功能是判断两个字符串指定区间、且具有相同长度的子串是否相等，它有两个重载的方法： 12public boolean regionMatches(int toffset, String other, int ooffset, int len);public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 它们的唯一区别是前者大小写敏感，后者可以指定是否忽略大小写。只有当一下某一个条件满足（即返回值为true）时，该方法的结果是false，即两个子串不相等： 下标越界：toffset&lt;0、ooffset&lt;0、toffset+len&gt;this.length()、ooffset+len&gt;other.length() 下标不越界情况下，两个子串的某一个位置对应的字符不相等 由于两个重载的方法中后者的功能涵盖了前者，因此我们只看后者的源码： 12345678910111213141516171819202122232425262728293031323334353637383940public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false; &#125; while (len-- &gt; 0) &#123; char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) &#123; continue; &#125; if (ignoreCase) &#123; // If characters don't match but case may be ignored, // try converting both characters to uppercase. // If the results match, then the comparison scan should // continue. char u1 = Character.toUpperCase(c1); char u2 = Character.toUpperCase(c2); if (u1 == u2) &#123; continue; &#125; // Unfortunately, conversion to uppercase does not work properly // for the Georgian alphabet, which has strange rules about case // conversion. So we need to make one last check before // exiting. if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123; continue; &#125; &#125; return false; &#125; return true;&#125; 转成大写再转小写这个做法在前面的部分CaseInsensitiveComparator中已经提到了，道理是类似的，我们来看看这个地方： 123456// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false;&#125; 这个地方的处理比较精妙，-1&gt;&gt;&gt;1等于2147483647，即int类型的上界，它考虑到了toffset和ooffset的值有可能是很靠近甚至等于这个上界的，如果使用toffset + len &gt; (long)value.length来判断的话，有可能出现toffset + len溢出的情况，而源码中的写法就能很好地解决了这个问题。 length直接返回内部字符数组的长度 123public int length() &#123; return value.length;&#125; isEmpty123public boolean isEmpty() &#123; return value.length == 0;&#125; charAt返回String类内部字符数组value在参数索引处的字符，如果该位置的字符是高低代理项，那么它返回的字符也是高低代理项的值 123456public char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return value[index];&#125; codePointAt这个方法和charAt不同的地方在于，它返回的是int型的Unicode代码点，因此他会有两种情况： index位置的字符是BMP的话，则直接返回index位置的字符对应的int值 index位置的字符是在高代理项的范围内，如果index+1&lt;value.length，而且index+1位置的字符在低代理项范围内，那么将会返回(index, index+1)这对字符对应的Unicode增补代码点 123456public int codePointAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointAtImpl(value, index, value.length);&#125; codePointBefore返回参数index位置之前的Unicode代码点，因此它会有如下情况： index-1位置的字符在低代理项范围内，且index-2是非负数，那么返回(index-2, index-1)对应的Unicode代码点 index-1位置的字符是没有配对的高代理项（可能的情况是index-1和index位置的字符是配对的）或者低代理项（这个不是很理解）的话，则直接返回index-1位置字符的int值，不作转换 1234567public int codePointBefore(int index) &#123; int i = index - 1; if ((i &lt; 0) || (i &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointBeforeImpl(value, index, 0);&#125; codePointCount计算[beginIndex, endIndex)范围内的子串的代码点个数，怎么计算的很容易，只需要注意的是，对于该范围内的子串，如果有字符是没有配对的代理项，那么它也当成一个代码点来计数 123456public int codePointCount(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0 || endIndex &gt; value.length || beginIndex &gt; endIndex) &#123; throw new IndexOutOfBoundsException(); &#125; return Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex);&#125; offsetByCodePoints计算从index位置开始，偏移codePointOffset个代码点后的索引位置，注意，这个codePointOffset可以是负数，这种情况下是往左偏移；同理，如果遇到不匹配的代理项，也是当成一个代码点来计数 1234567public int offsetByCodePoints(int index, int codePointOffset) &#123; if (index &lt; 0 || index &gt; value.length) &#123; throw new IndexOutOfBoundsException(); &#125; return Character.offsetByCodePointsImpl(value, 0, value.length, index, codePointOffset);&#125; getChars该方法的主要功能是将字符串读取成字符数组，默认修饰符的getChars是没有任何边界参数检测的，原因很简单，因为它只在类库内部才能使用（concat方法），按照契约式编程原则是不会有意外情况发生的；public修饰的方法，它会对参数进行边界条件检测，用于将指定范围（srcBegin、srcEnd）的子串复制到字符数组参数dst中 12345678910111213141516void getChars(char dst[], int dstBegin) &#123; System.arraycopy(value, 0, dst, dstBegin, value.length);&#125;public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin &gt; srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);&#125; getBytes获取字符串指定编码的字节数组，比如 charsetName 为 utf8，则将字符串转为 utf8 编码后对应的字节数组。如果不传参数则使用 JVM 默认编码，即Charset.defaultCharset() 1234567891011121314public byte[] getBytes(String charsetName) throws UnsupportedEncodingException &#123; if (charsetName == null) throw new NullPointerException(); return StringCoding.encode(charsetName, value, 0, value.length);&#125;public byte[] getBytes(Charset charset) &#123; if (charset == null) throw new NullPointerException(); return StringCoding.encode(charset, value, 0, value.length);&#125;public byte[] getBytes() &#123; return StringCoding.encode(value, 0, value.length);&#125; equals用来判断两个字符串的内容是否相同，但是仔细看可以发现，equals方法的参数其实是Object类型的，其实道理很简单，String类的equals方法是直接继承自Object类的，属于方法重写，参数个数和类型要相同，Object中的equals方法参数就是Object类型，该方法的实现思路如下： 首先判断是不是同一个对象，如果是则返回true 判断参数anObject是否是String类型（防御式编程），如果不是，则直接返回false 最后再逐个字符进行比较，因为这是在String类内部，可以直接访问value 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; contentEqualscontentEquals的功能和equals差不多，都是比较字符串的内容是否相同，区别在于它的参数是StringBuffer或者CharSequence，适用范围更广。 AbstractStringBuilder是StringBuffer和StringBuilder的公共父类，前者是线程安全的，后者是非线程安全的，因此需要分别对他们进行处理，StringBuffer需要加上synchronized同步块；注意到，无论是StringBuffer还是StringBuilder，cs都被强制转换为StringBuilder，最后调用nonSyncContentEquals方法来进行内容比较。 不同类型的字符串内容的比较算法都差不多，基本上都是先比较长度是否相同，这样可以避免不必要的循环遍历比较，如果相同再逐个字符比较 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean contentEquals(StringBuffer sb) &#123; return contentEquals((CharSequence)sb);&#125;private boolean nonSyncContentEquals(AbstractStringBuilder sb) &#123; char v1[] = value; char v2[] = sb.getValue(); int n = v1.length; if (n != sb.length()) &#123; return false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v1[i] != v2[i]) &#123; return false; &#125; &#125; return true;&#125;public boolean contentEquals(CharSequence cs) &#123; // Argument is a StringBuffer, StringBuilder if (cs instanceof AbstractStringBuilder) &#123; if (cs instanceof StringBuffer) &#123; synchronized(cs) &#123; return nonSyncContentEquals((AbstractStringBuilder)cs); &#125; &#125; else &#123; return nonSyncContentEquals((AbstractStringBuilder)cs); &#125; &#125; // Argument is a String if (cs instanceof String) &#123; return equals(cs); &#125; // Argument is a generic CharSequence char v1[] = value; int n = v1.length; if (n != cs.length()) &#123; return false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v1[i] != cs.charAt(i)) &#123; return false; &#125; &#125; return true;&#125; equalsIgnoreCase判断两个字符串在忽略大小写情况下内容是否相同，遇到大小写就应该想到个别字母的大小写转换规则比较特殊，参见CaseInsensitiveComparator部分具体说明，因此对应位置两个字符是否相同条件是以下其中一个： 直接==比较返回true Character.toUpperCase转换成大写字母后==比较相同 Character.toLowerCase转换成小写字母后==比较相同 当然，这部分的判断直接调用了内部的方法regionMatches进行比较了。 这个方法首先判断两个字符串是否是同一个对象，是则返回true，否则再判断参数字符串是否是null（防御式编程），然后再判断两个字符串长度是否相同，最后再比较字符串内容。 123456public boolean equalsIgnoreCase(String anotherString) &#123; return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length);&#125;","categories":[{"name":"源码","slug":"源码","permalink":"http://QQ876684433.github.io/categories/源码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"}]},{"title":"软件学院大三上教材推荐","slug":"软件学院大三上教材推荐","date":"2019-07-16T03:23:11.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/07/16/软件学院大三上教材推荐/","link":"","permalink":"http://QQ876684433.github.io/2019/07/16/软件学院大三上教材推荐/","excerpt":"","text":"软件学院大三上教材推荐 来源：根据某朱姓学长的聊天记录整理 教材推荐建议 课程 教材 备注 计算机与操作系统 操作系统教材，骆斌 原来是第五版，今年可能有第六版 数据库管理基础 数据库原理，编程与性能 数据库换了老师，今年的教材可能不确定 C++高级程序设计 C++程序设计，钱能 有推荐教材，但是老师不会按教材讲 软件系统设计 没有教材 大数据分析 没有教材，可以参考cs246的《大数据互联网大规模数据挖掘与分布式处理》 虽然推荐了cs246，但是老师不会按那个讲 云计算 没有教材 自动化测试 没有教材，可以参考陈振宇的《开发者测试》 除了开发者测试，还要学安卓测试，web测试，ai测试 web前端开发 有教材，但是经常变，去年是《Web开发权威指南》 编译原理 龙书，非常厚，可以买虎书看看，薄一点 龙书叫编译原理，看准翻译老师，是赵建华(计算机系编译原理、算法老师，今年给软院上离散)，郑滔(我们c++老师)，戴新宇(计算机系自然语言处理组老师)翻译的虎书叫现代编译原理 嵌入式系统概论 嵌入式系统软件工程 别买，血亏；很厚，没时间看 商务智能 没有教材 可以买复旦老师的《商务智能》，但是和贝佳的重点不一样，贝佳重点是数据仓库，复旦老师重点是数据挖掘 书籍的pdf资源TODO","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://QQ876684433.github.io/tags/软件工程/"}]},{"title":"Java 技术书籍大全","slug":"Java 技术书籍大全","date":"2019-07-16T01:33:19.000Z","updated":"2019-09-15T04:40:38.600Z","comments":true,"path":"2019/07/16/Java 技术书籍大全/","link":"","permalink":"http://QQ876684433.github.io/2019/07/16/Java 技术书籍大全/","excerpt":"","text":"转载原文：https://github.com/sorenduan/awesome-java-books Java 技术书籍大全本文档目前已收录 277本 Java相关领域经典技术书籍，从初级开发者到资深架构师，涵盖 Java 从业者的各个阶段，并持续更新。 涵盖领域：Java入门书籍，Java基础及进阶书籍，框架与中间件，架构设计，设计模式，数学与算法，JVM周边语言，项目管理&amp;领导力&amp;流程，职业素养与个人成长，格局与视野，面试参考书等。 推荐书籍可以点击 -&gt; 点击这里 书籍列表 -&gt; 点击这里 入门书籍 《明解Java》 - 豆瓣评分 8.5 《Java从入门到精通（第4版 附光盘）》 - 豆瓣评分 6 《入门很简单丛书：Java Web开发入门很简单》 《程序员炼成记 从小白到工程师》 《Java从小白到大牛》 《JavaWeb项目开发实战入门（全彩版）》 《Java精彩编程200例（全彩版）》 《Java轻松学》 《大话Java：程序设计从入门到精通（含DVD光盘1张）》 《Java语言袖珍指南（第二版）》 基础书籍 《Java编程思想（第4版） [thinking in java]》 - 豆瓣评分 9.1 《Java核心技术 卷I：基础知识（原书第10版）》 - 豆瓣评分 8.2 《Java核心技术卷II：高级特性（原书第10版）》 - 豆瓣评分 7.7 多线程与并发 《华章专业开发者丛书·Java并发编程实战》 - 豆瓣评分 9.1 《Java多线程编程实战指南（设计模式篇）》 - 豆瓣评分 8.5 《图解Java多线程设计模式》 - 豆瓣评分 8.4 《实战Java高并发程序设计》 - 豆瓣评分 8.3 《Java高并发编程详解：多线程与架构设计》 - 豆瓣评分 7.6 《Java核心技术系列：Java多线程编程核心技术 [Java Multi-thread Programming]》 - 豆瓣评分 5.1 《Java并发编程：核心方法与框架》 《Java多线程与Socket：实战微服务框架》 《NIO与Socket编程技术指南》 《Java并发编程之美》 《实战Java高并发程序设计（第2版）》 网络编程 《Java网络编程（第四版） [Java network programming, forth edition]》 - 豆瓣评分 7.6 数据结构 《数据结构与算法分析：Java语言描述（原书第3版）》 - 豆瓣评分 8.3 《图解数据结构：使用Java》 《数据结构与算法Java语言描述》 语言基础 《Java 8实战》 - 豆瓣评分 9.2 《Java函数式编程》 - 豆瓣评分 8.9 《Java编程的逻辑》 - 豆瓣评分 8.9 《O’Reilly：Head First Java（中文版 第2版 涵盖Java5.0）》 - 豆瓣评分 8.7 《写给大忙人看的Java核心技术》 - 豆瓣评分 7.1 《精通lambda表达式：Java多核编程 [Mastering Lambdas: Java Programming in a Multicore]》 《Java 9模块化开发：核心原则与实践》 《Java JDK 9学习笔记》 《Java 9编程参考官方大全（第10版） [Java：Thte Complete Reference，Tenth Edition]》 《写给大忙人的Java SE 9核心技术》 进阶 《深入分析Java Web技术内幕（修订版）》 - 豆瓣评分 7.5 《Java RESTful Web Service实战（第2版）》 性能优化 《Java性能优化权威指南 [Java performance]》 - 豆瓣评分 8.4 《Java程序性能优化：让你的Java程序更快、更稳定》 - 豆瓣评分 8.1 《Java性能权威指南》 - 豆瓣评分 8.1 《51CTO学院系列丛书·实战Java虚拟机：JVM故障诊断与性能优化》 - 豆瓣评分 8 《Java性能调优指南》 - 豆瓣评分 7 《大话Java性能优化》 - 豆瓣评分 4.4 响应式编程 《响应式架构：消息模式Actor实现与Scala、Akka应用集成》 - 豆瓣评分 8.1 《RxJava响应式编程》 《RxJava 2.x 实战》 JVM虚拟机 《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》 - 豆瓣评分 8.9 《Java核心技术系列：Java虚拟机规范（Java SE 8版） [The Java Virtual Machine Specification Jave SE 8 Edition]》 - 豆瓣评分 8.3 《揭秘Java虚拟机：JVM设计原理与实现》 - 豆瓣评分 7.9 《HotSpot实战》 - 豆瓣评分 7.1 《Java从入门到动手写虚拟机1（套装共2册）》 代码&amp;设计优化 《重构 改善既有代码的设计 Java语言版》 - 豆瓣评分 9.3 《代码大全（第2版）》 - 豆瓣评分 9.3 《Effective Java中文版（原书第3版）》 - 豆瓣评分 9 《代码整洁之道 程序员的职业素养》 - 豆瓣评分 8.8 《代码整洁之道 [Clean Code A Handbook of Agile Software Craftsmanship]》 - 豆瓣评分 8.6 《Spring实战（第4版）》 - 豆瓣评分 8.3 《代码不朽：编写可维护软件的10大要则（Java版）》 - 豆瓣评分 7 《Java代码与架构之完美优化 实战经典》 设计模式 《反应式设计模式》 - 豆瓣评分 9.3 《O’Reilly：Head First设计模式（中文版）》 - 豆瓣评分 9.2 《设计模式：可复用面向对象软件的基础》 - 豆瓣评分 9.1 《实现领域驱动设计 [Implementing Domain-Driven Design]》 - 豆瓣评分 8.7 《原创精品系列：设计模式之禅（第2版）》 - 豆瓣评分 8.7 《图解设计模式》 - 豆瓣评分 8.7 《大话设计模式》 - 豆瓣评分 8.3 《领域驱动设计 软件核心复杂性应对之道 修订版》 - 豆瓣评分 8 《Java测试驱动开发》 - 豆瓣评分 6.6 框架与中间件数据库 《高性能MySQL（第3版）》 - 豆瓣评分 9.3 《MySQL技术内幕：InnoDB存储引擎（第2版）》 - 豆瓣评分 8.6 《大型网站系统与Java中间件实践》 - 豆瓣评分 7.9 《深入浅出MySQL 数据库开发 优化与管理维护 第2版》 - 豆瓣评分 7.5 《PostgreSQL修炼之道：从小工到专家》 - 豆瓣评分 7.3 《PostgreSQL技术内幕：查询优化深度探索》 缓存与NoSQL 《Redis 深度历险：核心原理与应用实践》 - 豆瓣评分 9 《Redis实战》 - 豆瓣评分 8 《Redis入门指南（第2版）》 - 豆瓣评分 7.6 《深入分布式缓存：从原理到实践》 - 豆瓣评分 7.1 《人人都是架构师：分布式系统架构落地与瓶颈突破》 - 豆瓣评分 6.7 《MongoDB应用设计模式》 - 豆瓣评分 6.1 《MongoDB实战 架构、开发与管理》 《NoSQL数据库入门与实践（基于MongoDB、Redis）》 消息队列 《RabbitMQ实战指南》 - 豆瓣评分 9.1 《Kafka权威指南》 - 豆瓣评分 8.9 《Kafka入门与实践》 - 豆瓣评分 7.7 《RocketMQ实战与原理解析》 - 豆瓣评分 7.2 《Kafka技术内幕 图文详解Kafka源码设计与实现》 - 豆瓣评分 6.9 《深入理解Kafka：核心设计与实践原理》 《分布式消息中间件实践》 ORM框架 《MyBatis从入门到精通》 - 豆瓣评分 7.7 Spring家族 《Spring微服务实战》 - 豆瓣评分 8.3 《Spring Cloud微服务实战》 - 豆瓣评分 7.9 《深入理解Spring Cloud与微服务构建》 - 豆瓣评分 7.7 《MyBatis技术内幕》 - 豆瓣评分 7.6 《Spring Boot实战》 - 豆瓣评分 7.2 《深入浅出Spring Boot 2.x》 - 豆瓣评分 7 《JavaEE开发的颠覆者：Spring Boot实战》 - 豆瓣评分 6.3 《Spring技术内幕：深入解析Spring架构与设计原理（第2版）》 - 豆瓣评分 5.9 《Spring Boot 2精髓：从构建小系统到架构分布式大系统》 - 豆瓣评分 4.8 《Spring 5开发大全》 《Spring Cloud微服务架构进阶》 《Spring源码深度解析 第2版》 《Spring MVC实战》 《Spring Boot编程思想（核心篇）（限量版亲笔签名书签 随机发售）》 《互联网轻量级SSM框架解密：Spring、Spring MVC、MyBatis源码深度剖析》 《Spring学习指南 第3版》 《精通Spring MVC 4》 高并发 《Netty实战》 - 豆瓣评分 7.8 《七周七并发模型》 - 豆瓣评分 7.8 《Netty权威指南（第2版）》 - 豆瓣评分 6.9 《Netty进阶之路：跟着案例学Netty》 分布式 《从Paxos到Zookeeper分布式一致性原理与实践》 - 豆瓣评分 7.8 《ZooKeeper：分布式过程协同技术详解》 - 豆瓣评分 7.2 搜索引擎 《从Lucene到Elasticsearch：全文检索实战》 大数据 《Hadoop权威指南：大数据的存储与分析(第4版)》 - 豆瓣评分 8.7 《Hadoop构建数据仓库实践》 - 豆瓣评分 8.3 《HBase权威指南 [HBase： The Definitive Guide]》 - 豆瓣评分 8.1 《图解Spark：核心技术与案例实战》 - 豆瓣评分 7.6 《Hive编程指南 [Programming Hive]》 - 豆瓣评分 7.4 《HBase应用架构》 架构 《Web性能权威指南》 - 豆瓣评分 8.8 《从零开始学架构：照着做，你也能成为架构师》 - 豆瓣评分 8.5 《Java应用架构设计：模块化模式与OSGi》 - 豆瓣评分 6.9 《大型网站技术架构演进与性能优化》 - 豆瓣评分 6.8 《高可用架构（第1卷）》 - 豆瓣评分 6.3 《Java架构师指南》 《大话代码架构（项目实战版）》 《小团队构建大网站：中小研发团队架构实践》 《未来架构 从服务化到云原生(限量签名 随机发放)》 分布式架构 《可伸缩架构：面向增长应用的高可用》 - 豆瓣评分 7.4 《分布式服务架构：原理、设计与实战》 - 豆瓣评分 7.2 《亿级流量网站架构核心技术 跟开涛学搭建高可用高并发系统》 - 豆瓣评分 6.6 《大型分布式网站架构设计与实践》 - 豆瓣评分 6.2 《可伸缩服务架构：框架与中间件》 - 豆瓣评分 5.9 《架构探险：从零开始写分布式服务框架》 - 豆瓣评分 5.9 《Cloud Native分布式架构原理与实践》 《分布式系统常用技术及案例分析（第2版）》 《云原生Java：Spring Boot、Spring Cloud与Cloud Foundry弹性系统设计》 微服务架构 《微服务设计》 - 豆瓣评分 8.2 《生产微服务》 - 豆瓣评分 8 《架构解密：从分布式到微服务》 - 豆瓣评分 5.8 《Java微服务》 - 豆瓣评分 5.3 《Spring Cloud 微服务架构开发实战（全新升级版）》 《微服务实践》 架构方法论 《架构整洁之道》 - 豆瓣评分 8.8 《企业应用架构模式 [Patterns of Enterprise Application Architecture]》 - 豆瓣评分 8.3 《企业IT架构转型之道 阿里巴巴中台战略思想与架构实战》 - 豆瓣评分 8.2 《聊聊“架构”》 - 豆瓣评分 7.6 《架构真经：互联网技术架构的设计原则（原书第2版）》 - 豆瓣评分 7.5 《软件架构设计：程序员向架构师转型必备（第2版）》 - 豆瓣评分 7.4 《恰如其分的软件架构 [Just Enough Software Architecture]》 - 豆瓣评分 7.3 《软件架构设计：大型网站技术架构与业务架构融合之道》 JVM周边语言 《Scala编程（第3版）》 - 豆瓣评分 9.4 《Groovy程序设计》 - 豆瓣评分 8.2 《快学Scala（第2版）》 - 豆瓣评分 8 《Kotlin极简教程》 《Scala集合技术手册》 项目管理&amp;领导力&amp;流程 《构建之法 现代软件工程（第三版）》 - 豆瓣评分 9 《精益思想（白金版）》 - 豆瓣评分 8.2 《给产品经理讲技术》 项目管理 《持续交付：发布可靠软件的系统方法》 - 豆瓣评分 8.7 《名家经典系列：人件（原书第3版） [Peopleware: Productive Projects and Teams]》 - 豆瓣评分 8.4 《硝烟中的Scrum和XP：我们如何实施Scrum》 - 豆瓣评分 8.4 《敏捷软件开发实践 估算与计划》 - 豆瓣评分 8.4 《人月神话（40周年中文纪念版） [The Mythical Man-Month：Essays on Software Engineering Anniversary Edition]》 - 豆瓣评分 8.3 《Scrum敏捷软件开发》 - 豆瓣评分 8 《用户故事与敏捷方法 [User Stories Applied:For Agile Software Development]》 - 豆瓣评分 8 《用户故事地图 [User Story Mapping]》 - 豆瓣评分 7.4 《知行合一 实现价值驱动的敏捷和精益开发》 《互联网项目管理实践精粹》 团队管理 《卓有成效的管理者（珍藏版） [The Effective Executive]》 - 豆瓣评分 8.8 《跃迁：从技术到管理的硅谷路径》 - 豆瓣评分 8.4 《告别失控 软件开发团队管理必读》 - 豆瓣评分 7.9 《赋能：打造应对不确定性的敏捷团队 [Team of Teams]》 - 豆瓣评分 7.6 《OKR工作法：谷歌、领英等顶级公司的高绩效秘籍 [Radical Focus]》 - 豆瓣评分 7.6 《CTO说》 - 豆瓣评分 7.3 《轻流程 IT团队的积分式绩效管理》 - 豆瓣评分 7 《技术领导力：程序员如何才能带团队》 - 豆瓣评分 5.4 《敏捷文化：如何打造优秀的高效能团队 [The Agile Culture: Leading through Trust and Owner]》 数学与算法数学 《数学之美（第二版）》 - 豆瓣评分 8.9 《程序员的数学2 概率统计》 - 豆瓣评分 8.7 《程序员的数学3 线性代数》 - 豆瓣评分 8.6 《程序员的数学》 - 豆瓣评分 7.2 《程序员的数学思维修炼（趣味解读）》 - 豆瓣评分 5.4 《统计之美：人工智能时代的科学思维》 《统计思维：程序员数学之概率统计（第2版）》 算法 《算法导论（原书第3版）/计算机科学丛书 [Introduction to Algorithms, third edition]》 - 豆瓣评分 9.3 《算法图解》 - 豆瓣评分 8.4 《漫画算法：小灰的算法之旅（全彩）》 职业素养与个人成长 《我编程，我快乐：程序员职业规划之道》 - 豆瓣评分 7.9 《程序员的自我修养》 - 豆瓣评分 6.5 职业素养提升 《码农翻身：用故事给技术加点料》 - 豆瓣评分 9.1 《程序员修炼之道：从小工到专家》 - 豆瓣评分 8.8 《极客与团队：软件工程师的团队生存秘笈》 - 豆瓣评分 8.3 《程序员思维修炼(修订版)》 - 豆瓣评分 8.2 《高效能程序员的修炼》 - 豆瓣评分 8.2 《O’Reilly：卓有成效的程序员 [Productive programmer]》 - 豆瓣评分 8.1 《Java工程师修炼之道》 - 豆瓣评分 7.8 《程序员的成长课》 - 豆瓣评分 7.6 《高效程序员的45个习惯：敏捷开发修炼之道(修订版)》 - 豆瓣评分 7.6 《温伯格技术思想三部曲：颠覆完美软件 软件测试必须知道的几件事》 - 豆瓣评分 7.5 《温伯格技术思想三部曲：程序开发心理学（银年纪念版）》 - 豆瓣评分 7.4 《软件开发本质论：追求简约、体现价值、逐步构建》 - 豆瓣评分 7.3 《内外兼修：程序员的成长之路》 - 豆瓣评分 6.6 个人软技能 《把时间当作朋友（第3版 全彩）》 - 豆瓣评分 8.5 《暗时间》 - 豆瓣评分 8.4 《关键对话：如何高效能沟通（原书第2版） [Crucial Conversations: Tools for Talking When Stak]》 - 豆瓣评分 8.1 《温伯格技术思想三部曲：成为技术领导者 掌握全面解决问题的方法》 - 豆瓣评分 8 《软技能 代码之外的生存指南》 - 豆瓣评分 8 《程序员健康指南》 - 豆瓣评分 7.5 《如何把事情做到最好：改变全球9800万人的人生指导书 [Mastery]》 - 豆瓣评分 7.2 《程序员的英语》 - 豆瓣评分 5.9 《高效能人士的七个习惯（30周年纪念版）》 大厂出品阿里巴巴技术丛书 《码出高效：Java开发手册》 - 豆瓣评分 8.8 《大数据之路 阿里巴巴大数据实践》 - 豆瓣评分 7.8 《技术之瞳 阿里巴巴技术笔试心得》 - 豆瓣评分 7.7 《淘宝技术这十年》 - 豆瓣评分 7.3 《尽在双11 阿里巴巴技术演进与超越》 - 豆瓣评分 7.1 《逆流而上：阿里巴巴技术成长之路》 - 豆瓣评分 6.9 京东技术丛书 《京东基础架构建设之路（全彩）》 - 豆瓣评分 6.2 《京东系统质量保障技术实战》 - 豆瓣评分 6.1 《京东技术解密》 - 豆瓣评分 6.1 工具书 《Linux命令行与shell脚本编程大全（第3版）》 - 豆瓣评分 9.1 《阿里巴巴Java开发手册》 - 豆瓣评分 8.3 《SQL即查即用 （全彩版）》 《Linux命令速查手册（第三版）》 面试求职 《剑指Offer：名企面试官精讲典型编程题（第2版）》 - 豆瓣评分 9.1 《编程之美：微软技术面试心得》 - 豆瓣评分 8.4 《Java程序员面试笔试宝典》 - 豆瓣评分 7.6 《Java程序员面试宝典（第4版）》 - 豆瓣评分 5 《编程之法：面试和算法心得》 《Java程序员面试算法宝典》 《Java程序员面试笔试真题库》 《Java程序员面试笔试真题与解析》 《Java核心技术及面试指南》 《解忧程序员：高薪编程、求职面试与成长转型宝典》 格局与视野 《全球科技通史》 - 豆瓣评分 9.4 《浪潮之巅 第三版 套装上下册》 - 豆瓣评分 9.3 《黑客与画家：硅谷创业之父Paul Graham文集 [Hackers and Painters Big Ldeas From the Computer Age]》 - 豆瓣评分 8.8 《软件随想录 卷1》 - 豆瓣评分 8.8 《软件随想录 卷2》 - 豆瓣评分 8.7 《编程人生：15位软件先驱访谈录》 - 豆瓣评分 8.5 《大教堂与集市（最新版） [The Cathedral &amp; the Bazaar]》 - 豆瓣评分 8.4 《硅谷之谜：浪潮之巅 续集》 - 豆瓣评分 8.4 《原则 [Principles]》 - 豆瓣评分 8.4 《精益创业》 - 豆瓣评分 8.4 《态度：吴军博士新书》 - 豆瓣评分 8.1 《见识》 - 豆瓣评分 8.1 《极限创新 35岁之前改变世界的全球科技精英》 - 豆瓣评分 7.3 《大学的终结：泛在大学与高等教育革命》 - 豆瓣评分 7.2 《未来版图 全球聪明公司的科技创新趋势和商业化路径》 - 豆瓣评分 7.1 《你好哇，程序员——漫话程序员面试求职、升职加薪、创业与生活》 - 豆瓣评分 6.5 《图灵和ACM图灵奖（1966-2015 第五版） 纪念计算机诞生70周年》 《文明之光（全彩印刷套装1-4册）入选2014中国好书/第六届中华优秀出版物获奖图书》 《大师访谈录：成就非凡的软件人生》 Java之外 《计算机科学丛书：计算机程序的构造和解释（原书第2版）》 - 豆瓣评分 9.5 《计算机科学丛书：编译原理（第2版） [Compilers:Principle,Techniques and Tools]》 - 豆瓣评分 9.1 《一个APP的诞生——从零开始设计你的手机应用》 - 豆瓣评分 6.3 《大型网站性能优化实战：从前端、网络、CDN到后端、大促的全链路性能优化详解》 网络知识 《图解HTTP》 - 豆瓣评分 8.1 《图解TCP/IP 第5版》 - 豆瓣评分 7.8 安全知识 《白帽子讲Web安全（纪念版）》 - 豆瓣评分 7.4 《Web安全攻防：渗透测试实战指南》 工具 《Maven实战》 - 豆瓣评分 8.2 《大象：Thinking in UML（第2版）》 - 豆瓣评分 8.2 《Git学习指南》 - 豆瓣评分 6.7 《UML基础、案例与应用（第3版 修订版）》 运维&amp;DevOps 《编码：隐匿在计算机软硬件背后的语言 [Code:The Hidden Language of Computer Hardware and Software]》 - 豆瓣评分 9.3 《DevOps实践指南》 - 豆瓣评分 9 《性能之巅：洞悉系统、企业与云计算》 - 豆瓣评分 8.7 《鸟哥的Linux私房菜 基础学习篇 第四版》 - 豆瓣评分 8.2 《DevOps开发运维训练营》","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"转载","slug":"转载","permalink":"http://QQ876684433.github.io/tags/转载/"}]},{"title":"后端架构师技术图谱","slug":"后端架构师技术图谱","date":"2019-07-16T01:33:06.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/16/后端架构师技术图谱/","link":"","permalink":"http://QQ876684433.github.io/2019/07/16/后端架构师技术图谱/","excerpt":"","text":"转载原文：https://github.com/xingshaocheng/architect-awesome 推荐: 《Java技术书籍大全》 - awesome-java-books 从初级开发者到资深架构师，看这些书就够了 数据结构队列 《java队列——queue详细分析》 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。 《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》 集合 《Java Set集合的详解》 链表、数组 《Java集合详解–什么是List》 字典、关联数组 《Java map 详解 - 用法、遍历、排序、常用API等》 栈 《java数据结构与算法之栈（Stack）设计与实现》 《Java Stack 类》 《java stack的详细实现分析》 Stack 是线程安全的。 内部使用数组保存数据，不够时翻倍。 树二叉树每个节点最多有两个叶子节点。 《二叉树》 完全二叉树 《完全二叉树》 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。 平衡二叉树左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 《浅谈数据结构-平衡二叉树》 《浅谈算法和数据结构: 八 平衡查找树之2-3树》 二叉查找树（BST）二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。 《浅谈算法和数据结构: 七 二叉查找树》 红黑树 《最容易懂得红黑树》 添加阶段后，左旋或者右旋从而再次达到平衡。 《浅谈算法和数据结构: 九 平衡查找树之红黑树》 B，B+，B*树MySQL是基于B+树聚集索引组织表 《B-树，B+树，B*树详解》 《B-树，B+树与B*树的优缺点比较》 B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。 LSM 树LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。 《LSM树 VS B+树》 B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。 LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。 《LSM树（Log-Structured Merge Tree）存储引擎》 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。 Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。 BitSet经常用于大规模数据的排重检查。 《Java Bitset类》 《Java BitSet（位集）》 常用算法 《常见排序算法及对应的时间复杂度和空间复杂度》 排序、查找算法 《常见排序算法及对应的时间复杂度和空间复杂度》 选择排序 《Java中的经典算法之选择排序（SelectionSort）》 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。 冒泡排序 《冒泡排序的2种写法》 相邻元素前后交换、把最大的排到最后。 时间复杂度 O(n²) 插入排序 《排序算法总结之插入排序》 快速排序 《坐在马桶上看算法：快速排序》 一侧比另外一侧都大或小。 归并排序 《图解排序算法(四)之归并排序》 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 希尔排序TODO 堆排序 《图解排序算法(三)之堆排序》 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。 计数排序 《计数排序和桶排序》 和桶排序过程比较像，差别在于桶的数量。 桶排序 《【啊哈！算法】最快最简单的排序——桶排序》 《排序算法（三）：计数排序与桶排序》 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。 每个桶单独进行排序，然后再遍历每个桶。 基数排序按照个位、十位、百位、…依次来排。 《排序算法系列：基数排序》 《基数排序》 二分查找 《二分查找(java实现)》 要求待查找的序列有序。 时间复杂度 O(logN)。 《java实现二分查找-两种方式》 while + 递归。 Java 中的排序工具 《Arrays.sort和Collections.sort实现原理解析》 Collections.sort算法调用的是合并排序。 Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。 布隆过滤器常用于大数据的排重，比如email，url 等。核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。优点：空间和时间效率都很高。缺点：随着存入的元素数量增加，误算率随之增加。 《布隆过滤器 – 空间效率很高的数据结构》 《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》 《基于Redis的布隆过滤器的实现》 基于 Redis 的 Bitmap 数据结构。 《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》 使用Java中的 BitSet 类 和 加权和hash算法。 字符串比较KMP 算法KMP：Knuth-Morris-Pratt算法（简称KMP）核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。 《字符串匹配的KMP算法》 深度优先、广度优先 《广度优先搜索BFS和深度优先搜索DFS》 贪心算法 《算法：贪婪算法基础》 《常见算法及问题场景——贪心算法》 回溯算法 《 五大常用算法之四：回溯法》 剪枝算法 《α-β剪枝算法》 动态规划 《详解动态规划——邹博讲动态规划》 《动态规划算法的个人理解》 朴素贝叶斯 《带你搞懂朴素贝叶斯分类算法》 P(B|A)=P(A|B)P(B)/P(A) 《贝叶斯推断及其互联网应用1》 《贝叶斯推断及其互联网应用2》 推荐算法 《推荐算法综述》 《TOP 10 开源的推荐系统简介》 最小生成树算法 《算法导论–最小生成树（Kruskal和Prim算法）》 最短路径算法 《Dijkstra算法详解》 并发Java 并发 Java 并发知识合集 JAVA并发知识图谱 多线程 《40个Java多线程问题总结》 线程安全 《Java并发编程——线程安全及解决机制简介》 一致性、事务事务 ACID 特性 《数据库事务ACID特性》 事务的隔离级别 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。 序列化：所有事物串行处理（牺牲了效率） 《理解事务的4种隔离级别》 数据库事务的四大特性及事务隔离级别 《MySQL的InnoDB的幻读问题 》 幻读的例子非常清楚。 通过 SELECT … FOR UPDATE 解决。 《一篇文章带你读懂MySQL和InnoDB》 图解脏读、不可重复读、幻读问题。 MVCC 《【mysql】关于innodb中MVCC的一些理解》 innodb 中 MVCC 用在 Repeatable-Read 隔离级别。 MVCC 会产生幻读问题（更新时异常。） 《轻松理解MYSQL MVCC 实现机制》 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间 每次只操作比当前版本小（或等于）的 行。 锁Java中的锁和同步类 《Java中的锁分类》 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 《Java并发之AQS详解》 《Java中信号量 Semaphore》 有数量控制 申请用 acquire，申请不要则阻塞；释放用 release。 《java开发中的Mutex vs Semaphore》 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。 公平锁 &amp; 非公平锁公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。 《公平锁与非公平锁》 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。 悲观锁悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。 《【MySQL】悲观锁&amp;乐观锁》 乐观锁的方式：版本号+重试方式 悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。 《Mysql查询语句使用select.. for update导致的数据库死锁分析》 mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。 锁相同数据的不同索引条件可能会引起死锁。 《Mysql并发时经典常见的死锁原因及解决方法》 乐观锁 &amp; CAS 《乐观锁的一种实现方式——CAS》 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。 ABA 问题由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。 《Java CAS 和ABA问题》 《Java 中 ABA问题及避免》 AtomicStampedReference 和 AtomicStampedReference。 CopyOnWrite容器可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。 《JAVA中写时复制(Copy-On-Write)Map实现》 实现读写分离，读取发生在原始数据上，写入发生在副本上。 不用加锁，通过最终一致实现一致性。 《聊聊并发-Java中的Copy-On-Write容器》 RingBuffer 《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》 可重入锁 &amp; 不可重入锁 《可重入锁和不可重入锁》 通过简单代码举例说明可重入锁和不可重入锁。 可重入锁指同一个线程可以再次获得之前已经获得的锁。 可重入锁可以用户避免死锁。 Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock 《ReenTrantLock可重入锁（和synchronized的区别）总结》 synchronized 使用方便，编译器来加锁，是非公平锁。 ReenTrantLock 使用灵活，锁的公平性可以定制。 相同加锁场景下，推荐使用 synchronized。 互斥锁 &amp; 共享锁互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。 《ReadWriteLock场景应用》 死锁 《“死锁”四个必要条件的合理解释》 互斥、持有、不可剥夺、环形等待。 Java如何查看死锁？ JConsole 可以识别死锁。 java多线程系列：死锁及检测 jstack 可以显示死锁。 操作系统计算机原理 《操作系统基础知识——操作系统的原理，类型和结构》 CPU多级缓存典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。 《从Java视角理解CPU缓存和伪共享》 进程TODO 线程 《线程的生命周期及状态转换详解》 协程 《终结python协程—-从yield到actor模型的实现》 线程的调度是由操作系统负责，协程调度是程序自行负责 与线程相比，协程减少了无谓的操作系统切换. 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换. Linux 《Linux 命令大全》 设计模式设计模式的六大原则 《设计模式的六大原则》 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。 合成复用原则：尽量使用合成/聚合,而不是使用继承。 23种常见设计模式 《设计模式》 《23种设计模式全解析》 《设计模式类图与示例》 应用场景 《细数JDK里的设计模式》 结构型模式： 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC； 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy 创建模式: 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。 工厂方法：就是 一个返* 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。 行为模式： 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。 空对象模式：如 java.util.Collections#emptyList()。 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。 《Spring-涉及到的设计模式汇总》 《Mybatis使用的设计模式》 单例模式 《单例模式的三种实现 以及各自的优缺点》 《单例模式－－反射－－防止序列化破坏单例模式》 使用枚举类型。 责任链模式TODO MVC 《MVC 模式》 模型(model)－视图(view)－控制器(controller) IOC 《理解 IOC》 《IOC 的理解与解释》 正向控制：传统通过new的方式。反向控制，通过容器注入对象。 作用：用于模块解耦。 DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。 AOP 《轻松理解AOP(面向切面编程)》 《Spring AOP详解》 《Spring AOP的实现原理》 Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。 《Spring AOP 实现原理与 CGLIB 应用》 Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 UML 《UML教程》 微服务思想 《微服务架构设计》 《微服务架构技术栈选型手册》 康威定律 《微服务架构的理论基础 - 康威定律》 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。 《微服务架构核⼼20讲》 运维 &amp; 统计 &amp; 技术支持常规监控 《腾讯业务系统监控的修炼之路》 监控的方式：主动、被动、旁路(比如舆情监控) 监控类型： 基础监控、服务端监控、客户端监控、监控、用户端监控 监控的目标：全、块、准 核心指标：请求量、成功率、耗时 《开源还是商用？十大云运维监控工具横评》 Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。 《监控报警系统搭建及二次开发经验》 命令行监控工具 《常用命令行监控工具》 top、sar、tsar、nload 《20个命令行工具监控 Linux 系统性能》 《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》 APMAPM — Application Performance Management 《Dapper，大规模分布式系统的跟踪系统》 CNCF OpenTracing，中文版 主要开源软件，按字母排序 Apache SkyWalking CAT CNCF jaeger Pinpoint Zipkin 《开源APM技术选型与实战》 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。 统计分析 《流量统计的基础：埋点》 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度 《APP埋点常用的统计工具、埋点目标和埋点内容》 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。 《美团点评前端无痕埋点实践》 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 持续集成(CI/CD) 《持续集成是什么？》 《8个流行的持续集成工具》 Jenkins 《使用Jenkins进行持续集成》 环境分离开发、测试、生成环境分离。 《开发环境、生产环境、测试环境的基本理解和区》 自动化运维Ansible 《Ansible中文权威指南》 《Ansible基础配置和企业级项目实用案例》 puppet 《自动化运维工具——puppet详解》 chef 《Chef 的安装与使用》 测试TDD 理论 《深度解读 - TDD（测试驱动开发）》 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践. 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； 单元测试 《Java单元测试之JUnit篇》 《JUnit 4 与 TestNG 对比》 TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 《单元测试主要的测试功能点》 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 压力测试 《Apache ab 测试使用指南》 《大型网站压力测试及优化方案》 《10大主流压力/负载/性能测试工具推荐》 《真实流量压测工具 tcpcopy应用浅析》 《nGrinder 简易使用教程》 全链路压测 《京东618：升级全链路压测方案，打造军演机器人ForceBot》 《饿了么全链路压测的探索与实践》 《四大语言，八大框架｜滴滴全链路压测解决之道》 《全链路压测经验》 A/B 、灰度、蓝绿测试 《技术干货 | AB 测试和灰度发布探索及实践》 《nginx 根据IP 进行灰度发布》 《蓝绿部署、A/B 测试以及灰度发布》 虚拟化 《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》 KVM 《KVM详解，太详细太深入了，经典》 《【图文】KVM 虚拟机安装详解》 Xen 《Xen虚拟化基本原理详解》 OpenVZ 《开源Linux容器 OpenVZ 快速上手指南》 容器技术Docker 《几张图帮你理解 docker 基本原理及快速入门》 《Docker 核心技术与实现原理》 《Docker 教程》 云技术OpenStack 《OpenStack构架知识梳理》 DevOps 《一分钟告诉你究竟DevOps是什么鬼？》 《DevOps详解》 文档管理 Confluence-收费文档管理系统 GitLab? Wiki 中间件Web ServerNginx 《Ngnix的基本学习-多进程和Apache的比较》 Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。 《nginx与Apache的对比以及优缺点》 nginx只适合静态和反向代理，不适合处理动态请求。 OpenResty 官方网站 《浅谈 OpenResty》 通过 Lua 模块可以在Nginx上进行开发。 agentzh 的 Nginx 教程 Tengine 官方网站 Apache Httpd 官方网站 Tomcat架构原理 《TOMCAT原理详解及请求过程》 《Tomcat服务器原理详解》 《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》 《四张图带你了解Tomcat系统架构》 《JBoss vs. Tomcat: Choosing A Java Application Server》 Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。 Jboss 实现全部了JEE特性，软件开源免费、文档收费。 调优方案 《Tomcat 调优方案》 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； 《tomcat http协议与ajp协议》 《AJP与HTTP比较和分析》 AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。 并发高时，AJP协议优于HTTP协议。 Jetty 《Jetty 的工作原理以及与 Tomcat 的比较》 《jetty和tomcat优势比较》 架构比较:Jetty的架构比Tomcat的更为简单。 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 缓存 《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》 本地缓存 《HashMap本地缓存》 《EhCache本地缓存》 堆内、堆外、磁盘三级缓存。 可按照缓存空间容量进行设置。 按照时间、次数等过期策略。 《Guava Cache》 简单轻量、无堆外、磁盘缓存。 《Nginx本地缓存》 《Pagespeed—懒人工具，服务器端加速》 客户端缓存 《浏览器端缓存》 主要是利用 Cache-Control 参数。 《H5 和移动端 WebView 缓存机制解析与实战》 服务端缓存Web缓存 nuster - nuster cache varnish - varnish cache squid - squid cache Memcached 《Memcached 教程》 《深入理解Memcached原理》 采用多路复用技术提高并发性。 slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。 《Memcached软件工作原理》 《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》 《memcache 中 add 、 set 、replace 的区别》 区别在于当key存在还是不存在时，返回值是true和false的。 《memcached全面剖析》 Redis 《Redis 教程》 《redis底层原理》 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。 《Redis持久化方式》 RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。 AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。 也可以两者结合使用。 《分布式缓存–序列3–原子操作与CAS乐观锁》 架构 《Redis单线程架构》 回收策略 《redis的回收策略》 Tair 官方网站 《Tair和Redis的对比》 特点：可以配置备份节点数目，通过异步同步到备份节点 一致性Hash算法。 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。 几种存储引擎: MDB，完全内存性，可以用来存储Session等数据。 Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作 LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。 Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。 消息队列 《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》 RabbitMQ 消费者默认是推模式（也支持拉模式）。 Kafka 默认是拉模式。 Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。 Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。 《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》 消息总线消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。 《消息总线VS消息队列》 消息的顺序 《如何保证消费者接收消息的顺序》 RabbitMQ支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。 《RabbitMQ的应用场景以及基本原理介绍》 《消息队列之 RabbitMQ》 《RabbitMQ之消息确认机制（事务+Confirm）》 RocketMQJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。 《RocketMQ 实战之快速入门》 《RocketMQ 源码解析》 ActiveMQ纯Java实现，兼容JMS，可以内嵌于Java应用中。 《ActiveMQ消息队列介绍》 Kafka高吞吐量、采用拉模式。适合高IO场景，比如日志同步。 官方网站 《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》 《Kafka分区机制介绍与示例》 Redis 消息推送生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。 《Redis学习笔记之十：Redis用作消息队列》 ZeroMQ TODO 定时调度单机定时调度 《linux定时任务cron配置》 《Linux cron运行原理》 fork 进程 + sleep 轮询 《Quartz使用总结》 《Quartz源码解析 —- 触发器按时启动原理》 《quartz原理揭秘和源码解读》 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。 分布式定时调度 《这些优秀的国产分布式任务调度系统，你用过几个？》 opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares 《Quartz任务调度的基本实现原理》 Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 《Elastic-Job-Lite 源码解析》 《Elastic-Job-Cloud 源码解析》 RPC 《从零开始实现RPC框架 - RPC原理及实现》 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。 《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》 Dubbo 官方网站 dubbo实现原理简单介绍 ** SPI **TODO Thrift 官方网站 《Thrift RPC详解》 支持多语言，通过中间语言定义接口。 gRPC服务端可以认证加密，在外网环境下，可以保证数据安全。 官方网站 《你应该知道的RPC原理》 数据库中间件Sharding Jdbc 官网 源码解析 日志系统日志搜集 《从零开始搭建一个ELKB日志收集系统》 《用ELK搭建简单的日志收集分析系统》 《日志收集系统-探究》 配置中心 Apollo - 携程开源的配置中心应用 Spring Boot 和 Spring Cloud 支持推、拉模式更新配置 支持多种语言 《基于zookeeper实现统一配置管理》 《 Spring Cloud Config 分布式配置中心使用教程》 servlet 3.0 异步特性可用于配置中心的客户端 《servlet3.0 新特性——异步处理》 API 网关主要职责：请求转发、安全认证、协议转换、容灾。 《API网关那些儿》 《谈API网关的背景、架构以及落地方案》 《使用Zuul构建API Gateway》 《Spring Cloud Gateway 源码解析》 《HTTP API网关选择之一Kong介绍》 网络协议OSI 七层协议 《OSI七层协议模型、TCP/IP四层模型学习笔记》 TCP/IP 《深入浅出 TCP/IP 协议》 《TCP协议中的三次握手和四次挥手》 HTTP 《http协议详解(超详细)》 HTTP2.0 《HTTP 2.0 原理详细分析》 《HTTP2.0的基本单位为二进制帧》 利用二进制帧负责传输。 多路复用。 HTTPS 《https原理通俗了解》 使用非对称加密协商加密算法 使用对称加密方式传输数据 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。 《八大免费SSL证书-给你的网站免费添加Https安全加密》 网络模型 《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。 《select、poll、epoll之间的区别总结》 select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。 select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。 select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。 poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。 《select，poll，epoll比较 》 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。 《深入理解Java NIO》 NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务 《BIO与NIO、AIO的区别》 《两种高效的服务器设计模型：Reactor和Proactor模型》 Epoll 《epoll使用详解（精髓）》 Java NIO 《深入理解Java NIO》 《Java NIO编写Socket服务器的一个例子》 kqueue 《kqueue用法简介》 连接和短连接 《TCP/IP系列——长连接与短连接的区别》 框架 《Netty原理剖析》 Reactor 模式介绍。 Netty 是 Reactor 模式的一种实现。 零拷贝（Zero-copy） 《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。 序列化(二进制协议)Hessian 《Hessian原理分析》Binary-RPC;不仅仅是序列化 Protobuf 《Protobuf协议的Java应用例子》Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写 .proto 文件。 《Protocol Buffers序列化协议及应用》 关于协议的解释；缺点：可读性差; 《简单的使用 protobuf 和 protostuff》 protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。 数据库基础理论关系数据库设计的三大范式 《数据库的三大范式以及五大约束》 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性； 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情； 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）； MySQL原理 《MySQL的InnoDB索引原理详解》 《MySQL存储引擎－－MyISAM与InnoDB区别》 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁 《myisam和innodb索引实现的不同》 InnoDB 《一篇文章带你读懂Mysql和InnoDB》 优化 《MySQL36条军规》 《MYSQL性能优化的最佳20+条经验》 《SQL优化之道》 《mysql数据库死锁的产生原因及解决办法》 《导致索引失效的可能情况》 《 MYSQL分页limit速度太慢优化方法》 原则上就是缩小扫描范围。 索引聚集索引, 非聚集索引 《MySQL 聚集索引/非聚集索引简述》 《MyISAM和InnoDB的索引实现》 MyISAM 是非聚集，InnoDB 是聚集 复合索引 《复合索引的优点和注意事项》 文中有一处错误： 对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高; select * from table1 where col1=A AND col2=B AND col3=D 如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引 原文中提到索引是按照“col1，col2，col3”的顺序创建的，而mysql在按照最左前缀的索引匹配原则，且会自动优化 where 条件的顺序，当条件中只有 col2=B AND col1=A 时，会自动转化为 col1=A AND col2=B，所以依然会使用索引。 《MySQL查询where条件的顺序对查询效率的影响》 自适应哈希索引(AHI) 《InnoDB存储引擎——自适应哈希索引》 explain 《MySQL 性能优化神器 Explain 使用分析》 NoSQLMongoDB MongoDB 教程 《Mongodb相对于关系型数据库的优缺点》 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越； 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方； Hbase 《简明 HBase 入门教程（开篇）》 《深入学习HBase架构原理》 《传统的行存储和（HBase）列存储的区别》 《Hbase与传统数据库的区别》 空数据不存储，节省空间，且适用于并发。 《HBase Rowkey设计》 rowkey 按照字典顺序排列，便于批量扫描。 通过散列可以避免热点。 搜索引擎搜索引擎原理 《倒排索引–搜索引擎入门》 Lucene 《Lucene入门简介》 Elasticsearch 《Elasticsearch学习，请先看这一篇！》 《Elasticsearch索引原理》 Solr 《 Apache Solr入门教程》 《elasticsearch与solr比较》 sphinx 《Sphinx 的介绍和原理探索》 性能性能优化方法论 《15天的性能优化工作，5方面的调优经验》 代码层面、业务层面、数据库层面、服务器层面、前端优化。 《系统性能优化的几个方面》 容量评估 《联网性能与容量评估的方法论和典型案例》 《互联网架构，如何进行容量设计？》 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS CDN 网络 《CDN加速原理》 《国内有哪些比较好的 CDN？》 连接池 《主流Java数据库连接池比较与开发配置实战》 性能调优 《九大Java性能调试工具，必备至少一款》 大数据流式计算Storm 官方网站 《最详细的Storm入门教程》 Flink 《Flink之一 Flink基本原理介绍》 Kafka Stream 《Kafka Stream调研：一种轻量级流计算模式》 应用场景例如： 广告相关实时统计； 推荐系统用户画像标签实时更新； 线上服务健康状况实时监测； 实时榜单； 实时数据统计。 Hadoop 《用通俗易懂的话说下hadoop是什么,能做什么》 《史上最详细的Hadoop环境搭建》 HDFS 《【Hadoop学习】HDFS基本原理》 MapReduce 《用通俗易懂的大白话讲解Map/Reduce原理》 《 简单的map-reduce的java例子》 Yarn 《初步掌握Yarn的架构及原理》 Spark 《Spark(一): 基本架构及原理》 《子雨大数据之Spark入门教程(Python版)》 安全web 安全XSS 《xss攻击原理与解决方法》 CSRF 《CSRF原理及防范》 SQL 注入 《SQL注入》 Hash Dos 《邪恶的JAVA HASH DOS攻击》 利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。 《一种高级的DoS攻击-Hash碰撞攻击》 《关于Hash Collision DoS漏洞：解析与解决方案》 脚本注入 《上传文件漏洞原理及防范》 漏洞扫描工具 《DVWA》 W3af OpenVAS详解 验证码 《验证码原理分析及实现》 《详解滑动验证码的实现原理》 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。 《淘宝滑动验证码研究》 DDoS 防范 《学习手册：DDoS的攻击方式及防御手段》 《免费DDoS攻击测试工具大合集》 用户隐私信息保护 用户密码非明文保存，加动态salt。 身份证号，手机号如果要显示，用 “*” 替代部分字符。 联系方式在的显示与否由用户自己控制。 TODO 《个人隐私包括哪些》 《在互联网上，隐私的范围包括哪些？》 《用户密码保存》 序列化漏洞 《Lib之过？Java反序列化漏洞通用利用分析》 加密解密对称加密 《常见对称加密算法》 DES、3DES、Blowfish、AES DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。 DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。 哈希算法 《常用的哈希算法》 MD5 和 SHA-1 已经不再安全，已被弃用。 目前 SHA-256 是比较安全的。 《基于Hash摘要签名的公网URL签名验证设计方案》 非对称加密 《常见非对称加密算法》 RSA、DSA、ECDSA(螺旋曲线加密算法) 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。 《区块链的加密技术》 服务器安全 《Linux强化论：15步打造一个安全的Linux服务器》 数据安全数据备份TODO 网络隔离内外网分离TODO 登录跳板机在内外环境中通过跳板机登录到线上主机。 《搭建简易堡垒机》 授权、认证RBAC 《基于组织角色的权限设计》 《权限系统与RBAC模型概述》 《Spring整合Shiro做权限控制模块详细案例分析》 OAuth2.0 《理解OAuth 2.0》 《一张图搞定OAuth2.0》 双因素认证（2FA）2FA - Two-factor authentication，用于加强登录验证 常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key） 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html) 单点登录(SSO) 《单点登录原理与简单实现》 CAS单点登录框架 常用开源框架开源协议 《开源协议的选择》 如何选择一个开源软件协议 日志框架Log4j、Log4j2 《log4j 详细讲解》 《log4j2 实际使用详解》 《Log4j1,Logback以及Log4j2性能测试对比》 Log4J 异步日志性能优异。 Logback 《最全LogBack 详解、含java案例和配置说明》 ORM 《ORM框架使用优缺点》 主要目的是为了提高开发效率。 MyBatis： 《mybatis缓存机制详解》 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。 《MyBatis学习之代码生成器Generator》 网络框架TODO Web 框架Spring 家族Spring Spring 简明教程 Spring Boot 官方网站 《Spring Boot基础教程》 Spring Cloud Spring Boot 中文索引站 Spring Cloud 中文文档 《Spring Cloud基础教程》 工具框架 《Apache Commons 工具类介绍及简单使用》 《Google guava 中文教程》 分布式设计扩展性设计 《架构师不可不知的十大可扩展架构》 总结下来，通用的套路就是分布、缓存及异步处理。 《可扩展性设计之数据切分》 水平切分+垂直切分 利用中间件进行分片如，MySQL Proxy。 利用分片策略进行切分，如按照ID取模。 《说说如何实现可扩展性的大型网站架构》 分布式服务+消息队列。 《大型网站技术架构（七）–网站的可扩展性架构》 稳定性 &amp; 高可用 《系统设计：关于高可用系统的一些技术方案》 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。 自动化测试：通过完善的测试，减少发布引起的故障。 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。 《关于高可用的系统》 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。 硬件负载均衡 《转！！负载均衡器技术Nginx和F5的优缺点对比》 主要是和F5对比。 《软/硬件负载均衡产品 你知多少？》 软件负载均衡 《几种负载均衡算法》轮寻、权重、负载、最少连接、QoS 《DNS负载均衡》 配置简单，更新速度慢。 《Nginx负载均衡》 简单轻量、学习成本低；主要适用于web应用。 《借助LVS+Keepalived实现负载均衡 》 配置比较负载、只支持到4层，性能较高。 《HAProxy用法详解 全网最详细中文文档》 支持到七层（比如HTTP）、功能比较全面，性能也不错。 《Haproxy+Keepalived+MySQL实现读均衡负载》 主要是用户读请求的负载均衡。 《rabbitmq+haproxy+keepalived实现高可用集群搭建》 限流 《谈谈高并发系统的限流》 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。 Nginx 限流：通过 limit_req 等模块限制并发连接数。 应用层容灾 《防雪崩利器：熔断器 Hystrix 的原理与使用》 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。 Hystrix设计原则： 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 《缓存穿透，缓存击穿，缓存雪崩解决方案分析》 《缓存击穿、失效以及热点key问题》 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期； 热点数据：热点数据单独存储；使用本地缓存；分成多个子key； 跨机房容灾 《“异地多活”多机房部署经验谈》 通过自研中间件进行数据同步。 《异地多活（异地双活）实践经验》 注意延迟问题，多次跨机房调用会将延时放大数倍。 建房间专线很大概率会出现问题，做好运维和程序层面的容错。 不能依赖于程序端数据双写，要有自动同步方案。 数据永不在高延迟和较差网络质量下，考虑同步质量问题。 核心业务和次要业务分而治之，甚至只考虑核心业务。 异地多活监控部署、测试也要跟上。 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。 控制跨机房消息体大小，越小越好。 考虑使用docker容器虚拟化技术，提高动态调度能力。 容灾技术及建设经验介绍 容灾演练流程 《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》 常见故障画像 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。 平滑启动 平滑重启应用思路1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用 《JVM安全退出（如何优雅的关闭java服务）》推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。 《常见Java应用如何优雅关闭》Java、Spring、Dubbo 优雅关闭方式。 数据库扩展读写分离模式 《Mysql主从方案的实现》 《搭建MySQL主从复制经典架构》 《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》 《DRBD+Heartbeat+Mysql高可用读写分离架构》 DRDB 进行磁盘复制，避免单点问题。 《MySQL Cluster 方式》 分片模式 《分库分表需要考虑的问题及方案》 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。 问题：事务、Join、迁移、扩容、ID、分页等。 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。 分库策略：数值范围；取模；日期等。 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 《MySql分表和表分区详解》 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。 分表：物理上创建不同的表、客户端需要管理分表路由。 服务治理服务注册与发现 《永不失联！如何实现微服务架构中的服务发现？》 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。 服务器端服务发现模式：客户端通过负载均衡查询服务实例。 《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》 CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap） 作者认为目前 Consul 对 Spring cloud 的支持比较好。 《基于Zookeeper的服务注册与发现》 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 服务路由控制 《分布式服务框架学习笔记4 服务路由》 原则：透明化路由 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接 本地路由优先策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。 配置方式：统一注册表；本地配置；动态下发。 分布式一致CAP 与 BASE 理论 《从分布式一致性谈到CAP理论、BASE理论》 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致) CAP：一致性、可用性、分区容错性(网络故障引起) BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性） BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 分布式锁 《分布式锁的几种实现方式》 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入； 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。 Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。 《基于Zookeeper的分布式锁》 清楚的原理描述 + Java 代码示例。 《jedisLock—redis分布式锁实现》 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。 《Memcached 和 Redis 分布式锁方案》 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。 分布式一致性算法PAXOS 《分布式系列文章——Paxos算法原理与推导》 《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》 《【分布式】Zookeeper与Paxos》 Zab 《Zab：Zookeeper 中的分布式一致性协议介绍》 Raft 《Raft 为什么是更易理解的分布式一致性算法》 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人） 通过随机等待的方式发出投票，得票多的获胜。 Gossip 《Gossip算法》 两阶段提交、多阶段提交 《关于分布式事务、两阶段提交协议、三阶提交协议》 幂等 《分布式系统—幂等性设计》 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 分布式一致方案 《分布式系统事务一致性解决方案》 《保证分布式系统数据一致性的6种方案》 分布式 Leader 节点选举 《利用zookeeper实现分布式leader节点选举》 TCC(Try/Confirm/Cancel) 柔性事务 《传统事务与柔性事务》 基于BASE理论：基本可用、柔性状态、最终一致。 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。 分布式文件系统 说说分布式文件存储系统-基本架构 ？ 《各种分布式文件系统的比较》 ？ HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。 FastDFS：轻量级、适合小文件。 唯一ID 生成全局唯一ID 《高并发分布式系统中生成全局唯一Id汇总》 Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器) Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” UUID：缺点，无序，字符串过长，占用空间，影响检索性能。 MongoDB 方案：利用 ObjectId。缺点：不能自增。 《TDDL 在分布式下的SEQUENCE原理》 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。 一致性Hash算法 《一致性哈希算法》 设计思想 &amp; 开发模式DDD(Domain-driven Design - 领域驱动设计) 《浅谈我对DDD领域驱动设计的理解》 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。 《领域驱动设计的基础知识总结》 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字； 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。 使用的模式： 关联尽量少，尽量单项，尽量降低整体复杂度。 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互； 工厂（Factory）：类似于设计模式中的工厂模式。 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。 《领域驱动设计(DDD)实现之路》 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。 《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》 命令查询职责分离(CQRS)CQRS — Command Query Responsibility Seperation 《领域驱动设计系列 (六)：CQRS》 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。 《DDD CQRS架构和传统架构的优缺点比较》 最终一致的设计理念；依赖于高可用消息中间件。 《CQRS架构简介》 一个实现 CQRS 的抽象案例。 《深度长文：我对CQRS/EventSourcing架构的思考》 CQRS 模式分析 + 12306 抢票案例 贫血，充血模型 《贫血，充血模型的解释以及一些经验》 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重； 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。 作者主张使用贫血模式。 Actor 模式TODO 响应式编程ReactorTODO RxJavaTODO Vert.xTODO DODAF2.0 《DODAF2.0方法论》 《DODAF2.0之能力视角如何落地》 Serverless无需过多关系服务器的服务架构理念。 《什么是Serverless无服务器架构？》 Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。 Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。 Serverless 不代表某个具体的框架。 《如何理解Serverless？》 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service） Service Mesh 《什么是Service Mesh？》 《初识 Service Mesh》 项目管理架构评审 《架构设计之如何评审架构设计说明书》 《人人都是架构师：非功能性需求》 重构 《架构之重构的12条军规》 代码规范 《阿里巴巴Java开发手册》 代码 Review制度还是制度!另外，每个公司需要根据自己的需求和目标制定自己的 check list 《为什么你做不好 Code Review？》 代码 review 做的好，在于制度建设。 《从零开始Code Review》 《Code Review Checklist》 《Java Code Review Checklist》 《如何用 gitlab 做 code review》 RUP 《运用RUP 4+1视图方法进行软件架构设计》 看板管理 《说说看板在项目中的应用》 SCRUMSCRUM - 争球 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图； 五个价值观：专注、勇气、公开、承诺、尊重。 《敏捷项目管理流程-Scrum框架最全总结！》 《敏捷其实很简单3—敏捷方法之scrum》 敏捷开发TODO 极限编程（XP）XP - eXtreme Programming 《主流敏捷开发方法：极限编程XP》 是一种指导开发人员的方法论。 4大价值： 沟通：鼓励口头沟通，提高效率。 简单：够用就好。 反馈：及时反馈、通知相关人。 勇气：提倡拥抱变化，敢于重构。 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。 结对编程边写码，边review。能够增强代码质量、减少bug。 《结对编程》 PDCA 循环质量管理P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进 《PDCA》 FMEA管理模式TODO 通用业务术语TODO 技术趋势TODO 政策、法规法律 《中华人民共和国网络安全法》 2016年11月7日发布，自2017年6月1日起施行 《个人信息保护法》 个人信息保护法是一部保护个人信息的法律条款，现尚在制订中，2019全国两会信息安全相关提案中，有政协委员呼吁关注大数据时代隐私保护，加速立法。 《最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》 《解释》共十三条，自2017年6月1日起施行 1、对于行踪轨迹信息、通信内容、征信信息、财产信息，非法获取、出售或者提供50条以上即算“情节严重”； 2、对于住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息，标准则是 500条以上； 3、对于其他公民个人信息，标准为 5000条以上。 《中华人民共和国电子商务法》 2018年8月31日，十三届全国人大常委会第五次会议表决通过《电子商务法》，自2019年1月1日起施行 解读电子商务法（一）什么是电商 解读电子商务法（二）电商经营者 解读电子商务法（三）电商行为规范 解读电子商务法（四）电商的法律关系 解读电子商务法（外传）电商挣钱的秘密 解读电子商务法（外传）电商模式 程序员需要知道的法律常识 白话法律42讲-为程序员打造的专属法律武器 严格遵守刑法253法条我国刑法第253条之一规定： 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。 最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪” 《非法获取公民个人信息罪》 避风港原则“避风港”原则是指在发生著作权侵权案件时，当ISP（网络服务提供商）只提供空间服务，并不制作网页内容，如果ISP被告知侵权，则有删除的义务，否则就被视为侵权。如果侵权内容既不在ISP的服务器上存储，又没有被告知哪些内容应该删除，则ISP不承担侵权责任。 后来避风港原则也被应用在搜索引擎、网络存储、在线图书馆等方面。 《避风港原则》 架构师素质 《架构师画像》 业务理解和抽象能力 NB的代码能力 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； 全局：是否考虑到了对上下游的系统的影响。 权衡：权衡投入产出比；优先级和节奏控制； 《关于架构优化和设计，架构师必须知道的事情》 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。 基础设施、配置、测试、开发、运维综合考虑。 考虑人、团队、和组织的影响。 《如何才能真正的提高自己，成为一名出色的架构师？》 《架构师的必备素质和成长途径》 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 《架构设计师—你在哪层楼？》 第一层的架构师看到的只是产品本身 第二层的架构师不仅看到自己的产品，还看到了整体的方案 第三层的架构师看到的是商业价值 团队管理TODO 招聘资讯行业资讯 36kr Techweb 公众号列表TODO 博客团队博客 阿里中间件博客 美团点评技术团队博客 个人博客 阮一峰的网络日志 酷壳 - COOLSHELL-陈皓 hellojava-阿里毕玄 Cm’s Blog 程序猿DD-翟永超-《Spring Cloud微服务实战》作者 综合门户、社区国内： CSDN老牌技术社区、不必解释。 51cto.com ITeye 偏 Java 方向 博客园 ChinaUnix 偏 Linux 方向 开源中国社区 InfoQ 深度开源 伯乐在线 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。 ITPUB 腾讯云— 云+社区 阿里云— 云栖社区 IBM DeveloperWorks 开发者头条 LinkedKeeper 国外： DZone Reddit 问答、讨论类社区 segmentfault 问答+专栏 知乎 stackoverflow 行业数据分析 艾瑞网 QUEST MOBILE 国家数据 TalkingData 专项网站 测试: 领测国际 测试窝 TesterHome 运维: 运维派 Abcdocker Java: ImportNew 专注于 Java 技术分享 HowToDoInJava 英文博客 安全 红黑联盟 FreeBuf 大数据 中国大数据 其他专题网站： InfoQ 偏重于基础架构、运维方向 DockerInfo 专注于 Docker 应用及咨询、教程的网站 Linux公社 Linux 主题社区 其他类 程序员技能图谱 推荐参考书在线电子书 《深入理解Spring Cloud与微服务构建》 《阿里技术参考图册-研发篇》 《阿里技术参考图册-算法篇》 《2018美团点评技术年货（合辑）》70M InfoQ《架构师》月刊 《架构师之路》 纸质书更多架构方面书籍参考: awesome-java-books 开发方面 《阿里巴巴Java开发手册》详情 架构方面 《软件架构师的12项修炼：技术技能篇》详情 《架构之美》详情 《分布式服务架构》详情 《聊聊架构》 详情 《云原生应用架构实践》详情 《亿级流量网站架构核心技术》详情 《淘宝技术这十年》详情 《企业IT架构转型之道-中台战略思想与架构实战》 详情 《高可用架构（第1卷）》详情 技术管理方面 《CTO说》详情 《技术管理之巅》详情 《网易一千零一夜：互联网产品项目管理实战》详情 基础理论 《数学之美》详情 《编程珠玑》详情 工具方面TODO 大数据方面技术资源开源资源 github Apache 软件基金会 手册、文档、教程国内： W3Cschool Runoob.com HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。 Love2.io 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。 gitbook.cn 付费电子书。 ApacheCN AI、大数据方面系列中文文档。 国外： Quick Code 免费在线技术教程。 gitbook.com 有部分中文电子书。 Cheatography Cheat Sheets 大全，单页文档网站。 Tutorialspoint 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。 在线课堂 学徒无忧 极客时间 segmentfault 斯达克学院 牛客网 极客学院 51CTO学院 会议、活动 QCon ArchSummit GITC全球互联网技术大会 活动发布平台: 活动行 常用APP 极客时间 得到 找工作 Boss直聘 拉勾网 猎聘 100Offer 工具 极客搜索 技术文章搜索引擎。 代码托管 Coding 码云 文件服务 七牛 又拍云 综合云服务商 阿里云 腾讯云 百度云 新浪云 金山云 亚马逊云(AWS) 谷歌云 微软云 VPS Linode DigitalOcean Vultr","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"转载","slug":"转载","permalink":"http://QQ876684433.github.io/tags/转载/"}]},{"title":"精通Java之路-学习计划","slug":"精通Java之路-学习计划","date":"2019-07-16T01:22:52.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/07/16/精通Java之路-学习计划/","link":"","permalink":"http://QQ876684433.github.io/2019/07/16/精通Java之路-学习计划/","excerpt":"","text":"精通Java之路-学习计划玩好JDK 转载信息 作者：老刘 链接：https://www.zhihu.com/question/328775413/answer/741689212 来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Java运行时环境学习资料：《深入理解Java虚拟机 周志明 第二版》、《Java虚拟机规范 Java SE8版》 目标：对Java虚拟机有深入的理解，能够动手实现Java虚拟机核心功能 方式：阅读书籍并撰写阅读笔记，完成实现Java虚拟机的开源项目 所以，对于JVM，没什么可说的，就是往死里学，往死里研究，能有多深就多深！ Java的基础类库学习资料：jdk源码、各源码类技术博客、Oracle官方Java tutorial、《Java编程思想》 第一级别：精读源码1234java.iojava.langjava.util// 除了Exception和Error这一类的 目标：深入理解jdk源码的设计原则、编程思想，包括里面使用到的数据结构、算法等知识，精通相关API的使用，能够实现上述类库的核心功能 方式：阅读源码并撰写源码阅读笔记，完成类库核心功能的开源项目 第二级别：深刻理解12345java.lang.reflectjava.netjavax.net.*java.nio.*java.util.concurrent.* 目标：熟练掌握类库的使用，对类库的设计有较为深入的理解，包括类库设计背后的计算机基础知识（操作系统、网络等），并对核心功能的源码有深入的研究 方式：研究类库的使用方法及常见并撰写学习笔记 举个例子，反射你要了解清楚的话，你是不是要搞明白JVM的类加载机制？网络IO要搞清楚的话，你是不是要清楚TCP/IP和HTTP、HTTPS？包括并发包，如果你要搞清楚的话，是不是要了解并发的相关知识？因此，这四个包要彻底搞清楚，还是需要花费一定时间和精力的。但是，请相信我，这绝对是值得的，甚至可以说，这四个包用的够不够叼，基本决定了一个Java程序员所处的档次。 第三级别：会用即可1234567891011121314151617181920212223java.lang.annotationjavax.annotation.*java.lang.refjava.mathjava.rmi.*javax.rmi.*java.security.*javax.security.*java.sqljavax.sql.*javax.transaction.*java.textjavax.xml.*org.w3c.dom.*org.xml.sax.*javax.crypto.*javax.imageio.*javax.jws.*java.util.jarjava.util.loggingjava.util.prefsjava.util.regexjava.util.zip 目标：了解上述类库的API及其应用场景 方式：学习常见API的功能并撰写学习笔记 ps：这些类库都是有特定的应用场景的，可以留到实际开发中遇到时再作深入研究 就像sql包和transaction包，就是操作数据库时用到的。而xml、dom和sax这些，都是操作xml时用到的。其它的包也都是类似的，有使用注解时用的，有远程方法调用时用的，也有涉及到加密时用到的等等 四级别：直接无视能走到这一步，应该来说已经达到了熟悉/熟练使用Java的境界了，但是离精通Java还差得远 Java的开发工具 如果你有兴趣的话，也可以自己去JDK的bin目录下找找，看有没有什么更好玩的工具 12345678910steve@ubuntu-17-10:~$ ls /usr/lib/jvm/jdk1.8.0_201/bin/appletviewer javafxpackager jdb jrunscript pack200 unpack200ControlPanel javah jdeps jsadebugd policytool wsgenextcheck javap jhat jstack rmic wsimportidlj javapackager jinfo jstat rmid xjcjar java-rmi.cgi jjs jstatd rmiregistryjarsigner javaws jmap jvisualvm schemagenjava jcmd jmc keytool serialverjavac jconsole jmc.ini native2ascii servertooljavadoc jcontrol jps orbd tnameserv","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"}]},{"title":"JavaWeb开发笔记","slug":"JavaWeb开发笔记","date":"2019-07-14T15:27:20.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/14/JavaWeb开发笔记/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/JavaWeb开发笔记/","excerpt":"","text":"JavaWeb开发学习笔记Java SEJava基础（一）Java正则表达式（1）参考博客：https://segmentfault.com/a/1190000009162306 （2）对于*?这个符号， 如果 ? 是限定符 * 或 + 或 ? 或 {} 后面的第一个字符，那么表示非贪婪模式（尽可能少的匹配字符），而不是默认的贪婪模式 意思是，正则表达式匹配时从左往右扫描，当已扫描的字符串片段已经符合正则规则，则将其提取出来，即使再往后扫描一个字符依然符合这个规则，用代码解释如下： 1234567private static void test2() &#123; String str = \"Hello###, world!\"; String pattern1 = \"([#]&#123;2,&#125;?)\"; String pattern2 = \"([#]&#123;2,&#125;)\"; System.out.println(str.replaceAll(pattern1, \"&amp;\")); System.out.println(str.replaceAll(pattern2, \"%\"));&#125; 输出结果是 12Hello&amp;#, world!Hello%, world! 可以看出，在{}后面使用了?后，正则的匹配是非贪婪模式，扫描到##时，就已经满足pattern1的规则，故不再扫描到第三个#，而pattern2使用贪婪模式，因此匹配的是### （3）分组和反向引用 小括号 () 可以达到对正则表达式进行分组的效果。 在以正则表达式替换字符串的语法中，是通过 $ 来引用分组的反向引用，$0 是匹配完整模式的字符串（注意在 JavaScript 中是用 $&amp; 表示）；$1 是第一个分组的反向引用；$2 是第二个分组的反向引用，以此类推。 String pattern = &quot;(\\\\w)(\\\\s+)([.,])&quot;;使用了 [.] 来匹配普通字符 . 而不需要使用 [\\\\.]。因为正则对于 [] 中的 .，会自动处理为 [\\.]，即普通字符 . 进行匹配。 在小括号 () 内的模式开头加入 ?:，那么表示这个模式仅分组，但不创建反向引用。 在小括号中使用 ?&lt;name&gt; 将小括号中匹配的内容保存为一个名字为 name 的副本。 （4）Matcher、Pattern类的基本用法： 123456789101112String text = \"Hello Regex!\";Pattern pattern = Pattern.compile(\"\\\\w+\");// Java 中忽略大小写，有两种写法：// Pattern pattern = Pattern.compile(\"\\\\w+\", Pattern.CASE_INSENSITIVE);// Pattern pattern = Pattern.compile(\"(?i)\\\\w+\"); // 推荐写法Matcher matcher = pattern.matcher(text);// 遍例所有匹配的序列while (matcher.find()) &#123; System.out.print(\"Start index: \" + matcher.start()); System.out.print(\" End index: \" + matcher.end() + \" \"); System.out.println(matcher.group());&#125; Pattern.compile(正则表达式)返回Pattern对象，Pattern类的构造函数是私有的，不能通过new来创建 pattern.matcher(字符串)使用已经解析出来的pattern对象取匹配要处理的字符串，返回Matcher对象 关于Matcher类和Pattern类，参考：https://blog.csdn.net/yin380697242/article/details/52049999 Pattern类常用方法及介绍 Pattern complie(String regex)由于Pattern的构造函数是私有的,不可以直接创建,所以通过静态方法compile(String regex)方法来创建,将给定的正则表达式编译并赋予给Pattern类 String pattern() 返回正则表达式的字符串形式,其实就是返回Pattern.complile(String regex)的regex参数 Pattern.matcher(CharSequence input) 对指定输入的字符串创建一个Matcher对象 Pattern.quote(String s) 返回给定的字符串的字面量 matches()方法编译给定的正则表达式并且对输入的字串以该正则表达式为模开展匹配,该方法适合于该正则表达式只会使用一次的情况,也就是只进行一次匹配工作,因为这种情况下并不需要生成一个Matcher实例 Matcher类 常用方法及介绍 boolean matches() 最常用方法:尝试对整个目标字符展开匹配检测,也就是只有整个目标字符串完全匹配时才返回真值 boolean lookingAt() 对前面的字符串进行匹配,只有匹配到的字符串在最前面才会返回true boolean find() 对字符串进行匹配,匹配到的字符串可以在任何位置 int start() 返回当前匹配到的字符串在原目标字符串中的位置 int end() 返回当前匹配的字符串的最后一个字符在原目标字符串中的索引位置 String group() 返回匹配到的子字符串 对同一个Matcher对象，如果上一次find()方法调用成功，那么它会记录下上次match的start和end，当再一次执行find时，Matcher会在end后面继续匹配，而不是从头开始 Java正则源码解析参考：https://blog.csdn.net/li20081006/article/details/21999779 Java基本运算符（1）&amp;和&amp;&amp;的异同 电路问题： 对于：&amp; – &gt; 不管怎样，都会执行”&amp;”符号左右两边的程序 对于：&amp;&amp; – &gt; 只有当符号”&amp;&amp;”左边程序为真(true)后，才会执行符号”&amp;&amp;”右边的程序。 运算规则： 对于：&amp; – &gt; 只要左右两边有一个为false，则为false；只有全部都为true的时候，结果为true 对于：&amp;&amp; – &gt; 只要符号左边为false，则结果为false；当左边为true，同时右边也为true，则结果为true ——来源：https://www.cnblogs.com/hongten/p/hongten_java_yu.html 1234567private static void operatorTest(String str) &#123; if (str != null &amp;&amp; !str.equals(\" \")) System.out.println(\"str != null &amp;&amp; !str.equals(\\\"\\\")\"); if (str != null &amp; !str.equals(\" \")) System.out.println(\"str != null &amp; !str.equals(\\\"\\\")\");&#125;/*** 第二个判断条件会抛出异常*/ &amp;可以是按位与运算和逻辑与运算，&amp;&amp;只能是逻辑与运算 （2）|和||的异同 类似于（1）中的&amp;和&amp;&amp;，||和|都是表示“或”，区别是||只要满足第一个条件，后面的条件就不再判断，而|要对所有的条件进行判断 基本数据类型及其包装类（1）参考博客：https://alexyyek.github.io/2014/12/29/wrapperClass/ （2）自动装箱和自动拆箱 简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。 12Integer i = 10; //装箱int index = i; //拆箱 注意： 12Integer test = null;int f = test.intValue(); 这种写法会抛出空指针异常，编译不通过，因为将null赋值给Integer，这个时候不会进行自动装箱，也就没有创建Integer实例 （2）实现机制：在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue()方法。对其他的类型也类似，装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的xxxValue方法实现的。（xxx代表对应的基本数据类型） （3）关于null、void和Void的一些比较 void不是函数，是方法的修饰符，void的意思是该方法没有返回值，意思就是方法只会运行方法中的语句，但是不返回任何东西。 java.lang.Void是一种类型。例如给Void引用赋值null。通过Void类的源代码可以看到，Void类型不可以继承与实例化。 https://blog.csdn.net/f641385712/article/details/80409211 https://blog.csdn.net/claram/article/details/52053798 摘录一些比较重要的知识如下： 如果使用了带有null值的引用类型变量，instanceof操作将会返回false 123// 输出是falseBoxingAndUnboxingTest test = null;System.out.println(test instanceof BoxingAndUnboxingTest); 可以使用或者!=操作来比较null值，但是不能使用其他算法或者逻辑操作，例如小于或者大于 1234Integer i = null;Integer j = null;System.out.println(i == j);System.out.println(i &gt; j); 输出是 1234trueException in thread \"main\" java.lang.NullPointerException at tk.chph.demo.box.BoxingAndUnboxingTest.test5(BoxingAndUnboxingTest.java:16) at tk.chph.demo.box.BoxingAndUnboxingTest.main(BoxingAndUnboxingTest.java:9) class关键字用法 12345System.out.println(Void.class); //class java.lang.VoidSystem.out.println(void.class); //void//类似于下面的System.out.println(Integer.class); //class java.lang.IntegerSystem.out.println(int.class); //int Void类的用法： 用于反射中判断某方法的返回值是否为void 123456for(Method method : Test.class.getMethods()) &#123; //判断返回值类型 用到了Void类 if(method.getReturnType().equals(Void.TYPE)) &#123; System.out.println(method.getName()); &#125;&#125; 因为equals方法中不能传递关键字void，其中Void.TYPE源代码是public static final Class&lt;Void&gt; TYPE = (Class&lt;Void&gt;) Class.getPrimitiveClass(&quot;void&quot;); 使用泛型时函数并不需要返回结果或某个对象不需要值时候这是可以使用java.lang.Void类型表示 ==操作符 123456789class AutoUnboxingTest &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 &#125;&#125; 字符串编码（1）参考博客：https://my.oschina.net/mojiewhy/blog/177473 （2）主要有getBytes(Charset charset)和String(byte bytes[], String charsetName)两个方法： getBytes(Charset charset)：Encodes this {@code String} into a sequence of bytes using the charset, storing the result into a new byte array. String(byte bytes[], String charsetName)：Constructs a new {@code String} by decoding the specified array of bytes using the specified {@linkplain java.nio.charset.Charset charset}. 字符串在java中统一用unicode表示( 即utf-16 LE) Case mapping is based on the Unicode Standard version specified by the {@link java.lang.Character Character} class. 对于String gbkStr = &quot;你好哦!&quot;;这个方法： 如果源码文件是GBK编码, 操作系统（windows）默认的环境编码为GBK，那么编译时, JVM将 按照GBK编码将字节数组解析成字符，然后将字符转换为unicode格式的字节数组，作为内部存储。 当打印这个字符串时，JVM 根据操作系统本地的语言环境，将unicode转换为GBK，然后操作系统将GBK格式的内容显示出来。 str.getBytes(Charset charset)是按照给定的编码方式charset，将str内部存储的字节数据（实际上String类的内部实现里是维护一个私有的byte数组的）转换成一个新的byte数组并返回，这个时候新的byte数组的编码方式就是charset了 new String(bytes, charset)是使用charset这个编码来对字节数组bytes进行解码，得到新的字符串，这个字符串内部依然会维护一个byte数组，编码方式就是charset指定的 getBytes 和 new String() 来进行编码转换，核心工作都是在getbytes这个方法内部实现了，即将原编码方式的byte数组转换成给定的新的编码方式的byte数组，这时候实际上就已经完成了编码转换，new String只是按照新的编码方式将byte数组转出字符串对象而已，便于进行输出 如何正确的将GBK转UTF-8 ? （实际上是unicode转UTF-8) 12345678910111213// 利用getBytes将unicode字符串转成UTF-8格式的字节数组byte[] utf8Bytes = gbkStr.getBytes(\"UTF-8\"); // 然后用utf-8 对这个字节数组解码成新的字符串String utf8Str = new String(utf8Bytes, \"UTF-8\");// 简化后就是:unicodeToUtf8 (String s) &#123; return new String( s.getBytes(\"utf-8\") , \"utf-8\");&#125;// UTF-8 转GBK原理也是一样return new String( s.getBytes(\"GBK\") , \"GBK\"); String类默认的编码是UTF-8（参考：https://blog.csdn.net/sugar_rainbow/article/details/76945323） 1234567891011String str = \"数据结构与算法\";byte[] bytes = str.getBytes(\"utf8\");for (byte b : str.getBytes()) &#123; System.out.print(b);&#125;System.out.println();for (byte b : bytes) &#123; System.out.print(b);&#125;System.out.println();System.out.println(new String(bytes, \"unicode\")); 输出结果是 123-26-107-80-26-115-82-25-69-109-26-98-124-28-72-114-25-82-105-26-77-107-26-107-80-26-115-82-25-69-109-26-98-124-28-72-114-25-82-105-26-77-107냦趮鏦麄軧꺗� 可见，getBytes(&quot;utf8&quot;)和getBytes()返回的byte数组是一样的，而且最后一句可以看到，utf-8和Unicode是不一样的 不同的编码在Java中所占用的字节数：https://www.cnblogs.com/Qian123/p/5799835.html String 、StringBuffer和StringBuilder（1）参考：https://blog.csdn.net/weixin_41101173/article/details/79677982 String StringBuffer StringBuilder String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间 是可变类和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 可变类，速度更快 不可变 可变 可变 线程安全 线程不安全 多线程操作字符串 单线程操作字符串 Java基础（二）数组（Array）和列表（ArrayList）的区别（1）参考：https://blog.csdn.net/m0_37683661/article/details/78778483 Array ArrayList 空间大小 空间大小是固定的，空间不够时也不能再次申请，所以需要事前确定合适的空间大小 动态增长，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够 存储内容 Array数组可以包含基本类型和对象类型；Array数组在存放的时候一定是同种类型的元素 ArrayList却只能包含对象类型；ArrayList可以存储不同类型的对象，因为ArrayList可以存储Object 方法 添加全部addAll()、删除全部removeAll()、返回迭代器iterator()等 应用场景 如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里 如果需要频繁对数组进行增删改查操作，使用ArrayList会很方便；但是如果需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，使用ArrayList的效率很低，而使用Array进行这样的动作很麻烦，那么，我们可以考虑选择LinkedList （2）值得注意的是，Array中的包装类和基本类型可以混用（本质上是自动装箱和自动拆箱） 12345Integer[] arr = new Integer[3];arr[0] = 1;arr[2] = Integer.valueOf(\"2\");arr[1] = null;for (Integer i : arr) System.out.println(i); for循环使用的是Integer，所以null可以正常输出，如果改成int，那么null就会报错，因为没法自动拆箱成基本类型 值传递和引用传递（1）首先，Java内的传递使用的都是值传递，这里面有两层意思： 对于基本数据类型，传递的是变量的值 对于对象的引用传递，传递的只是对象引用的值（即只是传递引用指向的对象的地址，而不是对象本身，也不是对象的引用的引用） 参考博客：https://blog.csdn.net/javazejian/article/details/51192130 1234567891011121314151617181920212223242526public class CallByValue &#123; private static User user=null; private static User stu=null; /** * 交换两个对象 * @param x * @param y */ public static void swap(User x,User y)&#123; User temp =x; x=y; y=temp; &#125; public static void main(String[] args) &#123; user = new User(\"user\",26); stu = new User(\"stu\",18); System.out.println(\"调用前user的值：\"+user.toString()); System.out.println(\"调用前stu的值：\"+stu.toString()); swap(user,stu); System.out.println(\"调用后user的值：\"+user.toString()); System.out.println(\"调用后stu的值：\"+stu.toString()); &#125;&#125; 执行结果如下： 1234567调用前user的值：User [name=user, age=26]调用前stu的值：User [name=stu, age=18]调用后user的值：User [name=user, age=26]调用后stu的值：User [name=stu, age=18] 可以这么理解：Object obj = new Object();变量obj的值是新的对象new Objext()的地址，obj在方法调用时call(Object obj1)传递是值传递，就是把obj的值（新对象的地址）拷贝到了obj1中，这时候obj1持有的引用是new Object()，而不是obj，所以obj所做的任何修改只是对对象的修改，而对obj不会产生任何影响，只是副作用是obj指向的对象自身属性可能被（obj1）修改了 Java8新特性Lambda表达式（1）对于只有一个抽象方法（可以是重载的方法）的接口称为函数式接口，函数式接口与lambda兼容；实际上Java中的lambda表达式能做的也就是转换为函数式接口而已 （2）方法引用：使用::操作符来分隔对象或类与方法 object::instanceMethod（等价于(..)-&gt;object.instanceMethod(..)） Class::staticMethod（等价于(..)-&gt;Class.staticMethod(..)） Class::instanceMethod 特别注意的是第三个方法，它的参数列表中第一个参数会成为方法的目标（即调用该方法的对象），例如：String::compareToIngnoreCase等同于(x, y)-&gt;x.compareToIgnoreCase(y) （3）当有多个同名的重载方法时，编译器会自动选择最符合的那个版本 （4）lambda表达式中可以有this和super关键字 （5）Class::new可以调用一个构造器，具体是哪个构造器会根据上下文进行推导 （6）lambda表达式的三个部分： 一个代码块 参数 自由变量的值，指的是非参数而且不是在代码块中定义的变量 例如： 12345678public static void repeatMessage(String text, int delay)&#123; ActionListener listener = event -&gt; &#123; //注意text变量 System.out.println(text); Toolkit.getDefaultToolkit().beep(); &#125;; new Timer(delay, listener).start();&#125; 这里的text就是自由变量；由于repeatMessage和listener方法不是同步调用的，有可能出现repeatMessage调用结束后，listener才调用，而这时候text这个变量很可能已经被回收了，因此listener要正常运行，必须捕获自由变量的值 （7）闭包 （8）lambda表达式中只能引用值不会改变的变量，而且lambda表达式中捕获的变量必须实际上是最终变量（final或者像String这种不会改变的变量） （9）lambda表达式与嵌套块有相同的作用域，因此lambda表达式中声明一个与局部变量同名的参数或者局部变量是不合法的 123456789101112131415161718// 报错：Variable ‘event’ is already defined in the scopepublic static void repeatMessage(String text, int delay)&#123; int event = 1; ActionListener listener = event -&gt; &#123; System.out.println(text); Toolkit.getDefaultToolkit().beep(); &#125;;&#125;// 报错：Variable ‘i’ is already defined in the scopepublic static void repeatMessage(String text, int delay)&#123; int i = 1; ActionListener listener = event -&gt; &#123; int i; System.out.println(text); Toolkit.getDefaultToolkit().beep(); &#125;;&#125; （10）lambda表达式中的this关键字是指创建这个lambda表达式的方法的this参数： 123456789101112131415161718192021222324252627package tk.chph.demo.lambda;interface Listener &#123; void test(); default void method1()&#123; System.out.println(\"Listener\"); &#125;&#125;public class LambdaTest &#123; public static void main(String[] args) &#123; new LambdaTest().run(); &#125; public void method1() &#123; System.out.println(\"Lambda Test\"); &#125; public void run() &#123; Listener listener = () -&gt; &#123; // 这里的this关键字指的都是LambdaTest这个类的实例的引用，而不是listener的引用 this.method1(); method1(); &#125;; listener.test(); &#125;&#125; 输出结果是： 12Lambda TestLambda Test 各个jdk版本的新特性（1） 线程（1）Java中实现一个线程的方法有： 继承Thread类 实现Runnable接口 事实上，Thread类也实现了Runnable接口，并且自动获得了run方法 （2）为什么通过实现Runnable接口来实现线程的方法好？ 因为Java中类是单继承的，如果使用继承Thread类的方式来实现线程，那么他就不能再继承其他的类了 从面向对象的角度来看，继承一个类的目的更多是在原有类的基础上提供新的特征或者功能；如果我们只是想使用run()方法来使得我们的代码能够和主线程并行运行，实现Runnable接口是个更好的选择 （3）Java线程的生命周期 [ Thread in Java.png](https://i.loli.net/2019/05/20/5ce1fb9627bff98011.png) 当我们创建实现了Runnable接口或者继承了Thread类的实例后，我们只是创建了一个线程对象（处在图中的NEW状态），只有当我们调用start()方法后，这个线程才会启动（这时是在RUNNABLE状态），在start方法内部会调用run方法 处于RUNNABLE状态的线程还不一定在执行，需要等待线程调度器分配CPU资源去运行线程，也就是说，线程的run方法是由JVM调用的 run()方法和start方法的区别 when program calls start() method a new Thread is created and code inside run() method is executed in new Thread if you call run()method directly no new Thread is created and code inside run() will execute on current Thread Another difference between start vs run in Java thread is that you can not call start() method twice on thread object. once started, second call of start() will throw IllegalStateException in Java while you can call run() method twice 小知识点 线程执行完毕的顺序和线程start的顺序并不一致，这取决于jvm的线程调度器 当线程中的run方法运行结束后，线程进入DEAD状态，这时候再调用start方法，线程也无法再次启动 （4）线程与进程的区别 线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务 不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间（堆内存） 每个线程都拥有单独的栈内存用来存储本地数据 （5）Java内存模型(JMM)的Happens-before规则 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。 （6）volatile变量 参考：https://javarevisited.blogspot.com/2011/06/volatile-keyword-java-example-tutorial.html volatile variable in Java.png Java中的volatile关键字是用来指示Java编译器和线程不要缓存这个变量的值，始终都从主存中读取变量的值 Anyway, the volatile keyword in Java is used as an indicator to Java compiler and Thread that do not cache value of this variable and always read it from main memory 当我们需要使得对某个变量的读或者写操作是原子性的（例如对int或者boolean变量的读或者写），那么我们可以将其声明为volatile So if you want to share any variable in which read and write operation is atomic by implementation e.g. read and write in an int or a boolean variable then you can declare them as volatile variable volatile关键字只能用在变量上，不能用在类或者方法上 The Java volatile keyword cannot be used with method or class and it can only be used with a variable volatile关键字可以用在多线程环境的单例模式中 123456789101112131415public class Singleton&#123;private static volatile Singleton _instance; //volatile variable public static Singleton getInstance()&#123; if(_instance == null)&#123; synchronized(Singleton.class)&#123; if(_instance == null) _instance = new Singleton(); &#125; &#125; return _instance;&#125; 如果不将_instance声明为volatile，其中一个线程在创建了_instance后就失去了CPU资源，这时候其他线程的看到的_instance变量依然是null的，这时候其他线程就有可能再次创建_instance对象，这样Singleton类的实例就有可能不是单例模式的了 （7）如何停止一个线程 JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用 当run方法执行结束或者跑出异常时，线程会自动结束（简单的说，如果线程运行过程中抛出的异常没有被捕获，该线程将会停止执行） 可以通过结合volatile设置标记位来手动中断线程的执行 代码示例 12345678910111213141516171819private class Runner extends Thread&#123; volatile boolean bExit = false; public void exit(boolean bExit)&#123; this.bExit = bExit; &#125; @Override public void run()&#123; while(!bExit)&#123; System.out.println(\"Thread is running\"); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ex) &#123; Logger.getLogger(ThreadTester.class.getName()).log(Level.SEVERE, null, ex); &#125; &#125; &#125;&#125; 当我们调用exit()方法将bExit设置为true时，run方法就会在新一轮迭代开始时检测到，然后终止循环 要注意，每个线程都有自己的本地内存，bExit变量也一样，因此要使得bExit值的改变能够立即被其他线程看到，需要将bExit设置为volatile变量 （8）线程之间的消息传递 生产者消费者模式：where One thread produce and put something on shared bucket, and then tell other thread that there is an item for your interest in shared object, consumer thread than pick than item and do his job 如果不使用wait()和notify()/notifyAll()方式，消费者线程就必须得周期性地轮询bucket（一个共享对象），即使bucket的状态没有发生变化 消费者在检查条件的时候，要使用while循环而不是if判断 主要是为了避免虚假唤醒的情况，这样线程在休眠前和唤醒后都会进行条件的检查；因为有可能有多个线程在条件改变时同时被唤醒，其中的一些线程由于没有得到即使的响应，被其他唤醒的线程将条件改变了，那些没有及时响应的线程在获得CPU资源后，如果使用的是if检查添加，那么它就不会再去检查条件而是直接对共享对象进行操作，导致出错；如果使用的是while检查条件，那么它被唤醒之后，无论如何都回再去检查条件，如果条件没有满足，它会再次进入休眠状态而不是取操作共享对象 While if you call notifyAll method, all threads waiting on that lock will be woken up, but again all woken thread will fight for lock before executing remaining code and that’s why wait is called on loop because if multiple threads are woken up, the thread which will get lock will first execute and it may reset waiting for condition, which will force subsequent threads to wait. （9）notify()和notifyAll()的区别 The main difference between notify and notifyAll is that notify method will only notify one Thread and notifyAll method will notify all Threads which are waiting on that monitor or lock notify()唤醒的线程是哪一个是无法保证的，这由线程调度器来决定 当我们的程序中唤醒休眠中的线程，最终只会有一个线程会获得资源对共享对象进行操作的时候，我们应该使用notify()而不是notifyAll()，而且这样还能够节省CPU资源 You can use notify over notifyAll if all thread are waiting for the same condition and only one Thread at a time can benefit from condition becoming true. In this case, notify is optimized call over notifyAll because waking up all of them because we know that only one thread will benefit and all other will wait again, so calling notifyAll method is just waste of CPU cycles （10）为什么wait、notify和notifyAll是在Object类中定义的而不是Thread类 参考：https://javarevisited.blogspot.com/2012/02/why-wait-notify-and-notifyall-is.html （11）Thread.interrupted和isInterrupted的区别 interrupted() 和 isInterrupted()的主要区别是**前者会将中断状态清除而后者不会*。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()*来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。 （12）如果wait和nofity不在同步块中调用，代码就会抛出IllegalMonitorStateException异常 Java面向对象接口（1）接口中的所有方法自动地属于public ，因此, 在接口中声明方法时 , 不必提供关键字public；但是在实现接口时，必须把方法声明为public，否则编译器认为该方法的访问属性是包可见性 1234567891011interface InterfaceA &#123; void method1();&#125;public class ImplA implements InterfaceA &#123; // 这里会报错 // Error:(4, 10) java: tk.chph.demo.interface_.ImplA中的method1()无法实现tk.chph.demo.interface_.InterfaceA中的method1()正在尝试分配更低的访问权限; 以前为public void method1() &#123; &#125;&#125; （2）接口可以定义常量，但是不能有实例域；在jdk8之前，接口中的方法也不能含有实现 （3）可以使用instanceof检查一个类的实例是否实现了特定的接口 1new ImplA() instanceof InterfaceA; （4）接口中不能包含实例域或者静态方法（1.8之前），但是可以包含常量；接口中的方法自动的设置为public，而接口中的域也自动被设置为public static final （5）使用接口不使用抽象类的原因：Java中的类只能扩展一个抽象类或者超类，而可以实现多个接口；多重继承会使得语言本身变得复杂，同时效率低下 （6）jdk1.8之后interface中允许有静态方法，即static修饰的类方法，但是必须为其提供实现体；同时interface中也允许提供以default修饰的成员方法的默认实现，且默认方法可以调用任何其他的方法 123456789101112public interface InterfaceA &#123; void method1(); static void method2()&#123; &#125; default void method3()&#123; method1(); method2(); &#125;&#125; （7）默认方法冲突：如果一个接口中的一个默认方法和另一个超类或者接口中定义的方法签名相同，这是就产生了默认方法冲突问题，解决方法如下： 超类优先：如果超类提供了一个具体方法（如果是抽象的方法，那么实现类要么是实现该方法，要么是让该方法依旧抽象，从这一点来看，超接口的默认方法依然是被忽略的），且签名和默认方法相同，那么具体的实现是选择超类中的实现，忽略超接口的所有同签名方法不论是否是默认的 （ps：超类优先原则可以保证jdk8之前的代码兼容性，jdk8之后的接口提供签名相同的默认方法并不会造成冲突） （pss：默认方法重新定义Object类中的方法无效，因为所有的类都继承自Object，如果为toString或者equals这样的Object类方法定义默认方法，由于类优先原则，Object.toString或者Objects.equals方法会覆盖该默认方法） 接口冲突：如果是超接口提供了一个同签名的默认方法，那么实现类必须覆盖该默认方法以解决冲突 123456789101112131415161718192021222324252627282930313233343536373839package tk.chph.demo.interface_;public class ImplA extends AbstractA implements InterfaceA, InterfaceB &#123; @Override public void method4() &#123; &#125; public static void main(String[] args) &#123; new ImplA().method5(); &#125;&#125;abstract class AbstractA &#123; public abstract void method4(); public void method5()&#123; System.out.println(\"AbstractA\"); &#125;&#125;interface InterfaceA &#123; void method4(); default void method5()&#123; System.out.println(\"InterfaceA\"); &#125;&#125;interface InterfaceB &#123; void method4(); default void method5()&#123; System.out.println(\"InterfaceB\"); &#125;&#125; 输出为：AbstractA 如果将AbstractA这个抽象类去掉，那么输出结果是： 1Error:(3, 8) java: 类 tk.chph.demo.interface_.ImplA从类型 tk.chph.demo.interface_.InterfaceA 和 tk.chph.demo.interface_.InterfaceB 中继承了method5() 的不相关默认值 必须在ImplA中覆盖method5方法后才能编译通过 123456789101112131415161718package tk.chph.demo.interface_;public class ImplA implements InterfaceA, InterfaceB &#123; @Override public void method4() &#123; &#125; @Override public void method5() &#123; System.out.println(\"ImplA\"); &#125; public static void main(String[] args) &#123; new ImplA().method5(); &#125;&#125; 输出为：ImplA 当然也可以在ImplA中选择超接口的其中一个method5实现： 1234@Overridepublic void method5() &#123; InterfaceA.super.method5();&#125; 这里的例子是两个超接口都的冲突默认方法都提供了实现，然而实际上是，InterfaceA和InterfaceB只要至少一个提供了默认方法，那个实现类都必须覆盖该默认方法了 Comparable 和 Comparator接口（1）参考博客：https://www.cnblogs.com/skywang12345/p/3324788.html （2）若一个类实现了Comparable接口，就意味着“该类支持排序”。 “实现Comparable接口的类的对象的List列表(或数组)”，可以通过 Collections.sort（或 Arrays.sort）进行排序。 1234567package java.lang;import java.util.*;// 通过 x.compareTo(y) 来“比较x和y的大小”。若返回“负数”，意味着“x比y小”；返回“零”，意味着“x等于y”；返回“正数”，意味着“x大于y”。public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; （3）Comparator 是比较器接口，通过实现Comparator构建一个比较器，可以用来对某个没有实现Comparable接口的类进行排序 也就是说，我们可以通过“实现Comparator类来新建一个比较器”，然后通过该比较器对类进行排序。 123456789package java.util;// “比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2); boolean equals(Object obj);&#125; 若一个类要实现Comparator接口：它一定要实现compareTo(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。理由还是“类优先原则”，所有类都继承了Object的equals方法，因此超接口中的equals不用去实现也可以编译通过 （4）Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。 Cloneable接口和clone()方法（1）参考博客：https://www.cnblogs.com/xrq730/p/4858937.html （2）Cloneable接口 实现Cloneable接口（该接口是一个标记接口，内部没有任何方法），以指示Object的clone()方法可以合法地对该类实例进行按字段复制 如果在没有实现Cloneable接口的实例上调用Object的clone()方法，则会导致抛出CloneNotSupporteddException 实现此接口的类应该使用公共方法重写Object的clone()方法，Object的clone()方法在定义时是protected的，即只能在java.lang包下的类和子类能够调用clone()方法，所以在重写clone方法时要将修饰符改成public，以便重写的clone方法能够被其他类调用 （3）clone方法应该满足以下条件： x.clone() != x为true x.clone().getClass() == x.getClass()为true x.clone().equals(x)一般情况下为true，但这并不是必须要满足的要求 （4）clone方法不会调用类的构造函数 （5）浅克隆和深克隆 ​ 浅克隆（shallow clone）和深克隆（deep clone）反映的是，当对象中还有对象的时候，那么： 浅克隆，即很表层的克隆，如果我们要克隆对象，只克隆它自身以及它所包含的所有对象的引用地址 深克隆，克隆除自身对象以外的所有对象，包括自身所包含的所有对象实例 （6）其实Object的clone()方法，提供的是一种浅克隆的机制，如果想要实现对对象的深克隆，在不引入第三方jar包的情况下，可以使用两种办法： 先对对象进行序列化，紧接着马上反序列化出 先调用super.clone()方法克隆出一个新对象来，然后在子类的clone()方法中手动给克隆出来的非基本数据类型（引用类型）赋值，比如ArrayList的clone()方法 内部类（1）内部类的特点： 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据 可以对同一个包中的其他类隐藏起来 当要定义一个回调函数且不想编写大量代码时，可以使用匿名内部类 （2）内部类可以访问自己定义的成员，也可以访问创建它的外围类对象的成员（包括私有的） 123456789101112131415161718192021222324252627282930package tk.chph.demo.inner;public class InnerClassTest &#123; private int a; public class Inner&#123; private void method()&#123; // 访问外围类的成员变量a System.out.println(a); &#125; &#125;&#125;// 反编译class文件后是这样的public class InnerClassTest &#123; private int a; public InnerClassTest() &#123; &#125; public class Inner &#123; public Inner() &#123; &#125; private void method() &#123; // 注意这里 System.out.println(InnerClassTest.this.a); &#125; &#125;&#125; 实际上内部类的对象中有一个隐式的引用指向了创建它的外围类的对象；实际上编译器修改了所有内部类的构造函数，添加了一个外围类引用的参数，如下： 1234// 为了便于说明，将外围对象的引用定义为outerpublic Inner(InnerClassTest test) &#123; this.outer = test;&#125; 当InnerClassTest创建Inner类时，会这样调用构造函数：Inner inner = new Inner(this);将自身的引用传递到内部类对象中 （3）只有内部类可以是私有类, 而常规类只可以具有包可见性 , 或公有可见性 （4）内部类对外围类的引用正式语法是：OuterClass.this （5）外围类对象调用内部类的构造器的正式语法是：outerObject.new InnerClass(construction parameters) （6）在外围类的作用域外，可以这样引用其内部类：OuterClass.InnerClass （7）内部类声明的所有静态域都必须是final，原因是我们希望每一个静态域都只有一个实例，但是对每一个外部对象，它都会被分配一个单独的内部类实例（就是说不同外部对象的内部类实例都是不一样的对象），如果内部类静态域不是final，那么就可能出现不是唯一的情况 123456789101112private class Inner&#123; // 报错：Inner classes cannot have static declarations private static int b = 10; private void method()&#123; System.out.println(a); &#125; // 报错：Inner classes cannot have static declarations private static void test()&#123; &#125;&#125; （8）外围类可以访问内部类的任何成员，包括私有的 （9）局部内部类：定义在一个方法内的类 据不累不能用public或private访问修饰符声明，因为它的作用域被限制在声明这个局部内部类的块中 对外部世界，局部内部类可以完全隐藏起来 12345678910111213141516171819package tk.chph.demo.inner;public class InnerClassTest &#123; &#123; class InnerClass&#123;&#125; &#125; static &#123; class InnerClass&#123;&#125; &#125; void test1()&#123; class InnerClass&#123;&#125; &#125; static void test2()&#123; class InnerClass&#123;&#125; &#125;&#125; （10）局部内部类可以访问其所在块的作用域内的局部变量 12345678void test1(int a)&#123; class InnerClass&#123; private void test()&#123; System.out.println(a); &#125; &#125; new InnerClass().test();&#125; 和lambda的捕获一样，由于可能出现test1方法执行结束后局部变量消失，而内部类还未执行的情况，内部类会在外部块释放局部变量之前，将局部变量进行备份，实际上的实现是这样的： 编译器会修改局部内部类的成员和构造函数，开始时先检测局部内部类对局部变量的访问，为每个局部变量建立相应的数据域，然后将局部变量拷贝到构造器中，以便这些局部内部类的数据域初始化为局部变量的副本 而且，引用的局部变量必须是final的或者是实际上不变的对象： 12345678910void test1(int a)&#123; class InnerClass&#123; private void test()&#123; // 报错：Variable 'a' is accessed from within inner class, needs to be final or effectively final a = 10; System.out.println(a); &#125; &#125; new InnerClass().test();&#125; 因此上面划线部分补充一下，内部类建立的数据域实际上是final的，对它初始化后不能够再进行修改，所以出现a=10时会报错，即使是在内部类外面修改也不行： 1234567891011void test1(int a) &#123; // 这里修改 a = 10; class InnerClass &#123; private void test() &#123; // 报错：Variable 'a' is accessed from within inner class, needs to be final or effectively final System.out.println(a); &#125; &#125; new InnerClass().test();&#125; 总之，只要局部变量被局部内部类引用了，它就必须是final或者实际上的final了： 12345678910void test1(final int a) &#123; final int b = 90; class InnerClass &#123; private void test() &#123; System.out.println(b); System.out.println(a); &#125; &#125; new InnerClass().test();&#125; （11）如果一个类只被创建一个对象，那就不必命名了，这种类称为匿名内部类 如果构造参数的括号后面跟一个大括号，那么正在定义的是一个匿名内部类 由于匿名内部类没有类名，自然就没有构造函数，取而代之的是将构造器参数传递给超类的构造器 123456789101112131415161718192021package tk.chph.demo.inner;abstract public class AbstractClass &#123; protected int i; AbstractClass(int i) &#123; this.i = i; &#125; abstract public void test(String name); public static void main(String[] args) &#123; AbstractClass c = new AbstractClass(10) &#123; @Override public void test(String name) &#123; System.out.println(this.i + \": \" + name); &#125; &#125;; c.test(\"steve\"); &#125;&#125; 由于AbstractClass是抽象类，他不能直接被实例化，new出来的实际上是AbstractClass的一个子类（实现类），这个子类没有类名，是个匿名内部类，没有自己的构造函数，要将构造参数传递给超类的构造器 匿名内部类（子类）进行getClass() != other.getClass()测试时会失败： 12345678910111213141516AbstractClass c = new AbstractClass(10) &#123; @Override public void test(String name) &#123; System.out.println(this.i + \": \" + name); &#125;&#125;;AbstractClass abstractClass = new AbstractClass(10) &#123; @Override public void test(String name) &#123; System.out.println(this.i + \": \" + name); &#125;&#125;;System.out.println(c.getClass() != abstractClass.getClass());StringBuilder sb1 = new StringBuilder();StringBuilder sb2 = new StringBuilder();System.out.println(sb1.getClass() != sb2.getClass()); 输出为： 12true //注意这个false （12）静态内部类 只有内部类可以声明为static，静态内部类除了没有外围类的引用外，其他功能和所有内部类相同 静态内部类的初始化实在静态方法中完成的 静态内部类可以有静态域和方法 声明在接口中的内部类自动成为static和public类 12345678910111213141516171819202122package tk.chph.demo.inner;interface InterfaceA &#123; class InnerClass&#123; void test()&#123; System.out.println(\"InnerClass in InterfaceA\"); &#125; &#125;&#125;public class OuterClassA &#123; static class InnerClassA&#123; // 静态内部类拥有静态域 public static final String name = \"InnerClassA\"; // 静态内部类拥有静态方法，普通的内部类不能拥有静态方法，自然就不能有main方法 public static void main(String[] args) &#123; // 这里直接通过接口名引用接口中定义的内部类 InterfaceA.InnerClass innerClass = new InterfaceA.InnerClass(); &#125; &#125;&#125; 由于方法内部不能用static修饰变量，因此无法在方法内部声明一个静态局部内部类 泛型泛型方法（1）可以通过在修饰符（例如public static）后面、返回类型前面添加类型变量&lt;T&gt;来声明一个泛型方法： 1234567package tk.chph.demo.generic;public class GenericTest &#123; &lt;T&gt; void test1(T t)&#123; System.out.println(t); &#125;&#125; （2）泛型方法的调用是在方法名前面加上&lt;类型变量&gt;： 12345public static void main(String[] args) &#123; new GenericTest().&lt;String&gt;test1(\"string\"); // It's also ok like this // new GenericTest().test1(\"string\");&#125; 当然调用时的类型变量是可以省略的，编译器可以通过上下文推断出来 类型变量的限定（1）可以使用&lt;T extends SuperClass/SuperInterface&gt;的语法来对类型变量T做限定，意思是T是绑定类型的子类型（subtype），这里的extends关键字不是继承的意思，因为绑定类型是接口也是可以的 123456789101112131415161718192021package tk.chph.demo.generic;interface InterfaceA&#123; &#125;public class GenericTest &#123; &lt;T extends InterfaceA&gt; void test1(T t)&#123; System.out.println(t); &#125; public static void main(String[] args) &#123; // 这时候就会报错： // Error:(13, 26) java: 无法将类 tk.chph.demo.generic.GenericTest中的方法 test1应用到给定类型; // 需要: T // 找到: java.lang.String // 原因: 显式类型参数java.lang.String不符合声明的范围tk.chph.demo.generic.InterfaceA new GenericTest().&lt;String&gt;test1(\"string\"); &#125;&#125; （2）一个类型变量或通配符可以有多个限定，限定类型用&amp;分隔，逗号用来分隔类型变量 12345&lt;T extends InterfaceA &amp; Comparable, U extends InterfaceA &amp; Cloneable&gt; void test2(T t, U u) &#123; System.out.println(t); System.out.println(u);&#125; （3）根据Java的继承和实现接口原则，只能够单继承多实现，而且继承在实现前面，所以如果使用类作为限定，它必须是限定列表的第一个 泛型和虚拟机：类型擦除（1）有关 Java 泛型转换的事实 : 虚拟机中没有泛型 , 只有普通的类和方法 所有的类型参数都用它们的限定类型替换 桥方法被合成来保持多态 为保持类型安全性, 必要时插人强制类型转换 Javascript对象的访问方法对象Person的字面量创建方法 123456789101112131415var person = &#123; name : &#123; first : 'Bob', last : 'Smith' &#125;, age : 32, gender : 'male', interests : ['music', 'skiing'], bio : function() &#123; alert(this.name[0] + ' ' + this.name[1] + ' is ' + this.age + ' years old. He likes ' + this.interests[0] + ' and ' + this.interests[1] + '.'); &#125;, greeting: function() &#123; alert('Hi! I\\'m ' + this.name[0] + '.'); &#125;&#125;; 点表示法123person.ageperson.interests[1]person.bio() 括号表示法12person['age']person['name']['first'] 在这个意义上，使用了关联了值的名字，而不是索引去选择元素，因此对象有时被称之为关联数组(associative array)——对象做了字符串到值的映射，而数组做的是数字到值的映射。 创建对象成员123456person['eyes'] = 'hazel' // 括号表示法person.farewell = function() &#123; alert(\"Bye everybody!\") &#125; // 点表示法// 测试新成员person['eyes']person.farewell() 此外，使用括号表示法可以动态设置成员的名字，而点表示法不可以（点表示法只能接受字面量的成员的名字，不接受变量作为名字） 123var myDataName = nameInput.valuevar myDataValue = nameValue.valueperson[myDataName] = myDataValue 这里的nameInput里的值完全可以在运行脚本的时候，通过&lt;input/&gt;标签让用户动态输入 构建函数和对象构建函数JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征 123456function Person(name) &#123; this.name = name; this.greeting = function() &#123; alert('Hi! I\\'m ' + this.name + '.'); &#125;;&#125; 这个构建函数是 JavaScript 版本的类。它只定义了对象的属性和方法，除了没有明确创建一个对象和返回任何值和之外，它有了函数所拥有的全部功能 1var person = new Person('Bob'); 这样使用new，通过构建函数创建了类Person的一个实例（*实际的方法，比如greeting()仍然是定义在类里面， 而不是在对象里面*） 创建对象的其他方法使用Object()构造函数来创建一个新对象。一般对象都有构造函数，它创建了一个空的对象 1var person = new Object(); 这样创建了一个空的对象person，然后, 可以根据需要, 使用点或括号表示法向此对象添加属性和方法 12345person.name = 'Chris';person['age'] = 38;person.greeting = function() &#123; alert('Hi! I\\'m ' + this.name + '.');&#125; 可以将对象文本传递给Object() 构造函数作为参数， 以便用属性/方法填充它 1234567var person = new Object(&#123; name : 'Chris', age : 38, greeting : function() &#123; alert('Hi! I\\'m ' + this.name + '.'); &#125;&#125;); 使用create()方法JavaScript有个内嵌的方法Object.create(), 它允许您基于现有对象创建新的对象 1var newPerson = Object.create(person); newPerson和person具有相同的属性和方法，即create方法创建了原对象的一个副本 JavaScript原型链与继承参考资料 https://juejin.im/post/58f94c9bb123db411953691b https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes 确定原型和实例的关系123456789101112131415function Father()&#123; this.property = true;&#125;Father.prototype.getFatherValue = function()&#123; return this.property;&#125;function Son()&#123; this.sonProperty = false;&#125;//继承 FatherSon.prototype = new Father();//Son.prototype被重写,导致Son.prototype.constructor也一同被重写Son.prototype.getSonVaule = function()&#123; return this.sonProperty;&#125;var instance = new Son(); （1）instanceof操作符来测试实例(instance)与原型链中出现过的构造函数，结果就会返回true 123alert(instance instanceof Object);//truealert(instance instanceof Father);//truealert(instance instanceof Son);//true （2）使用 isPrototypeOf() 方法, 同样只要是原型链中出现过的原型，isPrototypeOf() 方法就会返回true 123alert(Object.prototype.isPrototypeOf(instance));//truealert(Father.prototype.isPrototypeOf(instance));//truealert(Son.prototype.isPrototypeOf(instance));//true 借用构造函数即在子类型构造函数的内部调用超类型构造函数，也叫作经典继承 123456789101112function Father()&#123; this.colors = [\"red\",\"blue\",\"green\"];&#125;function Son()&#123; Father.call(this);//继承了Father,且向父类型传递参数&#125;var instance1 = new Son();instance1.colors.push(\"black\");console.log(instance1.colors);//\"red,blue,green,black\"var instance2 = new Son();console.log(instance2.colors);//\"red,blue,green\" 可见引用类型值是独立的 这样就保证了原型链中的引用类型的值是独立的，不会被所有实例共享 这里本质上是Son类通过this来调用Father构造函数中的方法实现，用来构造Son实例，但是Son类、实例和Father类之间不具有任何继承关系，因此Father类中定义的方法对Son是不可见的，因为无法通过原型链到达Father类 组合继承使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性 123456789101112131415function Father(name)&#123; this.name = name; this.colors = [\"red\",\"blue\",\"green\"];&#125;Father.prototype.sayName = function()&#123; alert(this.name);&#125;;function Son(name,age)&#123; Father.call(this,name);//继承实例属性，第一次调用Father() this.age = age;&#125;Son.prototype = new Father();//继承父类方法,第二次调用Father()Son.prototype.sayAge = function()&#123; alert(this.age);&#125; Father.call(this, name)借用构造函数继承了Father类中的属性，如上一小节所说，这样继承的属性在Son类的不同实例中是独立的；Son.prototype = new Father()修改了Son类的原型，这样Son类的实例就能够通过原型链找到Father类中定义的方法 原型继承在object()函数内部, 先创建一个临时性的构造函数, 然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例 12345function object(o)&#123; function F()&#123;&#125; // 创建一个临时性的构造函数 F.prototype = o; // 将传入的对象作为这个构造函数的原型 return new F(); // 返回这个临时类型的一个新实例&#125; 实际上创建的新对象是传入的原对象o的一个浅复制，因为新的对象的原型被设置为了原对象o，所以新对象也就拥有了原对象的引用类型属性，即新对象与原对象的引用类型属性是共享的 前面提到的Object.create()就是原型继承的规范版本： object.create() 接收两个参数: 一个用作新对象原型的对象 (可选的)一个为新对象定义额外属性的对象 只有一个参数时，就是上面实现的object方法，如果接受第二个参数，它会将原来的同名属性覆盖： 123456789var person = &#123; name : \"Van\"&#125;;var anotherPerson = Object.create(person, &#123; name : &#123; value : \"Louis\" &#125;&#125;);alert(anotherPerson.name);//\"Louis\" 寄生式继承类似工厂模式，在原型继承的基础上，对新创建的对象增加了一些功能，然后再返回 1234567function createAnother(original)&#123; var clone = object(original);//通过调用object函数创建一个新对象 clone.sayHi = function()&#123;//以某种方式来增强这个对象 alert(\"hi\"); &#125;; return clone;//返回这个对象&#125; 寄生组合式继承*(不大明白)为了减小组合继承调用两次父类构造函数的开销提出的 12345function extend(subClass,superClass)&#123; var prototype = object(superClass.prototype);//创建对象 prototype.constructor = subClass;//增强对象 subClass.prototype = prototype;//指定对象&#125; 首先通过原型继承创建一个父类的实例，然后通过寄生式继承，为这个实例增加子类的构造函数，最后为子类指定原型为刚刚创建的父类的实例 ？ new运算符new运算符实际上做的工作是： 123var obj = &#123;&#125;; // 创建了一个空对象objobj.__proto__ = F.prototype; // 将这个空对象的__proto__成员指向了F函数对象prototype成员对象F.call(obj); // 将F函数对象的this指针替换成obj，然后再调用F函数 new 操作符调用构造函数的时候，函数内部实际上发生以下变化： 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this. 属性查找（1）当查找某个对象的属性时，JavaScript会沿着原型链一直寻找，直到Object.prototype，如果没有找到的话则会返回undefined （2）如果想避免原型链查找，可以通过hasOwnProperty方法，它不会遍历原型链，只会在对象内部查找 （3）isPrototypeOf功能与instanceof相反，它是用来判断该方法所属的对象是不是参数的原型对象，是则返回true，否则返回false （4）this instanceof arguments.callee 的值如果为 true 表示是作为构造函数被调用的,如果为 false 则表示是作为普通函数被调用 12345678function f()&#123; if(this instanceof arguments.callee) console.log('此处作为构造函数被调用'); else console.log('此处作为普通函数被调用');&#125;f();//此处作为普通函数被调用new f();//此处作为构造函数被调用 （5）typeof 则用以获取一个变量或者表达式的类型，如number，boolean，string，function（函数），object（NULL，数组，对象），undefined 一般的继承实现方式12345678910111213141516171819202122232425function Person(first, last, age, gender, interests) &#123; this.name = &#123; first, last &#125;; this.age = age; this.gender = gender; this.interests = interests; &#125; Person.prototype.greeting = function () &#123; alert('Hi! I\\'m ' + this.name.first + '.'); &#125;; function Teacher(first, last, age, gender, interests, subject) &#123; Person.call(this, first, last, age, gender, interests); this.subject = subject; &#125; Teacher.prototype = Object.create(Person.prototype); // 到这里的时候，Teacher.prototype.contructor === Person，所以下面这一步很有必要，否则就就破坏继承结构 Teacher.prototype.constructor = Teacher; 每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性，因为prototype本身就是定义在Function对象下的属性。当我们输入类似var person1=new Person(...)来构造对象时，JavaScript实际上参考的是Person.prototype指向的对象来生成person1。另一方面，Person()函数是Person.prototype的构造函数，也就是说Person===Person.prototype.constructor（不信的话可以试试）。 在定义新的构造函数Teacher时，我们通过function.call来调用父类的构造函数，但是这样无法自动指定Teacher.prototype的值，这样Teacher.prototype就只能包含在构造函数里构造的属性，而没有方法。因此我们利用Object.create()方法将Person.prototype作为Teacher.prototype的原型对象，并改变其构造器指向，使之与Teacher关联。 任何您想要被继承的方法都应该定义在构造函数的prototype对象里，并且永远使用父类的prototype来创造子类的prototype，这样才不会打乱类继承结构。 三种对象成员 那些定义在构造器函数中的、用于给予对象实例的。这些都很容易发现 - 在您自己的代码中，它们是构造函数中使用this.x = x类型的行；在内置的浏览器代码中，它们是可用于对象实例的成员（通常通过使用new关键字调用构造函数来创建，例如var myInstance = new myConstructor()）。 那些直接在构造函数上定义、仅在构造函数上可用的。这些通常仅在内置的浏览器对象中可用，并通过被直接链接到构造函数而不是实例来识别。 例如Object.keys()。 那些在构造函数原型上定义、由所有实例和对象类继承的。这些包括在构造函数的原型属性上定义的任何成员，如myConstructor.prototype.x()。 PromisePromise用法 参考： （1）https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises （2）http://es6.ruanyifeng.com/#docs/promise Promise实现原理 参考：https://juejin.im/post/5b83cb5ae51d4538cc3ec354 Fetch API 参考：https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch fetch与jQuery.ajax() 不同（1）当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject （2）默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项） 进行fetch请求（1）fetch的返回值是一个包含响应结果的Promise（一个Response对象，并非JSON）；为了获取JSON内容，需要使用json()方法 （2）fetch的第一个参数是请求的url，第二个参数是init，它的内容可以如下 12345678910111213141516fetch(url, &#123; body: JSON.stringify(data), // must match 'Content-Type' header cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached credentials: 'same-origin', // include, same-origin, *omit headers: &#123; 'user-agent': 'Mozilla/4.0 MDN Example', 'content-type': 'application/json' &#125;, method: 'POST', // *GET, POST, PUT, DELETE, etc. mode: 'cors', // no-cors, cors, *same-origin redirect: 'follow', // manual, *follow, error referrer: 'no-referrer', // *client, no-referrer&#125;).then(response =&gt; response.json()).then(data =&gt; console.log(data)) // JSON from `response.json()` call.catch(error =&gt; console.error(error)) 通过body设置请求实体，如果要传输json实体，则要在headers里面设置&#39;content-type&#39;: &#39;application/json&#39;，而且请求方式要是method: &#39;POST&#39; fetch返回的Promise对象通过then(response =&gt; response.json())转成json之后，便于后续的处理 如果要上传文件，可以通过FormData()来实现 12345678910111213var formData = new FormData();var fileField = document.querySelector(\"input[type='file']\");formData.append('username', 'abc123');formData.append('avatar', fileField.files[0]);fetch('https://example.com/profile/avatar', &#123; method: 'PUT', body: formData&#125;).then(response =&gt; response.json()).catch(error =&gt; console.error('Error:', error)).then(response =&gt; console.log('Success:', response)); 这里的body不需要转成json；FormData对象实际上就是一个键值对列表 多文件上传可以使用&lt;input type=&quot;file&quot; mutiple/&gt;来配合FormData 12345678910111213var formData = new FormData();var photos = document.querySelector(\"input[type='file'][multiple]\");formData.append('title', 'My Vegas Vacation');formData.append('photos', photos.files);fetch('https://example.com/posts', &#123; method: 'POST', body: formData&#125;).then(response =&gt; response.json()).then(response =&gt; console.log('Success:', JSON.stringify(response))).catch(error =&gt; console.error('Error:', error)); 检测请求是否成功由于返回resolved的Promise不一定是请求成功的，因此首先要判断Response.ok，再决定接下来的处理 123456789101112fetch('flowers.jpg').then(function(response) &#123; if(response.ok) &#123; // 如果response.ok是false的，实际上是取不到response.blob()的 return response.blob(); &#125; throw new Error('Network response was not ok.');&#125;).then(function(myBlob) &#123; var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL; &#125;).catch(function(error) &#123; console.log('There has been a problem with your fetch operation: ', error.message);&#125;); 自定义请求对象fetch还可以直接将第一、第二个参数封装成Request对象后再传递进去 12345678910111213141516// 请求头对象var myHeaders = new Headers();var myInit = &#123; method: 'GET', headers: myHeaders, mode: 'cors', cache: 'default' &#125;;var myRequest = new Request('flowers.jpg', myInit);fetch(myRequest).then(function(response) &#123; return response.blob();&#125;).then(function(myBlob) &#123; var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL;&#125;); Request()和fetch()接受的参数是一样的；由于Request()和Resonse Body被设计成了流的形式，不能被两次请求和读取，但可以通过拷贝再次使用request和response 1var anotherRequest = new Request(myRequest,myInit); 最佳实践是在使用响应的Promise之前检查 content type 是否正确 12345678910fetch(myRequest).then(function(response) &#123; // 判断响应头的contentType是不是json，是的话再将其转为json进行后续处理 if(response.headers.get(\"content-type\") === \"application/json\") &#123; return response.json().then(function(json) &#123; // process your JSON further &#125;); &#125; else &#123; console.log(\"Oops, we haven't got JSON!\"); &#125;&#125;); Response对象Response是fetch()处理完Promise后返回的，常见的属性有： Response.status — 整数(默认值为200) 为response的状态码 Response.statusText — 字符串(默认值为”OK”),该值与HTTP状态码消息对应 Response.ok — 该属性是来检查response的状态是否在200-299(包括200,299)这个范围内.该属性返回一个布尔值 Body实体请求和响应都可以包含Body，常见的类型有：ArrayBuffer、ArrayBufferView、Blob/File、String、URLSearchParams和FormData 可以通过Body类的arrayBuffer()、blob()、json()、text()和formData()方法来获取请求和响应的实体数据 当我们设置了Body实体但是没有在headers中设置contentType时，request和response会进行自动设置 Polyfill在不支持Fetch的浏览器中可以使用Fetch Polyfill 浏览器事件循环机制事件循环机制 参考：https://juejin.im/post/5afbc62151882542af04112d 事件循环可以简单描述为： （1）函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空; （2）在此期间WebAPIs完成这个事件，把回调函数放入CallbackQueue中等待; （3）当执行栈为空时，Event Loop把Callback Queue中的一个任务放入Stack中,回到第1步。 其中第（2）步是由浏览器的线程去完成，不关js引擎的事情 Event Loop是由javascript宿主环境（像浏览器）来实现的; WebAPIs是由C++实现的浏览器创建的线程，处理诸如DOM事件、http请求、定时器等异步事件; JavaScript 的并发模型基于”事件循环”; Callback Queue(Event Queue 或者 Message Queue) 任务队列,存放异步任务的回调函数 例子： 12345var start=new Date();setTimeout(function cb()&#123; console.log(\"时间间隔：\",new Date()-start+'ms');&#125;,500);while(new Date()-start&lt;1000)&#123;&#125;; 执行过程： main(Script) 函数入栈,start变量开始初始化 setTimeout入栈,出栈,丢给WebAPIs,开始定时500ms; while循环入栈,开始阻塞1000ms; 500ms过后,WebAPIs把cb()放入任务队列,此时while循环还在栈中,cb()等待; 又过了500ms,while循环执行完毕从栈中弹出,main()弹出,此时栈为空,Event Loop,cb()进入栈,log()进栈,输出’时间间隔：1003ms’,出栈,cb()出栈 宏任务和微任务（1）宏任务macro-task(Task)：一个event loop有一个或者多个task队列，task任务源有： setTimeout setInterval setImmediate I/O UI rendering （2）微任务micro-task(Job)：一个 event loop里只有一个microtask 队列，任务源有： process.nextTick promises Object.observe MutationObserver （3）例子： 12345678910111213Promise.resolve().then(function promise1 () &#123; console.log('promise1'); &#125;)setTimeout(function setTimeout1 ()&#123; console.log('setTimeout1') Promise.resolve().then(function promise2 () &#123; console.log('promise2'); &#125;)&#125;, 0)setTimeout(function setTimeout2 ()&#123; console.log('setTimeout2')&#125;, 0) 执行过程（脚本代码本身是一个task，会被列入task队列）： 循环1： 【task队列：script ；microtask队列：】 1、从task队列中取出script任务，推入栈中执行。 2、promise1列为microtask，setTimeout1列为task，setTimeout2列为task。 【task队列：setTimeout1 setTimeout2；microtask队列：promise1】 3、script任务执行完毕，执行microtask checkpoint，取出microtask队列的promise1执行。 循环2： 【task队列：setTimeout1 setTimeout2；microtask队列：】 4、从task队列中取出setTimeout1，推入栈中执行，将promise2列为microtask。 【task队列：setTimeout2；microtask队列：promise2】 5、执行microtask checkpoint，取出microtask队列的promise2执行。 循环3： 【task队列：setTimeout2；microtask队列：】 6、从task队列中取出setTimeout2，推入栈中执行。 7.setTimeout2任务执行完毕，执行microtask checkpoint。 【task队列：；microtask队列：】 *8、Update the rendering（更新渲染） 最关键的不同：每次event loop循环执行栈完成后，会继续执行完相应的microtask任务，最后每轮事件执行的最后，浏览器会去决定是否更新视图渲染（Update the rendering，也就是说可能不是每轮事件循环都去更新视图，只在有必要的时候才更新视图） async/await 参考：https://www.jianshu.com/p/ffa5cbe9ab29 JavaScript闭包（Closure） 参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures （1）JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量 （2）在循环中创建闭包的常见错误： 12345678910111213141516171819202122232425&lt;p id=\"help\"&gt;Helpful notes will appear here&lt;/p&gt;&lt;p&gt;E-mail: &lt;input type=\"text\" id=\"email\" name=\"email\"&gt;&lt;/p&gt;&lt;p&gt;Name: &lt;input type=\"text\" id=\"name\" name=\"name\"&gt;&lt;/p&gt;&lt;p&gt;Age: &lt;input type=\"text\" id=\"age\" name=\"age\"&gt;&lt;/p&gt;function showHelp(help) &#123; document.getElementById('help').innerHTML = help;&#125;function setupHelp() &#123; var helpText = [ &#123;'id': 'email', 'help': 'Your e-mail address'&#125;, &#123;'id': 'name', 'help': 'Your full name'&#125;, &#123;'id': 'age', 'help': 'Your age (you must be over 16)'&#125; ]; for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = function() &#123; showHelp(item.help); &#125; &#125;&#125;setupHelp(); 无论焦点在哪个input上，显示的都是关于年龄的信息，原因是赋值给onfocus的闭包是由他们的函数定义以及setupHelp作用域捕获的环境组成的，三个闭包在循环中被创建，但他们共享了同一个词法作用域，在这个作用域中存在一个变量item。当onfocus的回调执行时，item.help的值被决定。由于循环在事件触发之前早已执行完毕，变量对象item（被三个闭包所共享）已经指向了helpText的最后一项； 简单来说就是，三个闭包是共享词法作用域，而不是各自拥有不同的词法作用域，在setupHelp执行完毕时，他们共享的item已经指向了helpText最后一项 （3）解决方法 使用更多的闭包 123456789101112131415161718...function makeHelpCallback(help) &#123; return function() &#123; showHelp(help); &#125;;&#125;function setupHelp() &#123; ... for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = makeHelpCallback(item.help); &#125;&#125;... 这样赋值给onfocus的三个闭包不再共享词法作用域，而是各自拥有makeHelpCallback(help)中的不同词法作用域 使用匿名闭包 123456789101112...for (var i = 0; i &lt; helpText.length; i++) &#123; (function() &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = function() &#123; showHelp(item.help); &#125; &#125;)(); // 马上把当前循环项的item与事件回调相关联起来 &#125;... 这样每次循环中赋值给onfocus的闭包拥有的此法环境就限制在了匿名函数内部 使用let而不是var关键字 12345678910...for (var i = 0; i &lt; helpText.length; i++) &#123; let item = helpText[i]; document.getElementById(item.id).onfocus = function() &#123; showHelp(item.help); &#125;&#125;... 关于let关键字，查看 1.5.12 节 （4）使用闭包的注意点 滥用闭包，会造成内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 会改变父函数内部变量的值：如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 this、 call、bind和apply 参考：https://juejin.im/post/59bfe84351882531b730bac2 关于thisthis 的指向并不是在创建的时候就可以确定的，在 es5 中，this永远指向最后调用它的那个对象（例子见参考链接） 改变this的指向 可以通过call、bind和apply改变this的指向 使用箭头函数 在函数内部使用_this = this临时保存定义函数的对象的this调用 箭头函数箭头函数的 this 始终指向函数定义时的 this，而非执行时。使用箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined” apply、call、bind 区别 apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数 1fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象 argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组 1fun.call(thisArg[, arg1[, arg2[, ...]]]) bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列；即bind 是创建一个新的函数，我们必须要手动去调用 123456789var a =&#123; name : \"Cherry\", fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)() 再补充一点1234567891011121314151617181920212223242526// 1var a = &#123; name:'steve', b : function()&#123; setTimeout(()=&gt;console.log(this.name),100) &#125;&#125;a.b() //steve// 2var a = &#123; name:'steve', b : function()&#123; setTimeout(function()&#123;console.log(this.name)&#125;,100) &#125;&#125;a.b() //windowsName// 3var a = &#123; name:'steve', b : function()&#123; console.log(this.name) &#125;&#125;a.b() //steve （1）中使用的是箭头函数，由于函数闭包的作用，箭头函数里面的this.name是定义时的a对象的name属性，因此是steve，即使这个箭头函数是延迟执行的 如果没有使用箭头函数，由于setTimeout里面回调函数延迟执行的缘故，this指向的实际上是window对象，因此打印了windowsName 如果没有延迟执行，那么this.name指向的是最后调用的对象，在（3）中是使用a.b()来调用的，因此最后调用的对象是a，所以结果是steve 函数调用函数调用在js中一共有四种，如下 作为一个函数调用12345678var name = \"windowsName\";function a() &#123; var name = \"Cherry\"; console.log(this.name); // windowsName console.log(\"inner:\" + this); // inner: Window&#125;a();console.log(\"outer:\" + this) // outer: Window 这样定义的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined 函数作为（对象的）方法调用 在js中，函数是一个对象，它的内部有自己的属性和方法 12345678var name = \"windowsName\";var a = &#123; name: \"Cherry\", fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn(); 在这里，fn最后调用的对象是a，所以this.name指向的是a的name属性 *note： 123456789101112131415var name = \"windowsName\";var a = &#123; name : \"Cherry\", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function 这个例子中，由于func2中调用了setTimeout方法，这个方法里面的回调函数不是立即执行的，因此当回调函数执行的时候，它的this指向已经不是对象a了，而是window对象，因此this.func1()函数不存在 （作为构造函数调用123456789// 构造函数:function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125;// This creates a new objectvar a = new myFunction(\"Li\",\"Cherry\");a.lastName; 作为构造函数调用后，创建了对象，自然里面的this也是指向创建的对象的 使用apply、call和bind调用这个就不多解释了 Currying柯里化 参考：https://juejin.im/post/5af13664f265da0ba266efcf （1）Currying的作用之一是 可以实现参数的复用，例如有一个多参数函数，当传递了第一个参数之后，得到一个柯里化后的函数用来接受剩下的参数，这样这个函数在调用时，第一个参数就已经是固定的，即被复用 （2）基于Currying原理的一个函数库lodash，参考：https://www.jianshu.com/p/d46abfa4ddc9 let、var和const 参考：https://www.jianshu.com/p/4e9cd99ecbf5 （1）ES6才添加的let和const （2）js中没有块级作用域，因此在JS函数中的var声明，其作用域是函数体的全部 1234for(var i=0;i&lt;10;i++)&#123; var a = 'a';&#125;console.log(a); （3）在循环中容易出现变量过度共享 12345for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 1000);&#125; 原因是setTimeout中的回调函数是延迟调用的，可以肯定的是必然晚于循环的执行完毕，而当循环调用完毕时，var i其实已经是3了，因此打印的是3 3 3而不是0 1 2 （4）将var换成let可以解决以上两个bug（note：必须声明 ‘use strict’ 后才能使用let声明变量，否则浏览器并不能显示结果） let声明的变量拥有块级作用域 let声明的全局变量不是全局对象的属性 形如for (let x…)的循环在每次迭代时都为x创建新的绑定。 如果一个for (let…)循环执行多次并且循环保持了一个闭包，那么每个闭包将捕捉一个循环变量的不同值作为副本，而不是所有闭包都捕捉循环变量的同一个值 用let重定义变量会抛出一个语法错误（SyntaxError） 12let a = 'a';let a = 'b'; // 报错 （5）let和var都支持解构赋值 （6）const 就是用来定义常量的：只声明不赋值、重复声明常量和修改常量的值都是不允许的 （7）如果在函数体内部声明变量时没有使用var、const或者let，那么声明的变量实际上是一个全局变量，函数体外部也能访问 CSSflex布局 参考：https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb 1.6.2 数据结构与算法数据结构队列（1）实现循环队列： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package tk.chph.demo.ds_alg;class MyCircularQueue &#123; private int[] data; private int front, end; /** * Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) &#123; this.data = new int[k + 1]; front = 0; end = 0; &#125; /** * Insert an element into the circular queue. Return true if the operation is successful. */ public boolean enQueue(int value) &#123; if (isFull()) return false; data[end++] = value; end = end % data.length; return true; &#125; /** * Delete an element from the circular queue. Return true if the operation is successful. */ public boolean deQueue() &#123; if (isEmpty()) return false; front = (++front) % data.length; return true; &#125; /** * Get the front item from the queue. */ public int Front() &#123; if (isEmpty()) return -1; return data[front]; &#125; /** * Get the last item from the queue. */ public int Rear() &#123; if (isEmpty()) return -1; return data[(end - 1+data.length)%data.length]; &#125; /** * Checks whether the circular queue is empty or not. */ public boolean isEmpty() &#123; return front == end; &#125; /** * Checks whether the circular queue is full or not. */ public boolean isFull() &#123; return (end - (front - data.length) +1) % (data.length) == 0; &#125;&#125; 这个实现方法：以长度为k的数组实现，data数组要长度为k+1，原因是要使得front==end能够作为isEmpty的条件，isFull判断条件是：(end - (front - data.length) +1) % (data.length) == 0，enQueue和deQueue时要注意end和front越界，同时由于end指向的元素是空的，因此Rear时要注意end-1可能会出现&lt;1的情况 （2）添加顺序和处理顺序相同时，可以考虑使用队列来解决 SSM+Redis框架Java动态代理技术和设计模式JDK动态代理（1）建立动态代理的步骤： 代理对象和真实对象建立代理关系 实现代理对象的逻辑方法 （2）在 JDK 动态代理中，要实现代理逻辑类必须去实现 java.lang.reflect.InvocationHandler接口，它里面定义了 一个 invoke 方法，并提供接口数组用于下挂代理对象 123456789101112131415161718192021222324252627282930313233343536373839interface HelloWorld &#123; public void sayHelloWorld();&#125;class HelloWorldImpl implements HelloWorld &#123; public void sayHelloWorld() &#123; System.out.println(\"Hello World!\"); &#125;&#125;class JdkProxyExample implements InvocationHandler &#123; // 真实对象 private Object target = null; // 建立代理对象和真是对象的关系，并返回代理对象 Object bind(Object target) &#123; this.target = target; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; // 代理方法的逻辑 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"进入代理逻辑方法\"); System.out.println(\"调度真实对象前的服务\"); Object obj = method.invoke(target, args); System.out.println(\"调度真实对象后的服务\"); return obj; &#125;&#125;public class ProxyTest &#123; public static void main(String[] args) &#123; JdkProxyExample jdk = new JdkProxyExample(); // 进行代理，并获得代理对象，这时候外部只能直接访问代理对象，不能直接访问真实对象 HelloWorld proxy = (HelloWorld) jdk.bind(new HelloWorldImpl()); proxy.sayHelloWorld(); &#125;&#125; 测试方法中返回的HelloWorld对象已经是一个代理对象，proxy.sayHelloWorld();的调用会进入invoke方法中 （3）JDK动态代理必须提供接口才能使用，比如例子中的HelloWorld接口；Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);中的target.getClass().getInterfaces()就是获取真是对象实现的接口，并将真实对象挂靠在接口下，HelloWorld proxy = (HelloWorld) jdk.bind(new HelloWorldImpl());也得通过接口来引用代理对象 CGLIB动态代理（1） CGLIB 动态代理的优势在于不需要提供接口，只要一个非抽象类就能实现动态代理 （2）代码示例 123456789101112131415161718192021222324252627282930313233343536import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodProxy;...// 真实对象class HelloWorldImpl implements HelloWorld &#123; public void sayHelloWorld() &#123; System.out.println(\"Hello World!\"); &#125;&#125;// 代理对象class Interceptor implements MethodInterceptor &#123; public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.err.println(\"调用真实对象前\"); Object result = methodProxy.invokeSuper(proxy, args); System.err.println(\"调用真实对象后\"); return result; &#125;&#125;// 通过Enhancer建立代理对象与真实对象之间的关系public class CglibProxyExample &#123; public Object getProxy(Class cls)&#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(cls); enhancer.setCallback(new Interceptor()); return enhancer.create(); &#125; public static void main(String[] args) &#123; CglibProxyExample cglibProxyExample = new CglibProxyExample(); HelloWorldImpl helloWorld = (HelloWorldImpl) cglibProxyExample.getProxy(HelloWorldImpl.class); helloWorld.sayHelloWorld(); &#125;&#125; 代理类要实现MethodInterceptor接口，并在invoke方法中实现代理逻辑方法 注意，通过反射调用真实对象的方法时是invokeSuper方法，如Object result = methodProxy.invokeSuper(proxy, args);，因为Enhancer建立代理对象与真实对象的关系时是将超类设为真实类，setCallback将代理类设为我们定义的Interceptor 拦截器（1）代码实例 设计者提供的 12345678910111213141516171819202122232425262728293031323334public class InterceptorJdkProxy implements InvocationHandler &#123; private Object target; private String interceptorClass; private InterceptorJdkProxy(Object target, String interceptorClass) &#123; this.target = target; this.interceptorClass = interceptorClass; &#125; public static Object bind(Object target, String interceptorClass) &#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InterceptorJdkProxy(target, interceptorClass)); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (interceptorClass == null) &#123; return method.invoke(target, args); &#125; Object result = null; Interceptor interceptor = (Interceptor) Class.forName(interceptorClass).newInstance(); // 调用前置方法 if (interceptor.before(proxy, target, method, args)) &#123; // 前置方法返回true，反射原对象方法 result = method.invoke(target, args); &#125; else &#123; // 否则执行around方法 interceptor.around(proxy, target, method, args); &#125; // 调用后置方法 interceptor.after(proxy, target, method, args); return result; &#125;&#125; 12345public interface Interceptor &#123; boolean before(Object proxy, Object target, Method method, Object[] args); void after(Object proxy, Object target, Method method, Object[] args); void around(Object proxy, Object target, Method method, Object[] args);&#125; 开发者提供的 1234567891011121314151617public class MyInterceptor implements Interceptor &#123; @Override public boolean before(Object proxy, Object target, Method method, Object[] args) &#123; System.out.println(\"反射方法前逻辑\"); return false; &#125; @Override public void after(Object proxy, Object target, Method method, Object[] args) &#123; System.out.println(\"反射方法后逻辑\"); &#125; @Override public void around(Object proxy, Object target, Method method, Object[] args) &#123; System.out.println(\"取代了被代理对象的方法\"); &#125;&#125; 123456public class InterceptorTest &#123; public static void main(String[] args) &#123; HelloWorld proxy = (HelloWorld) InterceptorJdkProxy.bind(new HelloWorldImpl(), \"tk.chph.demo.proxy.interceptor.MyInterceptor\"); proxy.sayHelloWorld(); &#125;&#125; 这里使用的是JDK动态代理，对开发者来说，只需要实现设计者提供的拦截器接口Interceptor，然后通过bind方法将拦截器（代理对象）和自己的业务对象（真实对象）建立代理关系就可以了；而设计动态代理的代码全部由设计者来实现，开发者无需关心 另外拦截器实例化是被延迟到了代理方法（invoke）调用的时候才进行的，在此之前，代理对象只是保存了拦截器的全限定名 责任链模式（1）说白了就是：当一个对象在一条链上被多个拦截器拦截处理（拦截器也可以选择不拦截处理它）时，我们把这样的设计模式称为责任链模式 （2）责任链模式和拦截器的一点不同在于，要注意责任链模式上每个拦截器的before、after方法的执行顺序；责任链模式实质上是对代理对象进行代理，这样层层叠加： proxy3代理proxy2，proxy2代理proxy1，proxy1代理真实对象 这样在调用的时候，对proxy3来说，proxy2是它的真实对象，因此执行顺序是：proxy3.before-&gt;proxy2-&gt;proxy3.after，而proxy2的真实对象是proxy1，因此执行顺序变成了：proxy3.before-&gt;proxy2.before-&gt;proxy1-&gt;proxy2.after-&gt;proxy3.after，以此类推 观察者模式（发布订阅模式）（1）观察者模式定义了 一种一对多的依赖关系，让多个观察者对象同时监视着被观察者的状态，当被观察者的状态发生变化时 ， 会通知所有观察者 ， 并让其自动更新自己 （2）代码实例 被观察者，要继承Observable类 123456789101112131415161718192021public class ProductList extends Observable &#123; private List&lt;String&gt; productList=null; private static ProductList instance; private ProductList()&#123;&#125; public static ProductList getInstance()&#123; if (instance==null)&#123; instance = new ProductList(); instance.productList = new ArrayList&lt;&gt;(); &#125; return instance; &#125; public void addProduct(String newProduct)&#123; productList.add(newProduct); System.out.println(\"产品列表新增了产品：\"+newProduct); // =====注意这里===== this.setChanged(); this.notifyObservers(newProduct); &#125;&#125; 这里要注意的是，被观察者状态改变后，要调用setChanged将changed变量设为true，否则后面的notifyObservers方法没有效果；同时，notifyObservers方法调用完成后，changed为会被重新设置为false，等待下一次状态更新 观察者，要实现Observer接口及其接口里的update方法，因为被观察者调用notifyObservers方法，实际上是调用所有观察者的update方法 123456789101112131415class JingDongObserver implements Observer &#123; @Override public void update(Observable o, Object product) &#123; String newProduct = (String) product; System.err.println(\"发送新产品【\"+newProduct+\"】到京东商城\"); &#125;&#125;class TaoBaoObserver implements Observer &#123; @Override public void update(Observable o, Object product) &#123; String newProduct = (String) product; System.err.println(\"发送新产品【\"+newProduct+\"】到淘宝商城\"); &#125;&#125; 测试类 12345678public class ObserveTest &#123; public static void main(String[] args) &#123; ProductList productList = ProductList.getInstance(); productList.addObserver(new TaoBaoObserver()); productList.addObserver(new JingDongObserver()); productList.addProduct(\"MacBook Pro\"); &#125;&#125; Builder模式（1）很多时候由于对象的创建比较复杂，这时候就可以使用Builder模式，通过提供配置类来帮助创建复杂对象 （2）Builder 模式是一种分步构建对象的模式 Mybatis框架Mybatis的核心组件（1）mybatis核心组件由四部分组成 SqlSessionFactoryBuilder（构造器）：通过配置或者代码来生成SqlSessionFacotry对象，采用分步构建的Builder模式 SqlSessionFactory（工厂接口）：依靠它来生成SqlSession，使用工厂模式 SqlSession（会话）： 一个既可以发送 SQL 执行返回结果，也可以获取 Mapper 的接口。在现有的技术中， 一般我们会让其在业务逻辑代码中“消失”，而使用的是MyBatis 提供的 SQLMapper 接口编程技术，它能提高代码的可读性和可维护性 SQL Mapper（映射器）：MyBatis 新设计存在的组件，它由一个 Java 接口和 XML文件（或注解）构成，需要给出对应的 SQL 和映射规则。它负责发送 SQL 去执行，并返回结果 *Note：无论是映射器还是 SqlSession 都可以发送 SQL 到数据库执行 （2）SqlSessionFactory （工厂接口） Mybatis提供构造器SqlSessionFactoryBuilder以及配置类org.apache.ibatis.session.Configuration来生产SqlSessionFactory对象 org.apache.ibatis.session.Configuration对象既可以通过读取XML文件来生成，也可以直接通过Java代码来定义，它是整个mybatis的上下文 SqlSessionFactory是一个接口，它的实现类有SqlSessionManager和DefaultSqlSessionFactory；一般而言都是使用DefaultSqlSessionFactory，而SqlSessionManager用在多线程里，它的实现依靠DefaultSqlSessionFactory SqlSessionFactory唯一的作用是生产Mybatis的核心接口对象SqlSession，因此它一般来说是单例模式 使用XML文件描述SqlSessionFactory的配置文件就是mybatis-config.xml，然后就可以创建SqlSessionFactory对象了 12InputStream inputStream = Resource.getResourceAsStream(\"mybatis-config.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 采用XML配置的形式好处是：信息在配置文件中，便于后期维护和修改；同时不需要重新编译代码 （3）SqlSession 有两个实现类：DefaultSqlSession（用于单线程）和SqlSessionManager（用于多线程） SqlSession类似一个JDBC中的一个Connection，管理者一个连接中的资源启用 获取Mapper接口 1RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class); 发送SQL给数据库 控制数据库事务（提交和回滚） 使用SqlsessionFactory创建SqlSession的方法 1SqlSession sqlSession = sqlSessionFactory.openSession(); SqlSession只是一个门面接口，底层真正在工作的是Executor （4）映射器 它由一个接口和对应的XML（或者注解）组成 映射器的主要作用就是将 SQL 查询到的结果映射为一个 POJO，或者将 POJO 的数据插入到数据库中 ， 并定义一些关于缓存等的重要内容 Mybatis使用动态代理技术，根据XML或者注解的描述为接口创建一个代理对象去处理相关的逻辑 同时使用注解和XML创建映射器时，XML的方式会覆盖注解的定义 （5）发送SQL语句到数据库 SqlSession方式 1Role role = (Role) sqlSession.selectOne(\"com.learn.ssm.chapter3.mapper.RoleMapper.getRole\", 11); Mapper接口方式 12RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);Role role = roleMapper.getRole(1L); （6）生命周期 SqlSessionFactoryBuilder：它的作用是创建SqlSessionFactory，创建完后就失去了作用，可以被JVM回收了 SqlSessionFactory：作用相当于一个数据库连接池，一旦创建了 SqlSessionFactory ， 就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期；同时一般要求SqlSessionFactory是一个单例，在应用中被共享 SqlSession：SqlSession 就相当于一个数据库连接（ Connection 对象），它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory ， 否则数据库资源就很快被耗费精光，系统就会瘫痪 Mapper：它由 SqlSession 所创建，所以它的最大生命周期至多和 SqlSession保持一致；但由于SqlSession关闭后，它的数据库连接资源也会消失，所以它的生命周期应该小于等于 SqlSession 的生命周期 ；Mapper 代表的是一个请求中业务处理的一个步骤，所以它应该在一个请求中，一旦处理完了相关的业务，就应该随着SqlSession的关闭而废弃它 MyBatis 的解析和运行原理Spring-Mybatis整合（1）配置数据源 简单数据源SimpleDriverDataSource，没有提供数据库连接池功能 数据库驱动driver 数据库连接url 用户名username 密码password 第三方数据库连接池数据源DBCP（dbcp.BasicDataSource），提供了数据库连接池功能 数据库驱动driver 数据库连接url 用户名username 密码password 数据库连接池配置：maxActive、maxIdle、maxWait等 从web服务器获取数据源JNDI（jndi.JndiObjectFactoryBean） web服务器配置的数据源名称 jndiName （2）配置SqlSessionFactoryBean 数据源datasource mybatis配置文件configLocation （3）配置MapperScannerConfigurer 扫描路径basePackages SqlSessionFactoryBeanName 映射器的注解annotationClass Spring框架Spring IoC（1）控制反转是一种通过描述（在 Java中可以是 XML 或者注解）并通过第三方去产生或获取特定对象的方式。在 Spring 中实现控制反转的是 IoC 容器，其实现方法是依赖注入 （Dependency Injection, DI ） （2）Spring IoC容器主要是基于BeanFactory 和 ApplicationContext 两个接口，其中ApplicationContext 是 BeanFactory 的子接口之一，在绝大部分的工作场景下 ， 都会使用 ApplicationContext 作为Spring IoC 容器 （3）Spring IoC的初始化包括Bean的初始化和依赖注入两个步骤 Bean初始化 Resource 定位，这步是 Spring IoC 容器根据开发者的配置，进行资源定位，在 Spring的开发中，通过 XML 或者注解都是十分常见的方式 BeanDefinition 的载入，这个过程就是 Spring 根据开发者的配置获取对应的 POJO,用以生成对应实例的过程 BeanDefinition 的注册 ，这个步骤就相当于把之前通过 BeanDefinition 载入的 POJO往 Spring IoC 容器中注册，这样就可以使得开发和测试人员都可以通过描述从中得到 SpringIoC 容器的 Bean 了 依赖注入：在完成依赖注入之前的Bean还不能够使用，对于依赖注入，spring中默认的lazy-init（是否初始化Bean）是false，即 Spring IoC 默认会自动初始化 Bean；如果将其设置为 true，那么只有当我们使用 Spring IoC 容器的 getBean 方法获取它时，它才会进行初始化， 完成依赖注入。 （4）Spring Bean的生命周期 （占个坑orz） Spring Bean的装配（1）依赖注入的三种方式 构造器注入 setter注入 接口注入？ （2）将Bean装配进Spring IoC的配置方式（以注解为主，XML为辅） 在XML中显式配置 在Java的接口和类中实现配置 隐式Bean的发现机制和自动装配原则 （3）三种装配Bean方式的优先级 基于约定优于配置的原则，优先选择隐式Bean的发现机制和自动装配原则 在没法使用自动配置原则情况下，优先使用在Java的接口和类中实现配置，这样可以避免XML配置泛滥；同时，当一个父类有多个子类时，如果想通过IoC容器初始化父类，容器将无法决定使用哪个子类去初始化，这时候可以通过Java注解的方式去指定一个子类 最后选用XML方式，因为有时候使用第三方库时，没法取修改这些类库代码，这时候就可以通过XML方式去配置，将第三方类库的Bean装配到Spring IoC容器中 （4）XML装配Bean 1234567&lt;beans&gt; &lt;bean id=\"role2\" class=\"com.ssm.chapter9.pojo.Role\" &gt; &lt;property name=\"id\" value=\"1\"/&gt; &lt;property name=\"roleName\" value=\"高级工程师\"/&gt; &lt;property name=\"note\" value=\"重要人员\"/&gt; &lt;/bean&gt;&lt;/beans&gt; id是spring找到这个Bean的编号，如果没有指定，则spring会自动生成“全限定名#{num}”格式的编号 class是这个Bean的类的全限定名 property是定义类的属性，name是属性名，value是属性值，另外属性的值如果是引用类型，可以通过ref=“{source.id}”来引用定义的其他bean 当property是集合时，可以通过如下方式来定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!-- 列表 --&gt;&lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;value-list-1&lt;/value&gt; &lt;value&gt;value-list-2&lt;/value&gt; &lt;value&gt;value-list-3&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- 映射 --&gt;&lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"key1\" value=\"value-key-1\"/&gt; &lt;entry key=\"key2\" value=\"value-key-2\"/&gt; &lt;entry key=\"key3\" value=\"value-key-3\"/&gt; &lt;/map&gt;&lt;/property&gt;&lt;!-- Property --&gt;&lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"prop1\"&gt;value-prop-1&lt;/prop&gt; &lt;prop key=\"prop2\"&gt;value-prop-2&lt;/prop&gt; &lt;prop key=\"prop3\"&gt;value-prop-3&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;!-- 集合 --&gt;&lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;value-set-1&lt;/value&gt; &lt;value&gt;value-set-2&lt;/value&gt; &lt;value&gt;value-set-3&lt;/value&gt; &lt;/set&gt;&lt;/property&gt;&lt;!-- 数组 --&gt;&lt;property name=\"array\"&gt; &lt;array&gt; &lt;value&gt;value-array-1&lt;/value&gt; &lt;value&gt;value-array-2&lt;/value&gt; &lt;value&gt;value-array-3&lt;/value&gt; &lt;/array&gt;&lt;/property&gt; 如果list、map、set和array这些集合的元素是一个类而不是基本数据类型，那么可以将&lt;value/&gt;替换为&lt;ref bean=”xxx”/&gt;（map中&lt;entry/&gt;的key替换为key-ref、value替换为value-ref）来引用别处定义好的bean，这样就完成了类集合的Bean定义 （5）Spring中，Spring IoC容器发现Bean的方式有两中： 组件扫描：通过定义资源的方式 ， 让 Spring IoC 容器扫描对应 的包 ，从而把 Bean装配进来 自动装配：通过注解定义，使得一些依赖关系可以通过注解完成 常见的注解如下： @Component 1234567891011@Component(value = \"role\")public class Role&#123; @Value(\"1\") private Long id; @Value(\"role_name_1\") private String roleName; @Value(\"role_note_1\") private String note; // setters and getters&#125; 其中@Component表示Spring IoC会将这个类扫描成Bean实例，value后面的值是Bean在Spring中的id编号；如果不知道value，Spring会自动生成编号 @Value代表的是值的注入 @ComponentScan 123@ComponentScanpublic class PojoConfig&#123;&#125; 只有@Component还不行，还得设置@ComponentScan告诉Spring要扫描的包路径，这里没有设置值，则默认是扫描PojoConfig所在包下的类，所以上面的Role要和PojoConfig放在一起才能被Spring扫描到 @ComponentScan有两个配置项：basePackages，接受一个Java包数组，Spring会根据配置来扫描对于的包和这些包下面的子包；basePackagesClasses，它接受一个类的数组，Spring会根据这些类所在的包，为包和子包进行扫描装配对应配置的Bean 要注意的是： 如果定义了多个@ComponentScan，每个@ComponentScan都会对扫描到的Bean生成一个实例，这就可能出现很多重复的实例 但是对于同一个@ComponentScan里面的basePackages和basePackagesClasses，两者如果有出现扫描重复的Bean，也只会生成一个Bean实例 123ApplicationContext context =new AnnotationConfigApplicationContext(PojoConfig.class);Role role= context.getBean(Role.class); 接下来只需要将配置类PojoConfig添加到context中，就能通过context来获取Spring IoC扫描到的Bean实例了 自动装配@Autowired Spring在生成所有Bean后，如果发现有这个注解，就会根据类型在Bean容器中查找对应的Bean，将其注入进来，这就是依赖注入 如果IoC容器寻找失败，默认情况下会抛出异常，如果有些字段的实例可有可无，可以设置@Autowired(require = false)，这样IoC在没有找到对应的Bean实例的时候就不会抛出异常了 根据类型注入的问题在于：当Java中的一个接口（或者抽象类）有多个实现类的时候，这样就会造成通过类型（ by type ）获取 Bean 的不唯一 ， 从而导致 Spring IoC 类似于按类型的方法无法获得唯一的实例化类，这就是自动装配的歧义性。解决歧义性的方法是@Primary和@Qualifier： ＠Primary 注解告诉 Spring IoC 容器，如果存在某个类型的多个子类型，无法判断注入哪个的时候，优先将注解有@Primary 的实例注入 @Qualifier 注解是告诉Spring IoC容器根据Bean的名称而不是类型来进行注入，由于Bean的id的唯一性，这样就消除了歧义性 注意，@Primary是注解到Bean上的，@Quality是注解到Bean的引用变量上的 123456789@Component(\"roleService3\")@Primarypublic class RoleServiceimpl implements RoleService&#123; ...&#125;@Autowired@Qualifier(\"roleService3\")private RoleService roleService = null ; @Qualifier和@Autowired这两个注解可以注解到参数变量上 @Component只能注解到类上，不能注解到方法上；可以通过注解@Bean注解到方法上（但不能注解到类上），将方法的返回值作为Spring的Bean存放到IoC容器中 @Bean有四个配置项 name ： 是一个字符串数组，允许配置多个 BeanName autowire：标志是否是一个引用的 Bean 对象，默认值是 Autowire.NO initMethod ： 自定义初始化方法 destroyMethod ： 自定义销毁方法。 ＠ImportResource 如果使用XML和注解混用的方式配置Bean的时候，可以在配置类上面使用＠ImportResource来引入XML定义的Bean，这样就能将XML定义的Bean扫描进IoC容器 123@ImportResource(&#123;\"classpath:spring-dataSource.xml\", \"...\", ...&#125;)//接受一个数组public class ApplicationConfig&#123;&#125; @Import 如果配置分散到多个配置类中，那么就可以在主配置类上使用@Import来引入其他的配置类 1234@ComponentScan@Import(&#123;ApplicationConfig2.class, ApplicationConfig3.class, ...&#125;)//接受一个数组public class ApplicationConfig &#123;&#125; （6）使用Profile @Profile注解主要是配置Spring Bean的作用环境的（dev环境、test环境还是prod环境等） @Profile注解在Bean上 1234567891011@Bean(name = \"devDataSource\")@Profile(\"dev\")public DataSource getDevDataSource()&#123; ...&#125;@Bean(name = \"testDataSource\")@Profile(\"test\")public DataSource getDevDataSource()&#123; ...&#125; 激活Profile 在使用 Spring MVC 的情况下可以配置Web上下文参数 ，或者 DispatchServlet 参数 作为 JNDI 条目 配置环境变量 配置 JVM 启动参数 在集成测试环境中使用＠ActiveProfiles （9）加载属性（properties）文件 使用注解@PropertySource来加载属性文件，它有四个配置项： name ： 字符串，配置这次属性配置的名称 value ： 字符串数组，可以配置多个属性文件 ignoreResourceNotFound : boolean 值，默认为false，其含义为如果找不到对应的属性文件是否进行忽略处理，由于默认值为 false，所以在默认的情况下找不到对应的配置文件会抛出异常 encoding：编码，默认为”” 12345@Configuration@PropertySource(value=&#123;\"classpath:database-config.properties\"&#125;,ignoreResourceNotFound=true)public class ApplicationConfig &#123;&#125; 使用配置文件的属性 加载属性文件后，就可以通过context.getEnvironment().getProperty(&quot;xxx&quot;)来获得属性文件中的属性值，xxx是属性名 1String url = context.getEnvironment().getProperty(\"jdbc.database.url\"); 属性文件解析类PropertySourcesPlaceholderConfigurer 123456789@Configuration@PropertySource(value=&#123;\"classpath:database-config.properties\"&#125;,ignoreResourceNotFound=true)public class ApplicationConfig&#123; @Bean public PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer()&#123; return new PropertySourcesPlaceholderConfigurer(); &#125;&#125; 这样就可以直接使用@Value来引用配置的属性和占位符了 12345678910@Componentpublic clss DataSourceBean&#123; @Value(\"$&#123;jdbc.datasource.driver&#125;\") private String driver = null; @Value(\"$&#123;jdbc.datasource.url&#125;\") private String driver = url; ...&#125; （10）条件化装配Bean @Conditional可以配置一个或者多个类，这些类都得实现接口Condition 12345@Bean(name = \"dataSource\")@Conditional(&#123;DataSourceCondition.class, ...&#125;)public DataSource getDataSource()&#123; ...&#125; 1234567public class DataSourceCondition implements Condition&#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)&#123; Environment env = context.getEnvironment(); return env.containsProperty(\"jdbc.database.driver\") &amp;&amp; ...; &#125;&#125; 可以通过context获得Spring的运行环境，当matches方法返回值为true时则装配Bean，返回false则不会创建对应Bean 这样的作用是，如果属性配置文件的属性没有配置完整的话，可能会导致对应的Bean初始化失败，配置了@Conditional之后，可以自定义在属性配置完整后才初始化Bean （11）Bean的作用域 默认情况下，Spring IoC容器会为配置的Bean生成一个实例，而不是多个 Spring 提供了 4 种作用域，它会根据情况来决定是否生成新的对象： 单例（ singleton ）：它是默认的选项，在整个应用中 ， Spring 只为其生成一个 Bean的实例 原型（ prototype ） ： 当每次注入，或者通过 Spring IoC 容器获取 Bean 时， Spring 都会为它创建一个新的实例 会话（ session ） ： 在 Web 应用中使用，就是在会话过程中 Spring 只创建一个实例 请求（ request ） ： 在 Web 应用中使用的，就是在一次请求中 Spring 会创建一个实例，但是不同的请求会创建不同的实例（和会话不同的是，一次会话中可能会有多次请求） 使用@Scope注解在Bean上面来配置Bean的作用域 1@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) Spring AOP（1）AOP的流程 （2）常见术语 切面（Aspect）：整个工作环境，想当一个拦截器 通知（Advice）：通知是切面开启后，切面的方法。它根据在代理对象真实方法调用前、后的顺序和逻辑区分 引入（Introduction）：引入允许我们在现有的类里添加自定义的类和方法 切点（Pointcut）：动态代理中，被切面拦截的方法就是一个切点 连接点（join point）：连接点是一个判断条件，由它可以指定哪些是切点。对于指定的切点， Spring 会生成代理对象去使用对应的切面对其拦截，否则就不会拦截它 织入（Weaving）：生成代理对象的过程，Spring中使用JDK动态代理技术来织入 （3） SpringAOP 是一种基于方法拦截的 AOP，换句话说 Spring 只能支持方法拦截的 AOP （4）Spring 中有 4 种方式去实现 AOP 的拦截功能： 使用 ProxyFactoryBean 和对应的接口实现 AOP 使用 XML 配置 AOP 使用＠AspectJ 注解驱动切面（最常用） 使用 AspectJ 注入切面 （5）使用＠AspectJ 注解驱动切面 创建切面 Spring中只需要使用@Aspect注解一个类，那么Spring IoC容器就会认为这是一个切面 添加通知（各个通知的调用顺序如下图） 连接点：连接点是添加在通知注解里的 1234@Before(\"execution(*com.ssm.chapter11.aop.service.impl.RoleService.printRole(...))\")public void before()&#123; ...&#125; @Before里面的正则表达式就是连接点 execution ： 代表执行方法的时候会触发 *： 代表任意返回类型的方法 com.ssm.chapter11.aop .service.impl.RoleServicelmpl：代表类的全限定名 printRole ： 被拦截方法名称 (…) ： 任意的参数 切点：如果每个通知里面都重复写一样的连接点会很麻烦，这时候可以使用切点@Pointcut来解决 1234567891011121314@Pointcut(\"execution(*com.ssm.chapter11.aop.service.impl.RoleService.printRole(...))\")public void print()&#123; // 可以是空的&#125;@Before(\"print()\")public void before()&#123; ...&#125;@After(\"print()\")public void after()&#123; ...&#125; 这样print()就变成了这个切面的切点了，在通知中只需要将切点方法作为连接点就行了，避免重复书写冗长的正则表达式 启用AspectJ自动代理 123456789@Configuration@EnableAspectJAutoProxy@ComponentScanpublic class AppConfig&#123; @Bean public RoleAspect getRoleAspect()&#123; return new RoleAspect(); &#125;&#125; @EnableAspectJAutoProxy代表着启用 AspectJ 框架的 自动代理，这个时候 Spring 才会生成动态代理对象，进而可以使用 AOP；然后将我们定义的RoleAspect这个切面通过@Bean初始化到IoC容器中，这样就可以拦截printRole方法了 环绕通知 123456@Around(\"print()\")public void around(ProceedingJoinPoint jp)&#123; ... // 语句1 jp.proceed(); ... // 语句2&#125; 环绕通知Spring会提供一个参数ProceedingJoinPoint用来反射调用被代理对象的原有方法，这样实际上环绕通知可以在jp.proceed()前后实现@Before和@After一样的功能了; 假如也实现了@Before和@After通知的话，Spring调用的顺序是： ​ 语句1-&gt;@Before-&gt;print()-&gt;语句2-&gt;@After-&gt;@AtfterReturning/@AfterThrowing 织入 织入是生成代理对象的过程，在上述的代码中，切点方法所在的类都是拥有接口的类，而事实上即使没有接口 ， Spring 也能提供 AOP 的功能 当类的实现存在接口的时候， Spring 将提供 JDK 动态代理，从而织入各个通知 当类不存在接口的时候没有办法使用 JDK 动态代理，Spring 会采用 CGLIB 来生成代理对象 给通知传递参数 使用args()函数来给各类通知传递切点方法的参数 1234@Before(\"execution(*com.ssm.chapter11.aop.service.impl.RoleService.printRole(...)) &amp;&amp; args(role, sort)\")public void before(Role role, int sort)&#123; ...&#125; 注意这里，传给通知的参数是和传递给通知方法printRole(role, sort)一样的，这样就能够在前置方法中对传递的参数进行检查，不合法的话可以拦截下来，从而不调用拦截方法 引入 可以通过定义一个接口，在生成动态代理对象时将被拦截对象挂靠在这个接口上，就可以为被拦截对象添加新的功能了 1234567891011121314interface RoleVerifier&#123; boolean verify(Role role);&#125;class RoleVerifierImpl implements RoleVerifier&#123; @Override public boolean verify(Role role)&#123; return role != null; &#125;&#125;// 然后在切面类中添加如下代码@DeclareParents(value = \"com.ssm.chapter11.aop.service.impl.RoleServiceImpl+\", defaultImpl = RoleVerifierImpl.class)public RoleVerifier roleVerifier; @DeclareParents配置项： value=”com.ssm.chapter11.aop.service.impl.RoleServiceImpl+”： 表示对 RoleServicelmpl类进行增强，也就是在 RoleServicelmpl 中引入一个新的接口 defaultlmpl：代表其默认的实现类，这里是 RoleVerifierlmpl 实现的原理其实是在生成代理对象时， 1return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this) obj.getClass().getInterfaces()是用来给被代理对象添加挂靠接口的，只要生成代理对象时将它挂靠在我们声明的RoleVerifier接口上面，这样我们就能够通过强制类型装换将被代理对象转化为RoleVerifier，进而调用我们引入的方法（CGLIB动态代理也一样，Enhancer也有个提供挂靠接口的方法） 123456RoleService roleService = ctx.getBean(RoleService.class );RoleVerifier roleVerifier = (RoleVerifier) roleService;// 调用引入的方法if(roleVerifier.verify(role))&#123; ...&#125; 一个方法有多个切面时，这些切面的调用顺序是根据切面在配置类中的配置顺序来调用的；也可以通过注解@Order来在切面声明时给这些切面设置优先级（优先级一样时，依旧是按照配置顺序来调用的）；这其实就是一种责任链模式 12345@Aspect@Order(1)public class Aspect1&#123; ...&#125; 当然也可以通过实现Ordered接口，在gerOrder()方法中返回优先级也可以实现和@Order注解一样的效果 1234567@Aspectpublic class Aspect1 implements Ordered&#123; @Override public int getOrder() &#123; return 1; &#125;&#125; Spring数据库事务管理（1） MyBatis 框架用得最多的事务管理器是 DataSourceTransactionManager，配置事务管理器要提供数据源 123&lt;bean id＝\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; （2）数据库资源的产生和释放如果没有委托给数据库管理器，那么就由 jdbcTemplate 管理 ，但是此时已经委托给了事务管理器，所以jdbcTemplate 的数据库资源和事务己经由事务管理器处理了 （3）在配置类中使用注解＠EnableTransactionManagement后 ， 在 Spring 上下文中使用事务注解＠Transactional, Spring 就会知道使用这个数据库事务管理器管理事务了 （4）用 Java 配置的方式来实现 Spring 数据库事务，需要在配置类中实现接口TransactionManagementConfigurer 的 annotationDrivenTransactionManager 方法 。 Spring 会把annotationDrivenTransactionManager 方法返回的事务管理器作为程序中的事务管理器 123456789// 实现接口方法 ， 使得返回数据库事务管理器@Override@Bean(name=\"transactionManager\")public PlatformTransactionManager annotationDrivenTransactionManager()&#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); // initDataSource()是配置类中配置的数据源Bean transactionManager.setDataSource(initDataSource()); return transactionManager;&#125; （5）声明式事务（一种约定式事务） 如果使用的是声明式事务，那么当你的业务方法不发生异常（或者发生异常 ， 但该异常也被配置信息允许提交事务）时， Spring 就会让事务管理器提交事务 发生异常（并且该异常不被你的配置信息所允许提交事务）时，则让事务管理器回滚事务。 （6）＠Transactional （7）数据库事务 ACID特性 原子性：一个事务中的操作要么全部成功，要么全部失败，不可能停滞在中间的某个状态 一致性：事务可以修改数据库封装的状态，但是无论并发的事务有多少，数据库封装的状态都是一致的 隔离性：不同事务之间的隔离程度 持久性：事务一旦执行成功，那么该事务对数据库所做的修改就是永久保存的，不会被回滚 丢失更新 第一类丢失更新：一个事务提交、一个事务回滚导致的提交事务的更新丢失（当前主流数据库已经克服了此类更新） 第二类丢失更新：由于无法探知其他事务中的操作，导致两个或多个事务都提交后的更新丢失（即一个事务将之前事务的更新给覆盖掉） 隔离级别 脏读：允许一个事务去读取其他事务中已经修改但尚未提交的数据（如果被脏读的事务回滚了，这属于第一类更新丢失的情况，但是主流数据库已经克服了此类更新丢失，这样回滚的事务不会覆盖成功提交的事务，出现的问题就是相当于回滚的事务不起作用，成功提交的事务使用了脏读的数据进行数据库更新导致数据库最终的状态是保存了错误的数据） 读/写提交：一个事务只能读或者写另一个事务已经提交的数据（这样在一个事务成功提交、一个事务回滚的情况下，成功提交的事务没有脏读，回滚的事务由于第一类更新丢失被数据库的设计克服了，不会覆盖成功提交的事务；但是会出现的一个情况是，如果另一个事务B没有回滚，而是在另一个事务成功提交前也成功提交了，会导致最后提交的事务A出现不可重复读的现象，即 A在B提交前和B提交后读取的数据不一致） 可重复读：可重复读是针对同一条记录而言的，即不同事务对同一条记录的读/写按照一个序列化进行操作，不会产生交叉现象，保证了同一条数据的一致性（这个级别的隔离会导致幻读现象，幻读是针对多条记录而言的，即事务A在查询数据库多条记录，同时事务B往数据库添加或者删除了一条记录并成功提交后，事务A在提交时会幻读多出/少掉一条） 序列化：让SQL按照序列化的顺序进行读写操作，即所有事务对数据库的读写操作都是按照顺序执行的，不会产生交叉，这样就可以克服幻读现象了 （8）隔离级别和传播行为的选择 选择隔离级别的出发点在于两点 ： 性能和数据一致性，从脏读到序列化，系统性能直线下降，例如序列化，直接就抑制了并发，导致大量的请求被挂起 @Transactional通过Isolation设置隔离级别，通过propagation设置传播行为 ＠Transactional 隔离级别的默认值为 Isolation .DEFAULT，其含义是默认的，随数据库默认值的变化而变化 传播行为是指方法之间的调用事务策略的问题，一个方法调度另外一个方法时，可以对事务的特性进行传播配置；即当一个事务中是由多个数据库操作完成的（不同的方法），而这些操作之间是相互独立的，那么其中一个操作失败时，没必要回滚整个事务，而只需要将失败的那个操作回滚就可以了，因为这个回滚操作对其他的独立的操作不会造成数据不一致性的影响 （9）@Transactional 的自调用失效问题 注解＠Transaction 的底层实现是 SpringAOP 技术，而 SpringAOP 技术使用 的是动态代理 。 这就意味着对于静态（ static ）方法和非 public 方法 ， 注解＠Transactional 是失效的 由于＠Transactional 的实现原理是AOP ，而 AOP 的实现原理是动态代理 ，如果是自己调用自己的过程，并不存在代理对象的调用，这样就不会产生 AOP 去为我们设置＠Transactional配置的参数，这样就出现了自调用注解失效的 问题；解决的方法时，不直接进行自调用，而是通过从容器中获取代理对象来间接进行自调用，这样就能够启用AOP技术了 12// 从容器中获取 RoleService 对象 ，实际是一个代理对象RoleService service = ctx.getBean(RoleService.class); （10）使用@Transactional时的一些注意点 如果前后调用带有@Transactional的方法，那么这两次调用不在同一个事务中 不要长时间占用事务，比如在事务中长时间处理和数据库事务无关的东西，这样会严重浪费数据库资源 在@Transactional方法中捕获到异常时一定要再将其抛出，让Spring的事务管理器去处理；否则如果没有抛出，事务管理器就会任务代码运行正常，不会对出错的事务进行回滚 SpringMVC框架SpringMVC的组件和流程 （1）Servlet在初始化时，SpringMVC会根据配置获取配置信息，从而得到统一资源标识符URI和处理器Handler之间的映射关系（HandlerMapping）；同时为了更加灵活和增强功能，SpringMVC还给处理器加入了拦截器Interceptor，可以在处理器执行前后加入自己的功能，这样就构成了一个处理器执行链（HandlerExecutionChain）（拦截器+处理器） （2）当一个请求过来时，DispatchServlet首先通过请求和实现解析好的HandlerMapping，找到对应的处理器Handler，然后就准备开始执行拦截器和处理器 （3）由于运行处理器需要有一个对应的环境，它可以通过请求类型找到处理器适配器HandlerAdapter来运行对应的处理器及其拦截器，然后处理器将模型和视图ModalAndView返回给DispatchServlet （4）如果是逻辑视图，那么DispatchServlet就会将它传递给视图解析器ViewResolver解析它，将模型渲染到视图中去；如果不是逻辑视图，则不会进行处理，直接通过视图渲染数据模型 （5）最后将渲染好的视图返回给客户端 SpringMVC的初始化（1）初始化 Spring IoC 容器上下文 12345678910111213public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123; public void contextInitialized(ServletContextEvent event) &#123; // 初始化Spring IoC容器，使用的是满足ApplicationContext接口的Spring Web IoC容器 this.initWebApplicationContext(event.getServletContext()); &#125; public void contextDestroyed(ServletContextEvent event) &#123; // 关闭Web IoC容器 this.closeWebApplicationContext(event.getServletContext()); // 清除相关参数 ContextCleanupListener.cleanupAttributes(event.getServletContext()); &#125;&#125; DispatcherServlet 初始化前完成 Spring IoC 容器的初始化 在结束期完成对Spring IoC 容器的销毁 （2）初始化映射请求上下文 （略orz，SSM框架书籍P379页） （3）使用注解配置方式初始化 继承一个名字比较长的类 AbstractAnnotationConfigDispatcherServletlnitializer，然后实现它所定义的方法 12345678910111213141516171819202122public class MyWebAppinitializer extends AbstractAnnotationConfigDispatcherServletinitializer &#123; // Spring IoC 容器配置 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; // 可以返回 Spring 的 Java 配置文件数组 return new Class&lt;?&gt; [] &#123;&#125; ; &#125; //DispatcherServlet 的 URI 映射关系配置 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; // 可以返回 Spring 的 Java 配置文件数组 return new Class&lt;?&gt;[] &#123; WebConfig.class &#125;; &#125; // DispatcherServlet 拦截内容 @Override protected String[] getServletMappings () &#123; return new String[]&#123;\"*.do\"&#125;； &#125;&#125; 只要实现了 WebApplicationlnitializer 接口的 onStartup 方法，Spring MVC 就会把类当作一个初始化器加载进来；上面代码继承的是AbstractAnnotationConfigDispatcherServletlnitializer，它们的关系如下： 这就是只要继承 AbstractAnnotationConfigDispatcherServletlnitializer 类就完成了DispatcherServlet 映射关系和 Spring IoC 容器的初始化工作的原因。 MyWebApplnitializer 配置类 getRootConfigClasses 获取 Spring IoC 容器的 Java 配置类，用以装载各类 Spring Bean getRootConfigClasses 方法返回为空，就不加载自定义的 Bean 到 Spring IoC 容器中 getServletConfigClasses 获取各类 Spring MVC 的 URI 和控制器的配置关系类，用以生成 Web 请求的上下文 getServletConfigClasses 加载了 WebConfig，则它就是一个 URI和控制器的映射关系类 getServletMappings 定义 DispatcherServlet 拦截的请求 WebConfig配置类 123456789101112131415161718@Configuration//定义扫描的包，加载控制器@ComponentScan (\"com.*\")//启用 Spring Web MVC@EnableWebMvcpublic class WebConfig &#123; /*** * 创建视图解析器 * @return 视图解析器 */ @Bean(name=\"\"viewResolver\") public ViewResolver initViewResolver () &#123; InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); viewResolver.setPrefix(\"/WEB-INF/jsp/\") ; viewResolver.setSuffix (\".jsp\") ; return viewResolver ; &#125;&#125; 和 Spring IoC 使用 Java 的配置也是一样的， 只是多 了一个注解＠EnableWebMvc,它代表启动 Spring MVC 框架的配置 SpringMVC开发流程（1）@RequestMapping ＠RequestMapping 可以配置在类或者方法之上，它的作用是指定 URI 和哪个类（或者方法）作为一个处理请求的处理器； Spring MVC 还定义了处理器的拦截器 ， 当启动 Spring MVC 的 时候 ， Spring MVC 就会去解析＠Controller 中的@RequestMapping 的配置 ， 再结合所配置的拦截器，这样它就会组成多个拦截器和一个控制器的形式 ， 存放到一个 HandlerMapping 中去 如果没有配置@RequestMapping中的method属性，那么它会响应所有类型请求 （2）控制器开发 获取请求参数 @RequestParam 获取请求参数，默认情况下不为空，设置required为false实可以为空；为空时，可以通过设置defaultValue来设置默认值 Spring MVC 还提供了注解＠SessionAtrribute 去从 Session 中获取对应的数据 处理业务逻辑 绑定模型和视图 Spring MVC 会默认使用 JstlView 进行渲染，也就是它将查询出来的模型绑定到 JSTL （JSP 标准标签库）模型中 使用JSON视图MappingJackson2JsonView（非逻辑视图，井不需要视图解析器进行解析）可以将模型转化成JSON字符串返回到前端，一般用于Ajax请求 123ModelAndView mv = new ModelAndView();mv.setObject(\"role\", role);mv.setView(new MappingJackson2JsonView()); 这样SpringMVC就会将对象role转成json字符串；但是也可以使用@ResponseBody使得返回结果变成JSON 深入SpringMVC组件开发（1）控制器接收各类请求参数 接受普通参数 如果请求的参数名和控制器的参数名一致，则无需任何注解都能够正确接收；这种方式允许参数为空（基本数据类型除外，因为基本数据类型没有null这种值） 在没有任何注解的情况下，SpringMVC有映射POJO的能力，直接将请求参数与POJO内部的属性对应来生成POJO参数实例 使用＠RequestParam 注解获取参数 如果参数被＠RequestParam 注解，那么默认的情况下该参数不能为空，如果为空则系统会抛出异常。如果希望允许它为空，那么要修改它的配置项 required 为 false ＠RequestParam(“xxx”)中的xxx与请求的参数名对应 使用 ＠RequestMapping 和 ＠PathVariable 两个注解共同协作传递URL参数 ＠PathVariable允许对应的参数为空 传递JSON参数 控制器使用@RequestBody接收JSON参数，而且一个控制器只能有一个@RequestBody，如果有多个会报错，大概是第二个之后的@RequestBody要解析时，输入流已经关闭 @RequestBody也具备映射POJO的能力 客户端请求时要将json转为字符串传递JSON.stringify(data)，同时要蛇者ContentType为”application/json” 如果是手写json来请求的话，不能使用单引号，而是要使用双引号，否则SpringMVC会解析失败 接收列表数据和表单序列化 Spring MVC 将传递过来的 JSON 数组数据（基本类型或者POJO都可以，只要请求的数据格式和控制器的参数一致即可） ， 转换为对应的 Java 集合类型。 把 List 转化为数组（ Long[] ）也是可行的 将 form 数据序列化，传递给后台，则数据将以 roleName=xxx &amp;&amp; note=xxx 传递 1$(\"form\").serialize() 这样控制器只需要像接收普通参数一样接收即可（@RequestParam或者不用任何注解，具有解析POJO能力） （2）重定向 给数据模型Model附上对应的数据（作为重定向的控制器的参数），然后返回带有redirect的字符串来实现重定向功能 123456public String addRole(Model model, ...)&#123; ... model.addAttribute(\"roleName\", roleName); ... return \"redirect:./showRoleJsonInfo.do\";&#125; SpringMVC有个约定：当返回的字符串带有 redirect 的时候，它就会认为需要的是一个重定向，重定向redirect后面的内容是要重定向的url 通过返回视图来实现重定向 123456public ModelAndView addRole2(ModelAndView mv, ...)&#123; ... mv.addObject(\"roleName\", roleName); mv.setViewName(\"redirect:./showRoleJsonInfo.do\"); return mv;&#125; HTTP的重定向以字符串来传递参数，因此不能有效传递对象，这个时候 SpringMVC提供了 一个方法——flash 属性，需要提供的数据模型就是一个 RedirectAttribute 12345public String addRole3(RedirectAttributes ra, ...)&#123; ... ra.addFlashAttribute(\"role\", role); return \"redirect:./showRoleJsonInfo.do\";&#125; 这样就能给重定向的地址传递POJO对象参数了 使用addFlashAttribute 方法后， Spring MVC 会将数据保存到 Session 中 （Session 在一个会话期有效），重定向后就会将其清除，这样就能够传递数据给下一个地址了 （3）拦截器 拦截器可以在请求进入控制器前、后以及视图渲染完成后进行相关的操作 Spring 要求 处 理器 的 拦截器 都 要实 现 接 口 org.springframework. web.servlet.HandlerInterceptor，也可以继承HandlerInterceptorAdapter（实现了HandlerInterceptor接口） preHandle：在处理器之前执行的前置方法，这样 SpringMVC 可以在进入处理器前处理一些方法了。注意，它将返回一个 boolean 值，会影响到后面 Spring MVC的流程 postHandle：在处理器之后执行的后置方法，处理器的逻辑完成后运行它 afterCompletion：无论是否产生异常都会在渲染视图后执行的方法 springboot中使用拦截器，只需要在配置类（继承了WebMvcConfigurer且注解了@Configuration类）中重写addInterceptors方法即可，使用InterceptorRegistry来添加拦截器及拦截规则 1234567891011121314151617@Configurationpublic class InterceptorConfiguration implements WebMvcConfigurer &#123; public final static String SESSION_KEY = \"user\"; @Autowired AudienceInteceptor audienceInteceptor; @Autowired AdminInterceptor adminInterceptor; @Autowired ManagerInterceptor managerInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(audienceInteceptor).addPathPatterns(\"/user/**\"); registry.addInterceptor(adminInterceptor).addPathPatterns(\"/admin/**\"); registry.addInterceptor(managerInterceptor).addPathPatterns(\"/manager/**\"); &#125;&#125; 多个拦截器的执行顺序和责任链模式的执行顺序一致 当其中的一个 preHandle 方法返回为 false 后，按配置顺序，后面的 preHandle方法都不会运行了，而控制器和所有的后置方法 postHandle 也不会再运行。执行过 preHandle方法且该方法返回为 true 的拦截器的完成方法 （afterCompletion）会按照配置的逆序运行 附：随手记Java1.1、Java接口多继承 第一次注意到这个玩意是springMVC框架源码里面出现的接口多继承： 123456789101112131415/** * A &#123;@link GenericConverter&#125; that may conditionally execute based on attributes * of the &#123;@code source&#125; and &#123;@code target&#125; &#123;@link TypeDescriptor&#125;. * * &lt;p&gt;See &#123;@link ConditionalConverter&#125; for details. * * @author Keith Donald * @author Phillip Webb * @since 3.0 * @see GenericConverter * @see ConditionalConverter */public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter &#123;&#125; 搜了一下，摘录如下： 先从Java 8之前说起。要区分“声明多继承”与“实现多继承”。Java是不允许“实现多继承”，简称不允许“多继承”。但是Java支持“声明多继承”——Java的接口的多继承——一个类可以实现多个接口（“继承”了多个接口上的方法声明），而一个接口可以继承多个接口（同样是“继承”了多个接口上的方法声明）。接口只允许有方法声明而不允许有实现，因而不会出现像C++那样的实现多继承的决议问题；抽象类可以有方法实现，但要遵循Java类的单继承限制，也避免了实现多继承的问题。这是早期Java为了与C++区分开的一个决定。 然后，从Java 8开始，接口允许为方法提供“默认实现”了——默认方法（default method）。因而实质上Java 8的接口多继承其实也会涉及到实现多继承，并且语言层面有专门规定去解决实现多继承时选择哪个版本的问题——哪个都不选择，而是在发现会继承多个默认方法实现并且没有override时报错，逼使用户显式override可能冲突的方法。这使得Java 8开始接口可以当作traits来使用，达到实现多继承的目的。 作者：RednaxelaFX 链接：https://www.zhihu.com/question/24317891/answer/65097560 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1.2、Java中的byte，short，char进行计算时都会提升为int类型。（来源：https://www.nowcoder.com/test/question/done?tid=23696962&amp;qid=25211#summary） 1.3、依赖倒置原则 参考：https://zhuanlan.zhihu.com/p/24175489 1.4、Spring循环依赖问题 参考：https://zhuanlan.zhihu.com/p/34923466 jQuery2.1 GET与POST的区别 GET 基本上用于从服务器获得（取回）数据。注释：GET 方法可能返回缓存数据。 POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。 2.2 同源策略 参见：https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy 2.3 jsonp 参考：https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html 2.4 jQuery.validate插件 12345if ( typeof define === \"function\" &amp;&amp; define.amd ) &#123; define( [\"jquery\"], factory );&#125; else &#123; factory( jQuery );&#125; 代码解释：https://stackoverflow.com/questions/30953589/what-is-typeof-define-function-defineamd-used-for 2.5 require.js模块开发 参见：https://javascript.ruanyifeng.com/tool/requirejs.html 2.6 jQuery 库中的 $() 是什么？ $() 函数是 jQuery() 函数的别称。$() 函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你可以将一个选择器字符串传入 $() 函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象 2.7 $(document).ready()方法和window.onload有什么区别？ window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。 $(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。 2.8 jquery中$.get()提交和$.post()提交有区别吗？ 相同点：都是异步请求的方式来获取服务端的数据； 异同点： 请求方式不同：$.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。 参数传递方式不同：get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。 数据传输大小不同：get方式传输的数据大小不能超过2KB 而POST要大的多 安全问题： GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。 2.9 简单的$.ajax()的请求方式（$.ajax()接受的参数是键值对列表） 1234567891011$.ajax(&#123; url:'http://www.baidu.com', type:'POST', data:data, cache:true, headers:&#123;&#125;, beforeSend：function()&#123;&#125;, success:function()&#123;&#125;, error:function()&#123;&#125;, complete:function()&#123;&#125;&#125;); JavaScript面试题（1）参考自：https://www.cnblogs.com/wdlhao/p/8290436.html#_label1 （2）比较typeof与instanceof？ 相同点：JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。 typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。 细节： (1)、typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。 (2)、typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错。 (3)、对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。 Instanceof定义和用法：instanceof 用于判断一个变量是否属于某个对象的实例。 （3）细节： ​ 如下，得到的结果为‘N’,这里的 instanceof 测试的 object 是指 js 语法中的 object，不是指 dom 模型对象。 1if (window instanceof Object)&#123; alert('Y')&#125; else &#123; alert('N');&#125; // 'N' （4）跨域访问 什么是跨域：由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域 存在跨域的情况： 网络协议不同，如http协议访问https协议。 端口不同，如80端口访问8080端口。 域名不同，如qianduanblog.com访问baidu.com。 子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。 域名和域名对应ip,如www.a.com访问20.205.28.90. Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）；客户端请求js文件获取到本地之后会立即执行 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了 Mysql（1）限制查询范围时，offset要和limit配合使用，单独使用offset会报错 （2）mysql中不等号使用&lt;&gt;, !=均可；但如果是在mybatis中书写mysql查询语句时，由于&lt;&gt;得进行转义，使用不方便，因此推荐使用!=；mysql中的等号是=而不是== （3）mysql中的比较符号可以直接用在时间类型的字段比较中；current_timestamp()函数可以返回当前的时间戳 （4）mysql更新语句的update是和set一起配合使用的 1UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause] （5）删除记录的语法是delete from 1DELETE FROM table_name [WHERE Clause] （6）插入记录的语法是insert into 123INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); （7）MySQL LIKE 子句 LIKE 通常与 % 一同使用，类似于一个元字符的搜索，%字符表示匹配任意字符 like语句用在where条件中，用于进行模糊匹配 123SELECT field1, field2,...fieldN FROM table_nameWHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos; （8）MySQL UNION 操作符 MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中；多个 SELECT 语句会删除重复的数据 语法格式 1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; distinct：删除结果集中重复的数据【这是默认值】 all：返回所有结果集，包含重复数据 另外，union的结果集必须含有相同的列数，属性不同可以，但是会以第一个结果集的列属性为准；如果列属性不一样，那么distinct就会起作用了，它会根据数据的值来判断是否一致而不是属性类型来判断 123456789101112131415161718192021222324mysql&gt; select * from demo;+----+------+------+| id | name | note |+----+------+------+| 1 | test | test |+----+------+------+1 row in set (0.00 sec)mysql&gt; select id, name from demo union select id, note from demo;+----+------+| id | name |+----+------+| 1 | test |+----+------+1 row in set (0.00 sec)mysql&gt; select id, name from demo union all select id, note from demo;+----+------+| id | name |+----+------+| 1 | test || 1 | test |+----+------+2 rows in set (0.00 sec) 可以看到，union的两个结果集的列不一致，但是合并之后，以第一个结果集的属性最终结果集的属性（id name），然后使用union distinct时，它判断的是数据的值，发现name=’test’和note=’test’值相同，因此只有最终结果集中只有一条记录返回 （9）排序 12SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]] 通过order by设置排序的字段，可以有多个；默认按照升序排序ASC，也可以设置DESC设置降序排列 （10）分组 在MYSQL中使用GROUP BY对表中的数据进行分组时： GROUP BY X意思是将所有具有相同X字段值的记录放到一个分组里， GROUP BY X, Y意思是将所有具有相同X字段值和Y字段值的记录放到一个分组里。 分组之后需要对分组进行操作，这时候需要用到 COUNT, SUM, AVG,等函数 1234SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; function指的就是COUNT, SUM, AVG,等函数，函数里面的列是select后面的列中的一个或者多个，也可以是全部列(*) GROUP BY column_name后面在使用rollup关键字可以在分组统计数据的基础上在进行相同的统计（SUM,AVG,COUNT…） 12345678910mysql&gt; SELECT name, SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP;+--------+--------------+| name | singin_count |+--------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || NULL | 16 |+--------+--------------+4 rows in set (0.00 sec) 这个就是在计算了每个分组的sum之后，对所有的分组进行sum，即将所有分组看成一个大的分组进行sum （11）JOIN INNER JOIN（或者JOIN）：获取两个表中字段匹配关系的记录 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录（（没有记录的字段为NULL）） RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录（没有记录的字段为NULL） 示例代码 1select a.runoob_id, a.runoob_author, a.runoob_title, b.runoob_count from runoob_tbl a right join tcount_tbl b on a.runoob_author = b.runoob_author; 使用... left join/join/right ... on [条件] 的语法 （12）NULL值比较 IS NULL: 当列的值是 NULL,此运算符返回 true。 IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。 &lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。 &lt;=&gt;可以代替=运算符，好处是当其中一个值为null时返回false，都为null时返回true，即使得null可以进行比较 NULL 值与任何其它值的比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false ，同时NULL != NULL也返回false （13）正则表达式 ​ 在Mysql中可以使用REGEXP操作符来进行正则表达式匹配，可以起到和LIKE操作符模糊匹配一样的功能 12mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &apos;^st&apos;;mysql&gt; select * from runoob_tbl where runoob_author regexp &apos;^[^a-zA-Z]+$&apos;; （14）alter命令 ALTER TABLE testalter_tbl DROP i;用于删除表的i字段；如果标准只有一个字段，drop命令会失败 ALTER TABLE testalter_tbl ADD i INT;用于添加表字段；新添加的字段i会追加在原有表字段的末尾 如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后） 1234ALTER TABLE testalter_tbl DROP i;ALTER TABLE testalter_tbl ADD i INT FIRST;ALTER TABLE testalter_tbl DROP i;ALTER TABLE testalter_tbl ADD i INT AFTER c; ALTER TABLE testalter_tbl MODIFY c CHAR(10);用于修改现有表字段的描述，新的描述直接覆盖原有字段的描述； modify不能修改字段名，而change可以修改字段名 1ALTER TABLE testalter_tbl CHANGE i j BIGINT; 这个表示将原字段i修改名称为j，并且描述是BIGINT 也可以直接修改表的类型，ALTER TABLE testalter_tbl ENGINE = MYISAM;这个是修改数据表的存储引擎，可以通过SHOW TABLE STATUS LIKE &#39;testalter_tbl&#39;\\G来查看表的类型 123456789101112131415161718192021mysql&gt; show table status like &apos;runoob_tbl&apos;\\G*************************** 1. row *************************** Name: runoob_tbl Engine: MyISAM Version: 10 Row_format: Dynamic Rows: 5 Avg_row_length: 3276 Data_length: 16384Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: 6 Create_time: 2019-05-24 16:04:59 Update_time: 2019-05-24 15:10:46 Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment: 1 row in set (0.00 sec) 可以使用rename to来修改数据表的名称 1ALTER TABLE testalter_tbl RENAME TO alter_tbl; HTML+CSS（1）盒子模型 在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。 （2）src与href的区别 href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。 src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕（如果是js文件的话，会将js文件里面的代码执行完再接着往下处理），图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 （3）同步和异步的区别 同步是阻塞模式，异步是非阻塞模式 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 （4）px和em的区别 相同点：px和em都是长度单位； 异同点：px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。 px、em、rem区别介绍，参考：http://www.runoob.com/w3cnote/px-em-rem-different.html （5）sessionStorage 、localStorage 和 cookie 之间的区别 Web Storage 包含如下两种机制： sessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。 localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。 共同点：用于浏览器端存储的缓存数据 不同点： 存储内容是否发送到服务器端 当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费； web storage,会将数据保存到本地，不会造成宽带浪费； 数据存储大小不同 Cookie数据不能超过4K,适用于会话标识； web storage数据存储可以达到5M; 数据存储的有效期限不同 cookie只在设置了Cookid过期时间之前一直有效，即使关闭窗口或者浏览器； sessionStorage,仅在关闭浏览器之前有效； localStorage,数据存储永久有效； 作用域不同 cookie和localStorage是在同源同窗口中都是共享的； sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面； （6）请指出document load和document ready的区别？ 共同点：这两种事件都代表的是页面文档加载时触发。 异同点： ready 事件的触发，表示文档结构已经加载完成（不包含图片等非文字媒体文件）。 onload 事件的触发，表示页面包含图片等文件在内的所有元素都加载完成。 HTTP面试题 参考：https://juejin.im/post/5a8102e0f265da4e710f5910 web前端面试题前端攻击方式/前端安全XSS攻击：跨站脚本攻击 CSRF攻击：跨站请求伪造攻击 网站性能优化/js性能优化https://juejin.im/post/59672fbff265da6c3f70cd53 跨浏览器兼容react性能优化（1）重写shouldComponentUpdate来避免不必要的dom操作。 （2）使用 production 版本的react.js。 （3）使用key来帮助React识别列表中所有子组件的最小变化。 virtualDOM、合成事件系统 事件冒泡机制get和post有什么区别？其实，GET和POST本质上两者没有任何区别。他们都是HTTP协议中的请求方法。底层实现都是基于TCP/IP协议。所谓区别，只是浏览器厂家根据约定，做得限制而已。 get是通过明文发送数据请求，而post是通过密文； get传输的数据量有限，因为url的长度有限，post则不受限； GET请求的参数只能是ASCII码，所以中文需要URL编码，而POST请求传参没有这个限制 GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 document.onload和document.ready两个事件的区别页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页面包含图片等文件在内的所有元素都加载完成。 计算机网络部分DNS解析过程 1） 浏览器缓存 当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）； 2） 系统缓存 当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP； 3） 路由器缓存 当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存； 4） ISP（互联网服务提供商）DNS缓存 当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找； 5） 根域名服务器 当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器； 6） 顶级域名服务器 顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器； 7） 主域名服务器 主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录； 8）保存结果至缓存 本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。 算法与数据结构","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://QQ876684433.github.io/tags/javascript/"},{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://QQ876684433.github.io/tags/JavaWeb/"},{"name":"Spring","slug":"Spring","permalink":"http://QQ876684433.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://QQ876684433.github.io/tags/SpringMVC/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://QQ876684433.github.io/tags/Mybatis/"},{"name":"HTML","slug":"HTML","permalink":"http://QQ876684433.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://QQ876684433.github.io/tags/CSS/"},{"name":"jQuery","slug":"jQuery","permalink":"http://QQ876684433.github.io/tags/jQuery/"},{"name":"面试","slug":"面试","permalink":"http://QQ876684433.github.io/tags/面试/"}]},{"title":"64.最小路径和","slug":"64-最小路径和","date":"2019-07-14T15:23:52.000Z","updated":"2019-09-15T04:40:38.600Z","comments":true,"path":"2019/07/14/64-最小路径和/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/64-最小路径和/","excerpt":"","text":"64. 最小路径和原题目如下： 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入:[[1,3,1],[1,5,1],[4,2,1]] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路这道题比较简单，也是填表的问题，递推公式如下：$$dp[i][j] = dp[i][j]+min{dp[i+1][j]+dp[i][j+1]}$$意思是：从点(i, j)到终点有两个选择，从下边(i+1, j)或者右边(i, j+1)走，所以最短路径是下边或者右边走的最小值加上当前点的值，因此可以从右下角开始填表，注意处理好边界条件： 12345678910111213141516/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var minPathSum = function(grid) &#123; for(let i = grid.length-1;i&gt;=0;i--)&#123; for(let j = grid[0].length-1;j&gt;=0;j--)&#123; if(i==grid.length-1 &amp;&amp; j==grid[0].length-1) continue; let right = Infinity, bottom = Infinity; if(i!=grid.length-1) bottom = grid[i+1][j]; if(j!=grid[0].length-1) right = grid[i][j+1]; grid[i][j] = grid[i][j]+Math.min(bottom, right); &#125; &#125; return grid[0][0];&#125;; 复杂度分析 时间复杂度 ：O(m*n)。遍历整个矩阵恰好一次。 空间复杂度 ：O(1)O(1)。不需要额外空间。 题解官方给的题解其实思路都差不多，只是具体实现有区别 比如递归暴力解法，也是上面的思路，只是空间和时间开销巨大，我刚开始想的时候就直接拒绝了这种不优雅的做法； 二维数组动态规划和我的解法的唯一区别是它另外开辟了新的数组，这在一定情况下是必要的，当要求不能修改原数组时，就只能这么做； 针对二维数组动态规划的优化算法就是官解给出的一维动态规划，从我自己的解法中已经可以看出，我是从最下面一层开始往上面填表的，填完之后，下面的行就不再需要用了，所以可以复用一下： 12345678910111213var minPathSum = function(grid)&#123; const res = grid[grid.length-1]; for(let i = grid.length-1;i&gt;=0;i--)&#123; for(let j = grid[0].length-1;j&gt;=0;j--)&#123; if(i==grid.length-1 &amp;&amp; j==grid[0].length-1) continue; let right = Infinity, bottom = Infinity; if(i!=grid.length-1) bottom = res[j]; if(j!=grid[0].length-1) right = res[j+1]; res[j] = grid[i][j]+Math.min(bottom, right); &#125; &#125; return res[0];&#125;; ####","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"877.石子游戏","slug":"877-石子游戏","date":"2019-07-14T15:22:39.000Z","updated":"2019-09-15T04:40:38.600Z","comments":true,"path":"2019/07/14/877-石子游戏/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/877-石子游戏/","excerpt":"","text":"877. 石子游戏原题目如下： 亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。 示例： 输入：[5,3,4,5] 输出：true 解释： 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 提示： 2 &lt;= piles.length &lt;= 500piles.length 是偶数。1 &lt;= piles[i] &lt;= 500sum(piles) 是奇数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/stone-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 一个TLE的解法举个栗子，假设初始堆是：[1，2，3，4，5]，那么第一回合（即两个各拿一堆）后，会出现三种状态： 亚4,李1，剩下[2，3] ps：这里其实会出现“亚1,李4，剩下[2，3]”的情况，但是想想就知道，这两种情况的子问题都是[2，3]，如果“亚4,李1”不能保证亚赢的话，那“亚1,李4”就更不可能了，所以这种情况可以排除了 亚4,李3，剩下[1，2] 亚1,李2，剩下[3，4] 然后接下来就是递归求解了，最后当剩下两堆时，可以保证亚取得最优解，直接返回两人的分差（亚-李）；然后递归计算完上面三个子问题之后，取最优的一种情况返回，最优的情况指的是两人得分差别最大的那种取法 代码不仅冗长，甚至还超时了orz： 123456789101112131415161718192021222324252627282930313233343536373839/** * @param &#123;number[]&#125; piles * @return &#123;boolean&#125; */const sub = (left, right, piles)=&gt;&#123; const l = piles[left], r = piles[right]; if(right-left == 1)&#123; if(l&gt;r) return [l, r]; else return [r, l]; &#125;else&#123; const subRes1 = sub(left+1,right-1,piles); if (l&gt;r)&#123; subRes1[0] += l; subRes1[1] += r; &#125;else&#123; subRes1[0] += r; subRes1[1] += l; &#125; const subRes2 = sub(left+2, right, piles); subRes2[0] += l; subRes2[1] += piles[left+1]; const subRes3 = sub(left, right-2, piles); subRes3[0] += r; subRes3[1] += piles[right-1]; let res = subRes1; if (subRes2[0]-subRes2[1]&gt;res[0]-res[1]) res = subRes2; if (subRes3[0]- subRes3[1]&gt;res[0]-res[1]) res = subRes3; return res; &#125;&#125;;var stoneGame = function(piles) &#123; const res = sub(0, piles.length-1, piles); return res[0]&gt;res[1];&#125;; 题解让我们来见证一下真正的动态规划长啥样 参考：https://leetcode-cn.com/problems/stone-game/solution/dong-tai-gui-hua-by-cliant/ 首先将问题转换为先手所能拿到的石子总数减去对手能拿到的石子总数是否为正数，用f(i,j)来表示第i堆到第j堆的石子，先手比对手多拿的石子总数，那么有如下的递推关系式：$$\\begin{equation} \\left{ \\begin{array}{} f(i,j)=max(piles[i]-f(i+1,j),;piles[j]-f(i,j-1)),&amp;i\\ne j \\ f(i,j)=f(i),&amp;i==j\\end{array} \\right.\\end{equation}$$所以问题的解决过程就变成了已知对角线值的二维数组的填表，二维数组用dp[i][j]表示，dp[0][n-1]即为问题的解，n是石子的堆数 （1）初始条件，只有对角线的值已知，且是各堆石子的个数 （2）数组值的生成关系如图，红色星号是问题的解： （3）最终的计算顺序如红色箭头所示： 这样是为了保证不会产生重复计算问题，也便于编码 （4）代码如下： 12345678910111213var stoneGame = function(piles) &#123; const dp = []; for(let i = piles.length-1;i&gt;=0;i--)&#123; dp[i] = []; dp[i][i] = piles[i]; // 填表 for(let j = i+1;j&lt;piles.length;j++)&#123; dp[i][j] = Math.max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1]) &#125; &#125; return dp[0][piles.length-1]&gt;0;&#125;; （5）这里其实可以优化一下，因为这个二维数组其实只有一半有数，而且随着填表的进行，之前的值不会再被使用到了： 123456789101112var stoneGame = function(piles) &#123; const dp = []; for(let i = piles.length-1;i&gt;=0;i--)&#123; dp[i] = piles[i]; // 填表 for(let j = i+1;j&lt;piles.length;j++)&#123; dp[j] = Math.max(piles[i]-dp[j], piles[j]-dp[j-1]) &#125; &#125; return dp[piles.length-1]&gt;0;&#125;; 主要的思想是，第i-1行的值可以覆盖到第i行上去，因为一旦第i-1行计算出来，第i行就不再需要了，计算i-2行只用到了第i-1行和第i-2行；所以填表的那个循环，只是单纯将dp数组与i有关的索引去掉 12原来的：dp[i][j] = Math.max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1])优化后：dp [j] = Math.max(piles[i]-dp [j], piles[j]-dp [j-1]) 歪门邪道这道题可以钻空子，直接return true就可以AC了，不要问我为什么。。。 其实这是数学规律来的，leetcode官方已经给出了解释，但我还是根据自己的理解说一下： 首先只有两堆（假设是x1，y1）的时候，一定可以保证先手胜（假设x1&gt;y1，那么先手可选x1） 然后当有四堆（假设是y2，x1，y1，x2）的时候，那么先手一定可以保证取到y1+y2或者x1+x2（因为取y2时，可以保证y1可以取到，x同理），所以先手只需取总和最大的一组即可 那么显然，先手可以保证取到奇数位置的堆或者偶数位置的堆，先手从总和大的堆下手即可保证稳赢，所以结果是true","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"338.比特位计数","slug":"338-比特位计数","date":"2019-07-14T15:20:49.000Z","updated":"2019-09-15T04:40:38.600Z","comments":true,"path":"2019/07/14/338-比特位计数/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/338-比特位计数/","excerpt":"","text":"338. 比特位计数原题目如下： 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 输入: 2 输出: [0,1,1] 示例 2: 输入: 5 输出: [0,1,1,2,1,2] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/counting-bits著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路其实这道题还算简单，看到题目的第一个想法就是首先列举一下，找找规律： 1234567891011121314二进制 十进制 1的个数0000 0 00001 1 10010 2 10011 3 20100 4 10101 5 20110 6 20111 7 31000 8 1... 我给上面的结果分了个组，其实很容易看出来，每组的1的个数就是该组前面所有数的1的个数加一，所以答案已经很明显了： 12345678910111213141516/** * @param &#123;number&#125; num * @return &#123;number[]&#125; */var countBits = function(num) &#123; let res = [0]; for(let i =0;i&lt;num;i++)&#123; let j = 0; const len = res.length; for(;j&lt;len;j++)&#123; if(res.length==num+1) return res; res.push(res[j]+1); &#125; &#125; return res;&#125;; 这是我的第一个版本的代码，一次过： 执行结果： 通过 显示详情 执行用时 :116 ms, 在所有 JavaScript 提交中击败了100.00%的用户 内存消耗 :39.9 MB, 在所有 JavaScript 提交中击败了30.30%的用户 其他解法然后我看了一下其他的答案，感觉还是有些地方可以学习的 1234567891011121314151617// 奇数一定比上一个偶数多个 1，多的就是最低位的 1 // 偶数中 1 的个数一定和除以 2 之后的那个数一样多。// 因为最低位是0，除以 2 就是右移一位，也就是把那个0抹掉而已，所以1的个数是不变的。var countBits = function (num) &#123; let result = [] result[0] = 0; for (let i = 1; i &lt;= num; i++) &#123; if (i % 2 === 1) &#123; result[i] = result[i - 1] + 1; &#125; else &#123; result[i] = result[i / 2]; &#125; &#125; return result;&#125; 上面这个解释的已经很清晰了，就不多说了，这位老哥还提供了另一个更优化的解法： 1234567891011// Time: O(n), Space: O(1)// i &amp; (i-1) 消除二进制最低位的 1 var countBits = function (num) &#123; let result = [] result[0] = 0 for (let i = 1; i &lt;= num; i++) &#123; result[i] = result[i &amp; (i - 1)] + 1; &#125; return result;&#125; 我发现有不少解法里有这个东西：i &amp; (i - 1)，他说的消除二进制最低位的1是什么意思？举两个例子： 当i是奇数（例如xxx111），i &amp; (i - 1)很显然就是类似xxx111 &amp; xxx110 = xxx110，把xxx111的最低位1消去，效果相当于-1，和上上一个解法的这个说法 奇数一定比上一个偶数多个 1 道理一样 当i是偶数（例如xxx110），i &amp; (i - 1)类似于xxx110 &amp; xxx101 = xxx100，也是把最低位的1消掉，xxx110中1的个数和xxx100中1的个数相差1，这个是和上上个解法 偶数中 1 的个数一定和除以 2 之后的那个数一样多 有点不一样","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"动态规划算法介绍","slug":"动态规划算法介绍","date":"2019-07-14T15:16:37.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/14/动态规划算法介绍/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/动态规划算法介绍/","excerpt":"","text":"动态规划算法介绍 参考：https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html 基本概念动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。 基本思想与策略基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 适用的情况能采用动态规划求解的问题的一般要具有3个性质： (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 (3)有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 求解的基本步骤动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 ​ 图1 动态规划决策过程示意图 (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。 (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。 (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。 实际应用中可以按以下几个简化的步骤进行设计： （1）分析最优解的性质，并刻画其结构特征。 （2）递归的定义最优解。 （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 （4）根据计算最优值时得到的信息，构造问题的最优解 算法实现的说明动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。 使用动态规划求解问题，最重要的就是确定动态规划三要素： （1）问题的阶段 （2）每个阶段的状态 （3）从前一个阶段转化到后一个阶段之间的递推关系。 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。 1f(n,m)=max&#123;f(n-1,m), f(n-1,m-w[n])+P(n,m)&#125; 动态规划算法基本框架12345678910111213141516171819for(j=1; j&lt;=m; j=j+1) // 第一个阶段 xn[j] = 初始值;for(i=n-1; i&gt;=1; i=i-1)// 其他n-1个阶段 for(j=1; j&gt;=f(i); j=j+1)//f(i)与i有关的表达式 xi[j]=j=max（或min）&#123;g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])&#125;;t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for(i=2; i&lt;=n-1; i=i+1）&#123; t = t-xi-1[ji]; for(j=1; j&gt;=f(i); j=j+1) if(t=xi[ji]) break;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"}]},{"title":"数据结构与算法笔记","slug":"数据结构与算法笔记","date":"2019-07-14T15:13:50.000Z","updated":"2019-09-15T04:40:38.608Z","comments":true,"path":"2019/07/14/数据结构与算法笔记/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/数据结构与算法笔记/","excerpt":"","text":"数据结构与算法动态规划动态规划算法介绍 参考：https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html 基本概念动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。 基本思想与策略基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 适用的情况能采用动态规划求解的问题的一般要具有3个性质： (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 (3)有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 求解的基本步骤动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 ​ 图1 动态规划决策过程示意图 (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。 (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。 (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。 实际应用中可以按以下几个简化的步骤进行设计： （1）分析最优解的性质，并刻画其结构特征。 （2）递归的定义最优解。 （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 （4）根据计算最优值时得到的信息，构造问题的最优解 算法实现的说明动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。 使用动态规划求解问题，最重要的就是确定动态规划三要素： （1）问题的阶段 （2）每个阶段的状态 （3）从前一个阶段转化到后一个阶段之间的递推关系。 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。 1f(n,m)=max&#123;f(n-1,m), f(n-1,m-w[n])+P(n,m)&#125; 动态规划算法基本框架12345678910111213141516171819for(j=1; j&lt;=m; j=j+1) // 第一个阶段 xn[j] = 初始值;for(i=n-1; i&gt;=1; i=i-1)// 其他n-1个阶段 for(j=1; j&gt;=f(i); j=j+1)//f(i)与i有关的表达式 xi[j]=j=max（或min）&#123;g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])&#125;;t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for(i=2; i&lt;=n-1; i=i+1）&#123; t = t-xi-1[ji]; for(j=1; j&gt;=f(i); j=j+1) if(t=xi[ji]) break;&#125; LeetCode刷题338. 比特位计数我的解法原题目如下： 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 输入: 2 输出: [0,1,1] 示例 2: 输入: 5 输出: [0,1,1,2,1,2] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/counting-bits著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 其实这道题还算简单，看到题目的第一个想法就是首先列举一下，找找规律： 1234567891011121314二进制 十进制 1的个数0000 0 00001 1 10010 2 10011 3 20100 4 10101 5 20110 6 20111 7 31000 8 1... 我给上面的结果分了个组，其实很容易看出来，每组的1的个数就是该组前面所有数的1的个数加一，所以答案已经很明显了： 12345678910111213141516/** * @param &#123;number&#125; num * @return &#123;number[]&#125; */var countBits = function(num) &#123; let res = [0]; for(let i =0;i&lt;num;i++)&#123; let j = 0; const len = res.length; for(;j&lt;len;j++)&#123; if(res.length==num+1) return res; res.push(res[j]+1); &#125; &#125; return res;&#125;; 这是我的第一个版本的代码，一次过： 执行结果： 通过 显示详情 执行用时 :116 ms, 在所有 JavaScript 提交中击败了100.00%的用户 内存消耗 :39.9 MB, 在所有 JavaScript 提交中击败了30.30%的用户 其他解法然后我看了一下其他的答案，感觉还是有些地方可以学习的 1234567891011121314151617// 奇数一定比上一个偶数多个 1，多的就是最低位的 1 // 偶数中 1 的个数一定和除以 2 之后的那个数一样多。// 因为最低位是0，除以 2 就是右移一位，也就是把那个0抹掉而已，所以1的个数是不变的。var countBits = function (num) &#123; let result = [] result[0] = 0; for (let i = 1; i &lt;= num; i++) &#123; if (i % 2 === 1) &#123; result[i] = result[i - 1] + 1; &#125; else &#123; result[i] = result[i / 2]; &#125; &#125; return result;&#125; 上面这个解释的已经很清晰了，就不多说了，这位老哥还提供了另一个更优化的解法： 1234567891011// Time: O(n), Space: O(1)// i &amp; (i-1) 消除二进制最低位的 1 var countBits = function (num) &#123; let result = [] result[0] = 0 for (let i = 1; i &lt;= num; i++) &#123; result[i] = result[i &amp; (i - 1)] + 1; &#125; return result;&#125; 我发现有不少解法里有这个东西：i &amp; (i - 1)，他说的消除二进制最低位的1是什么意思？举两个例子： 当i是奇数（例如xxx111），i &amp; (i - 1)很显然就是类似xxx111 &amp; xxx110 = xxx110，把xxx111的最低位1消去，效果相当于-1，和上上一个解法的这个说法 奇数一定比上一个偶数多个 1 道理一样 当i是偶数（例如xxx110），i &amp; (i - 1)类似于xxx110 &amp; xxx101 = xxx100，也是把最低位的1消掉，xxx110中1的个数和xxx100中1的个数相差1，这个是和上上个解法 偶数中 1 的个数一定和除以 2 之后的那个数一样多 有点不一样 877. 石子游戏原题目如下： 亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。 示例： 输入：[5,3,4,5] 输出：true 解释： 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 提示： 2 &lt;= piles.length &lt;= 500piles.length 是偶数。1 &lt;= piles[i] &lt;= 500sum(piles) 是奇数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/stone-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 一个TLE的解法举个栗子，假设初始堆是：[1，2，3，4，5]，那么第一回合（即两个各拿一堆）后，会出现三种状态： 亚4,李1，剩下[2，3] ps：这里其实会出现“亚1,李4，剩下[2，3]”的情况，但是想想就知道，这两种情况的子问题都是[2，3]，如果“亚4,李1”不能保证亚赢的话，那“亚1,李4”就更不可能了，所以这种情况可以排除了 亚4,李3，剩下[1，2] 亚1,李2，剩下[3，4] 然后接下来就是递归求解了，最后当剩下两堆时，可以保证亚取得最优解，直接返回两人的分差（亚-李）；然后递归计算完上面三个子问题之后，取最优的一种情况返回，最优的情况指的是两人得分差别最大的那种取法 代码不仅冗长，甚至还超时了orz： 123456789101112131415161718192021222324252627282930313233343536373839/** * @param &#123;number[]&#125; piles * @return &#123;boolean&#125; */const sub = (left, right, piles)=&gt;&#123; const l = piles[left], r = piles[right]; if(right-left == 1)&#123; if(l&gt;r) return [l, r]; else return [r, l]; &#125;else&#123; const subRes1 = sub(left+1,right-1,piles); if (l&gt;r)&#123; subRes1[0] += l; subRes1[1] += r; &#125;else&#123; subRes1[0] += r; subRes1[1] += l; &#125; const subRes2 = sub(left+2, right, piles); subRes2[0] += l; subRes2[1] += piles[left+1]; const subRes3 = sub(left, right-2, piles); subRes3[0] += r; subRes3[1] += piles[right-1]; let res = subRes1; if (subRes2[0]-subRes2[1]&gt;res[0]-res[1]) res = subRes2; if (subRes3[0]- subRes3[1]&gt;res[0]-res[1]) res = subRes3; return res; &#125;&#125;;var stoneGame = function(piles) &#123; const res = sub(0, piles.length-1, piles); return res[0]&gt;res[1];&#125;; 题解让我们来见证一下真正的动态规划长啥样 参考：https://leetcode-cn.com/problems/stone-game/solution/dong-tai-gui-hua-by-cliant/ 首先将问题转换为先手所能拿到的石子总数减去对手能拿到的石子总数是否为正数，用f(i,j)来表示第i堆到第j堆的石子，先手比对手多拿的石子总数，那么有如下的递推关系式：$$\\begin{equation} \\left{ \\begin{array}{} f(i,j)=max(piles[i]-f(i+1,j),;piles[j]-f(i,j-1)),&amp;i\\ne j \\ f(i,j)=f(i),&amp;i==j\\end{array} \\right.\\end{equation}$$所以问题的解决过程就变成了已知对角线值的二维数组的填表，二维数组用dp[i][j]表示，dp[0][n-1]即为问题的解，n是石子的堆数 （1）初始条件，只有对角线的值已知，且是各堆石子的个数 （2）数组值的生成关系如图，红色星号是问题的解： （3）最终的计算顺序如红色箭头所示： 这样是为了保证不会产生重复计算问题，也便于编码 （4）代码如下： 12345678910111213var stoneGame = function(piles) &#123; const dp = []; for(let i = piles.length-1;i&gt;=0;i--)&#123; dp[i] = []; dp[i][i] = piles[i]; // 填表 for(let j = i+1;j&lt;piles.length;j++)&#123; dp[i][j] = Math.max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1]) &#125; &#125; return dp[0][piles.length-1]&gt;0;&#125;; （5）这里其实可以优化一下，因为这个二维数组其实只有一半有数，而且随着填表的进行，之前的值不会再被使用到了： 123456789101112var stoneGame = function(piles) &#123; const dp = []; for(let i = piles.length-1;i&gt;=0;i--)&#123; dp[i] = piles[i]; // 填表 for(let j = i+1;j&lt;piles.length;j++)&#123; dp[j] = Math.max(piles[i]-dp[j], piles[j]-dp[j-1]) &#125; &#125; return dp[piles.length-1]&gt;0;&#125;; 主要的思想是，第i-1行的值可以覆盖到第i行上去，因为一旦第i-1行计算出来，第i行就不再需要了，计算i-2行只用到了第i-1行和第i-2行；所以填表的那个循环，只是单纯将dp数组与i有关的索引去掉 12原来的：dp[i][j] = Math.max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1])优化后：dp [j] = Math.max(piles[i]-dp [j], piles[j]-dp [j-1]) 歪门邪道这道题可以钻空子，直接return true就可以AC了，不要问我为什么。。。 其实这是数学规律来的，leetcode官方已经给出了解释，但我还是根据自己的理解说一下： 首先只有两堆（假设是x1，y1）的时候，一定可以保证先手胜（假设x1&gt;y1，那么先手可选x1） 然后当有四堆（假设是y2，x1，y1，x2）的时候，那么先手一定可以保证取到y1+y2或者x1+x2（因为取y2时，可以保证y1可以取到，x同理），所以先手只需取总和最大的一组即可 那么显然，先手可以保证取到奇数位置的堆或者偶数位置的堆，先手从总和大的堆下手即可保证稳赢，所以结果是true 64. 最小路径和原题目如下： 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入:[[1,3,1],[1,5,1],[4,2,1]] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 我的解法这道题比较简单，也是填表的问题，递推公式如下：$$dp[i][j] = dp[i][j]+min{dp[i+1][j]+dp[i][j+1]}$$意思是：从点(i, j)到终点有两个选择，从下边(i+1, j)或者右边(i, j+1)走，所以最短路径是下边或者右边走的最小值加上当前点的值，因此可以从右下角开始填表，注意处理好边界条件： 12345678910111213141516/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var minPathSum = function(grid) &#123; for(let i = grid.length-1;i&gt;=0;i--)&#123; for(let j = grid[0].length-1;j&gt;=0;j--)&#123; if(i==grid.length-1 &amp;&amp; j==grid[0].length-1) continue; let right = Infinity, bottom = Infinity; if(i!=grid.length-1) bottom = grid[i+1][j]; if(j!=grid[0].length-1) right = grid[i][j+1]; grid[i][j] = grid[i][j]+Math.min(bottom, right); &#125; &#125; return grid[0][0];&#125;; 复杂度分析 时间复杂度 ：O(m*n)。遍历整个矩阵恰好一次。 空间复杂度 ：O(1)O(1)。不需要额外空间。 题解官方给的题解其实思路都差不多，只是具体实现有区别 比如递归暴力解法，也是上面的思路，只是空间和时间开销巨大，我刚开始想的时候就直接拒绝了这种不优雅的做法； 二维数组动态规划和我的解法的唯一区别是它另外开辟了新的数组，这在一定情况下是必要的，当要求不能修改原数组时，就只能这么做； 针对二维数组动态规划的优化算法就是官解给出的一维动态规划，从我自己的解法中已经可以看出，我是从最下面一层开始往上面填表的，填完之后，下面的行就不再需要用了，所以可以复用一下： 12345678910111213var minPathSum = function(grid)&#123; const res = grid[grid.length-1]; for(let i = grid.length-1;i&gt;=0;i--)&#123; for(let j = grid[0].length-1;j&gt;=0;j--)&#123; if(i==grid.length-1 &amp;&amp; j==grid[0].length-1) continue; let right = Infinity, bottom = Infinity; if(i!=grid.length-1) bottom = res[j]; if(j!=grid[0].length-1) right = res[j+1]; res[j] = grid[i][j]+Math.min(bottom, right); &#125; &#125; return res[0];&#125;; 96. 不同的二叉搜索树我的解法贪婪算法分治算法随机化算法回溯算法","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/tags/算法/"}]},{"title":"在React项目中使用Docz遇到的问题","slug":"在React项目中使用Docz遇到的问题","date":"2019-07-14T14:53:48.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/14/在React项目中使用Docz遇到的问题/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/在React项目中使用Docz遇到的问题/","excerpt":"","text":"在React项目中使用Docz遇到的问题（1）按照官网的Getting Start添加依赖后执行yarnpkg add docz，出现的问题如下： 1234567891011121314Failed to compile../node_modules/docz/dist/index.esm.js 23:38Module parse failed: Unexpected token (23:38)Failed to compile../node_modules/docz/dist/index.esm.js 23:38Module parse failed: Unexpected token (23:38)You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders| import &#123; MDXProvider &#125; from '@mdx-js/react';| &gt; const BasePlayground = loadable(() =&gt; import('./Playground.esm.js'));| const Playground = props =&gt; typeof window !== 'undefined' ? createElement(Suspense, &#123;| fallback: null Github上面的相关issue是：https://github.com/pedronauck/docz/issues/596 最关键的是这一个： 他给出的解决方案是对webpack降级： 1npm i -D webpack@4.28.4 问题解决！ 然而，事情远远没有那么简单，当再次运行yarn start启动项目时，爆炸了： 显然是docz和creact-react-app的webpack版本冲突了，我又在github搜罗了一番，解决方案是给docz单独指定一个webpack版本： 启动成功，舒服了","categories":[{"name":"项目","slug":"项目","permalink":"http://QQ876684433.github.io/categories/项目/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://QQ876684433.github.io/tags/项目/"},{"name":"React","slug":"React","permalink":"http://QQ876684433.github.io/tags/React/"}]},{"title":"Github开源项目license选择问题","slug":"Github开源项目license选择问题","date":"2019-07-14T14:52:31.000Z","updated":"2019-09-15T04:40:38.600Z","comments":true,"path":"2019/07/14/Github开源项目license选择问题/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/Github开源项目license选择问题/","excerpt":"","text":"Github开源项目license选择问题简单一点，借用阮一峰博客上面的一张图：","categories":[{"name":"项目","slug":"项目","permalink":"http://QQ876684433.github.io/categories/项目/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://QQ876684433.github.io/tags/项目/"}]},{"title":"将React项目部署到GithubPages","slug":"将React项目部署到GithubPages","date":"2019-07-14T14:50:59.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/14/将React项目部署到GithubPages/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/将React项目部署到GithubPages/","excerpt":"","text":"将React项目部署到Github Pages 参考：https://segmentfault.com/a/1190000019290048 一些注意事项： （1）Github Pages自定义域名问题 往gh-pages分支添加CNAME记录 将要添加的域名写入CNAME，但是注意不要加入http:// 这里还有个问题就是，由于gh-pages分支是将编译之后的内容上传的，如果直接在gh-pages分支添加CNAME文件，会导致出现重新部署的时候CNAME被删除，这时后如果再次访问自定义域名，就会出现Content Security Policy问题（参见：https://stackoverflow.com/questions/54380373/content-security-policy-while-deploying-to-github-pages-using-gatsby） 1Refused to load the image 'http://www.alexingberg.com/favicon.ico' because it violates the following Content Security Policy directive: \"img-src data:\". 你可以按照stackoverflow上面的方案解决（我没试过），但我这里提供一个简单的解决方案，就是将CNAME添加在项目的public文件夹下面，编译之后CNAME就会在build目录生成，这样就不会出现Content Security Policy问题了 （2）自定义域名后出现资源路径不正确的问题 网上一些教程都是教你把Github Pages生成的那一串链接地址设置到&quot;homepages&quot;中 这样会出现的问题就是，编译完成后，会在静态资源的路径前面都加上/chph-blog，这样肯定是找不到对应的资源的 可以通过把&quot;homepages&quot;设置成&quot;./&quot;即可","categories":[{"name":"项目","slug":"项目","permalink":"http://QQ876684433.github.io/categories/项目/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://QQ876684433.github.io/tags/项目/"},{"name":"React","slug":"React","permalink":"http://QQ876684433.github.io/tags/React/"}]},{"title":"ES6、ES7、ES8、ES9、ES10新特性一览","slug":"ES6、ES7、ES8、ES9、ES10新特性一览","date":"2019-07-14T14:49:42.000Z","updated":"2019-09-15T04:40:38.600Z","comments":true,"path":"2019/07/14/ES6、ES7、ES8、ES9、ES10新特性一览/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/ES6、ES7、ES8、ES9、ES10新特性一览/","excerpt":"","text":"ES6、ES7、ES8、ES9、ES10新特性一览 参考：https://juejin.im/post/5ca2e1935188254416288eb2","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://QQ876684433.github.io/tags/javascript/"}]},{"title":"async/await的基础用法","slug":"async-await的基础用法","date":"2019-07-14T14:47:48.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/14/async-await的基础用法/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/async-await的基础用法/","excerpt":"","text":"async/await的基础用法 参考：https://www.jianshu.com/p/ffa5cbe9ab29 推荐阅读：https://segmentfault.com/a/1190000007535316 另外补充：进程、线程和协程的理解 参考https://blog.csdn.net/hairetz/article/details/16119911 进程、线程和协程 堆 栈 调度 进程 独立 独立 操作系统 线程 共享 独立 操作系统 协程 共享 独立 程序员在代码中显式调度 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。 进程和其他两个的区别还是很明显的。 协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。 async/await的特点 Promise主要用then函数的链式调用，一直点点点，是一种从左向右的横向写法。async/await从上到下，顺序执行，就像写同步代码一样。这更符合人编写代码的习惯 Promise的then函数只能传递一个参数，虽然可以通过包装成对象，但是这会导致传递冗余信息，频繁的解析又重新组合参数，比较麻烦。async/await没有这个限制，就当做普通的局部变量来处理好了，用let或者const定义的块级变量，想怎么用就怎么用，想定义几个就定义几个，完全没有限制，也没有冗余的工作。 Promise在使用的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰。async/await整个书写习惯都是同步的，不需要纠结同步和异步的区别。当然，异步过程需要包装成一个Promise对象，放在await关键字后面，这点还是要牢记的。 Promise是根据函数式编程的范式，对异步过程进行了一层封装。async/await是基于协程的机制，是真正的“保存上下文，控制权切换 … … 控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述。 async/await是基于Promise的，是进一步的一种优化。不过再写代码的时候，Promise本身的API出现得很少，很接近同步代码的写法。 await关键字使用的注意点 只能放在async函数内部使用，不能放在普通函数里面，否则会报错。 后面放Promise对象，在Pending状态时，相应的协程会交出控制权，进入等待状态。这个是本质。 await是async wait的意思，wait的是resolve(data)消息，并把数据data返回。比如，下面代码中，当Promise对象由Pending变为Resolved的时候，变量a就等于data；然后再顺序执行下面的语句console.log(a);这真的是等待，真的是顺序执行，表现和同步代码几乎一模一样。 12345const a = await new Promise((resolve, reject) =&gt; &#123; // async process ... return resolve(data);&#125;);console.log(a); await后面也可以跟同步代码，不过系统会自动转化成一个Promise对象。比如const a = await &#39;hello world&#39;;其实就相当于const a = await Promise.resolve(&#39;hello world&#39;);这跟同步代码const a = &#39;hello world&#39;;是一样的，还不如省点事，去掉这里的await关键字。 await只关心异步过程成功的消息resolve(data)，拿到相应的数据data。至于失败消息reject(error)，不关心，不处理。当然对于错误消息的处理，有以下几种方法供选择：（1）让await后面的Promise对象自己catch（2）也可以让外面的async函数返回的Promise对象统一catch（3）像同步代码一样，放在一个try...catch结构中 async关键字使用的注意点 有了这个async关键字，只是表明里面可能有异步过程，里面可以有await关键字。当然，全部是同步代码也没关系。当然，这时候这个async关键字就显得多余了。不是不能加，而是不应该加。 async函数，如果里面有异步过程，会等待；但是async函数本身会马上返回，不会阻塞当前线程。 可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染。async函数内部由async关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回。 async函数的返回值是一个Promise对象，这个是和普通函数本质不同的地方。这也是使用时重点注意的地方（1）return newPromise();这个符合async函数本意；（2）return data;这个是同步函数的写法，这里是要特别注意的。这个时候，其实就相当于Promise.resolve(data);还是一个Promise对象。在调用async函数的地方通过简单的=是拿不到这个data的。那么怎么样拿到这个data呢？很简单，返回值是一个Promise对象，用.then(data =&gt; { })函数就可以。（3）如果没有返回，相当于返回了Promise.resolve(undefined); await是不管异步过程的reject(error)消息的，async函数返回的这个Promise对象的catch函数就负责统一抓取内部所有异步过程的错误。async函数内部只要有一个异步过程发生错误，整个执行过程就中断，这个返回的Promise对象的catch就能抓到这个错误。 async函数执行和普通函数一样，函数名带个()就可以了，参数个数随意，没有限制；也需要有async关键字。只是返回值是一个Promise对象，可以用then函数得到返回值，用catch抓去整个流程中发生的错误。","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://QQ876684433.github.io/tags/javascript/"}]},{"title":"less的一个变量多次定义","slug":"less的一个变量多次定义","date":"2019-07-14T14:46:30.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/14/less的一个变量多次定义/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/less的一个变量多次定义/","excerpt":"","text":"一个变量多次定义首先一个变量不需要在使用之前就定义，而且也可以在不同地方重复定义同一个变量，下面两个编译的结果一样： 123456.lazy-eval&#123; width: @var;&#125;@var:@a;@a:9%; 123456789.lazy-eval&#123; width: @var; @a:9%;&#125;@var:@a;@a:100%;// 定义在块级作用域里的@a(9%)覆盖了全局作用域里的@a(100%) 编译出来的css是： 123.lazy-eval &#123; width: 9%;&#125; 官网里的原话是： When defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value. 更经典的例子是： 12345678910@var: 0;.class &#123; @var: 1; .brass &#123; @var: 2; three: @var; @var: 3; &#125; one: @var;&#125; 编译结果： 123456.class &#123; one: 1;&#125;.class .brass &#123; three: 3;&#125; 可以看出，three首先被赋值@var: 2;，然后被下面定义的@var: 3;覆盖；而one的作用域内看不到@var: 2;和@var: 3;，因此最后被赋值为1","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"less","slug":"less","permalink":"http://QQ876684433.github.io/tags/less/"}]},{"title":"css中常见的选择符","slug":"css中常见的选择符","date":"2019-07-14T14:45:02.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/14/css中常见的选择符/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/css中常见的选择符/","excerpt":"","text":"css中常见的选择符 参考：https://yanhaijing.com/css/2014/01/04/the-30-css-selectors-you-must-memorize/ 官网：https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors#Simple_selectors 基本选择器 Type（类型）选择器 这种基本选择器会选择所有匹配给定元素名的元素。 语法：elename 例子：input 将会选择所有的 input 元素。 Class（类）选择器 这种基本选择器会基于类属性的值来选择元素。 语法： .classname 例子： .index 会匹配所有包含 index 类的元素 (由类似于class=&quot;index&quot;这样的属性定义的). ID选择器 这种基本选择器会选择所有id属性与之匹配的元素。需要注意的是一个文档中每个id都应该是唯一的。 语法：#idname 例子：#toc 将会匹配所有id属性为 toc 的元素 (类似于这样的定义 id=&quot;toc&quot;). 通用选择器 这个基本选择器选择所有节点。它也常常和一个名词空间配合使用，用来选择该空间下的所有元素。 语法： * ns|* *|* 例子：* （通配符）将会选择所有元素。 属性选择器 这个基本的选择器根据元素的属性来进行选择。（具体参考：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors） 语法：[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value] 例子：[autoplay] 将会选择所有具有 autoplay 属性的元素（不论这个属性的值是什么） 组合选择器 紧邻兄弟选择器 &#39;+&#39; 操作符选择相邻元素，即第二个节点紧邻着第一个节点，并且拥有共同的父节点。 语法: A + B 例子: ul + li 会匹配任何 ul 元素后紧邻的 li 元素。 一般兄弟选择器 &#39;~&#39; 操作符选择兄弟元素，也就是说，第二个节点在第一个节点后面的任意位置，并且这俩节点的父节点相同。 语法: A ~ B 例子: p ~ span 将会匹配同一父元素下，p 元素后的所有 span 元素。 子选择器 &#39;&gt;&#39; 操作符选择第一个元素的直接子节点。 语法: A &gt; B 例子: ul &gt; li 将会匹配直接嵌套在 ul 元素内的所有 li 元素。 后代选择器 &#39; &#39; (空格) 操作符将选择第一个元素的子代节点。 语法: A B 例子: div span 将匹配 div 元素内所有的 span 元素。","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://QQ876684433.github.io/tags/css/"}]},{"title":"withRouter的作用和用法","slug":"withRouter的作用和用法","date":"2019-07-14T14:43:29.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/14/withRouter的作用和用法/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/withRouter的作用和用法/","excerpt":"","text":"withRouter的作用和用法 参考：https://www.cnblogs.com/luowenshuai/p/9526341.html 作用把不是通过路由切换过来的组件中，将react-router 的 history、location、match 三个对象传入props对象上 默认情况下必须是经过路由匹配渲染的组件才存在this.props，才拥有路由参数，才能使用编程式导航的写法，执行this.props.history.push(‘/detail’)跳转到对应路由的页面 然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用withRouter就可以给此组件传入路由参数，此时就可以使用this.props 如何使用withRouter比如app.js这个组件，一般是首页，不是通过路由跳转过来的，而是直接从浏览器中输入地址打开的，如果不使用withRouter此组件的this.props为空，没法执行props中的history、location、match等方法。 我就通过在App.js组件中使用withRouter来简单介绍一下： 设置withRouter很简单只需要两步：（1）引入 （2）将App组件 withRouter() 一下 12345678910111213141516171819import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom' //引入withRouterimport One from './One'import NotFound from './NotFound'class App extends Component&#123; //此时才能获取this.props,包含（history, match, location）三个对象 console.log(this.props); //输出&#123;match: &#123;…&#125;, location: &#123;…&#125;, history: &#123;…&#125;, 等&#125; render()&#123;return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); //这里要执行一下WithRouter 介绍一个简单应用可以根据路由切换浏览器的title属性，对props.history进行监听，切换路由的时候获取当前的路由路径，同时可以根据不同的路由设置不同的浏览器title标题。 仍然是App.js组件： 1234567891011121314151617181920212223242526272829import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom'import One from './One'import NotFound from './NotFound'class App extends Component&#123; constructor(props)&#123; super(props); props.history.listen((location)=&gt;&#123; //在这里监听location对象 console.log(location.pathname); //切换路由的时候输出\"/one/users\"和\"/one/companies\" switch(location.pathname)&#123; //根据路径不同切换不同的浏览器title case '/one/users' : document.title = '用户列表'; break; case '/one/companies' : document.title = '公司列表'; break; default : break; &#125; &#125;) &#125; render()&#123; return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); 如果使用编程式导航this.props.history.push(‘/detail’) 去跳转页面，但是报 this.props.history 错误 undefined，请在此组件中使用 withRouter 将 history 传入到 props上。","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://QQ876684433.github.io/tags/React/"},{"name":"React-Router","slug":"React-Router","permalink":"http://QQ876684433.github.io/tags/React-Router/"}]},{"title":"区别React-Router中match的path和url","slug":"区别React-Router中match的path和url","date":"2019-07-14T14:41:21.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/14/区别React-Router中match的path和url/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/区别React-Router中match的path和url/","excerpt":"","text":"区别React-Router中match的path和url 参考：https://blog.51cto.com/zhuxianzhong/2120738 官方描述如下： path - (string) The path pattern used to match. Useful for building nested &lt;Route&gt;s url - (string) The matched portion of the URL. Useful for building nested &lt;Link&gt;s path用来标识路由匹配的URL部分。React Router使用了Path-to-RegExp库将路径字符串转为正则表达式。然后正则表达式会匹配当前路径。 当路由路径和当前路径成功匹配，会生成一个对象match。match对象有更多关于URL和path的信息。这些信息可以通过它的属性获取，如下所示： match.url.返回URL中匹配部分的字符串。用于创建嵌套的&lt;Link&gt;很有用。 match.path.用于匹配路径模式。用来创建嵌套的&lt;Route&gt;。 match.isExact.返回布尔值，如果准确（没有任何多余字符）匹配则返回true。 match.params.返回一个对象包含Path-to-RegExp包从URL解析的键值对。","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://QQ876684433.github.io/tags/React/"},{"name":"React-Router","slug":"React-Router","permalink":"http://QQ876684433.github.io/tags/React-Router/"}]},{"title":"PureComponent简介","slug":"PureComponent简介","date":"2019-07-14T14:39:59.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/14/PureComponent简介/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/PureComponent简介/","excerpt":"","text":"PureComponent 参考：https://juejin.im/entry/5934c9bc570c35005b556e1a 为什么使用？React15.3中新加了一个 PureComponent 类，顾名思义， pure 是纯的意思，PureComponent 也就是纯组件，取代其前身 PureRenderMixin ,PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可，可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码。 原理当组件更新时，如果组件的 props 和 state 都没发生改变，render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较： 1234if (this._compositeType === CompositeTypes.PureClass) &#123; shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);&#125; 而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://QQ876684433.github.io/tags/React/"}]},{"title":"前端笔记","slug":"前端笔记","date":"2019-07-14T13:49:44.000Z","updated":"2019-09-15T04:40:38.604Z","comments":true,"path":"2019/07/14/前端笔记/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/前端笔记/","excerpt":"","text":"前端笔记摘要ReactPureComponent 参考：https://juejin.im/entry/5934c9bc570c35005b556e1a 为什么使用？React15.3中新加了一个 PureComponent 类，顾名思义， pure 是纯的意思，PureComponent 也就是纯组件，取代其前身 PureRenderMixin ,PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可，可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码。 原理当组件更新时，如果组件的 props 和 state 都没发生改变，render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较： 1234if (this._compositeType === CompositeTypes.PureClass) &#123; shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);&#125; 而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。 React ReduxReact Router区别React-Router中match的path和url 参考：https://blog.51cto.com/zhuxianzhong/2120738 官方描述如下： path - (string) The path pattern used to match. Useful for building nested &lt;Route&gt;s url - (string) The matched portion of the URL. Useful for building nested &lt;Link&gt;s path用来标识路由匹配的URL部分。React Router使用了Path-to-RegExp库将路径字符串转为正则表达式。然后正则表达式会匹配当前路径。 当路由路径和当前路径成功匹配，会生成一个对象match。match对象有更多关于URL和path的信息。这些信息可以通过它的属性获取，如下所示： match.url.返回URL中匹配部分的字符串。用于创建嵌套的&lt;Link&gt;很有用。 match.path.用于匹配路径模式。用来创建嵌套的&lt;Route&gt;。 match.isExact.返回布尔值，如果准确（没有任何多余字符）匹配则返回true。 match.params.返回一个对象包含Path-to-RegExp包从URL解析的键值对。 withRouter的作用和用法 参考：https://www.cnblogs.com/luowenshuai/p/9526341.html 作用把不是通过路由切换过来的组件中，将react-router 的 history、location、match 三个对象传入props对象上 默认情况下必须是经过路由匹配渲染的组件才存在this.props，才拥有路由参数，才能使用编程式导航的写法，执行this.props.history.push(‘/detail’)跳转到对应路由的页面 然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用withRouter就可以给此组件传入路由参数，此时就可以使用this.props 如何使用withRouter比如app.js这个组件，一般是首页，不是通过路由跳转过来的，而是直接从浏览器中输入地址打开的，如果不使用withRouter此组件的this.props为空，没法执行props中的history、location、match等方法。 我就通过在App.js组件中使用withRouter来简单介绍一下： 设置withRouter很简单只需要两步：（1）引入 （2）将App组件 withRouter() 一下 12345678910111213141516171819import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom' //引入withRouterimport One from './One'import NotFound from './NotFound'class App extends Component&#123; //此时才能获取this.props,包含（history, match, location）三个对象 console.log(this.props); //输出&#123;match: &#123;…&#125;, location: &#123;…&#125;, history: &#123;…&#125;, 等&#125; render()&#123;return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); //这里要执行一下WithRouter 介绍一个简单应用可以根据路由切换浏览器的title属性，对props.history进行监听，切换路由的时候获取当前的路由路径，同时可以根据不同的路由设置不同的浏览器title标题。 仍然是App.js组件： 1234567891011121314151617181920212223242526272829import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom'import One from './One'import NotFound from './NotFound'class App extends Component&#123; constructor(props)&#123; super(props); props.history.listen((location)=&gt;&#123; //在这里监听location对象 console.log(location.pathname); //切换路由的时候输出\"/one/users\"和\"/one/companies\" switch(location.pathname)&#123; //根据路径不同切换不同的浏览器title case '/one/users' : document.title = '用户列表'; break; case '/one/companies' : document.title = '公司列表'; break; default : break; &#125; &#125;) &#125; render()&#123; return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); 如果使用编程式导航this.props.history.push(‘/detail’) 去跳转页面，但是报 this.props.history 错误 undefined，请在此组件中使用 withRouter 将 history 传入到 props上。 HTMLCSS传统csscss中常见的选择符 参考：https://yanhaijing.com/css/2014/01/04/the-30-css-selectors-you-must-memorize/ 官网：https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors#Simple_selectors 基本选择器 Type（类型）选择器 这种基本选择器会选择所有匹配给定元素名的元素。 语法：elename 例子：input 将会选择所有的 input 元素。 Class（类）选择器 这种基本选择器会基于类属性的值来选择元素。 语法： .classname 例子： .index 会匹配所有包含 index 类的元素 (由类似于class=&quot;index&quot;这样的属性定义的). ID选择器 这种基本选择器会选择所有id属性与之匹配的元素。需要注意的是一个文档中每个id都应该是唯一的。 语法：#idname 例子：#toc 将会匹配所有id属性为 toc 的元素 (类似于这样的定义 id=&quot;toc&quot;). 通用选择器 这个基本选择器选择所有节点。它也常常和一个名词空间配合使用，用来选择该空间下的所有元素。 语法： * ns|* *|* 例子：* （通配符）将会选择所有元素。 属性选择器 这个基本的选择器根据元素的属性来进行选择。（具体参考：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors） 语法：[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value] 例子：[autoplay] 将会选择所有具有 autoplay 属性的元素（不论这个属性的值是什么） 组合选择器 紧邻兄弟选择器 &#39;+&#39; 操作符选择相邻元素，即第二个节点紧邻着第一个节点，并且拥有共同的父节点。 语法: A + B 例子: ul + li 会匹配任何 ul 元素后紧邻的 li 元素。 一般兄弟选择器 &#39;~&#39; 操作符选择兄弟元素，也就是说，第二个节点在第一个节点后面的任意位置，并且这俩节点的父节点相同。 语法: A ~ B 例子: p ~ span 将会匹配同一父元素下，p 元素后的所有 span 元素。 子选择器 &#39;&gt;&#39; 操作符选择第一个元素的直接子节点。 语法: A &gt; B 例子: ul &gt; li 将会匹配直接嵌套在 ul 元素内的所有 li 元素。 后代选择器 &#39; &#39; (空格) 操作符将选择第一个元素的子代节点。 语法: A B 例子: div span 将匹配 div 元素内所有的 span 元素。 Sass (Syntactically Awesome StyleSheets)Less(Leaner Style Sheets)一个变量多次定义首先一个变量不需要在使用之前就定义，而且也可以在不同地方重复定义同一个变量，下面两个编译的结果一样： 123456.lazy-eval&#123; width: @var;&#125;@var:@a;@a:9%; 123456789.lazy-eval&#123; width: @var; @a:9%;&#125;@var:@a;@a:100%;// 定义在块级作用域里的@a(9%)覆盖了全局作用域里的@a(100%) 编译出来的css是： 123.lazy-eval &#123; width: 9%;&#125; 官网里的原话是： When defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value. 更经典的例子是： 12345678910@var: 0;.class &#123; @var: 1; .brass &#123; @var: 2; three: @var; @var: 3; &#125; one: @var;&#125; 编译结果： 123456.class &#123; one: 1;&#125;.class .brass &#123; three: 3;&#125; 可以看出，three首先被赋值@var: 2;，然后被下面定义的@var: 3;覆盖；而one的作用域内看不到@var: 2;和@var: 3;，因此最后被赋值为1 父选择器&amp;&amp;指的是所有的父选择器，而不单单指最近的一个父选择器： 12 JavaScriptasync/await的基础用法 参考：https://www.jianshu.com/p/ffa5cbe9ab29 推荐阅读：https://segmentfault.com/a/1190000007535316 另外补充：进程、线程和协程的理解 参考https://blog.csdn.net/hairetz/article/details/16119911 进程、线程和协程 堆 栈 调度 进程 独立 独立 操作系统 线程 共享 独立 操作系统 协程 共享 独立 程序员在代码中显式调度 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。 进程和其他两个的区别还是很明显的。 协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。 async/await的特点 Promise主要用then函数的链式调用，一直点点点，是一种从左向右的横向写法。async/await从上到下，顺序执行，就像写同步代码一样。这更符合人编写代码的习惯 Promise的then函数只能传递一个参数，虽然可以通过包装成对象，但是这会导致传递冗余信息，频繁的解析又重新组合参数，比较麻烦。async/await没有这个限制，就当做普通的局部变量来处理好了，用let或者const定义的块级变量，想怎么用就怎么用，想定义几个就定义几个，完全没有限制，也没有冗余的工作。 Promise在使用的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰。async/await整个书写习惯都是同步的，不需要纠结同步和异步的区别。当然，异步过程需要包装成一个Promise对象，放在await关键字后面，这点还是要牢记的。 Promise是根据函数式编程的范式，对异步过程进行了一层封装。async/await是基于协程的机制，是真正的“保存上下文，控制权切换 … … 控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述。 async/await是基于Promise的，是进一步的一种优化。不过再写代码的时候，Promise本身的API出现得很少，很接近同步代码的写法。 await关键字使用的注意点 只能放在async函数内部使用，不能放在普通函数里面，否则会报错。 后面放Promise对象，在Pending状态时，相应的协程会交出控制权，进入等待状态。这个是本质。 await是async wait的意思，wait的是resolve(data)消息，并把数据data返回。比如，下面代码中，当Promise对象由Pending变为Resolved的时候，变量a就等于data；然后再顺序执行下面的语句console.log(a);这真的是等待，真的是顺序执行，表现和同步代码几乎一模一样。 12345const a = await new Promise((resolve, reject) =&gt; &#123; // async process ... return resolve(data);&#125;);console.log(a); await后面也可以跟同步代码，不过系统会自动转化成一个Promise对象。比如const a = await &#39;hello world&#39;;其实就相当于const a = await Promise.resolve(&#39;hello world&#39;);这跟同步代码const a = &#39;hello world&#39;;是一样的，还不如省点事，去掉这里的await关键字。 await只关心异步过程成功的消息resolve(data)，拿到相应的数据data。至于失败消息reject(error)，不关心，不处理。当然对于错误消息的处理，有以下几种方法供选择：（1）让await后面的Promise对象自己catch（2）也可以让外面的async函数返回的Promise对象统一catch（3）像同步代码一样，放在一个try...catch结构中 async关键字使用的注意点 有了这个async关键字，只是表明里面可能有异步过程，里面可以有await关键字。当然，全部是同步代码也没关系。当然，这时候这个async关键字就显得多余了。不是不能加，而是不应该加。 async函数，如果里面有异步过程，会等待；但是async函数本身会马上返回，不会阻塞当前线程。 可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染。async函数内部由async关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回。 async函数的返回值是一个Promise对象，这个是和普通函数本质不同的地方。这也是使用时重点注意的地方（1）return newPromise();这个符合async函数本意；（2）return data;这个是同步函数的写法，这里是要特别注意的。这个时候，其实就相当于Promise.resolve(data);还是一个Promise对象。在调用async函数的地方通过简单的=是拿不到这个data的。那么怎么样拿到这个data呢？很简单，返回值是一个Promise对象，用.then(data =&gt; { })函数就可以。（3）如果没有返回，相当于返回了Promise.resolve(undefined); await是不管异步过程的reject(error)消息的，async函数返回的这个Promise对象的catch函数就负责统一抓取内部所有异步过程的错误。async函数内部只要有一个异步过程发生错误，整个执行过程就中断，这个返回的Promise对象的catch就能抓到这个错误。 async函数执行和普通函数一样，函数名带个()就可以了，参数个数随意，没有限制；也需要有async关键字。只是返回值是一个Promise对象，可以用then函数得到返回值，用catch抓去整个流程中发生的错误。 ES6、ES7、ES8、ES9、ES10新特性一览 参考：https://juejin.im/post/5ca2e1935188254416288eb2 前端项目将React项目部署到Github Pages 参考：https://segmentfault.com/a/1190000019290048 一些注意事项： （1）Github Pages自定义域名问题 往gh-pages分支添加CNAME记录 将要添加的域名写入CNAME，但是注意不要加入http:// 这里还有个问题就是，由于gh-pages分支是将编译之后的内容上传的，如果直接在gh-pages分支添加CNAME文件，会导致出现重新部署的时候CNAME被删除，这时后如果再次访问自定义域名，就会出现Content Security Policy问题（参见：https://stackoverflow.com/questions/54380373/content-security-policy-while-deploying-to-github-pages-using-gatsby） 1Refused to load the image 'http://www.alexingberg.com/favicon.ico' because it violates the following Content Security Policy directive: \"img-src data:\". 你可以按照stackoverflow上面的方案解决（我没试过），但我这里提供一个简单的解决方案，就是将CNAME添加在项目的public文件夹下面，编译之后CNAME就会在build目录生成，这样就不会出现Content Security Policy问题了 （2）自定义域名后出现资源路径不正确的问题 网上一些教程都是教你把Github Pages生成的那一串链接地址设置到&quot;homepages&quot;中 这样会出现的问题就是，编译完成后，会在静态资源的路径前面都加上/chph-blog，这样肯定是找不到对应的资源的 可以通过把&quot;homepages&quot;设置成&quot;./&quot;即可 Github开源项目license选择问题简单一点，借用阮一峰博客上面的一张图： 在React项目中使用Docz遇到的问题（1）按照官网的Getting Start添加依赖后执行yarnpkg add docz，出现的问题如下： 1234567891011121314Failed to compile../node_modules/docz/dist/index.esm.js 23:38Module parse failed: Unexpected token (23:38)Failed to compile../node_modules/docz/dist/index.esm.js 23:38Module parse failed: Unexpected token (23:38)You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders| import &#123; MDXProvider &#125; from '@mdx-js/react';| &gt; const BasePlayground = loadable(() =&gt; import('./Playground.esm.js'));| const Playground = props =&gt; typeof window !== 'undefined' ? createElement(Suspense, &#123;| fallback: null Github上面的相关issue是：https://github.com/pedronauck/docz/issues/596 最关键的是这一个： 他给出的解决方案是对webpack降级： 1npm i -D webpack@4.28.4 问题解决！ 然而，事情远远没有那么简单，当再次运行yarn start启动项目时，爆炸了： 显然是docz和creact-react-app的webpack版本冲突了，我又在github搜罗了一番，解决方案是给docz单独指定一个webpack版本： 启动成功，舒服了 在React中使用Scss 参考：https://segmentfault.com/a/1190000016571839 前端工具使用webpack","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/tags/前端/"}]}]}