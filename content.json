{"meta":{"title":"至繁归于至简 - chph's blog","subtitle":"steve_chph personal website","description":"the blog website of steve_chph, steve_chph的个人博客网站","author":"steve_chph","url":"http://QQ876684433.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-07-14T12:26:10.000Z","updated":"2019-09-15T05:02:14.670Z","comments":false,"path":"tags/index.html","permalink":"http://QQ876684433.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-14T12:26:19.000Z","updated":"2019-09-15T05:02:14.670Z","comments":false,"path":"categories/index.html","permalink":"http://QQ876684433.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C++面向对象之继承","slug":"CPP面向对象之继承","date":"2019-11-26T11:06:55.000Z","updated":"2019-11-28T15:15:15.205Z","comments":true,"path":"2019/11/26/CPP面向对象之继承/","link":"","permalink":"http://QQ876684433.github.io/2019/11/26/CPP面向对象之继承/","excerpt":"","text":"C++面向对象之继承 参考书籍：《Primer C++, 5th》 定义基类和派生类下面可能会用到的源码： 12345678910111213141516171819202122#ifndef QUOTE_H_#define QUOTE_H_#include &lt;iostream&gt;class Quote&#123;private: std::string bookNo;protected: double price = 0.0;public: Quote() = default; Quote(const std::string &amp;book, double sales_price) : bookNo(book), price(sales_price) &#123;&#125; std::string isbn() const &#123; return bookNo; &#125; virtual double net_price(std::size_t n) const &#123; return n * price; &#125; virtual ~Quote() = default;&#125;;#endif 定义基类继承关系中，根节点的类通常会定义一个虚析构函数，即使该函数不执行任何实际操作也是如此 成员函数与继承基类中通常有两种成员函数： 虚函数：基类希望其派生类进行覆盖的函数 当使用指针或者引用调用虚函数时，该调用将被动态绑定；根据引用或指针所绑定的对象类型的不同，该调用可能执行基类的版本，也可能执行某个派生类的版本 任何构造函数之外的非静态函数都可以是虚函数 并且virtual只能出现在类内部的声明语句之前，而不能用在类外部的函数定义 如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数（即使没有virtual关键字） 普通函数：基类希望派生类直接继承而不要改变的函数 非虚成员函数的解析过程发生在编译时而非运行时 访问控制与继承派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权限访问从基类继承而来的成员 （private、protected、public，过于简单，就不再赘述） 定义派生类派生类必须通过使用类派生列表明确指出它从哪些基类继承而来，每个基类前面可以使用三种访问说明符中的一个：public、protected、private 三种继承方式不影响子类对父类的访问权限，子类对父类只看父类的访问控制权；三种继承方式都能访问父类中的public和protected成员 简单来说：访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见 如果一个派生是共有的，则基类的共有成员也是派生类接口的组成部分，我们能将共有派生类型的对象绑定到基类的引用或指针上 派生类中的虚函数派生类经常（但不总是）覆盖它继承的虚函数；如果没有覆盖，则该虚函数的行为类似于其他普通成员，派生类会直接继承其在基类中的版本 派生类对象及派生类向基类的类型转换派生类对象包含多个组成部分： 派生类自己定义的（非静态）成员的子对象 与派生类继承的基类对应的子对象（如果基类有多个，那这样的子对象也有多个） 正因为如此，我们能够 把派生类的对象当成基类对象来使用 能将基类的指针或引用绑定到派生类对象的基类部分上 可以把派生类对象指针用在需要基类指针的地方 可以把派生类对象或者派生类对象的引用用到需要基类引用的地方 继承的关键所在：派生类对象中含有与基类对应的组成部分 派生类构造函数每个类控制它自己的成员的初始化过程：意味着派生类不能直接初始化继承的基类成员，需要通过基类的构造函数初始化它的基类部分 我们可以通过构造函数初始化列表将实参传递给基类构造函数，同时用这个方法指定我们要调用的基类的构造函数版本，否则派生类对象的基类对象会像数据成员一样执行默认初始化 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员 派生类使用基类的成员派生类可以访问基类的共有成员和受保护成员；派生类对象的作用域嵌套在基类的作用域之内，因此派生类的一个成员使用派生类其他成员的方式与使用基类成员的方式没有什么不同（除了基类private成员） 继承与静态成员如果基类定义了一个静态成员，那么整个继承体系中该静态成员只存在唯一的实例；静态成员遵循通用的访问控制规则， 如果某静态成员是可访问的，那么我们既能通过基类（及其对象）、也能通过派生类（及其对象）使用它 派生类的声明派生类的声明包含类名但是不包含它的派生列表；派生类列表与定义的其他细节必须与类的主体一起出现 一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体（如一个类、函数或者变量） 被用作基类的类一个类必须已经定义而非仅仅声明才能被用作基类： 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必然要知道基类中定义了哪些成员 言外之意：一个类不能派生它本身 每个类都会继承直接基类的所有成员；在整个继承体系中，最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象 防止继承发生C++11新标准：在类名后跟一个final，可以防止该类被继承 类型转换与继承静态类型与动态类型 静态类型：编译时就确定的，它是变量声明时的类型或表达式生成的类型 动态类型：变量或表达式表示的内存中的对象的类型 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致 不存在从基类向派生类的隐式类型转换有一种特别的情况：即使一个基类指针或者引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换 编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或者引用的静态类型来腿短该转换是否合法 如果基类中含有一个或多个虚函数，我们可以使用dynamic_case请求一个类型转换，该转换的安全检查将在运行时执行 1234Bulk_quote bulk;Quote *itemP = &amp;bulk;Bulk_quote *bulkP = dynamic_cast&lt;Bulk_quote *&gt;(itemP);cout &lt;&lt; bulkP-&gt;isbn() &lt;&lt; endl; 如果我们已知某个基类向派生类的转换是安全的，则我们可以使用static_cast来强制覆盖掉编译器的检查工作 1234Bulk_quote bulk;Quote *itemP = &amp;bulk;Bulk_quote *bulkP = static_cast&lt;Bulk_quote *&gt;(itemP);cout &lt;&lt; bulkP-&gt;isbn() &lt;&lt; endl; 在对象之间不存在类型转换派生类向基类的自动类型转换只针对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换： 初始化或赋值一个类类型对象时，实际上是在调用某个函数 执行初始化时，调用的是构造函数 执行赋值操作时，调用的是赋值运算符 这些成员函数通常都包含一个参数，该参数的类型是类类型的const版本的引用 这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象，因为这些操作不是虚函数，因此： 当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基类自己的成员 当我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算符也是基类中定义的那个，该运算符同样只能处理基类自己的成员 引入知识点：对象切片 原文链接：https://blog.csdn.net/beckle_ye/article/details/4700612 If you upcast to an object instead of a pointer or reference, something will happen that may surprise you: the object is “sliced” until all that remains is the subobject that corresponds to the destination type of your cast.—— Thinking In C++ 这句话的意思也就是说：在函数传参处理多态性时，如果一个派生类对象在UpCasting时，用的是传值的方式，而不是指针和引用，那么，这个派生类对象在UpCasting以后，将会被slice（切分）成基类对象，也就是说，派生类中独有的成员变量和方法都被slice掉了，只剩下和基类相同的成员变量和属性。这个派生类对象被切成了一个基类对象如下例子： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Pet&#123; string pname;public: Pet(const string &amp;name) : pname(name) &#123;&#125; virtual string name() const &#123; return pname; &#125; virtual string description() const &#123; return \"This is \" + pname; &#125;&#125;;class Dog : public Pet&#123; string favoriteActivity;public: Dog(const string &amp;name, const string &amp;activity) : Pet(name), favoriteActivity(activity) &#123;&#125; string description() const &#123; return Pet::name() + \" likes to \" + favoriteActivity; &#125;&#125;;void describe(Pet p)&#123; // Slices the object cout &lt;&lt; p.description() &lt;&lt; endl;&#125;int main()&#123; Pet p(\"Alfred\"); Dog d(\"Fluffy\", \"sleep\"); describe(p); //正常调用基类函数 describe(d); //对象切片&#125; 执行结果： 12This is AlfredThis is Fluffy 发生对象切片前后的情况是这样的： 发生Object Slicing后，原先的虚函数Dog vptr表变成了Pet vptr，Dog的成员favoriteActivity也不存在了，其实这时候执行了一些步骤： 在正常情况下，main函数中执行describe函数，在传递Dog对象d的时候，调用了Pet类的拷贝构造函数，相当于此时，在describe函数中的那个Pet类对象p是拷贝构造的结果，所以，跟Dog对象d已经没有了关系。所以，此时，p.description()执行的会是调用的基类也就是Pet类的description函数 但是如果将description函数声明为纯虚函数： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Pet&#123; string pname;public: Pet(const string &amp;name) : pname(name) &#123;&#125; virtual string name() const &#123; return pname; &#125; virtual string description() const = 0；&#125;;class Dog : public Pet&#123; string favoriteActivity;public: Dog(const string &amp;name, const string &amp;activity) : Pet(name), favoriteActivity(activity) &#123;&#125; string description() const &#123; return Pet::name() + \" likes to \" + favoriteActivity; &#125;&#125;;void describe(Pet p)&#123; // Slices the object cout &lt;&lt; p.description() &lt;&lt; endl;&#125;int main()&#123; Pet p(\"Alfred\"); Dog d(\"Fluffy\", \"sleep\"); describe(p); //正常调用基类函数 describe(d); //对象切片&#125; 那么这时候Pet类型就不能被实例化，所以在全局的describe函数中不可能有者拷贝构造函数来实例化一个Pet类对象，此时编译器就会报错 这里就体现出了纯虚函数的一个重要意义：可以在编译期间避免对象切片，从而避免很多可能会出现的问题 虚函数使用基类的引用或指针调用一个虚成员函数时会执行动态绑定；如果我们通过一个具有普通类型的表达式调用虚函数时，在编译时就会将调用的版本确定下来 通常如果我们不使用某个函数，则无须为该函数提供定义；但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，否则会编译出错 派生类中的虚函数基类中的虚函数在派生类中隐含地也是一个虚函数 当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配； 派生类中虚函数的返回类型也必须与基类函数匹配 例外情况是，当类的虚函数返回类型是类本身的指针或引用时，该条规则失效 1234567class A&#123; virtual A&amp; func()&#123;&#125;&#125;;class B:public A&#123; B&amp; func()&#123;&#125;&#125;; 即这样也是有效的 final和override说明符 我们可以使用override显式指定派生类中的某个函数是覆盖基类对应的虚函数，如果override标记的派生类的函数是在基类中不存在，那么编译器将报错 如果我们把某个函数指定为final，则之后派生类中任何尝试覆盖该函数的操作将引发错误 注意：final和override都只能用在虚函数上，而且也只能出现在形参列表（包括从const或引用修饰符）以及尾置返回类型之后 123456789101112class A&#123; virtual A &amp;func() &#123;&#125; void func2();&#125;;class B : public A&#123; B &amp;func() override &#123;&#125; void func2() override; void func3() final;&#125;; 编译器报错： 123456Test01.cpp:18:10: error: ‘void B::func2()’ marked ‘override’, but does not override void func2() override; ^~~~~Test01.cpp:19:10: error: ‘void B::func3()’ marked ‘final’, but is not virtual void func3() final; ^~~~~ 虚函数与默认实参虚函数可以拥有默认实参，如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定 如果通过基类的引用或者指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此，因此传入派生类函数的将是基类函数定义的默认实参；如果派生类函数依赖不同的是实参，则程序结果将与我们的预期不同 回避虚函数的机制可以使用作用域运算符来使得虚函数的调用不要进行动态绑定，而是强迫执行虚函数的某个特定版本，这种调用将在编译时完成解析 抽象基类纯虚函数一个纯虚函数无须给出定义，通过在函数体的位置（即声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数（=0只能出现在类内部的虚函数声明语句处） 当然我们也可以给纯虚函数提供定义，不过函数体必须定义在类的外部，也就是说，我们不能在类的内部为一个=0的函数提供函数体 含有纯虚函数的类是抽象基类含有纯虚函数的类是抽象基类，抽象基类负责定义接口，后续的其他类可以覆盖该接口 我们不能创建一个抽象基类的对象 访问控制与继承受保护成员受保护成员对于类的用户来说是不可访问的，派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象的受保护成员没有任何访问特权 例子如下： 派生类B的成员函数无法通过基类对象来访问受保护成员，也就是说此时B是基类A的用户，用户代码B无法访问A的受保护成员，它只能通过this指针来访问 至于友元函数，则是书上的例子： 公有、私有和受保护继承 派生访问说明符对于派生类的成员及友元能否访问其直接基类的成员没什么影响，对基类成员的访问权限只与基类中的访问说明符有关 派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限 这是私有继承的例子： 受保护继承的例子： （按照我个人的理解是这样的：私有派生将基类的成员继承过来之后，这部分基类的成员*对外的访问说明符变成了私有private，即基类的成员不会成为派生类对外的接口*，而对于派生类内部没有任何影响） 派生类向基类转换的可访问性有三种情况： D公有地继承B，用户代码才能使用派生类向基类的转换；受保护或私有继承不行 不论D如果继承B，D的成员函数和友元都能使用派生类向基类的转换 如果D公有地或受保护地继承B，则D的派生类的成员和友元可以使用D向B的类型转换；如果D私有继承B，则不能使用 书中给出了一个助记的方法： 关键概念：类的设计与受保护的成员（讲的太好了，没必要自己整理，故全文截图如下） 友元与继承友元关系既不能传递，也不能继承 每个类负责控制自己的成员的访问权限，即使对于派生类的基类部分也是如此： 可以看到例子中，可以通过派生类B在基类A的友元类Test中访问基类A的私有成员，而直接使用B访问x则会报错，这是因为派生类B的基类子对象部分的访问控制依然是由基类来控制的 改变个别成员的可访问性可以通过using声明来改变派生类继承的某个名字的访问级别 通过在类内部使用using声明语句，我们可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来： using语句出现在类的private部分：该名字只能被类的成员和友元访问 using语句出现在类的public部分：类的所有用户都能访问它 using语句出现在类的protected部分：该名字对于成员、友元和类的派生类是可访问的 默认的继承保护级别默认情况下： class关键字定义的派生类是私有继承的 struct关键字定义的派生类是公有继承的 ps：struct和class的唯一差别就是默认访问说明符和默认派生说明符；除此之外，再无其他不同之处 继承中的类作用域每个类定义自己的作用域，当存在继承关系时，派生类的作用域嵌套在基类的作用域之内 如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义 在编译时进行名字查找一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的；即使静态类型和动态类型不一致，但是我们能够使用哪些成员依然是由静态类型决定的 （按我的个人理解，对象、引用或者指针的静态类型决定了当前作用域，其派生类的作用域对与当前的对象、引用或者指针是不可见的，如果存在继承链A -&gt; B -&gt; C，通过B调用时，查找将从B开始，然后再到A，而C的作用域对B是不可见的） 名字冲突与继承定义在内层作用域（即派生类）中的名字将隐藏外层作用域（即基类）的名字 通过作用域运算符来使用隐藏的成员作用域运算符::能覆盖掉原有的查找规则，并指示编译器从基类的作用域中开始查找名字 名字查找的过程（以p-&gt;mem()或p.mem()为例）： 首先确定p的静态类型 在p的静态类型对应的类中查找名字mem 如果找不到，则依次在直接基类中不断查找直至到达继承链顶端；如果仍然找不到，编译器将报错 一旦找到名字mem，就进行常规的类型检查，以确认对于当前找到的名字mem，本次调用是否合法 如果调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码 如果mem是虚函数，且我们通过引用或指针进行调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型（即运行时的实际类型） 反之（mem不是虚函数或者我们是通过对象本身（而非引用或指针）进行调用），编译器将产生一个常规函数调用，并且这个调用是在编译期间就已经确定的 如果调用非法，则编译器报错，并且不会再向上继续往基类中查找 名字查找先于类型检查 声明在内层作用域的函数并不会重载声明在外层作用域的函数 因此，定义派生类中的函数也不会重载其基类的成员 如果派生类（内层作用域）的成员与基类（外层作用域）的某个成员同名，则派生类的成员将隐藏其作用域内该基类成员，即使派生类成员与基类成员的形参列表不一样 虚函数与作用域多重继承与虚继承多重继承的派生类继承了所有父类的属性 多重继承 关键字class对应的默认访问说明符是private，关键字struct对应的是public 多重继承的派生列表只能包含已经被定义过的类，而且这些类不能是final的 派生列表中，同一个基类只能出现一次 多重继承的派生类从每个基类中继承状态多重继承关系中，派生类的对象包含有每个基类的子对象，例如： 12class Bear: public ZooAnimal &#123;...&#125;class Panda: public Bear, public Endangered &#123;...&#125; 派生类构造函数初始化所有基类构造一个派生类的对象将同时构造并初始化它的所有基类子对象，多重继承的派生类的构造函数初始值只能初始化它的直接基类（例如Panda的直接基类是Bear和Endangered） 基类的构造顺序与派生列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中的基类顺序无关 继承的构造函数与多重继承C++11中允许派生类继承多个基类的构造函数，但是如果从多个基类中继承了相同的构造函数（形参列表完全相同），那么程序将报错 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;memory&gt;struct Base1&#123; Base1() = default; Base1(const std::string &amp;); Base1(std::shared_ptr&lt;int&gt;);&#125;;struct Base2&#123; Base2() = default; Base2(const std::string &amp;); Base2(int);&#125;;struct D1: public Base1, public Base2&#123; using Base1::Base1; using Base2::Base2;&#125;;int main(int argc, char const *argv[])&#123; D1 d; return 0;&#125; 控制台输出： 12345tempCodeRunnerFile.cpp:20:18: error: ‘D1::D1(const string&amp;)’ inherited from ‘Base2’ using Base2::Base2; ^~~~~tempCodeRunnerFile.cpp:19:18: error: conflicts with version inherited from ‘Base1’ using Base1::Base1; 此时必须在派生类中定义这个冲突构造函数的派生类自己的版本 123456struct D1: public Base1, public Base2&#123; using Base1::Base1; using Base2::Base2; D1(const std::string &amp;)&#123;&#125; D1() = default;&#125;; 注意：前面版本的D1之所以只对D1::D1(const string&amp;)报错，是因为D1中没有定义自己版本的构造函数，编译器为D1合成了默认的构造函数，覆盖了从Base1和Base2继承过来的冲突的默认版本的构造函数；但是现在这个版本定义了自己的D1(const std::string &amp;){}来解决冲突，导致编译器不会为D1合成默认构造函数，因此也需要为D1显式定义默认构造函数 析构函数与多重继承析构函数的调用顺序与构造函数相反： 12345678ZooAnimal()Bear()Endangered()Panda()~Panda()~Endangered()~Bear()~ZooAnimal() 多重继承的派生类的拷贝与移动操作 多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或者赋值操作 只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作 例如Panda调用合成版本的拷贝构造函数，首先调用Bear的拷贝构造函数拷贝Bear子对象部分，而Bear又会在执行之前调用呢ZooAnimal的拷贝构造函数拷贝ZooAnimal子对象部分，Bear子对象部分拷贝完成后，又会调用Endangered拷贝构造函数拷贝Endangered子对象部分，最后才调用Panda的合成构造函数拷贝Panda部分 类型转换与多个基类派生类有多个基类时，如果存在多个以基类为参数的重载函数，那么编译器会报错，因为编译器不会在派生类向基类的几种转换中进行比较和选择： 1234567891011121314151617#include \"Panda.h\"#include \"Bear.h\"#include \"Endangered.h\"#include \"ZooAnimal.h\"void func(Bear &amp;) &#123; cout &lt;&lt; \"func(Bear &amp;)\"; &#125;void func(Endangered &amp;) &#123; cout &lt;&lt; \"func(Endangered &amp;)\"; &#125;void func(ZooAnimal &amp;) &#123; cout &lt;&lt; \"func(ZooAnimal &amp;)\"; &#125;int main(int argc, char const *argv[])&#123; Panda p; func(p); return 0;&#125; 编译报错，程序有二义性： 12345678910111213Test01.cpp: In function ‘int main(int, const char**)’:Test01.cpp:15:11: error: call of overloaded ‘func(Panda&amp;)’ is ambiguous func(p); ^Test01.cpp:6:6: note: candidate: void func(Bear&amp;) void func(Bear &amp;) &#123; cout &lt;&lt; \"func(Bear &amp;)\"; &#125; ^~~~Test01.cpp:8:6: note: candidate: void func(Endangered&amp;) void func(Endangered &amp;) &#123; cout &lt;&lt; \"func(Endangered &amp;)\"; &#125; ^~~~Test01.cpp:10:6: note: candidate: void func(ZooAnimal&amp;) void func(ZooAnimal &amp;) &#123; cout &lt;&lt; \"func(ZooAnimal &amp;)\"; &#125; ^~~~ 注意：这个只限于直接基类为参数的重载，比如下面的例子： 1234567891011121314151617#include \"Panda.h\"#include \"Bear.h\"#include \"Endangered.h\"#include \"ZooAnimal.h\"void func(Bear &amp;) &#123; cout &lt;&lt; \"func(Bear &amp;)\" &lt;&lt;endl; &#125;// void func(Endangered &amp;) &#123; cout &lt;&lt; \"func(Endangered &amp;) &lt;&lt; endl;\"; &#125;void func(ZooAnimal &amp;) &#123; cout &lt;&lt; \"func(ZooAnimal &amp;)\" &lt;&lt; endl; &#125;int main(int argc, char const *argv[])&#123; Panda p; func(p); return 0;&#125; 继承关系是ZooAnimal -&gt; Bear -&gt; Panda，输出结果是： 123456789ZooAnimal()Bear()Endangered()Panda()func(Bear &amp;)~Panda()~Endangered()~Bear()~ZooAnimal() 即会调用继承链上最近的那个重载版本 基于指针类型或引用类型的查找通过基类指针来引用派生类对象时，如果析构函数是非虚函数，那么delete时无法调用派生类对象的析构函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ZooAnimal&#123;private: /* data */public: ZooAnimal(/* args */); ~ZooAnimal();&#125;;... ...int main(int argc, char const *argv[])&#123; // Panda p; ZooAnimal *z_ptr = new Panda(); // func(p); delete z_ptr; return 0;&#125;输出：ZooAnimal()Bear()Endangered()Panda()~ZooAnimal() ======================================================================================================================================== class ZooAnimal&#123;private: /* data */public: ZooAnimal(/* args */); virtual ~ZooAnimal();&#125;;... ...int main(int argc, char const *argv[])&#123; // Panda p; ZooAnimal *z_ptr = new Panda(); // func(p); delete z_ptr; return 0;&#125;输出：ZooAnimal()Bear()Endangered()Panda()~Panda()~Endangered()~Bear()~ZooAnimal() 在基类和派生类的析构函数都是虚函数时，无论使用哪个基类的指针来引用派生类对象，调用析构函数时，都是按照调用派生类对象析构函数的顺序执行： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Created by steve_chph#include &lt;iostream&gt;using namespace std;class Base1&#123;public: virtual ~Base1() &#123; cout &lt;&lt; \"~Base1()\" &lt;&lt; endl; &#125;&#125;;class Base2&#123;public: virtual ~Base2() &#123; cout &lt;&lt; \"~Base2()\" &lt;&lt; endl; &#125;&#125;;class D1 : public Base1&#123;public: virtual ~D1() &#123; cout &lt;&lt; \"~D1()\" &lt;&lt; endl; &#125;&#125;;class D2 : public Base2&#123;public: virtual ~D2() &#123; cout &lt;&lt; \"~D2()\" &lt;&lt; endl; &#125;&#125;;class MI : public D1, public D2&#123; virtual ~MI() &#123; cout &lt;&lt; \"~MI()\" &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[])&#123; Base1 *pb1 = new MI; Base2 *pb2 = new MI; D1 *pd1 = new MI; D2 *pd2 = new MI; delete pb2; cout &lt;&lt; endl; delete pb1; cout &lt;&lt; endl; delete pd2; return 0;&#125; 输出： 1234567891011121314151617~MI()~D2()~Base2()~D1()~Base1()~MI()~D2()~Base2()~D1()~Base1()~MI()~D2()~Base2()~D1()~Base1() 多重继承下的类作用域单继承与多继承时的不同： 单继承时，派生类的作用域嵌套在直接基类和间接基类的作用域中，查找过程沿着继承体系自底向上进行，直到找到所需的名字；派生类的名字将隐藏基类的同名成员 多继承时，相同的查找过程将在所有直接基类中同时进行，如果名字在多个基类中都被找到，则对该名字的使用将具有二义性 注意一点是，上面强调的是名字，即使派生类继承的两个函数形参列表不同也可能产生错误，因为它是按名字查找，先查找名字后进行类型检查，当编译器在两个作用域中同时发现了同名成员将直接报告一个调用二义性的错误 对一个派生类来说，从多个基类中分别继承同名的成员是完全合法的，只不过在使用这个名字时必须明确指出它的版本（这个如下面代码所示）；也就是说，派生仅是产生了潜在的二义性，只要没有调用就不会产生二义性（可以通过编译）；要想避免潜在的二义性，最好的办法是在派生类中为该函数定义一个新版本，或者通过using来显式使用确定的基类版本（例如using ZooAnimal::max_weight，或者using Endangered::max_weight） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Created by steve_chph#include &lt;iostream&gt;using namespace std;class Base1&#123;public: virtual ~Base1() &#123; cout &lt;&lt; \"~Base1()\" &lt;&lt; endl; &#125;&#125;;class Base2&#123;public: virtual ~Base2() &#123; cout &lt;&lt; \"~Base2()\" &lt;&lt; endl; &#125;&#125;;class D1 : public Base1&#123;public: virtual ~D1() &#123; cout &lt;&lt; \"~D1()\" &lt;&lt; endl; &#125; void func1()&#123;&#125;;&#125;;class D2 : public Base2&#123;public: virtual ~D2() &#123; cout &lt;&lt; \"~D2()\" &lt;&lt; endl; &#125; void func1(int)&#123;&#125;;&#125;;class MI : public D1, public D2&#123;public: virtual ~MI() &#123; cout &lt;&lt; \"~MI()\" &lt;&lt; endl; &#125; // using D1::func1;&#125;;int main(int argc, char const *argv[])&#123; Base1 *pb1 = new MI; Base2 *pb2 = new MI; D1 *pd1 = new MI; D2 *pd2 = new MI; delete pb2; cout &lt;&lt; endl; delete pb1; cout &lt;&lt; endl; delete pd2; MI mi; mi.D1::func1(); // 显式指定使用的名字的版本 return 0;&#125; 虚继承虽然派生列表中同一个基类只能出现一次，但是派生类可以多次继承同一个类；派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类 默认情况下，派生类中含有继承链上每个类对应的字部分，如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象： 从图中可以看到，B1(base)和B2(base)中包含的A(base)是两个不同子部分（从x值不同可以看出，并且A的构造函数也调用了两次） 有时候要实现多次出现的同一个基类的共享，可以使用虚继承：虚继承的目的是令某个类作出声明，承诺愿意共享它的基类（共享的基类子对象称为虚基类），这样不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象： 从上图可以看出此时A基类子对象只有一个，A只调用了一次构造函数 虚基类的缺点：必须在虚派生的真实需求出现之前就已经完成了虚派生的操作；在实际编程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题，它不会影响派生类本身，只会影响从制定了虚基类的派生类章进一步派生出来的类： 例如Bear声明ZooAnimal为虚继承不会对Bear自身造成影响，但会对Panda造成影响 使用虚基类指定虚基类的方式是在派生列表中添加关键字virtual，其中virtual和访问修饰符如public的顺序随意 virtual说明符表明了一种愿望：在后续的派生类中共享虚基类的同一份实例 虚基类成员的可见性 在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并且不会产生二义性 如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员 如果成员被多于一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本 例如有如下继承关系： 12345678class B&#123;public: int x;&#125;;class D1: virtual public B&#123;...&#125;;class D2: virtual public B&#123;...&#125;;class D: public D1, public D2&#123;...&#125;; 如果在D的对象中使用x，则有三种可能性： D1、D2都没有x的定义，此时x被解析为B的成员，此时不存在二义性 D1和D2只有其中一个有x的定义，此时依然没有二义性，派生类（D1或者D2）的x比共享虚基类B的x优先级更高（如下代码所示） D1、D2中均有x的定义，直接访问x将产生二义性 解决这种二义性的最好方法是在派生类中为成员自定义新的实例 构造函数与虚继承在虚派生中，虚基类是由最底层的派生类初始化的 虚继承的对象的构造方式含有虚基类的对象的构造顺序与一般的顺序稍有区别： 首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分 接下来按照直接基类在派生列表中出现的次序依次对其进行初始化 也就是说：虚基类总是先于非虚基类构造，与他们在继承体系中的次序和位置无关；如下代码所示，B处于派生列表的第一个，但是虚基类A先于B进行初始化： 但是如果有多个虚基类的时候，虚基类的构造顺序则与派生列表的顺序有关，如下面代码所示，派生列表中B1是第一个直接基类，B1虚继承了A2，因此A2先于A1执行初始化： 构造函数与虚构函数的次序一个类可以有多个虚基类，这些虚的子对象按照它们在派生列表中出现的顺序依次从左向右构造：编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类；如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类 对于如下的继承体系： 它们的构造顺序如下： 合成的拷贝和移动构造函数按照上面完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值；和往常一样，对象的销毁顺序与构造顺序正好相反：首先销毁TeddyBear，最后销毁ZooAnimal部分 最后来一个例子： 因为Class不是虚基类，因此new Final对象中含有多份Class的子对象部分，当使用Class类型指针绑定到new Final对象时，会造成Class基类的二义性，即控制台报错的：ex18_29.cpp:15:21: error: ‘Class’ is an ambiguous base of ‘Final’ 接下来我们修改一下，将其中一个Class申明为虚继承，另一个依然为普通继承： 可以看到，Class还是存在二义性：ex18_29.cpp:15:21: error: ‘Class’ is an ambiguous base of ‘Final’ 其他知识点","categories":[{"name":"C++","slug":"C","permalink":"http://QQ876684433.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://QQ876684433.github.io/tags/C/"},{"name":"继承","slug":"继承","permalink":"http://QQ876684433.github.io/tags/继承/"},{"name":"面向对象","slug":"面向对象","permalink":"http://QQ876684433.github.io/tags/面向对象/"}]},{"title":"操作系统-进程管理","slug":"操作系统-进程管理","date":"2019-11-17T03:18:33.000Z","updated":"2019-11-17T14:35:03.519Z","comments":true,"path":"2019/11/17/操作系统-进程管理/","link":"","permalink":"http://QQ876684433.github.io/2019/11/17/操作系统-进程管理/","excerpt":"","text":"进程管理 参考资料： 操作系统教程（第5版） - 费翔林 骆斌 编著 进程定义和属性定义 从原理角度看：进程是支持程序执行的一种系统机制，它对处理器上运行程序的活动规律进行抽象 从实现角度看：进程是一种数据结构，用来准确地刻画运行程序的状态和系统动态变化状况 操作系统有两个重要的特性：程序的并发性和资源的共享性。进程的概念既能描述程序的并发执行，又能共享系统的资源 程序的并发性 正因为“程序”自身这种静态的概念无法刻画程序的并发性，因此需要引入“进程”来描述系统内部程序的并发执行，提高资源利用率 资源的共享性 “可再入”程序：能够被多个程序同时调用的程序 “可再用”程序：在备用过程中可以有自身修改，在调用它的程序退出之前不允许其他程序来调用 “可再入”程序是纯代码，在执行过程中不被修改，调用它的各应用程序提供工作区，因此它可以被多个应用程序调用 进程是既能描述程序的并发执行，又能共享系统资源的一个基本单位，当然操作系统也要为引入进程而付出（进程占用的）空间和（调度进程的）时间代价 进程的定义：进程是具有独立功能的程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位 进程的属性 进程的状态和转换三态模型进程是活动的且有状态变化，状态及其转换体现进程的动态性，进程在执行过程中有三种状态： 运行态（running） 进程占有处理器正在运行的状态 就绪态（ready） 进程具备运行条件，等待系统分配处理器以便运行的状态 等待态（wait） 阻塞态（blocked）或睡眠态（sleep），指进程不具备运行条件，正在等待某个时间完成的状态 处于运行态的进程个数不能大于处理器的个数，处于就绪态和等待态的进程可能有多个（非运行态进程的划分的主要依据是不能运行的原因） CPU只会从就绪态队列选择进程来执行，因此等待态队列的进程是被暂时性剥夺了获得CPU的机会 三态模型的状态转换 进程在创建后处于就绪态 运行态进程因出现等待事件或者等待信号而进入等待态 当等待事件发生或者等待信号到达后，等待态进程变成就绪态 处理器的调度会引起运行态和就绪态进程之间的切换 七态模型 新建态（new） 新建态对应于进程被创建时的状态，尚未进入就绪队列（有时候根据系统性能要求或内存容量限制推迟新建态被调度执行） 创建进程要通过两个步骤： 先为新进程分配所需资源和建立必要的管理信息 然后设置该进程为就绪态，并等待被调度执行 终止态（exit） 进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态，处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失 进程终止要通过两个步骤： 先等待操作系统或相关进程进行善后处理（如抽取信息） 然后回收占用的资源并被系统删除 进程挂起的原因：（1）由于不断创建进程，当系统资源尤其是内存资源已经不能满足进程运行要求时，必须把某些进程挂起（suspend），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度，起到平滑系统负荷的目的；（2）也可能系统出现故障，需要暂时挂起一些进程，以便故障消除后再解除挂起并恢复进程运行；（3）用户调试程序过程中，可以请求挂起进程，以便进行某种检查和修改 挂起就绪态（ready suspend） 进程具备运行条件，但目前在外存中，只有当它被对换到内存中才能被调度执行 挂起等待态（blocked suspend） 进程正在等待某一事件发生且进程在外存中 挂起进程等同于不在内存中的进程，因此挂起进程不参与低级调度直到它们被对换进内存 挂起进程的特征： 该进程不能被立即执行 该进程可能会等待事件或者等待信号，但是所等待的事件或者信号是独立于挂起条件的，事件结束并不能导致进程具备执行条件 该进程进入挂起状态是由于操作系统、父进程或者进程自身阻止它的运行 结束进程挂起状态的命令只能通过操作系统或父进程发出 进程描述和组成进程映像 参考资料：http://www.tldp.org/LDP/LG/issue23/flower/psimage.html 程序和数据是进程必需的组成部分，用来刻画静态特征；还需要一种称为进程控制块的数据结构来刻画进程的动态特征，描述进程状态、占用资源状况、记录调度信息等。由于进程状态不断发生变化，某时刻进程的内容及其状态集合称为进程映像（process image），包括如下要素： 进程控制块 每个进程捆绑一个，用来存储进程的标志信息、现场信息和控制信息。进程创建时建立进程控制块，进程撤销时回收进程控制块，它与进程一一对应 进程程序块 被进程执行的程序，规定进程一次运行所应完成的功能；这部分是可以被不同的进程共享的 进程核心栈 每个进程捆绑一个，进程在内核态工作时使用，用来保存中断/异常现场，保存函数调用的参数、局部变量和返回地址等 内核栈: 系统栈（也叫核心栈、内核栈）是内存中属于操作系统空间的一块区域，其主要用途为： (1)保存中断现场，对于嵌套中断，被中断程序的现场信息依次压入系统栈，中断返回时逆序弹出； (2)保存操作系统子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。用户栈是用户进程空间中的一块区域，用于保存用户进程的子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。 那么为什么不直接用一个栈，何必浪费那么多的空间呢？？原因有二： ​ （1）如果只用系统栈。系统栈一般大小有限，如果中断有16个优先级，那么系统栈一般大小为15（只需保存15个低优先级的中断，另一个高优先级中断处理 程序处于运行），但用户程序子程序调用次数可能很多，那样15次子程序调用以后的子程序调用的参数、返回值、返回点以及子程序(函数)的局部变量就不能被 保存，用户程序也就无法正常运行了 ​ （2）如果只用用户栈。我们知道系统程序需要在某种保护下运行，而用户栈在用户空间（即cpu处于用户态，而cpu处于核心态时是受保护的），不能提供相应的保护措施（或相当困难） 来源：https://www.cnblogs.com/yysblog/archive/2012/11/05/2755226.html 进程数据块 进程的私有地址空间，存放各种私有数据，用户栈也在数据块中开辟，用于在函数调用时存放栈帧、局部变量和返回地址等参数 May be distinguished as initialised variables including external global and static variables, uninitialised variables (known as a bss area on Unix derivative systems). Data blocks are not shared between processes by default. 可区分为初始化变量（包括外部全局变量和静态变量）和非初始化变量(在Unix派生系统中称为bss区域)；默认情况下，进程之间不共享数据块 进程上下文进程在系统中存在及活动除了本身映像外，还需要环境支撑，如硬件寄存器、程序状态字寄存器、支持动态地址转换的页表和相关的核心数据结构。在操作系统中，进程物理实体和支持进程运行的环境合称进程上下文（process context），进程在其当前上下文运行，当系统调度新进程占有处理器时，新老进程随之发生上下文切换。进程上下文由三部分组成： 用户级上下文（user level context） 由程序块（可执行的机器指令序列）、数据块（进程可访问的信息）、共享内存区（进程通信使用的内存区）、用户栈（存放函数调用过程中的信息）组成，它们占用进程的虚存空间。对换至磁盘的分段或页面仍然是用户级上下文的组成部分 寄存器上下文（register context） 由处理器状态寄存器（进程当前状态）、指令计数器（下一条该执行的指令地址）、栈指针（指向用户栈或核心栈当前地址）、通用寄存器等组成。当进程不处于运行态时，处理器状态信息保存在寄存器上下文中 系统级上下文（system level context） 由进程控制块（进程的状态）、内存管理信息（进程页表或段表）、核心栈（进程内核态运行时的工作区）等操作系统管理进程所需要的信息组成 Linux系统的进程上下文： 用户级上下文：text、data、shared memory和user stack等 寄存器上下文：general register、program counter、EFLAGS、ESP等 系统级上下文：task_struct、mm_struct、vm_area_struct、pgd、pmd、pte和kernel stack等 进程控制块每个进程有且仅有一个进程控制块（Process Control Block，PCB），或称进程控制符（process descriptor），它是进程存在的唯一标识，是操作系统用来记录和刻画进程状态及环境信息的数据结构，是进程动态特征的汇集，也是操作系统掌握进程的唯一资料结构和管理进程的主要依据；进程控制块包括进程执行时的情况，以及进程让出处理器之后所处的状态、断点等信息，一般来说PCB包含以下三类信息： 标识信息 标识信息用于唯一地标识一个进程，分为用户使用的外部标识符和系统使用的内部标识符。系统中所有进程都被赋予唯一的、内部使用的数值型进程号（0~32768的正整数），操作系统内核函数可通过进程号来引用PCB。常用的标识信息包括进程标识ID、进程组标识ID、用户进程名、用户组名等 现场信息 现场信息用于保留进程在运行时存放在处理器现场中的各种信息，包括通用寄存器内容、控制寄存器内容、栈指针、程序状态字等。进程在让出处理器时，必须将此时的现场信息保存到它的PCB中，而当此进程恢复运行时也应恢复处理器现场 控制信息 控制信息用于管理和调度进程，包括进程调度的相关信息、进程组成信息、进程间的族系信息、进程间通信信息、进程段/页表和进程映像在外存中的地址、CPU的占用和使用信息、进程特权信息、资源清单、文件传输和I/O信息 进程队列及其管理进程的主要特征主要由PCB来刻画，为了便于对进程进行管理和调度，常常将进程的PCB通过某种方式组织起来，一般来说，把处于同一状态的所有进程的PCB链接在一起的数据结构称为进程队列（process queue），简称队列。有两种队列组织方式，链接方式和索引方式： 链接方式 对同一状态进程的PCB，通过PCB中的链接指针将其链接成队列 不同状态的进程可以排成不同队列，如： 运行队列 通常只有一个进程 就绪队列 可按照优先级或者FCFS的原则排队，也可按照进程优先级的高低分成多个就绪队列 等待队列 通常有多个，对应不同的等待状态，如等待I/O操作完成、等待信号量等 此外，还可以将空闲PCB结构链接成自由队列以便使用 当发生某个事件使进程状态发生转换时，此进程就要退出所在队列而排入另一个队列中去。处理器调度中负责进程入队和出队工作的功能模块称为队列管理模块，其任务是对进程的PCB重新排队并修改其状态和响应链接结构 索引方式 索引方式利用索引表记录不同状态进程的PCB地址或在PCB表中的编号，系统建立若干索引表，如就绪索引表、等待索引表、空闲索引表等。状态相同进程的PCB组织在同一张索引表中，每个索引表的表目中存放PCB地址或在PCB表中的编号，各索引表在内存中的起始地址放在内核专用指针单元中 进程上下文切换与处理器状态转换进程上下文切换中断和异常是激活操作系统的仅有方法，它暂停当前运行进程的执行，把处理器转换至内核态，内核获得处理器控制权之后，如果需要就可以实现进程上下文切换，所以进程切换必定在内核态而非用户态发生。 内核在处理中断事件或系统调用过程中可能会导致被阻塞的高优先级进程变为就绪态（等待事件发生或在等待信号到达），或在处理时钟中断事件期间发现运行进程的时间片耗尽，或当前运行进程执行阻塞型I/O指令等，均有可能引发内核实施进程上下文切换。 执行上下文切换时，保存老进程的上下文并装入新进程的上下文，以便新进程运行。 实现进程上下文切换的步骤： 保存被中断进程的处理器现场信息 修改被中断进程PCB的有关信息，如进程状态等 把被中断进程的PCB加入相关队列 选择占用处理器运行的另一进程 修改被选中进程PCB的有关信息，如改为就绪态 设置被选中进程的地址空间，恢复存储管理信息 根据被选中进程的上下文信息恢复处理器现场 进程上下文切换时机进程调度和切换是操作系统内核程序，内核处理过程中发现满足调度条件便可请求重新调度 原则上，发生请求重新调度事件、执行调度程序和实施进程上下文切换工作应该连续发生，但是实际上由于种种原因不能连续完成，内核中不能立即进行调度和切换的情况有： 内核正在处理中断的过程中 进程运行在内核临界区中 内核处在需要屏蔽中断的原子操作中 在上述情况中产生引起调度条件而不能马上进行调度和切换，系统采用置请求调度标志延迟到敏感性操作完成后才进行。Linux在进程task_struct设计重调度标志need_resched，当需要进程重调度时先置调度标志位，在调度时机来临时判别标志位是否为1，以决定要否进行调度。Linux调度时机分为： 主动调度 调用schedule()函数来释放CPU引起新一轮调度，通常发生在当前进程状态被改变，如执行了read()、write()、exit()等系统调用，导致进程终止、进程阻塞等 被动调度 发生了引起调度的条件，通常发生在新进程产生、某个进程优先级改变、进程被唤醒、进程时间片用完等。这时仅置进程TIF_NEED_RESCHED调度标志。调度标志设置有如下情况： 时钟中断中调用函数scheduler_tick()，它负责查看当前进程（实时进程除外）的时间片是否耗尽，如果是，则设置重调度标志 函数try_to_wake_up()将阻塞的进程唤醒，把它加入运行队列中，如果其优先级比当前正在运行的进程优先级高，则设置重调度标志。此外，设置应用程序优先级参数nice值、创建新进程、SMP负载均衡时都有可能使高优先级进程进入就绪状态，也都可能设置重调度标志 执行sched_setscheduler()（设置调度策略）、sched_yield()（暂时让出处理器）、pause()（暂停）等系统调用时，均要设置重调度标志 每当中断处理和系统调用处理结束返回时，在ret_from_sys_call代码段中会主动测试调度标志，若置位则调用schedule()函数 处理器状态转换与进程上下文切换有关的是处理器状态转换（又称处理器模式转换），从用户态到内核态或从内核态到用户态是处理器的状态转换，此时仍在同一个进程中运行 当发生中断或系统调用时暂停当前正在运行的进程，把处理器状态从用户态转换到内核态，执行操作系统服务例程，这是一次状态转换，此时进程仍在自己的上下文中执行，仅处理器状态发生变化，内核在被中断进程的上下文中进行处理 处理器状态转换步骤： 保存被中断进程的处理器现场信息 处理器从用户态转换到内核态，以便执行系统服务例程或中断处理程序 如果处理中断，可根据所规定的中断级别设置中断屏蔽位 根据系统调用号或中断号，从系统调用表或中断入口地址表中找到系统服务例程或中断处理程序的地址 处理器状态转换不同于进程上下文切换，在大多数情况下，状态转换不一定引起上下文切换，在完成系统调用服务或中断处理之后，可通过逆向处理器状态转换来恢复被中断进程运行 处理器执行进程在任何时刻必处于以下4个活动范围内： 用户空间中，处于进程上下文，应用进程在用户态下运行，使用用户栈 内核空间中，处于进程上下文，内核代表进程在内核下运行，使用核心栈 内核空间中，处于中断上下文，与任何进程无关，中断服务例程在内核态下处理特定中断 内核空间中，内核线程（无用户地址空间的进程）运行于内核态 Linux中进程上下文切换与处理器状态转换 进程控制和管理","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://QQ876684433.github.io/categories/操作系统/"},{"name":"笔记","slug":"操作系统/笔记","permalink":"http://QQ876684433.github.io/categories/操作系统/笔记/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://QQ876684433.github.io/tags/操作系统/"},{"name":"进程管理","slug":"进程管理","permalink":"http://QQ876684433.github.io/tags/进程管理/"}]},{"title":"linux下制作ext4文件系统镜像","slug":"linux下制作ext4文件系统镜像","date":"2019-11-07T15:47:51.000Z","updated":"2019-11-07T15:52:13.718Z","comments":true,"path":"2019/11/07/linux下制作ext4文件系统镜像/","link":"","permalink":"http://QQ876684433.github.io/2019/11/07/linux下制作ext4文件系统镜像/","excerpt":"","text":"linux下制作ext4文件系统镜像 由于网上的资料基本上都是一样的，大家抄来抄去，找不到最初的原作者，所以也没法在这里给出原文作者，但是声明一下，以下内容是转载自网络的 步骤如下： 生成一个空的2MiB文件 dd if=/dev/zero of=rootfs.ext4 bs=1024 count=2048 (指定每一块大小为1024字节，一共又2048块，那么就是2048 * 1024 B = 2MiB) 对生成的文件进行格式化 mkfs.ext4 rootfs.ext4 挂载此空镜像 mount -o loop rootfs.ext4 /mnt 向挂载好的文件系统中写入需要加入的文件 cp everyfile /mnt 卸载根文件系统(意味着镜像已经制作完成) umount /mnt 将镜像写入sd卡的某个分区中 dd if=rootfs.ext4 of=/dev/mmcblk0p3 此时挂载一下sd卡的某分区即可在发现刚才复制进去的文件","categories":[{"name":"linux","slug":"linux","permalink":"http://QQ876684433.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://QQ876684433.github.io/tags/linux/"},{"name":"ext4","slug":"ext4","permalink":"http://QQ876684433.github.io/tags/ext4/"}]},{"title":"NASM学习记录","slug":"NASM学习记录","date":"2019-11-07T06:34:04.000Z","updated":"2019-11-23T08:56:55.869Z","comments":true,"path":"2019/11/07/NASM学习记录/","link":"","permalink":"http://QQ876684433.github.io/2019/11/07/NASM学习记录/","excerpt":"","text":"NASM学习记录零散知识点NASM汇编程序中的宏定义NASM汇编程序中的宏定义的格式如下: 123%macro 宏名 参数名列表 宏体%endmacro 例如： 1234567%macro Descriptor 3dw %2 &amp; 0FFFFh dw %1 &amp; 0FFFFh db (%1 &gt;&gt; 16) &amp; 0FFh dw ((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh) db (%1 &gt;&gt; 24) &amp; 0FFh %endmacro ; 共 8 字节 这个宏定义了操作系统中描述符的格式，宏名为：Descriptor 。使用时只需定义： 1Descriptor 参数1, 参数2, 参数3 即可。其中宏定义中的%1代表参数1，%2代表参数2，%3代表参数3 EQU指令 原文链接：https://blog.csdn.net/liukun321/article/details/5549023 有时，一个表达式在程序中会多次出现，重复书写可能较为繁杂，易出错。另一方面。如果要对该表达式进行变动，那么必须在程序中找到每一个表达式，一一做出修改，稍有不慎，就会遗漏，引出麻烦。利用EQU伪指令，就可以避免这些问题的发生。 $$格式：&lt;符号名&gt; EQU &lt;表达式&gt;$$ 该伪指令的含义是为EQU后面的&lt;表达式&gt;起一个叫做&lt;符号名&gt;的名字。这样一来，程序中凡是需要用到该表达式的地方，就都可以用这个名字代替了。这里，&lt;表达式&gt;可以是任何有效的数据，可以是能够算出值的表达式，也可以是有效的助记符等。 例 COUNT EQU 256 表示赋予数256一个名字，叫做COUNT。 VAR1 EQU COUNT-2 表示赋予表达式COUNT-2一个名字，叫做VAR1。如果有COUNT EQU 256在先，那么由于COUNT是数值256，所以VAR1就代表数值254。 PH EQU PUSH 表示赋予PUSH一个名字PH。由于PUSH是汇编语言的一个助记符，因此，在程序中书写PH AX，就相当于 PUSH AX。 伪指令= 与EQU伪指令类似的是等号伪指令“=”。它们的区别是：由EQU伪指令定义后的符号名是不能重复再定义的，而“=”伪指令中定义的符号名可重复定义。例如： 12345EMP=7┋EMP=EMP+2 这表示，开始把符号名EMP定义为是数值7，后来把符号名EMP重新定义为代表数值9。但是不能写成： 12345EMP EQU 7┋EMP EQU EMP+2 LGDT指令 原文：http://www.hgy413.com/hgydocs/IA32/instruct32_hh/vc155.htm LGDT/LIDT - 用于加载全局/中断描述符表格寄存器 操作码 指令 说明 0F 01 /2 LGDT m16&amp;32 将 m 加载到 GDTR 0F 01 /3 LIDT m16&amp;32 将 m 加载到 IDTR 将源操作数中的值加载到全局描述符表格寄存器 (GDTR) 或中断描述符表格寄存器 (IDTR)。源操作数指定 6 字节内存位置，它包含全局描述符表格 (GDT) 或中断描述符表格 (IDT) 的基址（线性地址）与限制（表格大小，以字节计）。如果操作数大小属性是 32 位，则将 16 位限制（6 字节数据操作数的 2 个低位字节）与 32 位基址（数据操作数的 4 个高位字节）加载到寄存器。如果操作数大小属性是 16 位，则加载 16 位限制（2 个低位字节）与 24 位基址（第三、四、五字节）。这里，不使用操作数的高位字节，GDTR 或 IDTR 中基址的高位字节用零填充。 LGDT 与 LIDT 指令仅用在操作系统软件中；它们不用在应用程序中。在保护模式中，它们是仅有的能够直接加载线性地址（即，不是段相对地址）与限制的指令。它们通常在实地址模式中执行，以便处理器在切换到保护模式之前进行初始化。 CLD指令 来源：https://c9x.me/x86/html/file_module_x86_id_29.html CLD指令主要是用来清除EFLAGS寄存器中的DF标志位，即DF = 0，对其他标志位无影响 DF标志(DF flag)这个方向标志(位于EFLAGS寄存器的第10位)控制串指令(MOVS, CMPS, SCAS, LODS以及STOS)。设置DF标志使得串指令自动递减（从高地址向低地址方向处理字符串），清除该标志则使得串指令自动递增。STD以及CLD指令分别用于设置以及清除DF标志。 When the DF flag is set to 0, string operations increment the index registers (ESI and/or EDI). 即DF = 0时，字符串操作会自动递增索引寄存器ESI和/或EDI LODS指令 来源：https://baike.baidu.com/item/LODS 汇编语言串装入指令（load string），规定源操作数为(DS:SI)，目的操作数隐含为AL（字节）或AX（字）寄存器。三种指令都用于将目的操作数的内容取到AL或AX寄存器，字节还是字操作由寻址方式确定，并根据寻址方式自动修改SI的内容 LODS SRC 语法格式： LODS SI ；DST隐含为AL（字节）或AX（字） LODSB ；字节操作，DST隐含为AL，SRC隐含为SI LODSW ；字操作， DST隐含为AX，SRC隐含为SI 注意：不影响标志位，一般不带重复前缀 执行的操作： （AL）←（DS:SI），（SI）←（SI）±1(字节) （AX）←（DS:SI），（SI）←（SI）±2(字) 控制寄存器cr0 来源： https://en.wikipedia.org/wiki/Control_register https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8 控制寄存器（CR0～CR3）用于控制和确定处理器的操作模式以及当前执行任务的特性。CR0中含有控制处理器操作模式和状态的系统控制标志；CR1保留不用；CR2含有导致页错误的线性地址；CR3中含有页目录表物理内存基地址，因此该寄存器也被称为页目录基地址寄存器PDBR（Page-Directory Base address Register） CR0 has various control flags that modify the basic operation of the processor. Bit Name Full Name Description 0 PE Protected Mode Enable If 1, system is in protected mode, else system is in real mode 1 MP Monitor co-processor Controls interaction of WAIT/FWAIT instructions with TS flag in CR0 2 EM Emulation If set, no x87 floating-point unit present, if clear, x87 FPU present 3 TS Task switched Allows saving x87 task context upon a task switch only after x87 instruction used 4 ET Extension type On the 386, it allowed to specify whether the external math coprocessor was an 80287 or 80387 5 NE Numeric error Enable internal x87 floating point error reporting when set, else enables PC style x87 error detection 16 WP Write protect When set, the CPU can’t write to read-only pages when privilege level is 0 18 AM Alignment mask Alignment check enabled if AM set, AC flag (in EFLAGS register) set, and privilege level is 3 29 NW Not-write through Globally enables/disable write-through caching 30 CD Cache disable Globally enables/disable the memory cache 31 PG Paging If 1, enable paging and use the § CR3 register, else disable paging. 要注意的是其中的两个标志位： PE CR0的位0是启用保护（Protection Enable）标志。当设置该位时即开启了保护模式；当复位时即进入实地址模式。这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG标志都要置位 PG CR0的位31是分页（Paging）标志。当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于物理地址。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位 retf指令 原文链接：https://blog.csdn.net/ZCMUCZX/article/details/80216145 关于ret指令和retf指令 ret指令是用栈中的数据，修改IP的内容，从而实现了近转移(就是只修改IP)retf指令是用栈中的数据，修改CS和IP的内容，从而实现了远转移(就是修改了CS和IP)当CPU执行指令ret的时候，会进行下面的操作 121、(IP)= ((ss *16)+(sp))2、(sp)=(sp)+2 当CPU执行指令retf的时候相当于进行了下面的操作 12341、(IP)= ((ss *16)+(sp))2、(sp)=(sp)+23、(CS)=((ss *16)+(sp))4、(sp)=(sp)+2 其实就相当于CPU在执行ret指令的时候就是在执行下面的汇编语句 1pop IP CPU在执行retf指令的时候其实就是在执行下面的汇编语句 12pop IPpop CS stosb, stosw, stosd指令stosb, stosw, stosd这三个指令把al/ax/eax的内容存储到edi指向的内存单元中，同时edi的值根据方向标志的值增加或者减少 LTR指令LTR - 加载任务寄存器： 将源操作数加载到任务寄存器的段选择器字段。源操作数（通用寄存器或内存位置）包含指向任务状态段 (TSS) 的段选择器。段选择器加载到任务寄存器之后，处理器使用段选择器在全局描述符表格 (GDT) 中确定 TSS 的段描述符的位置。接着，它将 TSS 的段限制与基址从段描述符加载到任务寄存器。任务寄存器指向的任务标记为忙，但不发生任务切换 提供的 LTR 指令用于操作系统软件；不应该在应用程序中使用它。它只能在 CPL 为 0 时在保护模式中执行。它常用在初始化代码，建立要执行的第一个任务 操作数大小属性不影响此指令。 DIV指令指令格式： 123DIV reg8/mem8DIV reg16/mem16DIV reg32/mem32 div指令只有一个操作数，即除数，被除数保存在AX（或者DX:AX，EDX:EAX）中，计算的结果商保存在AL（或者AX，EAX），余数保存在AH（或者DX，EDX），如图： MUL指令MUL: 无符号乘 影响 OF、CF 标志位指令格式: 1MUL r/m 参数是乘数 如果参数是 r8/m8, 将把 AL 做乘数, 结果放在 AX 如果参数是 r16/m16, 将把 AX 做乘数, 结果放在 EAX 如果参数是 r32/m32, 将把 EAX 做乘数, 结果放在 EDX:EAX cmp和test的区别test逻辑与运算结果为零,就把ZF(零标志)置1;cmp 算术减法运算结果为零,就把ZF(零标志)置1. in和out端口指令 in：从端口读取数据 out：把数据写入端口 0-255时，8位端口用al，16位端口用ax 256-65535时，用dx 传输的时候需要先进入地址端口，再传输数据；比如70h为地址端口，71h为数据端口，读取2号单元的内容： 123mov al,2hout 70h,alin al,71h %rep预处理指令例如： 123%rep 128 Gate SelectorCode32, SpuriousHandler, 0, DA_386IGate%endrep 指令的作用是让Gate SelectorCode32, SpuriousHandler, 0, DA_386IGate重复执行128次 MOVZX指令movzx一般用于将较小值拷贝到较大值中 SGDT/SIDT指令将全局描述符表格寄存器 (GDTR) 或中断描述符表格寄存器 (IDTR) 中的内容存储到目标操作数。目标操作数是指定 6 字节内存位置。如果操作数大小属性为 32 位，则寄存器的 16 位限制字段存储到内存位置的 2 个低位字节，32 位基址存储到 4 个高位字节。如果操作数大小属性为 16 位，则限制字段存储在 2 个低位字节，24 位基址存储在第三、四及五字节，第六字节使用 0 填充。 SGDT 与 SIDT 指令仅在操作系统软件中有用；不过它们也可以在应用程序中使用，而不会导致生成异常。 hlt指令 使程序停止运行，处理器进入暂停状态，不执行任何操作，不影响标志。当RESET线上有复位信号、CPU响应非屏蔽中断、CPU响应可屏蔽中断3种情况之一时，CPU脱离暂停状态，执行HLT的下一条指令 如果hlt指令之前，做了cli，那可屏蔽中断不能唤醒cpu hlt是“只能在实方式和ring0执行的指令”，要区别于“IO敏感指令”。通过设置IOPI或IO许可位图，可以让ring1乃至ring3执行“IO敏感指令”，但“只能在实方式和ring0执行的指令”是规定死的","categories":[{"name":"汇编","slug":"汇编","permalink":"http://QQ876684433.github.io/categories/汇编/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"http://QQ876684433.github.io/tags/汇编/"},{"name":"NASM","slug":"NASM","permalink":"http://QQ876684433.github.io/tags/NASM/"}]},{"title":"数据库课堂笔记（2019-11-05）","slug":"数据库课堂笔记（2019-11-05）","date":"2019-11-05T06:00:53.000Z","updated":"2019-11-05T06:00:53.384Z","comments":true,"path":"2019/11/05/数据库课堂笔记（2019-11-05）/","link":"","permalink":"http://QQ876684433.github.io/2019/11/05/数据库课堂笔记（2019-11-05）/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数据库课堂笔记（2019-10-29）","slug":"数据库课堂笔记（2019-10-29）","date":"2019-10-29T05:58:08.000Z","updated":"2019-10-29T05:58:51.348Z","comments":true,"path":"2019/10/29/数据库课堂笔记（2019-10-29）/","link":"","permalink":"http://QQ876684433.github.io/2019/10/29/数据库课堂笔记（2019-10-29）/","excerpt":"","text":"数据库课堂笔记 参考资料： 南大软件学院课程《数据管理基础》课程资料 《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著 《数据库系统概论》第五版 - 王珊 萨师煊 著 《数据库系统概念》 数据库课堂笔记（2019-10-29）Ch06 Database Design","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"},{"name":"笔记","slug":"数据库/笔记","permalink":"http://QQ876684433.github.io/categories/数据库/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/tags/数据库/"}]},{"title":"使用Oracle嵌入式SQL预处理器Pro*C过程记录","slug":"使用Oracle嵌入式SQL预处理器Pro-C过程记录","date":"2019-10-24T08:23:28.000Z","updated":"2019-10-24T09:13:48.038Z","comments":true,"path":"2019/10/24/使用Oracle嵌入式SQL预处理器Pro-C过程记录/","link":"","permalink":"http://QQ876684433.github.io/2019/10/24/使用Oracle嵌入式SQL预处理器Pro-C过程记录/","excerpt":"","text":"使用Oracle嵌入式SQL预处理器Pro*C过程记录这玩意儿坑还挺多的，主要还是资料比较少，废话少说，先上参考链接： 参考： https://www.cnblogs.com/uriel/p/4275423.html https://blog.csdn.net/Leafage_M/article/details/72082011 说明：这篇文章主要是记录摸索过程中的关键步骤，以便后面使用的时候有章可循，具体关于Oracle的ESQL以及Pro*C的进阶使用，后面有时间会专门开一系列博客来记录 背景在数据库课程学习上，专门有一章是用来讲Oracle嵌入式SQL（ESQL）的，主要是结合C语言来讲解。但是由于课上只是在书面上讲，而且这玩意之前没有听说过，总感觉如果不上手玩一玩的话就不能更加深入理解这玩意儿，所以就决定上手体验一下，从此开启了踩坑之路。 编程环境： Oracle数据库使用的是阿里云的Docker镜像（registry.cn-hangzhou.aliyuncs.com/qida/oracle-xe-11g） 开发环境是Deepin Linux 15.11 工具安装 Oracle的嵌入式SQL的预编译工具是Pro*C，它的编译过程是这样的： 1Pro*C源文件(*.pc) -&gt; C源文件(*.c) -&gt; 目标文件(*.o) -&gt; 可执行文件 所以首先要安装这个预编译工具，这里可以直接从oracle官网下载： https://www.oracle.com/database/technologies/instant-client/precompiler-112010-downloads.html 官网没有提供deb安装包，但是有rpm安装包，只需要通过alien命令来安装即可： 1sudo alien -i xxxx.rpm 安装完成后，可以通过命令proc -help查看是否安装成功，proc就是Pro*C预编译器入口命令 Pro*C头文件和库文件原先我想的是直接将ProC安装到我的主机上，然后将预处理和编译过程都放在本机上完成，然后运行时直接访问docker中的oracle数据库。理论上应该是可行的，但后来我发现一个问题就是，我本机没有安装oracle数据库，自然在开发Pro\\.C源程序的时候会找不到相关的Pro*C头文件和库文件，就是下面这些： 而从原博客中可以看出，这些头文件和库文件是随着oracle的安装就被安装进去的，这时我想到了，这些头文件和库文件应该是躺在Docker中的oracle容器中的： 123456789root@989eb62277c6:/u01/app/oracle/product/11.2.0/xe/precomp# tree ..|-- admin| `-- ottcfg.cfg`-- lib `-- ottclasses.zip2 directories, 2 filesroot@989eb62277c6:/u01/app/oracle/product/11.2.0/xe/precomp# 然而实际上是没有的orz，官网的原文是这样说的： The ORACLE_BASE\\ORACLE_HOME\\precomp\\public directory contains the Pro*C/C++ header files https://docs.oracle.com/cd/B19306_01/win.102/b14321/use.htm 估计被精简掉了。。。 场面一度很焦灼，先摸索一会儿，找到解决方案后再更新orz。。。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"}],"tags":[{"name":"Pro*C","slug":"Pro-C","permalink":"http://QQ876684433.github.io/tags/Pro-C/"},{"name":"Oracle","slug":"Oracle","permalink":"http://QQ876684433.github.io/tags/Oracle/"},{"name":"嵌入式SQL","slug":"嵌入式SQL","permalink":"http://QQ876684433.github.io/tags/嵌入式SQL/"},{"name":"Embedded SQL","slug":"Embedded-SQL","permalink":"http://QQ876684433.github.io/tags/Embedded-SQL/"}]},{"title":"数据库课堂笔记（2019-10-24）","slug":"数据库课堂笔记（2019-10-24）","date":"2019-10-24T05:51:33.000Z","updated":"2019-10-24T05:53:08.052Z","comments":true,"path":"2019/10/24/数据库课堂笔记（2019-10-24）/","link":"","permalink":"http://QQ876684433.github.io/2019/10/24/数据库课堂笔记（2019-10-24）/","excerpt":"","text":"数据库课堂笔记 参考资料： 南大软件学院课程《数据管理基础》课程资料 《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著 《数据库系统概论》第五版 - 王珊 萨师煊 著 《数据库系统概念》 数据库课堂笔记（2019-10-24）Ch05 Programs to Access a Database","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"},{"name":"笔记","slug":"数据库/笔记","permalink":"http://QQ876684433.github.io/categories/数据库/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/tags/数据库/"}]},{"title":"new/delete vs malloc/free","slug":"new_delete vs malloc_free","date":"2019-10-24T04:08:04.000Z","updated":"2019-10-24T04:10:25.784Z","comments":true,"path":"2019/10/24/new_delete vs malloc_free/","link":"","permalink":"http://QQ876684433.github.io/2019/10/24/new_delete vs malloc_free/","excerpt":"","text":"new/delete vs malloc/free","categories":[{"name":"C++","slug":"C","permalink":"http://QQ876684433.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://QQ876684433.github.io/tags/C/"},{"name":"new","slug":"new","permalink":"http://QQ876684433.github.io/tags/new/"},{"name":"delete","slug":"delete","permalink":"http://QQ876684433.github.io/tags/delete/"},{"name":"malloc","slug":"malloc","permalink":"http://QQ876684433.github.io/tags/malloc/"},{"name":"free","slug":"free","permalink":"http://QQ876684433.github.io/tags/free/"}]},{"title":"操作系统-存储管理","slug":"操作系统-存储管理","date":"2019-10-23T13:23:37.000Z","updated":"2019-10-25T02:03:19.727Z","comments":true,"path":"2019/10/23/操作系统-存储管理/","link":"","permalink":"http://QQ876684433.github.io/2019/10/23/操作系统-存储管理/","excerpt":"","text":"存储管理 参考资料： 操作系统教程（第5版） - 费翔林 骆斌 编著 内存空间一般分为两部分： 系统区：存放操作系统内核程序和数据结构等 用户区：存放应用程序和数据 有效的存储管理也是多道程序设计技术的关键支撑，存储管理包含以下功能： 存储器工作原理存储器层次目前计算机均采用层次结构的存储子系统，自上至下依次为：寄存器、缓存、内存、磁盘、磁带5层。其中寄存器、缓存和内存是操作系统存储管理的管辖范畴；磁盘和磁带属于文件管理和设备管理的管辖对象。 地址转换与存储保护源程序在计算机上运行涉及的过程： 编译程序或汇编程序处理源程序并生成目标代码（程序） 链接程序将目标代码链接为一个可重定位代码（程序），此时程序处在逻辑地址空间中 装载程序将可执行代码装入物理地址空间，直到此时程序才能运行 程序编译程序编译指的是编译程序（compiler）或汇编程序（assembly）的处理生成目标模块（目标代码）。一个程序可以由独立编写的且具有不同功能的多个源程序模块组成，由于模块包含外部引用，即指向其他模块中的数据或指令地址，或包含对库函数的引用，编译程序或汇编程序负责记录引用发生的位置，其处理结果将产生相应的多个目标模块，每个目标模块都附有供引用使用的内部符号表和外部符号表。符号表中依次给出各个符号名及在本目标模块中的名字地址，在模块被链接时进行转换 程序链接链接程序（linker）的作用是根据目标模块之间的调用和依赖关系，将主模块、被调模块以及所用到的库函数装配和链接成一个完整的可装载执行模块。 根据程序链接发生的时刻和链接的方式，程序链接可以分成以下三种方式： 静态链接 在程序装载到内存和运行之前，就已经将它的所有目标模块及所需要的库函数进行链接和装配成一个完整的可执行程序且此后不再拆分 简单来说就是在链接阶段，将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件，该可执行文件可能会比较大 这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行 缺点是：文件太大，一个全静态方式生成的简单print文件都有857K。而动态链接生成的一样的可执行文件却只要8.４Ｋ reference：https://blog.csdn.net/freestyle4568world/article/details/49817799 可重定位目标程序： 动态链接 程序在装入内存前并未事先进行程序各目标模块的链接，而是在程序装载时一边装载一遍链接，生成一个可执行程序。 在装载目标模块时，若发生外部模块调用，将引发外部目标模块的搜索、装载和链接 同时若发现所需某部目标模块已在内存，可直接进行链接且无需再次装载，支持目标模块的共享 运行时链接 将某些目标模块或库函数的链接推迟到执行时才进行。在程序执行过程中，若发现被调用模块或库函数尚未链接，先在内存中进行搜索以查看其是否装入内存 若已装入，则直接将其链接到调用者程序中 否则进行该模块在外存上的搜索，以及装入内存和进行链接，生成一个可执行程序 运行时链接的好处： 避免事先无法知道本次要运行哪些目标模块 避免程序执行过程中不被调用的某些目标模块在执行前进行链接和装载而引起的开销，提高系统资源利用率和系统效率 采用运行时链接时，程序执行所需要的库函数所在的部分目标模块是伴随着其被调用才动态进行装载和链接。具体的做法是：不必将程序所需的外部函数代码从系统库中提取出并链入目标模块中，而仅仅是在程序调用处登记调用信息，记录函数名及入口号，形成调用链接；一旦函数库调入内存后，就可以确定所调函数在内存的物理地址。 程序装载装载程序（loader）把可执行程序装入内存的方式有三种： 磁盘中的装载模块使用的是逻辑地址，逻辑地址的集合称为进程的逻辑地址空间： 逻辑地址空间可以是一维的，这时逻辑地址限制在从0开始顺序排序的地址空间内 逻辑地址空间也可以是二维的，这时整个程序被分为若干段，每段都有不同段号，段内地址从0开始顺序编址 物理内存从统一的基地址开始顺序编址的存储单元称为物理地址或绝对地址，物理地址的总体构成物理地址空间 可执行程序逻辑地址转换（绑定）为物理地址的过程称为地址重定位、地址映射或地址转换，基于程序装入方式的不同，可以区分三种地址重定位： 静态地址重定位 动态地址重定位 运行时链接地址重定位 为了允许程序因对换或空闲区收集而被移动（会导致正在执行的程序在不同时刻处于内存的不同位置），必须使用动态地址重定位。动态地址重定位要借助于硬件地址转换机制来实现，重定位寄存器的内容通常保护在进程控制块中，每当执行进程上下文切换时，当前运行进程的重定位寄存器中的内容与其他信息被一起保护起来，新进程的重定位寄存器的内容会被恢复，这样进程就在上次中断的位置恢复运行，所使用的是与上次在此位置的同样的内存基地址。 存储保护涉及防止地址越界和控制正确存取： 地址越界保护：无论采用何种地址重定位方式，通常进程运行时产生的所有内存访问地址都应进行检查，确保进程仅访问自己的内存区，以免破坏其他进程的内存区 信息存取保护：进程在访问分配给自己的内存区时，要对访问权限进行检查，如允许读、写、执行等，从而确保数据的安全性和完整性，防止有意或无意的误操作而破坏内存信息 连续存储管理固定分区存储管理固定分区又称为静态分区模式，基本思想是：内存空间被划分为数目固定不变的分区，各分区大小不等，每个分区只装入一个作业，若多个分区中都装有作业，则它们可以并发执行。 为了说明各分区分配和使用情况，需要设置一张内存分配表，记录内存中划分的分区及其使用情况。内存分配表指出各分区起始地址和长度，占用标志用来指示此分区是否被使用，当其值为0时，表明此分区尚未被占用。 固定分区管理的一项任务是何时及如何把内存空间划分成分区。这项工作通常由系统管理员和操作系统初始化模块协同完成。系统初次启动时，管理员根据当天作业情况把内存划分成大小不等但数目固定的分区。 排队策略作业进入固定分区的两种排队策略： 一是每个分区有单独的作业等待队列，调度程序选中作业后，创建用户进程并将其排入一个能够装入它的最小分区的进程等待队列尾部，当此分区空闲时，就装入队首进程执行 好处是可以使装入分区浪费的空间最小 但是如果等待处理的作业大小很不均匀，将导致分区有的空闲而有的忙碌 二是所有等待处理的作业排成一个等待队列，每当有分区空闲时，就从队首依次搜索分区长度能够容纳的作业以便装入执行；为了防止小作业占用大分区，也可以搜索分区长度能够容纳的最大作业装入执行 优缺点优点： 实现简单，对于程序大小和出现频率已知的情形还是比较合适的 解决了单道程序运行在并发环境下不能与CPU速度匹配的问题 解决了单道程序运行时内存空间利用率低的问题 缺点： 可变分区存储管理可变分区内存空间的分配和去配可变分区（variable partition）存储管理又称为动态分区模式，按照作业大小来划分分区，但划分的时间、大小、位置都是动态的。系统把作业装入内存时，根据其所需要的内存容量查看是否有足够的空间，若有则按需分割一个分区分配给此作业；若无则令此作业等待资源。 可变分区能够克服固定分区内存资源浪费的问题，有利于多道程序设计，提高内存资源利用率。 内存中分区数目和大小随着作业的执行而不断改变，为了方便内存空间的分配和去配，用于管理的数据结构可由两张表组成：已分配区表和未分配区表。 当装入新作业时，从未分配区表中找出一个足够容纳它的空闲区，将此区分成两部分，一部分用来装入作业，成为已分配区；另一部分仍是空闲区（若有）。 这时应该从分配区表中找出一个空栏目登记新作业的起始地址、占用长度，同时修改未分配区表中空闲区的长度和起始地址 当作业撤离时，已分配区表中的相应状态改为空闲，而将收回的分区登记到未分配区表中，若有相邻空闲区再将其连接后登记 当一个作业X撤离时的四种情况： 由于分区数目不定，而且分区表占用了较多的额外空间，采用链表是另一种较好的空闲区管理方法： 通过指针把所有的空闲区链接起来，每个空闲区的开头单元存放本空闲区长度及下一个空闲区起始地址指针，系统设置指向空闲区链的头指针 使用时，沿链查找并取一个长度能够满足要求的空闲分区分配给进程，再修改链表 归还时，把此空闲区链入空闲区链表的相应位置即可 空闲区链表管理比空闲区表格管理复杂，但是优点是链表自身并不占用存储单元 可变分区分配算法 最先适应（first fit）分配算法 下次/邻近适应（next fit）分配算法 最优适应（best fit）分配算法 最坏适应（worst fit）分配算法 快速适应（quick fit）分配算法 地址转换和存储保护 对固定分区采用静态地址重定位，进程运行时使用绝对地址，可由加载程序进行地址越界检查 对可变分区则采用动态地址重定位，进程的程序和数据的地址转换由硬件完成，硬件设置两个专用控制寄存器： 基址寄存器：存放分配给进程使用的分区的起始地址 限长寄存器：存放分配给进程所占用的连续存储空间的长度 多道程序系统中，硬件只需要设置一对基址/限长寄存器： 进程在执行过程中出现等待事件时，操作系统把基址/限长寄存器的内容随此进程的其他信息（如PSW、通用寄存器等）一起保护起来 另一个被选中执行的线程，则将其基址/限长值再送入基址/限长寄存器 在有N个重定位寄存器的机器中，允许每个进程获得N个不同的内存段，并在运行时进行动态地址重定位： 如果每个进程只能占用一个分区，则不允许各个进程之间有公共区域（因为有存取保护机制） 提供两对或者多对基址/限长寄存器的机器中，允许一个进程占用两个或者多个分区，这样可以通过规定某对基址/限长寄存器的区域是共享的来实现不同进程之间的共享区域，且进程共享部分取相同的基址/限长值： 内存不足的存储管理技术 补充：内部碎片和外部碎片 来源：https://www.cnblogs.com/zlcxbb/p/5759790.html internal fragmentation:when memory allocated to a process is larger than requested memory, the difference between these two numbers is internal fragmentation. 在内存管理中，内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间 external fragmentation:External fragments exists when total memory space exists to satisfy a request, but it is not continous. storage is broken into little pieces. 外部碎片是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块。 一般情况下，固定分区存在内部碎片，可变式分区分配会存在外部碎片； 页式虚拟存储系统存在内部碎片（为了有效的利用内存，使内存产生更少的碎片，要对内存分页，内存以页为单位来使用，最后一页往往装不满，于是形成了内部碎片） 段式虚拟存储系统存在外部碎片（为了共享要分段，在段的换入换出时形成外部碎片，比如5K的段换出后，有一个4k的段进来放到原来5k的地方，于是形成1k的外部碎片） 移动技术当在未分配分区表中找不到足够大的空闲区来装入新进程时，可采用移动技术把已在内存中的进程分区连接到一起，使分散的空闲区汇集成片，也叫内存紧凑（compact） 第一种方式是把所有当前占用的分区内容移动到内存的一端 第二种方式是把占用分区内容移动到内存的一端，但是当产生足够大小的空闲区时就停止移动 内存中的进程在移动过程中，凡是涉及地址的信息都需要进行修改，例如基址寄存器、地址指针、内存分配表等。那么什么时候进行移动？ 一是进程撤销之后释放分区时，如果它不与空闲区邻接，立即实施移动，于是系统始终保持只有一个空闲区 二是进程装入分区时，若空闲区的总和够用，但是没有一个空闲区能容纳此进程时实施移动 移动技术分配内存空间的算法： 移动操作也为进程运行过程中动态扩充内存空间提供了方便，当进程执行过程中要求增加内存空间时，只需要适当移动邻近的占用分区内容就可以增加其所占有的连续区的长度，移动后的基址值和经扩大的限长值都要相应修改 对换技术对换技术（swapping）广泛应用于分时系统调度中，以解决内存容量不足的问题。如果当前一个或者多个驻留进程都处于阻塞态，此时选择其中一个进程，将其暂时移出内存，腾出空间给其他进程使用，同时把磁盘中的某个进程换入内存，让其投入运行，这种互换称为对换。 由于有硬件地址重定位寄存器的支持，对换进来的进程映像被复制到新分配的内存区域并重置定位寄存器的值。 为了有效实施对换，必须确定以下事情： 首先选择哪个进程换出：通常系统把时间片耗尽或优先级较低的进程换出，因为短时间内它们不会投入运行 其次应决定把进程的哪些信息移出去 最后需要确定对换时机 批处理系统中，当进程要求动态扩充内存空间且得不到满足时可触发对换 分时系统中，每个时间片结束或执行I/O操作时实施，调度程度启动一个挪出的进程换入，这样轮到它执行时立即可以启动（需要解决对换过程中进程的地址重定位问题） 与移动不同，对换要访问磁盘，这是I/O集中型操作，但是系统可以让对换与计算型进程并行工作。换出的进程候选者当首选被阻塞的进程，否则就挑选就绪进程，同时需要考虑进程的属性，例如消耗CPU时间、在内存已逗留时间等 覆盖技术移动和对换技术解决因多个程序存在而导致内存区不足的问题，这种内存短缺是暂时的；如果程序长度超过物理内存总和，或超出固定分区大小，则出现内存永久性短缺，大进程无法运行，前两种方法无法解决，解决方案是使用覆盖（overlaying）技术。 但是不足之处是，存储管理工作转给了程序员，他们必须根据物理内存空间来设计和编写程序。 分页存储管理分页存储管理的基本原理采用分页存储管理允许程序存放到若干不相邻的空闲块中，既可免除移动信息工作，又可充分利用内存空间，消除动态分区法中的“碎片”问题，从而提高内存空间利用率 基本概念： 页面：进程逻辑地址空间分成大小相等的区，每个区称为页面或页，页号从0开始依次编号 页框：页框又称为页帧，把内存物理地址空间分成大小相等的区，其大小与页面大小相等，每个区是一个页框（物理块），块号从0开始依次编号 逻辑地址：分页存储器的逻辑地址由页号和页内位移两部分组成 内存页框表：该表长度取决于内存划分的物理块数，编号可与物理块号一致，页框表的表项给出物理块使用情况（0：空闲，1：占用），有的系统还会增加保护位 页表（如下一小节） 页表在进行内存分配时以页框为单位，进程信息有多少页，那么把它装入内存时就分配多少页框，其中进程的逻辑地址是划分成编号连续的页面的，而装入内存的页框却未必相连。每个 （1）页面与被分配的页框如何建立联系？ 页表是操作系统为进程建立的，是程序页面和内存页框的对照表，页表中的每一栏指明程序中的一个页面和分得页框之间的对应关系。 为了减少系统开销，操作系统在内存中开辟存储区（软件）存放进程页表，另外设置页表寄存器（硬件）来存放当前运行进程的页表起始地址，以加快地址转换速度。 进程在内存中的每个页框内的地址是连续的，但是页框之间的地址可以不连续。 （2）逻辑地址（页面）如何转换成物理地址（页框）？ 进程在运行前由系统把它的页表基地址送入页表基址寄存器，运行时借助硬件地址转换机制按页面进行动态地址重定位。 CPU获得逻辑地址后，由硬件自动按设定的页面尺寸分成页号p和页内位移d两部分，先从页表基址寄存器找到页表基地址，再用页号p作为索引查页表，得到对应的页框号 然后计算出要访问的内存单元地址（物理地址），实际上就是页框号和页内位移进行拼接得到物理地址 （3）如何保证程序正确运行？ 虽然进程存放在若干不连续的页框中，但是在执行过程中总能按正确的物理地址进行存取。整个系统只有一个页表基址寄存器，只有占用CPU的进程才占有它；多道程序设计中，当某道程序让出处理器时，应同时让出此寄存器供其他进程使用 翻译块表（Translation Look-aside Buffer，TLB）","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://QQ876684433.github.io/categories/操作系统/"},{"name":"笔记","slug":"操作系统/笔记","permalink":"http://QQ876684433.github.io/categories/操作系统/笔记/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://QQ876684433.github.io/tags/操作系统/"},{"name":"存储管理","slug":"存储管理","permalink":"http://QQ876684433.github.io/tags/存储管理/"}]},{"title":"数据库课堂笔记（2019-10-22）","slug":"数据库课堂笔记（2019-10-22）","date":"2019-10-22T05:52:13.000Z","updated":"2019-10-23T07:12:45.518Z","comments":true,"path":"2019/10/22/数据库课堂笔记（2019-10-22）/","link":"","permalink":"http://QQ876684433.github.io/2019/10/22/数据库课堂笔记（2019-10-22）/","excerpt":"","text":"数据库课堂笔记 参考资料： 南大软件学院课程《数据管理基础》课程资料 《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著 《数据库系统概论》第五版 - 王珊 萨师煊 著 《数据库系统概念》 数据库课堂笔记（2019-10-22）Ch4. Object-Relational SQL (Oracle)Object Types（对象类型）类型的循环嵌套定义对象类型(object type)不能嵌套定义， 但 REF 关系可以实现嵌套引用 123456create type police_officer_t as object( pol_person person_t, badge_number integer, partner ref police_officer_t); REF 的其它约束 两张表之间的相互REF关系的定义 两个具有相互REF关系的表/类型的删除 REF属性数据的加载 Collection Types（集合类型）集合类型允许我们将多个值（即值的集合）存放到一行记录的某一列中，在Oracle中，集合类型有以下两种： 表类型（Table Types，嵌套表） 数组类型（Array Types） 其中数组类型中存放的元素是具有相同的类型（the element type）的 表类型和嵌套表（Table Types and Nested Tables）创建一个表类型（table type）的方法： 1CREATE TYPE dependents_t AS TABLE OF person_t; 这样就可以通过表类型（dependents_t）来定义新的表，而dependents_t则形成一个嵌套表： 123456create table employees ( eid int, eperson person_t, dependents dependents_t, primary key (eid)) 如上，dependents属性的类型就是一个表类型（dependents_t），它是employees的嵌套表 嵌套表的访问 对嵌套表进行访问时，如果需要对表类型属性进行子查询，那么需要使用转换函数：table(…)： 嵌套表属性不能直接使用统计函数，比如count(…)等，同样需要使用转换函数table(…) Oracle 数据库没有提供 nested table 的相等比较运算，但是提供了单个对象的相等比较功能 Oracle是支持嵌套表与表自身的联接查询的 12select e.eid, d.ssnofrom employees e, table(e.dependents) d Oracle的外联接（outer join） 参考：https://www.cnblogs.com/hehaiyang/p/4745897.html 对于外连接， 也可以使用“(+) ”来表示。 关于使用（+）的一些注意事项： （+）操作符只能出现在WHERE子句中，并且不能与OUTER JOIN语法同时使用。 当使用（+）操作符执行外连接时，如果在WHERE子句中包含有多个条件，则必须在所有条件中都包含（+）操作符。 （+）操作符只适用于列，而不能用在表达式上。 （+）操作符不能与OR和IN操作符一起使用。 （+）操作符只能用于实现左外连接和右外连接，而不能用于实现完全外连接。 用（+）来实现， 这个+号可以这样来理解： + 表示补充，即哪个表有加号，这个表就是匹配表。如果加号写在右表，左表就是全部显示，所以是左连接： 1Select * from t_A a,t_B b where a.id=b.id(+); 如果加号写在左表，右表就是全部显示，所以是右连接： 1Select * from t_A a,t_B b where a.id(+)=b.id; 而对于全外联接，左表和右表都不做限制，所有的记录都显示，两表不足的地方均为NULL。 全外连接不支持（+）写法。 嵌套游标（Nested Cursors）可以使用嵌套游标来实现对嵌套表的查询，例如对于普通的查询操作： 123select e.eid, d.ssno as dep_ssofrom employees e, table(e.dependents) dwhere d.age &lt; 16; 可以使用嵌套游标来实现相同的功能： 12345select e.eid, cursor ( select d.ssno as dep_ssno from table(e.dependents) d where d.age &lt; 16) dep_tabfrom employees e; 另外，嵌套游标也可以用来实现对嵌套表属性的统计功能： 1234select eid, cursor ( select count(*) from table(e.dependents) )from employees e; 但是似乎cursor是多余的，因为以下两种方式也可以对嵌套表属性进行统计： Array Types（数组类型）嵌套表类型（Nested Table）和数组类型（VARRAY）的对比： Nested table VARRAY 成员的排列次序 无序 有序 成员的最大数目 没有限制 确定的值 成员的存储组织 单独的存储表 直接存储在原表中 两者在访问模式上的区别： 可以对嵌套表属性执行insert操作， 或通过update操作修改其成员的取值 但对于 VARRAY 属性则不能执行上述的插入或修改操作， 只能通过update语句修改整个 VARRAY 属性的取值","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"},{"name":"笔记","slug":"数据库/笔记","permalink":"http://QQ876684433.github.io/categories/数据库/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/tags/数据库/"}]},{"title":"Makefile学习笔记","slug":"Makefile学习笔记","date":"2019-10-21T02:08:59.000Z","updated":"2019-10-21T02:08:59.036Z","comments":true,"path":"2019/10/21/Makefile学习笔记/","link":"","permalink":"http://QQ876684433.github.io/2019/10/21/Makefile学习笔记/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"操作系统-中断技术","slug":"操作系统-中断技术","date":"2019-10-17T12:57:02.000Z","updated":"2019-10-18T07:44:33.336Z","comments":true,"path":"2019/10/17/操作系统-中断技术/","link":"","permalink":"http://QQ876684433.github.io/2019/10/17/操作系统-中断技术/","excerpt":"","text":"中断技术 参考资料： 操作系统教程（第5版） - 费翔林 骆斌 编著 Linux Kernel Teaching - https://linux-kernel-labs.github.io/master/lectures/interrupts.html 概念​ 每当应用程序执行系统调用要求获得操作系统服务、I/O设备报告传输情况，或者产生各种内部和外部事件时，都需要通过中断机制产生中断信号并启动操作系统内核工作，可以说，操作系统是由“中断驱动”的。最初中断技术仅作为设备向CPU报告I/O操作情况的一种手段，以免CPU因不断地轮训设备而耗费CPU时间，中断的出现解决了主机和设备的并行性问题。 ​ 中断（interrupt）指的是在程序执行过程中遇到急需处理的事件时，暂时终止现行程序在CPU上的运行，转而执行相应的事件处理程序，待处理完成后再返回断点或调度其他程序执行的过程。 ​ 不同的计算机系统中通常有不同的中断源和中断装置，但是它们都有一个共性：中断事件发生后，中断装置能改变处理器内操作的执行顺序。 中断源分类硬中断由硬件发出或产生的中断称为硬中断，按照硬中断事件的来源和实现手段，可以将硬中断划分为外中断和内中断 外中断又称为中断或异步中断，是指来自处理器之外的中断信号，包括：时钟中断、键盘中断、它机中断、外部设备中断等。外中断又分为 可屏蔽中断 不可屏蔽中断 各个中断具有不同的中断优先级，表示事件的紧急程度，在处理高一级中断时，往往会部分或者全部屏蔽低级中断。 内中断又称为异常（exception）或同步中断，是指来自处理器内部的中断信号，通常是由于在程序执行过程中，发现与当前指令关联的、不正常的或错误的事件。内中断可被细分为： 访管中断，由执行系统调用引起 硬件故障中断，如电源失效、奇偶校验错误、总线超时等 程序性异常，如非法操作、地址越界、页面故障、调试指令、除数为0和浮点数溢出等 这些事件都由异常处理程序处理，并且通常依赖于执行程序的当前现场。内中断不能被屏蔽，一旦出现应立即予以响应并进行处理，而异常处理程序运行时是否屏蔽外部中断或屏蔽哪些中断，可根据异常处理的需要来设定 中断和异常的区别 中断由与当前运行程序无关的中断信号触发的，系统不能确定中断事件的发生时间，故中断与CPU是异步的，CPU对中断的响应完全是被动的。中断的发生与CPU当前状态无关，既可以发生在用户态也可以发生在内核态，因为无论是用户态还是内核态，都需要处理外部设备发来的中断请求。一般来说，中断处理程序所提供的服务不是当前进程所需要的，如时钟中断、磁盘中断等 异常是由CPU控制单元产生的，源于现行程序执行指令过程中检测到的例外（exception）。异常与CPU是同步的，允许指令在执行过程期间响应异常，而且允许多次响应异常，大部分异常发生在用户态，而内核态唯一发生的异常是“缺页异常” “中断”应该被快速处理以便及时响应其他中断信号，所以中断处理程序处理过程中是不能阻塞的 “异常”处于被打断的当前进程上下文中，所提供的服务是当前进程所需要的，所以异常处理程序处理过程中是可以阻塞的 中断允许发生嵌套，但异常大多为一重；异常处理过程中可能会发生中断，但是中断处理过程中绝不会被异常打断 reference：https://stackoverflow.com/questions/7295936/what-is-the-difference-between-interrupt-and-exception-context Interrupts and exceptions both alter the program flow. The difference between the two is that interrupts are used to handle external events (serial ports, keyboard) and exceptions are used to handle instruction faults, (division by zero, undefined opcode). Interrupts are handled by the processor after finishing the current instruction. If it finds a signal on its interrupt pin, it will look up the address of the interrupt handler in the interrupt table and pass that routine control. After returning from the interrupt handler routine, it will resume program execution at the instruction after the interrupted instruction. Exceptions on the other hand are divided into three kinds. These are Faults, Traps and Aborts. Faults are detected and serviced by the processor before the faulting instructions. Traps are serviced after the instruction causing the trap. User defined interrupts go into this category and can be said to be traps; this includes the MS- DOS INT 21h software interrupt, for example. Aborts are used only to signal severe system problems, when operation is no longer possible. 中断和异常的响应及服务产生处理器外部中断或者内部异常的时候，CPU都会在执行完当前指令后，根据中断源所提供的“中断向量”，在内核中找到响应中断服务例程并调度执行。 中断向量由硬件或操作系统预先分配和设置，系统调用所对应的向量则在访管指令中给出；各种异常向量在CPU的硬件结构中预先规定。这样不同情况就因中断向量的不同而区分开来。 操作系统如何转到中断处理程序和异常处理程序执行呢？ 对于中断，它主要由外部设备、时钟部件或其他计算机发出的（发现中断源并产生中断的硬件称为中断控制器，这些硬件包括中断逻辑线路和中断寄存器）当前指令执行结束后，CPU会检查中断寄存器是否有中断事件发生： 若无中断信号或中断信号被屏蔽，则继续执行程序的后续指令 否则将暂停执行当前程序，转向内核的中断处理程序执行 对于异常，它是在执行指令时，由于指令本身的原因发生的，指令的控制逻辑和实现线路一旦发现异常情况便转向内核的异常处理程序 这个由硬件对中断和异常事件做出反应的过程称为中断响应。目前的计算机都采用软硬件结合（硬件中断控制器和软件中断/异常处理程序相结合）的方法实现中断/异常处理。中断/异常响应需要执行以下四个步骤： 中断优先级和多重中断中断优先级中断装置所预设的中断响应顺序称为中断优先级。例如，同样是设备，可以设定高速设备优先级高，慢速设备优先级低，以提高高速设备的利用率。那么中断系统如何按照预先设定的优先顺序予以响应？可以使用硬件和软件方法 硬件方法根据排定的优先级顺序做一个硬件链式排队器，当产生高一级中断事件时，应该屏蔽比它优先级低的所有中断源 软件方法编写一个查询程序，依据优先级顺序从高到低进行查询，一旦发现有中断请求，便转入相应中断事件处理程序入口","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://QQ876684433.github.io/categories/操作系统/"},{"name":"笔记","slug":"操作系统/笔记","permalink":"http://QQ876684433.github.io/categories/操作系统/笔记/"}],"tags":[{"name":"中断","slug":"中断","permalink":"http://QQ876684433.github.io/tags/中断/"},{"name":"操作系统","slug":"操作系统","permalink":"http://QQ876684433.github.io/tags/操作系统/"}]},{"title":"Linux写时拷贝技术（copy-on-write）","slug":"Linux写时拷贝技术（copy-on-write）","date":"2019-10-17T10:36:13.000Z","updated":"2019-10-17T12:55:08.093Z","comments":true,"path":"2019/10/17/Linux写时拷贝技术（copy-on-write）/","link":"","permalink":"http://QQ876684433.github.io/2019/10/17/Linux写时拷贝技术（copy-on-write）/","excerpt":"","text":"Linux写时拷贝技术（copy on write）fork() 和 exec() 参考资料： https://www.geeksforgeeks.org/difference-fork-exec/ https://stackoverflow.com/questions/1653340/differences-between-fork-and-exec 每一个应用程序都是通过进程来运行的，进程是一个程序运行的实例，fork()和exec()都可以创建新的进程 fork()1pid_t pid = fork(); fork()创建的新进程是原调用进程的的一个拷贝，新进程称为子进程，原进程是它的父进程，父子进程之间的差别在于： 子进程有自己独立的进程ID（pid），而且pid与任意已经存在的进程组的ID都不同 （链接原文说的是“进程组”，目前没搞懂和直接说“进程”有什么不同，待考证） 在兼容于POSIX标准的操作系统中，进程组（英语：Process group，又译过程组群）是指一个或多个进程的集合。进程组被使用于控制信号的分配。对于一个进程组发出的的信号，会被个别递送到这个组群下的每个进程成员中。 进程组本身，也可以被集合成一个组群来管理，称为会话组（sessions）。归属于某个特定会话组下的进程组，不能移动到别的会话组下；在某个进程组下的特定进程，在创造出新的进程时，这个进程也只能属于这个父进程所归属的相同会话组。 —— 来源 https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E7%BE%A4%E7%B5%84 The child’s parent process ID is the same as the parent’s process ID.（这个没必要翻译orz） The child does not inherit its parent’s memory locks and semaphore adjustments 子进程不会继承父进程的内存锁和信号量调整 The child does not inherit outstanding asynchronous I/O operations from its parent nor does it inherit any asynchronous I/O contexts from its parent 子进程不会从其父级继承未完成的异步I / O操作，也不会从其父级继承任何异步I / O上下文 fork()的返回值 如果创建子进程成功，那么子进程的PID就会被返回到父进程中，即pid_t pid = fork();中的pid就是创建的子进程的PID，而对子进程而言pid_t pid = fork();中的pid的值是0；可以根据父进程和子进程返回值的不同来使得父进程和子进程接下来执行不同的任务 如果创建子进程失败，那么父进程中pid_t pid = fork();返回值是-1，然后不会有子进程被创建出来，并且错误码会被设置 fork()之后子进程是父进程的拷贝，父进程和子进程会从相同的指令处接着往下面继续执行，即父进程和子进程都会从pid_t pid = fork();下面一行开始执行 exec() there is a whole family of exec calls (execl, execle, execve and so on) but exec in context here means any of them exec()是一系列函数的统称 exec()使用新的进程映像替换当前的进程映像，即它将要运行的程序加载到当前的进程空间中，然后从新程序的入口点开始运行。一般可以结合fork()和exec()来使得当前进程能够启动一个新进程来运行新程序。下面是一个在bash中运行ls程序来获取目录文件列表的例子： 1234567891011121314151617181920212223242526272829+--------+| pid=7 || ppid=4 || bash |+--------+ | | calls fork V+--------+ +--------+| pid=7 | forks | pid=22 || ppid=4 | ----------&gt; | ppid=7 || bash | | bash |+--------+ +--------+ | | | waits for pid 22 | calls exec to run ls | V | +--------+ | | pid=22 | | | ppid=7 | | | ls | V +--------++--------+ || pid=7 | | exits| ppid=4 | &lt;---------------+| bash |+--------+ | | continues V fork()和exec()的区别 fork starts a new process which is a copy of the one that calls it, while exec replaces the current process image with another (different) one. Both parent and child processes are executed simultaneously in case of fork() while Control never returns to the original program unless there is an exec() error. Copy On Write 参考资料：https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html ​ 从上面的介绍中可以知道，fork()会创建一个和父进程完全相同的子进程，但是子进程接下来可能会执行exec()来加载新的程序，如果子进程一创建就调用exec()，那么系统开销是很大的，因为刚刚拷贝了一份父进程，就接着被新的进程替换掉，显然前面的备份是有点多余的。因此，为了提高效率，Linux中引入了copy on write（写时复制）技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。 在fork之后、exec之前，父子进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，即两者的虚拟空间不同，但其对应的物理空间是同一个 当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间 如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同） 如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间 fork之后内核会通过将子进程放在队列的前面，以让子进程先执行，以免父进程先运行导致写时复制，而后子进程才执行exec系统调用，这样可以避免无意义的复制而造成效率的下降 详解​ 对于一个父进程P1，它的虚拟地址空间上有：正文段，数据段，堆，栈这四个部分，相应地，内核要为这四个部分分配各自的物理块，即正文段块，数据段块，堆块，栈块 现在P1用fork()函数为进程创建一个子进程P2 对于内核来说，它会执行如下的任务： 复制P1的正文段，数据段，堆，栈这四个部分，并且它们内容相同 为这四个部分分配物理块，对于新的进程P2： 正文段－＞P1的正文段的物理块，其实就是不为P2分配正文段块，让P2的正文段指向P1的正文段块 数据段－＞P2自己的数据段块（为其分配对应的块） 堆－＞P2自己的堆块 栈－＞P2自己的栈块 如图所示：其中大箭头表示内容复制方向 写时复制技术 内核只为新生成的子进程创建虚拟空间结构，它们来复制于父进程的虚拟空间结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间 vfork() 内核连子进程的虚拟地址空间结构也不创建了，直接共享了父进程的虚拟空间，自然地子进程也共享了父进程的物理空间 传统的fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。Linux的fork()使用写时拷贝（copy-on-write）页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候。在页根本不会被写入的情况下（举例来说，fork()后立即调用exec()）它们就无需复制了。fork()的实际开销就是复制父进程的页表以及给子进程创建惟一的进程描述符。在一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据（地址空间里常常包含数十兆的数据）。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。这里补充一点：Linux COW与exec没有必然联系 （原文中还提到C++中string的copy-on-write技术，因为这个与本主题无关，想要了解的话可以通过上面的参考链接查看）","categories":[{"name":"Linux","slug":"Linux","permalink":"http://QQ876684433.github.io/categories/Linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://QQ876684433.github.io/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"http://QQ876684433.github.io/tags/Linux/"}]},{"title":"操作系统-程序接口与系统调用","slug":"操作系统-程序接口与系统调用","date":"2019-10-16T00:03:25.000Z","updated":"2019-10-17T10:33:35.081Z","comments":true,"path":"2019/10/16/操作系统-程序接口与系统调用/","link":"","permalink":"http://QQ876684433.github.io/2019/10/16/操作系统-程序接口与系统调用/","excerpt":"","text":"程序接口与系统调用 参考资料： 操作系统教程（第5版） - 费翔林 骆斌 编著 Linux Kernel Teaching - https://linux-kernel-labs.github.io/master/index.html 用户接口操作系统通过“程序接口”和“操作接口”将其服务和功能提供给用户： 程序接口是操作系统对外提供服务和功能的手段，它由一组系统调用组成，在应用程序中使用“系统调用”可获得操作系统的低层服务，访问或使用系统管理的各种软硬件资源 操作接口由一组控制命令和（或）作业控制语言组成，是操作系统为用户提供的组织和控制其作业（应用程序）执行的手段 程序接口与系统调用系统调用概念 因此可以这样认为，内核的主体是系统调用的集合 At a high level system calls are “services” offered by the kernel to user applications and they resemble library APIs in that they are described as a function call with a name, parameters and return value. 在高层次上来看，系统调用是内核为用户应用程序提供的“服务”，它们类似于库API，因为它们被描述为具有名称，参数和返回值的函数调用 为什么使用系统调用 根本原因是为了对系统进行“保护” 系统调用是一种中介角色，把用户和硬件资源隔离开来，应用程序只有通过系统调用才能请求系统服务并使用系统资源 系统调用的作用 内核可以基于权限和规则对资源访问进行裁决，保证系统的安全性 系统调用对资源进行抽象，提供一致性接口，避免用户在使用资源时发生错误，且使编程效率大大提高 系统调用是应用程序获得操作系统服务的唯一途径 API、库函数和系统调用不同操作系统提供的系统调用功能虽然大同小异，但是实现细节不尽相同，因此如果应用程序直接使用系统调用，那么会存在问题： 接口复杂，使用困难 应用程序跨平台可移植性受到很大限制 不同操作系统之间的可移植性POSIX（Portable Operating System Interface）为不同平台下的应用程序提供相同的应用程序接口（API），但是它并没有保证相同的API的内部实现是一致的。其中系统调用只是其中一种API 库函数和系统调用 库函数属于应用程序，在用户态运行（用户可以替换库函数） 系统调用对应的服务例程属于系统程序，在内核态运行（用户通常不能替换系统调用） 系统调用分类 系统调用实现 操作系统实现系统调用功能的机制称为陷阱或异常处理机制 由于系统调用引起处理器中断的机器指令称为访管指令、自陷指令或中断指令 其中访管指令为非特权指令，在目态下执行时会将CPU转换到内核态 每个系统调用都事先规定编号，称为功能号，发出访管指令、自陷指令或中断指令时，必须通过某种方式指明对应系统调用的功能号（另外还要附带传递给相应服务例程的参数） 应用程序和系统调用之间传递参数所采用的方法： 访管指令或自陷指令自带参数 通过CPU通用寄存器传递参数 在内存区中开辟专用堆栈区传递参数 系统调用与函数调用的区别 System Calls in Linux Kernel reference：https://linux-kernel-labs.github.io/master/lectures/syscalls.html Linux System Call Table for x86-64（Linux x86-64系统调用表）：http://shell-storm.org/shellcode/files/syscalls.html 在进行系统调用的时候，特定的汇编指令会做如下的工作： setup information to identify the system call and its parameters trigger a kernel mode switch retrieve the result of the system call 在Linux中，系统调用是通过数字编号来标识的，系统调用的参数的大小是机器的字长（word，32或者64位）。系统调用的参数最多有6个，系统调用编号和参数都是保存在特定的寄存器中，例如在32bit的x86架构中： 系统调用数字编号保存在EAX寄存器中 系统调用的参数保存在EBX、ECX、EDX、ESI、EDI、EBP寄存器中 为了使得开发应用程序时进行系统调用更简便，一些系统函数库（例如libc）会提供函数来完成系统调用内部的实际实现 当发生用户态到内核态的转移的时候，当前程序的执行流被中断，然后跳转到内核的入口点，这类似于中断和异常处理的方式（事实上，在一些架构中用户态到内核态的转换是异常处理的结果） During the user - kernel mode transition the stack is also switched from ther user stack to the kernel stack. 在发生用户态向内核态转移的时候，当前的系统堆栈也会由用户栈切换到内核态 在系统调用的入口点会将当前寄存器的值（这些寄存器包含的是用户空间的值，并且包括系统调用数字编号和系统调用参数）保存起来 系统调用例子 更详细的系统调用过程（结合Linux源码解析），参考：http://zhongmingmao.me/2019/04/20/linux-system-call-process/ 系统调用调度器（system call dispatcher）的功能是验证系统调用的数字编号，然后运行和系统调用相关的内核函数，如下代码所示： 12345678910111213141516171819202122/* Handles int $0x80 *//* 在进入内核之前，通过push和SAVE_ALL将当前用户态的寄存器，保存在pt_regs结构里面，然后调用do_int80_syscall_32 */__visible void do_int80_syscall_32(struct pt_regs *regs)&#123; enter_from_user_mode(); local_irq_enable(); do_syscall_32_irqs_on(regs);&#125;/* simplified version of the Linux x86 32bit System Call Dispatcher */static __always_inline void do_syscall_32_irqs_on(struct pt_regs *regs)&#123; unsigned int nr = regs-&gt;orig_ax; /* 系统调用的数量由 NR_syscalls 宏给定，这个判断似乎是检查系统调用号是不是合法的，如果合法则进行接下来的实际内核函数的执行，并且把返回结果保存到ax中 */ /* 似乎这里的 regs-&gt;ax 指的是eax（32bit）或者rax（64bit）的统称，而不是x86中16bit的ax寄存器 */ if (nr &lt; IA32_NR_syscalls) regs-&gt;ax = ia32_sys_call_table[nr](regs-&gt;bx, regs-&gt;cx, regs-&gt;dx, regs-&gt;si, regs-&gt;di, regs-&gt;bp); syscall_return_slowpath(regs);&#125; 下面参考自：https://blog.csdn.net/hq815601489/article/details/80009791 Linux提供了200多个系统调用，通过汇编指令 int 0x80 实现，用系统调用号来区分入口函数。 Linux实现系统调用的基本过程是： 应用程序准备参数，发出调用请求； C库封装函数引导。该函数在Linux提供的标准C库，即 glibc 中。对应的封装函数由下列汇编指令实现（以读函数调用为例）： 1234567; NASM; read(int fd, void *buffer, size_t nbytes)mov eax, 3 ; read系统调用号为3mov ebx, fdmov ecx, buffermov edx, nbytesint 0x80 ; 触发系统调用 执行系统调用。前两步在用户态工作，陷入后在内核态工作。系统调用处理程序根据系统调用号，按系统调用表中的偏移地址跳转，调用对应的内核函数； 系统调用完成相应功能，将返回值存入 eax ，返回到中断处理函数； 系统调用返回。内核函数处理完毕后，库函数读寄存器（ eax ）返回值，并返回给应用程序。恢复现场。 应用程序调用系统调用的过程是： 把系统调用号存入 eax ； 把函数参数存入其它通用寄存器（约定顺序为 ebx 、 ecx 、 edx 、 esi 、 edi ，更多的参数（通常不会出现这种情况）使用堆栈传递，也可以通过寄存器存放指向参数在用户空间的地址指针来传递）； 触发 0x80 号中断（ int 0x80 ）。 示例： 123456789101112131415161718192021; NASM; 向显示器输出hello, world; write(int fd, const void *buffer, size_t nbytes); exit(int status) global _start section .text_start: mov eax, 4 ; write系统调用号为4 mov ebx, 1 ; 文件描述符1：标准输出stdout mov ecx, message ; 要输出的信息 mov edx, message.len ; 要输出的长度 int 0x80 mov eax, 1 ; exit系统调用号为1 mov ebx, 0 ; 状态码0：正常退出 int 0x80 section .datamessage: db &quot;hello, world&quot;, 10.len equ $ - message Linux系统调用实现机制： 系统调用初始化 系统调用处理程序 system_call() 的入口地址放在系统的中断表述符表IDT（Interrupt Descriptor Table）中，Linux系统初始化时，由 trap_init() 将其填写完整，其设置系统调用处理程序的语句为： 1set_system_gate(0x80, &amp;system_call) 经过初始化以后，每当执行 int 0x80 指令时，产生一个异常使系统陷入内核空间并执行128号异常处理程序，即系统调用处理程序 system_call() 系统调用公共入口 system_call() 是所有系统调用的公共入口，其功能是保护现场，进行正确性检查，根据系统调用号跳转到具体的内核函数。内核函数执行完毕时需调用ret_from_sys_call()，这时完成返回用户空间前的最后检查，用RESTORE_ALL宏恢复现场并执行iret指令返回用户断点 保护现场 硬件（CPU）保护：ss 、 esp 、 eflags 、 cs 、 eip ，压入核心栈 软件（操作系统）保护 使用 SAVE_ALL 宏将寄存器压入堆栈，加载内核的 ds 和 es ，往 edx 中放入 $(_KERNEL_DS) 以指明使用内核数据段，把内核数据段选择符装入 ds 和 es 。注意：该宏压入寄存器的顺序不是随意的，而是和系统调用的参数传递密切相关 es 、 ds 、 eax 、 ebp 、 edi 、 esi 、 edx 、 ecx 、 ebx ，压入核心栈 系统调用处理时的核心栈内容： 寄存器 硬件完成 ss 硬件完成 esp 硬件完成 eflags 硬件完成 cs 硬件完成 eip 软件完成 es 软件完成 ds 软件完成 eax 软件完成 ebp 软件完成 edi 软件完成 esi 软件完成 edx 软件完成 ecx 软件完成 ebx 返回值传递 当内核函数返回到 system_call() 时， eax 中存放着内核函数的返回值。要将这个返回值传递给应用程序，内核先将 eax 放入原先 SAVE_ALL 宏保存 eax 的位置，这样当 system_call() 调用 RESTORE_ALL 恢复寄存器时， eax 便被恢复成系统调用的返回值，完成了返回值从内核空间到用户空间的传递 系统调用号和系统调用表 系统调用的数量由 NR_syscalls 宏给定，每个系统调用所对应的编号已预先在系统文件中定义，且都用一个宏表示，其定义有如下形式： 1234#define _NR_exit 1#define _NR_fork 2#define _NR_read 3... Linux的系统调用号和内核函数映射关系的系统调用表也被预先定义在系统文件中，具有如下形式： 1234567.dataENTRY(sys_call_table) .long SYMBOL_NAME(sys_ni_syscall) /* 空项 */ .long SYMBOL_NAME(sys_exit) .long SYMBOL_NAME(sys_fork) .long SYMBOL_NAME(sys_read)... 内核函数入口地址为： eax * 4 + sys_call_table 上面参考自：https://blog.csdn.net/hq815601489/article/details/80009791 概括来说，系统调用过程中会发生如下的事情： The application is setting up the system call number and parameters and it issues a trap instruction The execution mode switches from user to kernel; the CPU switches to a kernel stack; the user stack and the return address to user space is saved on the kernel stack The kernel entry point saves registers on the kernel stack The system call dispatcher identifies the system call function and runs it The user space registers are restored and execution is switched back to user (e.g. calling IRET) The user space application resumes 系统调用表系统调用调度器通过系统调用表来将系统调用号映射到内核函数（系统调用服务例程）： 123456#define __SYSCALL_I386(nr, sym, qual) [nr] = sym,const sys_call_ptr_t ia32_sys_call_table[] = &#123; [0 ... __NR_syscall_compat_max] = &amp;sys_ni_syscall, #include &lt;asm/syscalls_32.h&gt;&#125;; 123456789__SYSCALL_I386(0, sys_restart_syscall, )__SYSCALL_I386(1, sys_exit, )#ifdef CONFIG_X86_32__SYSCALL_I386(2, sys_fork, )#else__SYSCALL_I386(2, sys_fork, )#endif__SYSCALL_I386(3, sys_read, )__SYSCALL_I386(4, sys_write, ) 系统调用参数处理因为系统调用的参数是由用户空间设置的，内核不能保证参数的正确性，因此必须每次都对参数进行验证。指针参数有以下特殊情况是必须要检验的： 不允许指针指向内核空间 检测指针是否有效 因为系统调用是在内核态执行的，它们有访问内核空间的权限，因此如果没有对指针进行合适的检测，那么就会使得用户应用程序拥有读或者写内核空间的权限（甚至不正确的写内核空间会破坏内核内存）。 类似的，如果用户程序传递的指针是无效的（例如一个写指针指向一个只读的内存区域），它也会导致内核崩溃。 有以下两种方法来解决以上问题： 在使用指针之前，先对照用户地址空间检查指针 避免检查指针，依靠MMU来检测指针何时无效，并使用页错误处理程序确定指针无效 （原文中还有些比较高级的内容，这里不再列出，毕竟涉及的知识比较高深，参见：https://linux-kernel-labs.github.io/master/lectures/syscalls.html）","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://QQ876684433.github.io/categories/操作系统/"},{"name":"笔记","slug":"操作系统/笔记","permalink":"http://QQ876684433.github.io/categories/操作系统/笔记/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://QQ876684433.github.io/tags/操作系统/"},{"name":"系统调用","slug":"系统调用","permalink":"http://QQ876684433.github.io/tags/系统调用/"}]},{"title":"数据库课堂笔记（2019-10-15）","slug":"数据库课堂笔记（2019-10-15）","date":"2019-10-15T03:25:09.000Z","updated":"2019-10-22T06:15:38.487Z","comments":true,"path":"2019/10/15/数据库课堂笔记（2019-10-15）/","link":"","permalink":"http://QQ876684433.github.io/2019/10/15/数据库课堂笔记（2019-10-15）/","excerpt":"","text":"数据库课堂笔记 参考资料： 南大软件学院课程《数据管理基础》课程资料 《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著 《数据库系统概论》第五版 - 王珊 萨师煊 著 《数据库系统概念》 数据库课堂笔记（2019-10-15）Ch4. Object-Relational SQL (Oracle)对象关系型数据表相关例子如下： Object Types（对象类型）定义新的数据类型对象类型的创建和删除语法（CREATE TYPE … AS OBJECT）如下： 12CREATE TYPE typename AS OBJECT(attrname datatype, ......); 1DROP TYPE typename; 这些数据类型一经定义， 便以持久形式保存在数据库系统中， 用户可以像使用系统内置的数据类型一样使用这些复杂的数据类型， 以此来扩充系统的数据类型 创建对象类型的语法跟创建表的语法差不多，只不过对象类型的定义中没有约束条件的定义（constraint define），创建一个person_t的类型如下： 123456CREATE TYPE person_t AS OBJECT( ssno int, pname name_t, age int); 对象类型的使用自定义的对象类型可以有以下用法： 使用所创建的对象类型来创建新类型 用于定义新类型中的属性 (类型的嵌套定义) 123456CREATE TYPE person_t AS OBJECT( ssno int, pname name_t, age int); 其中name_t就是一个对象类型 使用所创建的对象类型来创建新的表用于定义表中的属性 12345CREATE TABLE teachers ( tid int, tname name_t, room int ); 其中name_t就是一个对象类型 使用对象数据类型来直接创建一张表 新创建的‘表’ 的结构与对象类型的结构相同 12CREATE TABLE tablename OF typename&#123; ( constraint-define ) &#125; ; 可以在创建的‘表’ 中增加完整性约束定义 1234CREATE TABLE people OF person_t( PRIMARY KEY( ssno )) ; 对象值的创建、 查询与更新两个重要的函数： 对象构造函数 1typename ( argument, …… ) 例如：name_t ( ‘Einstein’, ‘Albert’, ‘E’ )，就跟普通关系型数据表的行的创建一样 返回对象取值的函数 Ø Even though the primary table is object table, still it displays the rows in general format. Ø To display the entire structure of the object, this will be used. reference：http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html 1value ( … ) 尽管oracle是对象关系型数据库，但是在直接查询一个对象关系表的时候，表中数据的类型是不会被返回的，因此需要使用value(…)函数来将表中属性类型返回回来 Even though the vendors table is object table it will not show the adt along with data, to see the data along with the adt SQL&gt;Select * from vendors; This will give the data without adt. SQL&gt;Select value(v) from vendors v; This will give the columns data along wih the type. reference：http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html 对象值的创建（使用对象构造函数）： 对象值的查询（使用连续的点运算符）： 对象值的更新： 修改整个对象值 可以用对象值直接给对象属性进行赋值（即直接使用对象构造函数构造的新对象值替换表中的对象属性值），例如： 如果某张表是基于“对象类型”创建的，那么可以用“对象”值直接修改整个元组 修改对象中成员属性的值 使用点运算符修改对象类型的某个属性值，例如： 对象的引用类型可以通过以下语句创建对象的引用类型： 1REF &lt;object type&gt; 创建的是指向某个元组对象的指针类型 引用类型可以用来实现对象类型之间的嵌套引用 在使用含有REF类型的对象类型(Object Type)来创建关系表时， 必须使用Scope for子句来限制REF属性的取值范围。 定义类型之间的引用关系的基本方法： ​ 假设当前已经定义了三个对象类型customer_t, agents_t, products_t，那么可以通过如下方式来定义类型之间的引用关系： 123456789101112create type order_t as object ( ordno int, month char(3), cid char(4), aid char(3), pid char(3), qty int, dollars double precision, ordcust ref customer_t, ordagent ref agent_t, ordprod ref product_t); 最后三行新增三个REF属性， 分别引用（指向） 三个不同的元组对象（Row Object） 创建含有引用类型的关系表的基本方法： 先使用基本对象类型创建相应的基本关系表 123456create table customers of customer_t(primary key (cid));create table products of product_t(primary key (pid));create table agents of agent_t(primary key (aid)); 再使用含有REF属性的引用类型创建对应的关系表 123456create table orders of order_t ( primary key (ordno), scope for (ordcust) is customers, scope for (ordagent) is agents, scope for (ordprod) is products); 其中scope for是用来限制REF属性的取值范围的，在创建关系表时如果表中含有引用类型，那么必须使用scope for来指定属性要引用的对象 根据元组之间的REF引用关系进行查询和普通的查询是一样的，都可以使用点运算符，例如： 123select distinct o.ordcust.cname, o.ordagent.anamefrom orders o 其中ordcust和ordagent都是引用类型 引用类型两个函数和两个谓词： 两个函数 获取对象(元组)的引用指针: REF(……) Ø The ref function allows referencing of existing row objects. Ø Each of the row objects has an object id value assigned to it. Ø The object id assigned can be seen by using ref function. reference：http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html 从上面可以看出，ref实际返回的是引用对象的id，因此如果需要查询并查看引用对象的内容，需要使用下面要介绍的deref。可以用来判断一个引用类型的引用对象是不是给定的对象，例如： 返回引用指针所指向对象的值: DEREF(……) Ø The deref function performs opposite action. Ø It takes a reference value of object id and returns the value of the row objects. reference：http://oracle-knowledgeshare.blogspot.com/2011/09/ref-deref-value.html 它用来检索整个被引用对象， 而不是仅仅获得该对象的引用指针，例如： 12345678select value ( p ), deref ( p.partner )from police_officers pcreate type police_officer_t as object ( pol_person person_t, badge_number integer, partner ref police_officer_t ); 两个判定谓词： IS DANGLING 用于判断所引用的元组对象是否存在 如果所引用的元组对象不存在， 那么该谓词返回逻辑真(TRUE)， 否则返回逻辑假(FALSE) 该谓词主要用于检查那些错误的对象引用指针 例如： 12select o.cid from orders owhere o.ordcust IS DANGLING; 等价于 1234select o.cid from orders owhere o.ordcust &lt;&gt; (select ref(c) from customers c where c.cid = o.cid) 即可以用来检索cid和引用的对象是否一致 IS NULL 可以使用 IS NULL 谓词来查找取值为空(NULL) 的 REF 属性，但是‘is dangling’不等于‘is null’ 对象引用指针的使用规则 A dangling REF is non-null but useless If o.ordcust is null or dangling, then o.ordcust.cname is null A null pointer just means the pointer isn’t pointing to anything, or in some languages means it is unknown what it is pointing at. But because it is a null pointer, you know this, the code knows this, so no problem. A dangling pointer is one that you think is pointing at something but in reality is no longer there, hence the pointer is actually inaccurate but doesn’t know it. reference：https://stackoverflow.com/questions/12714199/null-pointer-vs-dangling-pointer","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"},{"name":"笔记","slug":"数据库/笔记","permalink":"http://QQ876684433.github.io/categories/数据库/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/tags/数据库/"}]},{"title":"从头到尾彻底理解KMP/BM/Sunday算法","slug":"从头到尾彻底理解KMP-BM-Sunday算法","date":"2019-10-07T15:54:05.000Z","updated":"2019-10-08T03:43:51.929Z","comments":true,"path":"2019/10/07/从头到尾彻底理解KMP-BM-Sunday算法/","link":"","permalink":"http://QQ876684433.github.io/2019/10/07/从头到尾彻底理解KMP-BM-Sunday算法/","excerpt":"","text":"【转载】从头到尾彻底理解KMP/BM/Sunday算法暴力匹配算法假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？ 如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。 理清楚了暴力匹配算法的流程及内在的逻辑，咱们可以写出暴力匹配的代码，如下： 12345678910111213141516171819202122232425262728int ViolentMatch(char* s, char* p)&#123; int sLen = strlen(s); int pLen = strlen(p); int i = 0; int j = 0; while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; if (s[i] == p[j]) &#123; //①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++ i++; j++; &#125; else &#123; //②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0 i = i - j + 1; j = 0; &#125; &#125; //匹配成功，返回模式串p在文本串s中的位置，否则返回-1 if (j == pLen) return i - j; else return -1;&#125; 举个例子，如果给定文本串S“BBC ABCDAB ABCDABCDABDE”，和模式串P“ABCDABD”，现在要拿模式串P去跟文本串S匹配，整个过程如下所示： 1. S[0]为B，P[0]为A，不匹配，执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[1]跟P[0]匹配，相当于模式串要往右移动一位（i=1，j=0） ![](https://img-blog.csdn.net/20140723224710203) 2. S[1]跟P[0]还是不匹配，继续执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[2]跟P[0]匹配（i=2，j=0），从而模式串不断的向右移动一位（不断的执行“令i = i - (j - 1)，j = 0”，i从2变到4，j一直为0） 3. 直到S[4]跟P[0]匹配成功（i=4，j=0），此时按照上面的暴力匹配算法的思路，转而执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，可得S[i]为S[5]，P[j]为P[1]，即接下来S[5]跟P[1]匹配（i=5，j=1） 4. S[5]跟P[1]匹配成功，继续执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，得到S[6]跟P[2]匹配（i=6，j=2），如此进行下去 5. 直到S[10]为空格字符，P[6]为字符D（i=10，j=6），因为不匹配，重新执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，相当于S[5]跟P[0]匹配（i=5，j=0） 6. 至此，我们可以看到，如果按照暴力匹配算法的思路，尽管之前文本串和模式串已经分别匹配到了S[9]、P[5]，但因为S[10]跟P[6]不匹配，所以文本串回溯到S[5]，模式串回溯到P[0]，从而让S[5]跟P[0]匹配。 而S[5]肯定跟P[0]失配。为什么呢？因为在之前第4步匹配中，我们已经得知S[5] = P[1] = B，而P[0] = A，即P[1] != P[0]，故S[5]必定不等于P[0]，所以回溯过去必然会导致失配。那有没有一种算法，让i 不往回退，只需要移动j 即可呢？ 答案是肯定的。这种算法就是本文的主旨KMP算法，它利用之前已经部分匹配这个有效信息，保持i 不回溯，通过修改j 的位置，让模式串尽量地移动到有效的位置。KMP算法定义Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。 下面先直接给出KMP的算法流程（如果感到一点点不适，没关系，坚持下，稍后会有具体步骤及解释，越往后看越会柳暗花明☺）： 假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文的3.3.3节中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。 很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀后缀。 此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。 转换成代码表示，则是： 1234567891011121314151617181920212223242526int KmpSearch(char* s, char* p)&#123; int i = 0; int j = 0; int sLen = strlen(s); int pLen = strlen(p); while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ if (j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else &#123; //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] //next[j]即为j所对应的next值 j = next[j]; &#125; &#125; if (j == pLen) return i - j; else return -1;&#125; 继续拿之前的例子来说，当S[10]跟P[6]匹配失败时，KMP不是跟暴力匹配那样简单的把模式串右移一位，而是执行第②条指令：“如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]”，即j 从6变到2（后面我们将求得P[6]，即字符D对应的next 值为2），所以相当于模式串向右移动的位数为j - next[j]（j - next[j] = 6-2 = 4）。{% image https://img-blog.csdn.net/20140726213353687 '' '' %} 向右移动4位后，S[10]跟P[2]继续匹配。为什么要向右移动4位呢，因为移动4位后，模式串中又有个“AB”可以继续跟S[8]S[9]对应着，从而不用让i 回溯。相当于在除去字符D的模式串子串中寻找相同的前缀和后缀，然后根据前缀后缀求出next 数组，最后基于next 数组进行匹配（不关心next 数组是怎么求来的，只想看匹配过程是咋样的，可直接跳到下文3.3.4节）。 步骤 ①寻找前缀后缀最长公共元素长度 对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为“abab”，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示： 比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k + 1 = 2）。 ②求next数组 next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示： 比如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k = 1）。 ③根据next数组进行匹配 匹配失配，j = next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀pj-k pj-k+1, …, pj-1 跟文本串si-k si-k+1, …, si-1匹配成功，但pj 跟si匹配失败时，因为next[j] = k，相当于在不包含pj的模式串中有最大长度为k 的相同前缀后缀，即p0 p1 …pk-1 = pj-k pj-k+1…pj-1，故令j = next[j]，从而让模式串右移j - next[j] 位，使得模式串的前缀p0 p1, …, pk-1对应着文本串 si-k si-k+1, …, si-1，而后让pk 跟si 继续匹配。如下图所示： 综上，KMP的next 数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。如模式串中在j 处的字符跟文本串在i 处的字符匹配失配时，下一步用next [j] 处的字符继续跟文本串i 处的字符匹配，相当于模式串向右移动 j - next[j] 位。 接下来，分别具体解释上述3个步骤。 解释寻找最长前缀后缀如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：{% image https://img-blog.csdn.net/20140725231726921 '' '' %} 也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（下简称《最大长度表》）： 基于《最大长度表》匹配因为模式串中首尾可能会有重复的字符，故可得出下述结论： 失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值 下面，咱们就结合之前的《最大长度表》和上述结论，进行字符串的匹配。如果给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示： 因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第5个字符A匹配成功： 继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为6个（ABCDAB），然后根据《最大长度表》可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论，可知需要向右移动6 - 2 = 4 位。 模式串向右移动4位后，发现C处再度失配，因为此时已经匹配了2个字符（AB），且上一位字符B对应的最大长度值为0，所以向右移动：2 - 0 =2 位。 A与空格失配，向右移动1 位。 继续比较，发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B对应的最大长度2，即向右移动6 - 2 = 4 位。 经历第5步后，发现匹配成功，过程结束。 通过上述匹配过程可以看出，问题的关键就是寻找模式串中最大长度的相同前缀和后缀，找到了模式串中每个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。而这个最大长度便正是next 数组要表达的含义。根据《最大长度表》求next 数组由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为： 而且，根据这个表可以得出下述结论 失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值 上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。 给定字符串“ABCDABD”，可求得它的next 数组如下： 把next 数组跟之前求得的最大长度表对比后，不难发现，next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。 换言之，对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下： 根据最大长度表求出了next 数组后，从而有 失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值 ​ 而后，你会发现，无论是基于《最大长度表》的匹配，还是基于next 数组的匹配，两者得出来的向右移动的位数是一样的。为什么呢？因为： 根据《最大长度表》，失配时，模式串向右移动的位数 = 已经匹配的字符数 - 失配字符的上一位字符的最大长度值 而根据《next 数组》，失配时，模式串向右移动的位数 = 失配字符的位置 - 失配字符对应的next 值 其中，从0开始计数时，失配字符的位置 = 已经匹配的字符数（失配字符不计数），而失配字符对应的next 值 = 失配字符的上一位字符的最大长度值，两相比较，结果必然完全一致。 所以，你可以把《最大长度表》看做是next 数组的雏形，甚至就把它当做next 数组也是可以的，区别不过是怎么用的问题。 通过代码递推计算next 数组接下来，咱们来写代码求下next 数组。 基于之前的理解，可知计算next 数组的方法可以采用递推： 如果对于值k，已有p0 p1, …, pk-1 = pj-k pj-k+1, …, pj-1，相当于next[j] = k。 此意味着什么呢？究其本质，next[j] = k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀。有了这个next 数组，在KMP匹配中，当模式串中j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动j - next[j] 位。 举个例子，如下图，根据模式串“ABCDABD”的next 数组可知失配位置的字符D对应的next 值为2，代表字符D前有长度为2的相同前缀和后缀（这个相同的前缀后缀即为“AB”），失配后，模式串需要向右移动j - next [j] = 6 - 2 =4位。 向右移动4位后，模式串中的字符C继续跟文本串匹配。 下面的问题是：已知next [0, …, j]，如何求出next [j + 1]呢？对于P的前j+1个序列字符： 若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1； 若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] = next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。 相当于在字符p[j+1]之前不存在长度为k+1的前缀”p0 p1, …, pk-1 pk”跟后缀“pj-k pj-k+1, …, pj-1 pj”相等，那么是否可能存在另一个值t+1 &lt; k+1，使得长度更小的前缀 “p0 p1, …, pt-1 pt” 等于长度更小的后缀 “pj-t pj-t+1, …, pj-1 pj” 呢？如果存在，那么这个t+1 便是next[ j+1]的值，此相当于利用已经求得的next 数组（next [0, …, k, …, j]）进行P串前缀跟P串后缀的匹配。 一般的文章或教材可能就此一笔带过，但大部分的初学者可能还是不能很好的理解上述求解next 数组的原理，故接下来，我再来着重说明下。 如下图所示，假定给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。 {% image https://img-blog.csdn.net/20140729182154066 '' '' %} 但如果pk != pj 呢？说明“p0 pk-1 pk” ≠ “pj-k pj-1 pj”。换言之，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。 结合上图来讲，若能在前缀“ p0 pk-1 pk ” 中不断的递归前缀索引k = next [k]，找到一个字符pk’ 也为D，代表pk’ = pj，且满足p0 pk&apos;-1 pk&apos; = pj-k&apos; pj-1 pj，则最大相同的前缀后缀长度为k&apos; + 1，从而next [j + 1] = k’ + 1 = next [k&apos; ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] = 0。 那为何递归前缀索引k = next[k]，就能找到长度更短的相同前缀后缀呢？这又归根到next数组的含义。我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。此过程相当于模式串的自我匹配，所以不断的递归k = next[k]，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。如下图所示： 引用下一读者wudehua55555于本文评论下留言，以辅助大家从另一个角度理解：“ 一直以为博主在用递归求next数组时没讲清楚，为何要用k = next[k],仔细看了这个红黄蓝分区图才突然恍然大悟，就是找到p[k]对应的next[k]，根据对称性，只需再判断p[next[k]]与p[j]是否相等即可，于是令k = next[k],这里恰好就使用了递归的思路。其实我觉得不要一开始就陷入递归的方法中，换一种思路，直接从考虑对称性入手，可直接得出k = next[k]，而这正好是递归罢了。以上是一些个人看法，非常感谢博主提供的解析，非计算机的学生也能看懂，虽然从昨晚9点看到了现在。高兴。” 所以，因最终在前缀ABC中没有找到D，故E的next 值为0： 模式串的后缀：ABDE 模式串的前缀：ABC 前缀右移两位： ABC 读到此，有的读者可能又有疑问了，那能否举一个能在前缀中找到字符D的例子呢？OK，咱们便来看一个能在前缀中找到字符D的例子，如下图所示： 给定模式串DABCDABDE，我们很顺利的求得字符D之前的“DABCDAB”的各个子串的最长相同前缀后缀的长度分别为0 0 0 0 1 2 3，但当遍历到字符D，要求包括D在内的“DABCDABD”最长相同前缀后缀时，我们发现pj处的字符D跟pk处的字符C不一样，换言之，前缀DABC的最后一个字符C 跟后缀DABD的最后一个字符D不相同，所以不存在长度为4的相同前缀后缀。 怎么办呢？既然没有长度为4的相同前缀后缀，咱们可以寻找长度短点的相同前缀后缀，最终，因在p0处发现也有个字符D，p0 = pj，所以p[j]对应的长度值为1，相当于E对应的next 值为1（即字符E之前的字符串“DABCDABD”中有长度为1的相同前缀和后缀）。 综上，可以通过递推求得next 数组，代码如下所示：123456789101112131415161718192021void GetNext(char* p,int next[])&#123; int pLen = strlen(p); next[0] = -1; int k = -1; int j = 0; while (j &lt; pLen - 1) &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) &#123; ++k; ++j; next[j] = k; &#125; else &#123; k = next[k]; &#125; &#125;&#125; 用代码重新计算下“ABCDABD”的next 数组，以验证之前通过“最长相同前缀后缀长度值右移一位，然后初值赋为-1”得到的next 数组是否正确，计算结果如下表格所示：{% image https://img-blog.csdn.net/20140812004705968 '' '' %} 从上述表格可以看出，无论是之前通过“最长相同前缀后缀长度值右移一位，然后初值赋为-1”得到的next 数组，还是之后通过代码递推计算求得的next 数组，结果是完全一致的。基于《next 数组》匹配下面，我们来基于next 数组进行匹配。{% image https://img-blog.csdn.net/20140721231622000 '' '' %} 还是给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示： 在正式匹配之前，让我们来再次回顾下上文2.1节所述的KMP算法的匹配流程： “假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。” 最开始匹配时 P[0]跟S[0]匹配失败 所以执行“如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]”，所以j = -1，故转而执行“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++”，得到i = 1，j = 0，即P[0]继续跟S[1]匹配。 P[0]跟S[1]又失配，j再次等于-1，i、j继续自增，从而P[0]跟S[2]匹配。 P[0]跟S[2]失配后，P[0]又跟S[3]匹配。 P[0]跟S[3]再失配，直到P[0]跟S[4]匹配成功，开始执行此条指令的后半段：“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++”。 P[1]跟S[5]匹配成功，P[2]跟S[6]也匹配成功, …，直到当匹配到P[6]处的字符D时失配（即S[10] != P[6]），由于P[6]处的D对应的next 值为2，所以下一步用P[2]处的字符C继续跟S[10]匹配，相当于向右移动：j - next[j] = 6 - 2 =4 位。 向右移动4位后，P[2]处的C再次失配，由于C对应的next值为0，所以下一步用P[0]处的字符继续跟S[10]匹配，相当于向右移动：j - next[j] = 2 - 0 = 2 位。 移动两位之后，A 跟空格不匹配，模式串后移1 位。 P[6]处的D再次失配，因为P[6]对应的next值为2，故下一步用P[2]继续跟文本串匹配，相当于模式串向右移动 j - next[j] = 6 - 2 = 4 位。 匹配成功，过程结束。 匹配过程一模一样。也从侧面佐证了，next 数组确实是只要将各个最大前缀后缀的公共元素的长度值右移一位，且把初值赋为-1 即可。基于《最大长度表》与基于《next 数组》等价我们已经知道，利用next 数组进行匹配失配时，模式串向右移动 j - next [ j ] 位，等价于已匹配字符数 - 失配字符的上一位字符所对应的最大长度值。原因是： j 从0开始计数，那么当数到失配字符时，j 的数值就是已匹配的字符数； 由于next 数组是由最大长度值表整体向右移动一位（且初值赋为-1）得到的，那么失配字符的上一位字符所对应的最大长度值，即为当前失配字符的next 值。 但为何本文不直接利用next 数组进行匹配呢？因为next 数组不好求，而一个字符串的前缀后缀的公共元素的最大长度值很容易求。例如若给定模式串“ababa”，要你快速口算出其next 数组，乍一看，每次求对应字符的next值时，还得把该字符排除之外，然后看该字符之前的字符串中有最大长度为多大的相同前缀后缀，此过程不够直接。而如果让你求其前缀后缀公共元素的最大长度，则很容易直接得出结果：0 0 1 2 3，如下表格所示： 然后这5个数字 全部整体右移一位，且初值赋为-1，即得到其next 数组：-1 0 0 1 2。 Next 数组与有限状态自动机next 负责把模式串向前移动，且当第j位不匹配的时候，用第next[j]位和主串匹配，就像打了张“表”。此外，next 也可以看作有限状态自动机的状态，在已经读了多少字符的情况下，失配后，前面读的若干个字符是有用的。 Next 数组的优化 行文至此，咱们全面了解了暴力匹配的思路、KMP算法的原理、流程、流程之间的内在逻辑联系，以及next 数组的简单求解（《最大长度表》整体右移一位，然后初值赋为-1）和代码求解，最后基于《next 数组》的匹配，看似洋洋洒洒，清晰透彻，但以上忽略了一个小问题。 比如，如果用之前的next 数组方法求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1（0 0 1 2整体右移一位，初值赋为-1），当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 =2位。{% image http://hi.csdn.net/attachment/201106/14/8394323_1308075859Zfue.jpg '' '' %} 右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？ 问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]。 所以，咱们得修改下求next 数组的代码。12345678910111213141516171819202122232425262728//优化过后的next 数组求法void GetNextval(char* p, int next[])&#123; int pLen = strlen(p); next[0] = -1; int k = -1; int j = 0; while (j &lt; pLen - 1) &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) &#123; ++j; ++k; //较之前next数组求法，改动在下面4行 if (p[j] != p[k]) next[j] = k; //之前只有这一行 else //因为不能出现p[j] = p[ next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]] next[j] = next[k]; &#125; else &#123; k = next[k]; &#125; &#125;&#125; 利用优化过后的next 数组求法，可知模式串“abab”的新next数组为：-1 0 -1 0。可能有些读者会问：原始next 数组是前缀后缀最长公共元素长度值右移一位， 然后初值赋为-1而得，那么优化后的next 数组如何快速心算出呢？实际上，只要求出了原始next 数组，便可以根据原始next 数组快速求出优化后的next 数组。还是以abab为例，如下表格所示：{% image https://img-blog.csdn.net/20140801160510832 '' '' %} 只要出现了p[next[j]] = p[j]的情况，则把next[j]的值再次递归。例如在求模式串“abab”的第2个a的next值时，如果是未优化的next值的话，第2个a对应的next值为0，相当于第2个a失配时，下一步匹配模式串会用p[0]处的a再次跟文本串匹配，必然失配。所以求第2个a的next值时，需要再次递归：next[2] = next[ next[2] ] = next[0] = -1（此后，根据优化后的新next值可知，第2个a失配时，执行“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符”），同理，第2个b对应的next值为0。对于优化后的next数组可以发现一点：如果模式串的后缀跟前缀相同，那么它们的next值也是相同的，例如模式串abcabc，它的前缀后缀都是abc，其优化后的next数组为：-1 0 0 -1 0 0，前缀后缀abc的next值都为-1 0 0。 然后引用下之前3.1节的KMP代码：1234567891011121314151617181920212223242526int KmpSearch(char* s, char* p)&#123; int i = 0; int j = 0; int sLen = strlen(s); int pLen = strlen(p); while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ if (j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else &#123; //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] //next[j]即为j所对应的next值 j = next[j]; &#125; &#125; if (j == pLen) return i - j; else return -1;&#125; 接下来，咱们继续拿之前的例子说明，整个匹配过程如下： S[3]与P[3]匹配失败。 S[3]保持不变，P的下一个匹配位置是P[next[3]]，而next[3]=0，所以P[next[3]]=P[0]与S[3]匹配。 由于上一步骤中P[0]与S[3]还是不匹配。此时i=3，j=next [0]=-1，由于满足条件j==-1，所以执行“++i, ++j”，即主串指针下移一个位置，P[0]与S[4]开始匹配。最后j==pLen，跳出循环，输出结果i - j = 4（即模式串第一次在文本串中出现的位置），匹配成功，算法结束。 KMP的时间复杂度分析相信大部分读者读完上文之后，已经发觉其实理解KMP非常容易，无非是循序渐进把握好下面几点： 如果模式串中存在相同前缀和后缀，即pj-k pj-k+1, …, pj-1 = p0 p1, …, pk-1，那么在pj跟si失配后，让模式串的前缀p0 p1…pk-1对应着文本串si-k si-k+1…si-1，而后让pk跟si继续匹配。 之前本应是pj跟si匹配，结果失配了，失配后，令pk跟si匹配，相当于j 变成了k，模式串向右移动j - k位。 因为k 的值是可变的，所以我们用next[j]表示j处字符失配后，下一次匹配模式串应该跳到的位置。换言之，失配前是j，pj跟si失配时，用p[ next[j] ]继续跟si匹配，相当于j变成了next[j]，所以，j = next[j]，等价于把模式串向右移动j - next [j] 位。 而next[j]应该等于多少呢？next[j]的值由j 之前的模式串子串中有多大长度的相同前缀后缀所决定，如果j 之前的模式串子串中（不含j）有最大长度为k的相同前缀后缀，那么next [j] = k。 如之前的图所示： {% image https://img-blog.csdn.net/20140812223633281 '' '' %} 接下来，咱们来分析下KMP的时间复杂度。分析之前，先来回顾下KMP匹配算法的流程：“KMP的算法流程： 假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。” 我们发现如果某个字符匹配成功，模式串首字符的位置保持不动，仅仅是i++、j++；如果匹配失配，i 不变（即 i 不回溯），模式串会跳过匹配过的next [j]个字符。整个算法最坏的情况是，当模式串首字符位于i - j的位置时才匹配成功，算法结束。 所以，如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。 扩展1：BM算法KMP的匹配是从模式串的开头开始匹配的，而1977年，德克萨斯大学的Robert S. Boyer教授和J Strother Moore教授发明了一种新的字符串匹配算法：Boyer-Moore算法，简称BM算法。该算法从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的时间复杂度。在实践中，比KMP算法的实际效能高。 BM算法定义了两个规则： 坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果”坏字符”不包含在模式串之中，则最右出现位置为-1。 好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。 下面举例说明BM算法。例如，给定文本串“HERE IS A SIMPLE EXAMPLE”，和模式串“EXAMPLE”，现要查找模式串是否在文本串中，如果存在，返回模式串在文本串中的位置。 首先，”文本串”与”模式串”头部对齐，从尾部开始比较。”S”与”E”不匹配。这时，”S”就被称为”坏字符”（bad character），即不匹配的字符，它对应着模式串的第6位。且”S”不包含在模式串”EXAMPLE”之中（相当于最右出现位置是-1），这意味着可以把模式串后移6-(-1)=7位，从而直接移到”S”的后一位。 依然从尾部开始比较，发现”P”与”E”不匹配，所以”P”是”坏字符”。但是，”P”包含在模式串”EXAMPLE”之中。因为“P”这个“坏字符”对应着模式串的第6位（从0开始编号），且在模式串中的最右出现位置为4，所以，将模式串后移6-4=2位，两个”P”对齐。 依次比较，得到 “MPLE”匹配，称为”好后缀”（good suffix），即所有尾部匹配的字符串。注意，”MPLE”、”PLE”、”LE”、”E”都是好后缀。 发现“I”与“A”不匹配：“I”是坏字符。如果是根据坏字符规则，此时模式串应该后移2-(-1)=3位。问题是，有没有更优的移法？ 更优的移法是利用好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串中上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。 所有的“好后缀”（MPLE、PLE、LE、E）之中，只有“E”在“EXAMPLE”的头部出现，所以后移6-0=6位。 可以看出，“坏字符规则”只能移3位，“好后缀规则”可以移6位。每次后移这两个规则之中的较大值。这两个规则的移动位数，只与模式串有关，与原文本串无关。 继续从尾部开始比较，“P”与“E”不匹配，因此“P”是“坏字符”，根据“坏字符规则”，后移 6 - 4 = 2位。因为是最后一位就失配，尚未获得好后缀。 由上可知，BM算法不仅效率高，而且构思巧妙，容易理解。扩展2：Sunday算法上文中，我们已经介绍了KMP算法和BM算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上，KMP算法并不比最简单的c库函数strstr()快多少，而BM算法虽然通常比KMP算法快，但BM算法也还不是现有字符串查找算法中最快的算法，本文最后再介绍一种比BM算法更快的查找算法即Sunday算法。 Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似： 只不过Sunday算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。 如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1； 否则，其移动位数 = 模式串中最右端的该字符到末尾的距离+1。 下面举个例子说明下Sunday算法。假定现在要在文本串”substring searching algorithm”中查找模式串”search”。 刚开始时，把模式串与文本串左边对齐： 123substring searching algorithmsearch^ 结果发现在第2个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，如下图： 123substring searching algorithm search ^ 结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，于是把模式串向右移动3位（r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，如下： 123substring searching algorithm search ^ 匹配成功。 回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于Sunday算法每一步的移动量都比较大，效率很高。完。 参考文献 《算法导论》的第十二章：字符串匹配； 本文中模式串“ABCDABD”的部分图来自于此文：http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html； 本文3.3.7节中有限状态自动机的图由微博网友@龚陆安 绘制：http://d.pr/i/NEiz； 北京7月暑假班邹博半小时KMP视频：http://www.julyedu.com/video/play/id/5； 北京7月暑假班邹博第二次课的PPT：http://yun.baidu.com/s/1mgFmw7u； 理解KMP 的9张PPT：http://weibo.com/1580904460/BeCCYrKz3#_rnd1405957424876； 详解KMP算法（多图）：http://www.cnblogs.com/yjiyjige/p/3263858.html； 本文第4部分的BM算法参考自此文：http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html； http://youlvconglin.blog.163.com/blog/static/5232042010530101020857； 《数据结构 第二版》，严蔚敏 &amp; 吴伟民编著； http://blog.csdn.net/v_JULY_v/article/details/6545192； http://blog.csdn.net/v_JULY_v/article/details/6111565； Sunday算法的原理与实现：http://blog.chinaunix.net/uid-22237530-id-1781825.html； 模式匹配之Sunday算法：http://blog.csdn.net/sunnianzhong/article/details/8820123； 一篇KMP的英文介绍：http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/kmpen.htm； 我2014年9月3日在西安电子科大的面试&amp;算法讲座视频（第36分钟~第94分钟讲KMP）：http://www.julyedu.com/video/play/21； 一幅图理解KMP next数组的求法：http://v.atob.site/kmp-next.html 版权声明：本文为CSDN博主「v_JULY_v」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/v_july_v/article/details/7041827","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"},{"name":"转载","slug":"算法/转载","permalink":"http://QQ876684433.github.io/categories/算法/转载/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"股票问题通解-有限状态机","slug":"股票问题通解-有限状态机","date":"2019-10-02T03:21:30.000Z","updated":"2019-10-07T11:36:52.747Z","comments":true,"path":"2019/10/02/股票问题通解-有限状态机/","link":"","permalink":"http://QQ876684433.github.io/2019/10/02/股票问题通解-有限状态机/","excerpt":"","text":"【转载】股票问题通解 - 有限状态机很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。 这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。 先随便抽出一道题，看看别人的解法： 123456789101112int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN; for(int i=1;i&lt;prices.size();++i) &#123; s1 = max(s1, -prices[i]); s2 = max(s2, s1+prices[i]); s3 = max(s3, s2-prices[i]); s4 = max(s4, s3+prices[i]); &#125; return max(0,s4);&#125; 能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。 本文就来告诉你这个框架，然后带着你一道一道秒杀。 这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。 第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。 一、穷举框架首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。 递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。 而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。 1234for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp状态1[...] = 择优(选择1，选择2...) 比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k &gt; 0 的前提下操作。 很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合： 123456789dpi[0 or 1]0 &lt;= i &lt;= n-1, 1 &lt;= k &lt;= Kn 为天数，大 K 为最多交易数此问题共 n × K × 2 种状态，全部穷举就能搞定。for 0 &lt;= i &lt; n: for 1 &lt;= k &lt;= K: for s in &#123;0, 1&#125;: dpi[s] = max(buy, sell, rest) 而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？ 我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。 记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。 二、状态转移框架现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。 通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程： 12345678910111213dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 选择 rest , 选择 sell )解释：今天我没有持有股票，有两种可能：要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 选择 rest , 选择 buy )解释：今天我持有着股票，有两种可能：要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。 这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。 现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。 12345678dp[-1][k][0] = 0解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。dp[-1][k][1] = -infinity解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。dp[i][0][0] = 0解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。dp[i][0][1] = -infinity解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。 把上面的状态转移方程总结一下： 1234567base case：dp[-1][k][0] = dp[i][0][0] = 0dp[-1][k][1] = dp[i][0][1] = -infinity状态转移方程：dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。 三、秒杀题目第一题，k = 1直接套状态转移方程，根据 base case，可以做一些化简： 123456789dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i])解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。可以进行进一步化简去掉所有 k：dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], -prices[i]) 直接写出代码： 1234567int n = prices.length;int[][] dp = new int[n][2];for (int i = 0; i &lt; n; i++) &#123; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]);&#125;return dp[n - 1][0]; 显然i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理： 12345678910111213141516171819for (int i = 0; i &lt; n; i++) &#123; if (i - 1 == -1) &#123; dp[i][0] = 0; // 解释： // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][1] = -prices[i]; //解释： // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue; &#125; dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]);&#125;return dp[n - 1][0]; 第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1): 12345678910111213// k == 1int maxProfit_k_1(int[] prices) &#123; int n = prices.length; // base case: dp[-1][0] = 0, dp[-1][1] = -infinity int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); // dp[i][1] = max(dp[i-1][1], -prices[i]) dp_i_1 = Math.max(dp_i_1, -prices[i]); &#125; return dp_i_0;&#125; 两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。 第二题，k = +infinity如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架： 1234567dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) 直接翻译成代码： 12345678910int maxProfit_k_inf(int[] prices) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i]); &#125; return dp_i_0;&#125; 第三题，k = +infinity with cooldown每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可： 123dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。 翻译成代码： 123456789101112int maxProfit_with_cool(int[] prices) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; int dp_pre_0 = 0; // 代表 dp[i-2][0] for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]); dp_pre_0 = temp; &#125; return dp_i_0;&#125; 第四题，k = +infinity with fee每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程： 1234dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)解释：相当于买入股票的价格升高了。在第一个式子里减也是一样的，相当于卖出股票的价格减小了。 在第一个式子里减也是一样的，相当于卖出股票的价格减小了。直接翻译成代码： 12345678910int maxProfit_with_fee(int[] prices, int fee) &#123; int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i &lt; n; i++) &#123; int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee); &#125; return dp_i_0;&#125; 第五题，k = 2k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。 这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。 123原始的动态转移方程，没有可化简的地方dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 按照之前的代码，我们可能想当然这样写代码（错误的）： 12345678int k = 2;int[][][] dp = new int[n][k + 1][2];for (int i = 0; i &lt; n; i++) if (i - 1 == -1) &#123; /* 处理一下 base case*/ &#125; dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);&#125;return dp[n - 1][k][0]; 为什么错误？我这不是照着状态转移方程写的吗？ 还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举： 12345678910111213141516int max_k = 2;int[][][] dp = new int[n][max_k + 1][2];for (int i = 0; i &lt; n; i++) &#123; for (int k = max_k; k &gt;= 1; k--) &#123; if (i - 1 == -1) &#123; /* 处理 base case */ dp[i][k][0] = 0; dp[i][k][1] = -prices[i]; continue; &#125; dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); &#125;&#125;// 穷举了 n × max_k × 2 个状态，正确。return dp[n - 1][max_k][0]; 如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。 这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以： 12345678910111213141516dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])dp[i][1][1] = max(dp[i-1][1][1], -prices[i])int maxProfit_k_2(int[] prices) &#123; int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE; int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE; for (int price : prices) &#123; dp_i20 = Math.max(dp_i20, dp_i21 + price); dp_i21 = Math.max(dp_i21, dp_i10 - price); dp_i10 = Math.max(dp_i10, dp_i11 + price); dp_i11 = Math.max(dp_i11, -price); &#125; return dp_i20;&#125; 有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。 第六题，k = any integer有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？ 一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。 直接把之前的代码重用： 1234567891011121314int maxProfit_k_any(int max_k, int[] prices) &#123; int n = prices.length; if (max_k &gt; n / 2) return maxProfit_k_inf(prices); int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i &lt; n; i++) for (int k = max_k; k &gt;= 1; k--) &#123; if (i - 1 == -1) &#123; /* 处理 base case */ &#125; dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); &#125; return dp[n - 1][max_k][0];&#125; 至此，6 道题目通过一个状态转移方程全部解决。 四、最后总结本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。 关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？ 具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。 所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。 买卖股票的最佳时机 买卖股票的最佳时机 II 买卖股票的最佳时机 III 买卖股票的最佳时机 IV 最佳买卖股票时机含冷冻期 买卖股票的最佳时机含手续费 推荐阅读动态规划设计方法：归纳思想 滑动窗口算法解决一类子串问题 腾讯面试题详解：编辑距离 作者：labuladong链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-lab/来源：力扣（LeetCode）","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"},{"name":"转载","slug":"算法/转载","permalink":"http://QQ876684433.github.io/categories/算法/转载/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"数据库课堂笔记（2019-09-26）","slug":"数据库课堂笔记（2019-09-26）","date":"2019-09-26T13:24:12.000Z","updated":"2019-10-20T15:02:04.277Z","comments":true,"path":"2019/09/26/数据库课堂笔记（2019-09-26）/","link":"","permalink":"http://QQ876684433.github.io/2019/09/26/数据库课堂笔记（2019-09-26）/","excerpt":"","text":"数据库课堂笔记 参考资料： 南大软件学院课程《数据管理基础》课程资料 《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著 《数据库系统概论》第五版 - 王珊 萨师煊 著 《数据库系统概念》 数据库课堂笔记（2019-09-26）Ch3. Basic SQL Query LanguageUNION和FOR ALL条件 Union：结果中没有重复行（会将重复行给剔除） Union All：结果中可能会有重复行（即不会将重复行给剔除） 例子： R1 := S1 UNION S2 R2 := S1 UNION ALL S2 R3 := ( S1 UNION ALL S2 ) UNION S3 R4 := S1 UNION ALL ( S2 UNION S3 ) 只要最后一个操作是UNION，那么结果就没有重复行；所以R1&amp;R3的结果中没有重复行 INTERSECT和EXCEPT操作 INTERSECT The INTERSECT clause in SQL is used to combine two SELECT statements but the dataset returned by the INTERSECT statement will be the intersection of the data-sets of the two SELECT statements. In simple words, the INTERSECT statement will return only those rows which will be common to both of the SELECT statements. The INTERSECT statement will return only those rows present in the deep green shaded region. i.e. common to both of the data-sets. EXCEPT The SQL EXCEPT clause/operator is used to combine two SELECT statements and returns rows from the first SELECT statement that are not returned by the second SELECT statement. This means EXCEPT returns only rows, which are not available in the second SELECT statement. Just as with the UNION operator, the same rules apply when using the EXCEPT operator. MySQL does not support the EXCEPT operator. SQL中的DIVISION操作SQL中没有类似于关系代数中的÷（division）操作，但可以通过两个NOT EXIST来实现除法操作，例子如下： 123Q: Find cids of customers who place orders with ALL agents based in New York.A: o[cid, aid] ÷ (a where city=‘New York’)[aid] 以上是关系代数运算，它的意思等价于： 123if row c in customers table is a customer of result set, then for each row a in agents table which is based in New York we can find a row o in orders table which: o.cid = c.cid and o.aid = a.aid -&gt;等价于： 1234if row c in customers table is a customer of result set, then no row(a) in agents table which is based in New York, and \"no row(o) in orders table which o.cid = c.cid and o.aid = a.aid\" 这样我们可以根据最后一句构造出第一个条件： 1cond1: NOT EXISTS ( select * from orders o where o.cid=c.cid and o.aid=a.aid ) -&gt;等价于： 1234if row c in customers table is a customer of result set, then no row(a) in agents table which is based in New York, and cond1 然后使用cond1可以构造出第二个条件： 1cond2: NOT EXISTS ( select * from agents a where city = ‘New York’ and cond1 ) -&gt;等价于： 123if row c in customers table is a customer of result set, then cond2 最后我们可以使用cond2写出SQL查询语句： 1SELECT c.cid FROM customers c WHERE cond2 ) 完整的SQL查询语句如下： 1234567SELECT c.cid FROM customers cWHERE NOT EXISTS ( SELECT * FROM agents a WHERE a.city = ‘New York’ and NOT EXISTS ( SELECT * FROM orders o WHERE o.cid=c.cid and o.aid=a.aid ) ) 按照我自己的理解的话，这个类似于”双重否定表肯定”的感觉，或者逆否命题 搬一张图片：","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"},{"name":"笔记","slug":"数据库/笔记","permalink":"http://QQ876684433.github.io/categories/数据库/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/tags/数据库/"}]},{"title":"数据库课堂笔记（2019-09-24）","slug":"数据库课堂笔记（2019-09-24）","date":"2019-09-24T03:25:09.000Z","updated":"2019-10-15T03:30:19.855Z","comments":true,"path":"2019/09/24/数据库课堂笔记（2019-09-24）/","link":"","permalink":"http://QQ876684433.github.io/2019/09/24/数据库课堂笔记（2019-09-24）/","excerpt":"","text":"数据库课堂笔记 参考资料： 南大软件学院课程《数据管理基础》课程资料 《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著 《数据库系统概论》第五版 - 王珊 萨师煊 著 《数据库系统概念》 数据库课堂笔记（2019-09-24）Ch3. Basic SQL Query Language建立数据库ANSI SQL数据类型 字符数据类型（Character） 固定长度字符串类型：CHARACTER(n)，CHAR(n) 可变长度字符串类型：CHARACTER VARYING(n)，CHAR VARYING(n) 数字数据类型（Numeric） (此处推荐阅读：https://academy.vertabelo.com/blog/understanding-numerical-data-types-sql/) precision(p)：数字的总位数 scale(s)：小数点右边的数字个数 Precision is an integer that represents the total number of digits allowed in this column. These digits are in a particular radix, or number base – i.e. binary (base-2) or decimal (base-10). They are usually defined with a decimal point. The scale, also an integer value, represents the number of decimal places to the right (if positive) or left (if negative; this is rarely used) of the decimal point. 12345&gt; CREATE TABLE account (&gt; accountNo integer,&gt; balance numeric(8,2)&gt; );&gt; Exact numeric data types(means the values are stored as a literal representation of the number’s value): NUMERIC(p, s), DECIMAL(p, s), DEC(p, s) INTEGER, INT, SMALLINT Approximate numeric data types(means they are not represented as exact numbers in the database): FLOAT(p) REAL DOUBLE PRECISION Oracle数据库中NUMBER数据类型的例子： 创建数据表的语句12345CREATE TABLE tablename&#123; colname datatype [NOT NULL] &#123; , colname datatype [NOT NULL] ...&#125; [ , PRIMARY KEY (colname &#123; , colname ...&#125;)]&#125;; (1) [ … ] -&gt; 表示可选，即出现0次或者1次 { … } -&gt; 表示出现0次或者多次 (2) CREATE TABLE (3) NOT NULL (4) PRIMARY KEY 说明创建一个数据表时，必须至少包含一个属性，另外主键可以有0个、1个或者多个 简单的选择语句select语句12345SELECT ......FROM …...[ WHERE …… ][ GROUP BY …... [ HAVING …… ] ][ ORDER BY …… ]; 1234567SELECT * | colname &#123; , colname ... &#125;FROM tablename &#123; , tablename ... &#125;[ WHERE search_condition ][ GROUP BY colname &#123; , colname ... &#125;[ HAVING search_condition ] ][ ORDER BY colname [ ASC | DESC ]&#123; , colname [ ASC | DESC ] ... &#125; ]; 可以看出HAVING语句是跟GROUP BY一起使用的，不能单独存在；另外可以根据多个属性对查询结果进行排序，并且可以分别为每一个属性指定按照升序或者降序排列 关系代数和SQL查询 ALL|DISTINCTselect语句中可以添加all或者distinct来指示查询结果是否剔除重复行，下面的查询结果中每一行都是唯一的 1SELECT distinct pid FROM orders ; 表和列的别名 表别名 table_name as alias_name或者table_name alias_name，即as是可以省略的。给表取别名可以用在表与表自身联接查询的情况： （这里有一个技巧是通过c1.cid &lt; c2.cid来将查询结果重复行和逆序行去掉） 列别名 expression as alias_name，这个可以向表别名一样直接给列取别名（as同样是可选的），也可以给列表达式取别名，例如： 123SELECT ordno, dollars,o.qty*p.price*(1-c.discnt*0.01) as mydollarsFROM ... 表达式取别名的作用是在查询结果作为子查询的时候，能够方便的通过别名来访问使用了表达式的列 *贴一道诡异的题目（注释是我的个人理解，这样sql语句才能解释的通）： 子查询IN1expr [NOT] IN ( subquery ) 相关子查询和独立子查询（非相关子查询） 非相关子查询的执行不依赖与外部的查询。 执行过程：（1）执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。（2）执行外部查询，并显示整个结果。 相关子查询的执行依赖于外部查询。多数情况下是子查询的WHERE子句中引用了外部查询的表。执行过程：（1）从外层查询中取出一个元组，将元组相关列的值传给内层查询。（2）执行内层查询，得到子查询操作的值。（3）外查询根据子查询返回的结果或结果集得到满足条件的行。（4）然后外层查询取出下一个元组重复做步骤1-3，直到外层的元组全部处理完毕。 参考资料：https://blog.csdn.net/shiyong1949/article/details/80923083 例子： 另外要注意表名和列名作用域问题，IN语句中的表名和列名不能被语句外部使用： 定量比较谓词1expr  SOME|ANY|ALL ( subquery ) 定量谓词 vs [NOT] IN IN相当于SOME NOT IN相当于&lt;&gt; ALL ps：SOME 和 ANY是一样的（参考：https://stackoverflow.com/questions/1383988/tsql-some-any-why-are-they-same-with-different-names） 例子： 1571108972229 划线部分到底是ALL还是ANY/SOME？ 翻译的意思是：比任何客户都小。因此使用ALL 存在谓词1[NOT] EXISTS ( subquery ) NOT EXISTS可以用来实现差运算 BETWEEN运算符1expr [NOT] BETWEEN expr1 AND expr2 The BETWEEN operator selects values within a given range. The values can be numbers, text, or dates. The BETWEEN operator is inclusive: begin and end values are included. expr1和expr2是计算两个边界值的表达式 IS NULL运算符1column IS [NOT] NULL null值字段不能和其他非null字段直接比较（&gt;、&lt;、=等），可以使用IS NULL来判断一个字段的值是不是NULL LIKE运算符1column [NOT] LIKE val1 [ ESCAPE val2 ] val1是模板值（pattern），val2是转义指示字符 Underscore ( _ ) : Wildcard for any single character，任何单个字符的通配符 Percent ( % ) : Wildcard for any sequence of zero or more characters，任何零个或多个字符的通配符，即%可以不匹配任何字符 Escape character : Precedes quoted literal character，转义字符 All other characters : Represent themselves，代表字符本身","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"},{"name":"笔记","slug":"数据库/笔记","permalink":"http://QQ876684433.github.io/categories/数据库/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/tags/数据库/"}]},{"title":"数据库课堂笔记（2019-09-17）","slug":"数据库课堂笔记（2019-09-17）","date":"2019-09-17T03:25:09.000Z","updated":"2019-10-03T04:12:11.585Z","comments":true,"path":"2019/09/17/数据库课堂笔记（2019-09-17）/","link":"","permalink":"http://QQ876684433.github.io/2019/09/17/数据库课堂笔记（2019-09-17）/","excerpt":"","text":"数据库课堂笔记 参考资料： 南大软件学院课程《数据管理基础》课程资料 《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著 《数据库系统概论》第五版 - 王珊 萨师煊 著 《数据库系统概念》 数据库课堂笔记（2019-09-17）Ch2. The Relational Model操作的相互依赖性（The Interdependence of Operations） 基本关系集合：并、差、乘积、选择、投影[、别名]，这可以称为关系完备（Relationally Complete）的 交运算 连接运算 除法运算 其他的关系运算外联接（OUTER JOIN） 外联接是左外联接和右外联接的并集 联接运算符（JOIN）无法反向重构出原来参与运算的关系表，例如如果通过（R JOIN S）和R反向重构出S： 外联接与比普通联接运算符的不同在于：针对未参与自然联接的元组u，生成对应的外联接结果元组时使用null来填充空缺值。例子如下 外联接可以通过结果和其中一个关系来反向重构另一个关系： 1反向重构关系S： ((R outer join S) where C&lt;&gt;null )[B, C] θ - 联接 定义： 一个更加通俗理解是这样： 可以把θ联接看成是带条件查询的笛卡尔乘积 自然联接是θ联接中的的θ为”=”的特殊情况，即： 文字描述： 要求关系R和关系S必须有相同的属性组B(B1, B2, …) R和S的属性组B的值完全相同的元组才能够连接 要在结果中去掉重复的属性列（这些重复列的值完全一样） 例子：","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"},{"name":"笔记","slug":"数据库/笔记","permalink":"http://QQ876684433.github.io/categories/数据库/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/tags/数据库/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-15T05:02:14.666Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/09/15/hello-world/","link":"","permalink":"http://QQ876684433.github.io/2019/09/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"数据库课堂笔记（2019-09-12）","slug":"数据库课堂笔记（2019-09-12）","date":"2019-09-12T03:25:09.000Z","updated":"2019-09-21T02:50:12.234Z","comments":true,"path":"2019/09/12/数据库课堂笔记（2019-09-12）/","link":"","permalink":"http://QQ876684433.github.io/2019/09/12/数据库课堂笔记（2019-09-12）/","excerpt":"","text":"数据库课堂笔记 参考资料： 南大软件学院课程《数据管理基础》课程资料 《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著 《数据库系统概论》第五版 - 王珊 萨师煊 著 《数据库系统概念》 数据库课堂笔记（2019-09-12）Ch2. The Relational Model关系代数（Relational Algebra）自然关系运算 连接（等值连接，自然连接，JOIN） 其作用是： 根据两个关系中的同名属性的相等比较， 来实现两个关系的合并；可以表示为 R join S 或者 R ∞ S 如果R和S的同名属性为B1和B2，那么这里的R ∞ S相当于：((R × S) where R.B1 = S.B1 and R.B2 = S.B2 ) [R.A, R.B1, R.B2, S.C]。注意与R × S的区别：R × S没有进行任何同名属性的比较，只是单纯进行笛卡尔积，并且新的表的表头是原来两个表的表头的拼接。 If Head(R) ∩ Head(S) = ∅ , then R ∞ S = R x SIf Head(R) = Head(S) , then R ∞ S = R ∩ SIf Head(R) is subset of Head(S) , then R ∞ S is subset of S 乘积和连接运算满足交换律和结合律： 1) R x S = S x R2) R ∞ S = S ∞ R 3) (R x S) x T = R x (S x T)4) (R ∞ S) ∞ T = R ∞ (S ∞ T) 除法（Division） 注意T：the largest possible set 除法有如下性质： 使用除法操作的场景：可以使用除法division运算来回答使用关键词”All、所有”的问题 （1）对PRODUCTS进行投影操作PRODUCTS[pid]的原因：除数的列集合必须是被除数的列集合的子集 （2）为什么要对ORDERS在cid、pid上进行投影：因为我们最终想要的结果只需要cid的集合，因此其他属性不需要投影，而pid在进行除法运算后就没了","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"},{"name":"笔记","slug":"数据库/笔记","permalink":"http://QQ876684433.github.io/categories/数据库/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/tags/数据库/"}]},{"title":"152.乘积最大子序列","slug":"152-乘积最大子序列","date":"2019-09-10T03:38:00.000Z","updated":"2019-09-15T05:02:14.662Z","comments":true,"path":"2019/09/10/152-乘积最大子序列/","link":"","permalink":"http://QQ876684433.github.io/2019/09/10/152-乘积最大子序列/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数据库课堂笔记（2019-09-10）","slug":"数据库课堂笔记（2019-09-10）","date":"2019-09-10T03:25:09.000Z","updated":"2019-09-17T14:22:52.096Z","comments":true,"path":"2019/09/10/数据库课堂笔记（2019-09-10）/","link":"","permalink":"http://QQ876684433.github.io/2019/09/10/数据库课堂笔记（2019-09-10）/","excerpt":"","text":"数据库课堂笔记 参考资料： 南大软件学院课程《数据管理基础》课程资料 《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著 《数据库系统概论》第五版 - 王珊 萨师煊 著 《数据库系统概念》 数据库课堂笔记（2019-09-10）Ch2. The Relational Model键、超键和空值（Keys，Superkeys，and Null Values）键（Keys） 条件1说明了任意一行u在属性集K上的值是唯一的；表可能具有不止一个键；关系规则3保证了所有列的集合可以唯一区分任意两行，因此关系中至少存在一个键 超键（Superkeys） 属性集是不是键或者超键，取决于“设计者的意图”，有时候某些属性集在特定时刻它满足条件1，但是可能随着时间的改变，很有可能不再满足该条件，这样的属性集不是键或者超键 空集既不是超键也不是键，因为属性集为空集时无法唯一确定某一行，因为所有行在空集上的取值都是空集 候选键和主键（Candidate Key &amp; Primary Key） 主键是数据库设计者从候选键中选择出来，用来唯一确定数据表某一行的键 它有可能被其他表用来作为对当前表特定行的引用来使用 空值（Null Values） 空值应该被解释为未知的或者尚未定义的，意思是当我们以后知道更多情况的时候会重新填写该值。 A null value is placed in a field of a table when a specific value is either unknown or inappropriate. 要注意的是：空值和数字0（对于数值属性）或者是空串（对于字符串属性）是不同的 主键不能包含空值，因为表的主键是唯一区分表的单独行的，在还没确定主键的值之前，该行是不允许被存储到数据表中的 实体完整性规则与3NF等价 空值无法与任何非空值进行比较，用属性的非空值作为条件进行查询，永远也无法查询到该属性为空值的所在行 关系代数（Relational Algebra）关系代数可以看作根据查询结果来生成新表的方法的集合，这些方法称为关系代数运算。 关系代数的运算分为两种类型： 集合论运算：以行为元素单位进行的集合运算 自然关系运算：基于行的结构的运算 相容表（兼容表）当表R和S有相同的表头（表标题），那么表R和表S是相容表，即： 相同的表头的含义：相同数量的属性、属性对的域相同、属性对有相同的名字 ps：关系型数据库中，两列有相同的含义意思是他们有相同的列名（属性名）；同时属性集是无序的，因此两个数据表的表头中属性顺序不一致，并不影响它们是相容表 交、并、差 并（UNION）和交（INTERACTION）是满足交换律和结合律的；差（DIFFERENCE）不满足交换律 赋值、别名 S为表R的别名，简写为S:=R，通常用于：“关系自身的连接运算”、用来保存计算的“中间结果”。 乘积运算（R×S）乘积运算是基于集合运算中的笛卡尔积的，它可以允许我们建立一个包含两个表中行之间所有可能的相互联系的新表。 我们可以使用相对较小的表来构造大表，例如1000行的表的积可以有100万行 当要计算表与自身的乘积时，会存在限定符名重复的问题，例如乘积R×R是不允许的，我们可以通过使用表的别名来避免，例如S:=R，那么R与自身的乘积可以表示为：R×S 自然关系运算 用关系代数表达式回答用自然语言表达的对数据的查询要求，我们称这样的表达式为关系代数查询，简称为查询 投影运算（project） 投影运算实际上是在表中选择列的运算，运算结果其实是新的表，因此它会将重复的行删除，以保证任意两行是不一样的 选择运算（selection） 从给定的表中选择出满足特定准则的行来构成新的表 C是比较表达式，比较符号有：&lt;, &gt;, =, &lt;=, &gt;=, 和&lt;&gt;，其中&lt;&gt;为不等符号，类似于!= 如果比较的条件中有字符常量，那么要使用引号，例如city=&#39;Dallas&#39;，其中字符常量是按照字典顺序来比较的 比较条件可以是复合表达式，例如C AND C&#39;等 进行选择运算时要避免内容依赖的问题：即对于某个特定时刻表的内容，两个查询结果相同还不足以保证这两个查询表达式是等价的，他们必须要求对于所有可能的表的内容都给出相同的结果 关系代数的优先级","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"},{"name":"笔记","slug":"数据库/笔记","permalink":"http://QQ876684433.github.io/categories/数据库/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/tags/数据库/"}]},{"title":"软件系统设计02-质量属性策略","slug":"软件系统设计02-质量属性策略","date":"2019-09-09T12:37:15.000Z","updated":"2019-09-21T02:02:20.102Z","comments":true,"path":"2019/09/09/软件系统设计02-质量属性策略/","link":"","permalink":"http://QQ876684433.github.io/2019/09/09/软件系统设计02-质量属性策略/","excerpt":"","text":"软件系统设计02-质量属性策略第四章 理解质量属性质量属性定义质量属性（Quality Attribute，QA）：它是一个系统可度量或者可测试的属性，用来指示系统在多大程度上满足了它的利益相关者的需求 架构和需求需求的分类 功能性需求（Functional Requirements）：描述了系统必须做的事情（必须实现的功能），以及在运行时接受外部刺激时系统应该表现出的行为或者反应 质量属性需求（Quality Attribute Requirements）：它是功能性需求或者整个产品的质量或者限定条件——对于功能性需求来说，它描述了系统响应有多快或者在接受错误输入时必须具备多大的弹性等；对于整个系统来说，它描述了产品的部署需要的时间或者对运营成本的限制 约束（Constraints）：约束条件是具有零自由度的设计决策，即是说它是一个已经做出的设计决策，不能再修改。例如系统使用的编程语言或者要依赖的指定模块等 不同种类的需求在架构中的体现 功能性需求：通过整个设计中合适的职责分配来满足 质量属性需求：通过设计到架构中的各种结构以及填充这些结构的元素的行为和交互来满足 约束：通过接受设计决策并将其与其他受影响的设计决策进行协调来满足约束条件 功能性需求功能性需求不能决定架构。原因是对于一个给定的功能性需求集合，我们可以有很多不同的方法来将功能性需求划分到不同的架构模块中；事实上，即使我们不划分模块，甚至内部毫无架构结构可言，也依旧有可能将功能性需求实现。 我们进行架构设计是为了使得系统更加易于理解，以便支持各种各样的其他目的——即质量属性需求。 尽管功能性需求独立于特定的系统结构，但是它是通过将系统的职责分配到不同的架构元素中来实现的；虽然职责可以被任意分配到某一个模块中，但是当质量属性占很重要地位的时候，软件架构会约束系统职责的分配。 质量属性考量功能性需求和质量属性都不是自身独立的。 从架构师的角度，系统质量属性会有以下三个问题： 某个质量属性的定义是不可测试的 对质量属性的讨论通常侧重于特定问题所属的质量，而且这个问题往往在不同的质量属性范围中有重叠 每个质量社区都发展出了自己的属性词汇 前两个问题可以通过才用“质量属性场景”这个工具来区分不同的质量属性；第三个问题可以通过对每一个属性的多个社区词汇进行讨论，寻找出某个质量属性的不通社区词汇之间最本质最基础的概念 质量属性分类 系统运行时的属性：可用性（Availability）、性能（Performance）、易用性（Usability）等 系统开发时的属性：可修改性（Modifiability）、可测试性（Testability） 在复杂的系统中，质量属性相互之间不可能是独立开的，一个质量属性的实现对其他质量属性产生或积极或负面的影响，因此在架构设计时需要在这些设计决策之间作出合适的权衡。 制定质量属性需求质量属性需求应当是明确的和可测试的。质量属性表达的常用形式包含这些部分： 刺激（Stimulus）：到达系统的事件，例如易用性中的用户操作，安全性中的外部攻击，可修改性中的修改需求，可测试性中的某个开发阶段的完成等 刺激源（Stimulus source）：不同的刺激源，系统对待和处理的方式会不一样，例如受信任用户和不受信任用户经历的审查是不一样的 响应（Response）：对于刺激，系统应当采取的措施，例如在可修改性的场景中，一个修改需求的到达要求开发者将这个修改需求实现、测试并部署所作出的修改 响应度量（Response measure）：判断系统的响应是否满足需求，例如性能的度量可以是延迟或者吞吐量，可修改性的度量可以是工作量或者修改、测试和部署修改所需的时间等 环境（Environment）：需求的环境是一系列场景发生情况的集合，它充当了刺激的限定词，例如对待代码冻结以发布前后发生的错误，处理的方式是不一样的 工件（Artifact）：它是系统中需求适用的部分，不同的问题，它可能影响整个系统，也有可能只影响系统的某一个部分，例如数据库出错和元数据库出错的处理方式是不一样的，用户接口的修改需求和中间件的修改需求所需要的时间也是不一样的，等等 质量属性需求可以划分为六个场景，它们可能单独发生，也有可能伴随发生，特别是系统架构设计初期 质量属性场景示例图 通过策略来实现质量属性需求架构策略（Architectural Tactics）架构策略是用来实现需要的质量属性的技术，它是一种设计决策，会影响质量属性响应的实现以及会直接影响系统对某些刺激的响应。策略赋予一种设计可移植性，将性能传递给另一种设计，并将可集成性传递给第三种设计。 指导设计决策架构是应用设计决策集合的结果。设计决策可以分为七个类别，在设计架构的时候可以分别从某个设计决策的维度进行设计考量，降低架构设计的复杂度： 职责分配（Allocation of Responsibilities） 涉及职责分配的决策包括： 识别重要的职责（基础系统功能、架构基础设施、质量属性的满足） 决定如何将这些职责分配到运行时和非运行时元素 制定如上决策的策略有：功能分解、对真实世界对象建模、基于操作的主要模式分组、基于相似的质量属性分组 协作模型（Coordination Model） 软件架构中各个元素之间相互交互的设计机制就是协作模型，它包括如下方面： 识别系统中必须协作或者禁止协作的元素 确定协作的属性，例如时间线、完成度、正确性和一致性等 选择实现上面协作属性的通信机制，例如有状态的和无状态的、同步的和异步的、保证交付和不保证交付的，以及与性能相关的属性（吞吐量，延迟等） 数据模型（Data Model） 每个系统必须以某种内部方式表示系统范围内的数据，这就是数据模型。有关数据模型的决策如下： 选择主要的数据抽象（属性与相应的操作）。它包括数据的创建、初始化、访问、持久化、操作、解释和销毁 编译一致解释数据所需的元数据 组织数据，包括数据是否要存储在关系型数据库、对象集合中，或者两者兼有。如果两者兼有，则还得确定两个不同位置之间的映射 资源管理（Management of Resource） 软件架构必须仲裁系统中共享资源的使用，包括硬件资源（CPU、存储、电源、硬件缓冲、系统时钟和I/O端口等）和软件资源（系统锁、软件缓冲、线程池，以及非线程安全的代码），资源管理决策包括如下方面： 识别必须被管理的资源，确定每种资源的限度 确定每种资源是由哪个系统元素管理的 当资源存在竞争时，要确定资源的共享方式以及采取的仲裁策略 确定各种资源饱和时会造成的影响，例如随着CPU负载的增加，系统的性能会相应地下降；当内存逐渐耗尽，会在某个点开始密集地分页/交换，随之而来的是性能突然下降甚至崩溃 架构元素之间的映射（Mapping among Architectural Elements） 不同类型架构之间的映射 例如开发单元（模块）到执行单元（线程或者进程）的映射 软件元素和环境元素之间的映射 例如进程到特定CPUs的映射 一般有如下比较实用的映射： 开发模块与运行时元素之间的相互映射，即运行时元素是由每个模块创建出来的，开发模块包含了对应每个运行时元素的代码 运行时元素到处理器的分配 数据模型到数据存储的分配 开发模块和运行时元素到交付单元之间的映射 绑定时间决策（结合时间决策，Binding Time Decision） Binding time is an important, yet underestimated viewpoint in software architecture and design. It defines the latest time during the software life cycle when something flexible becomes decided and fixed. This heavily impacts the flexibility of a software design and the resulting application. A terminology for describe binding time is established and an analysis is carried out in form of side-by-side comparisons for patterns and mechanisms from the creational, structural, and behavioral domains. These terminology and synoptic comparisons with the binding time considerations can aid software architects and developers in selecting patterns and taking correct architectural decisions for their binding time requirements. ——Abstract from Paper “Describing binding time in software design patterns” 绑定时间是软件架构和设计中一个重要但却被低估的观点，它定义了软件生命周期中具备灵活性的元素变成确定的和固定的状态时的最迟时间。它会深刻影响软件设计以及最终应用程序的灵活性。 其他六种决策也都和结合时间决策有关联： 对于职责分配，可以在构建编译时通过参数化的makefile来选择模块 对于协作模型的选择，可以设计一个运行时通信协议进行协作 对于资源管理，可以设计一个机制，使得系统能够允许在运行时接受新的外围设备插入，紧接着识别设备并自动下载安装相应的驱动程序 对于技术选型，可以构建app store方式来为已经购买app的用户自动下载适合版本的app等 在制定结合时间决策时，要考虑实现这种决策的开销，以及后续修改这种决策实现的开销。例如考虑到代码开发完成后有迁移系统平台的可能性，那么就应该在设计时通过一些额外的开销来将自己的开发工作变得平台独立，以便后续的平台移植。 技术选择（Choice of Technology） 技术选择是这七种决策的约束，因此我们必须选择合适的技术来实现这七种决策。技术选型决策包含以下方面： 确定哪些技术能够实现其他六种决策 确定是否有合适的开发工具（IDEs，模拟器，测试工具，等等）来支持开发活动 确定内部人员对技术的熟悉程度，以及外部资源对技术的支持程度（例如课程、手册、示例，以及能够提供紧急情况专业知识的承包商的可用性） 确定所选技术的副作用，例如技术限制的协作迷行、资源管理等 确定一个新的技术是否和现有的技术栈兼容 第五章 可用性Availability=detect+correct+restart 当系统提供的服务与相应的服务规格不一致的时候，我们认为该系统失效（Failure）了，这种失效是可以被系统的用户直接观测到的 可用性损失期（从发生故障到发现故障，修复故障，最后到系统重启恢复到故障发生前的状态）由以下方面决定： Time to detect failure Time to correct failure Time to restart application 单点故障 单点故障（英语：single point of failure，缩写SPOF）是指系统中一旦失效，就会让整个系统无法运作的部件，换句话说，单点故障即会整体故障。 高可用性的一些策略： 消除单点失效（单点故障） 复制（备份机制，例如checkpoint等）、故障转移（快速恢复） 自动检测和重启机制 可恢复性 在应用程序或系统发生故障后重新建立性能级别并恢复受影响数据的能力 可用性的计算方式 可用性可以计算为在指定时间间隔内在指定范围内提供指定服务的概率，一般表示为%形式，如下图所示： 要注意的是，由于系统维护的原因，在计算可用性时不会考虑定期的关机时间。 根据上面的公式，可以想到的提高可用性的措施： 缩短系统修复时间 延长系统两次失败之间的时间间隔 Outage, Failure, Fault, and Error Fault：系统出错或者故障，他是系统失效（failure）的原因，但是此时系统还是可用的 Failure：系统失效，它是系统状态可以被观测到的特征，往往当系统Failure时，这个系统已经不能为用户提供系统预期的服务了，甚至有可能系统已经宕机了 Error：是由Fault变成可观测的系统Failure的中间状态 Outage：指的是系统停机或者停止服务时间，它包括系统失效/出故障这种非正常的情况，也包括定期维护而停止服务的时间；提高可用性就是通过减少系统出错（Fault），从而缩短系统停止服务（Outage）的时间 为了使系统更加安全和高可用，首先需要对这两方面进行分析：自己定系统最容易发生错误，以及每种错误发生后最有能造成的后果。为了进行这种分析，可以才用如下方法： 危害分析（Hazard Analysis） 可以根据严重性来对每种危害进行分类，例如： 灾难性的（Catastrophic）：这种失效会导致整个系统直接崩溃，后果最严重 赌运气的（冒险的，Hazardous）：这种失效对系统的安全或者性能有很大概率的负面影响 重大的（Major）：危害也很重大，但是程度比上面两种稍微轻一些 轻微的（Minor）：这种失效是显而易见的，但是危害程度小很多 没有影响（No Effect）：这种失效没有任何影响 故障树分析（Fault Tree Analysis） 失效模式，效果和临界性/危害性分析（Failure Mode, Effects, and Criticality Analysis） 可用性通用场景 可用性策略（Tactis for Availability）由于系统出错（Fault）有可能导致系统失效（Failure），因此我们应该采取一些策略来防止出错（Fault）演变成失效（Failure），或者至少限制出错的影响范围然后尽可能修复。 （题外话：这些策略有可能以软件基础设施的形式提供（例如中间件工具包），所以架构师的职责之一是选择和使用（而不是实现它）适合的可用性策略以及正确的策略组合） 错误检测（Detect Faults） Ping/Echo 它是节点间异步的请求/响应消息对，通常用来确定可达性和往返延迟，同时echo节点也能够通过ping来确定发出ping的组件是存活的、能够正确响应的 通常来说ping是由监控节点主动发出的，用来确认某个或者某些节点是可达的以及往返延迟是多少 Ping/Echo需要预设一个时间阈值，这个阈值用来告诉监控节点：在接收到echo之前，监控节点会等待多长时间，超时之后才会认为被监控的节点已经失效 Monitor（监视器） 监视器是用来监视系统中多个部分健康状况的组件，例如监控：处理器、进程、IO、存储等待 HeartBeat（心跳机制） HeartBeat在系统监视器以及被监视的进程之间周期性地交互消息以检测是否有错误发生 例子： 被监控的进程周期性地主动发送心跳消息到监视器以重置watch dog中的计时器，防止计时器超时而使得监视器错误地发出一个错误信号标识被监控的进程失效 HeartBeat vs Ping/Echo：区别主要在于负责初始化健康监测机制的组件是谁，监视器还是被监控的组件自身，HeartBeat中是被监控的进程主动发出心跳信号，而Ping/Echo中是监视器主动发出ping信号来监测被监控组件的健康状态 Timestamp（时间戳） 主要用于监测不正确的时间序列，一般用在分布式消息传递系统中。可以通过在事件发生时立即将本地时间附加到事件消息中来实现时间戳机制；如果具体的时间信息不重要的话，可以直接使用序列数字作为时间戳（但这样的话似乎需要一个集中发放序列号的组件？） Sanity Checking（健全检测） 它通常是用来监测某个特定操作或者某个组件的输出的有效性或者合理性，这种策略通常基于系统内部设计、系统的状态或者正在审议中的信息等；它经常在接口中采用，用来检验特定的信息流 Condition Monitoring（条件监控） 它通常是用来监测一个进程或者设备的条件状态、或者验证设计时做出的假设的有效性。例如常见的方法是校验和checksum。但是监控组件自身必须足够简单以避免引入新的软件错误 Voting（投票） 这种策略最常见的实现方式是三重模块化冗余（triple modular redundancy，TMR），使用是三个组件来做同样的事情，每个组件都接受相同的输入，然后将它们的输出转发到投票逻辑单元（voting logic）中检验三个输出状态的一致性 当遇到输出状态不一致的时候，投票器会报告出错状态，但同时它也还需要决定输出结果是什么，一般可以采用多数人规则（majority rule）或者对离散结果取平均，这些策略都取决于具体的投票逻辑。并且，投票逻辑应该被实现为一个简单、经过严格审查和测试的单例，以降低引入新的错误的概率 Replication：各个组件是相互之间的克隆，通过相同组件的拷贝可以防止硬件的随机错误，但是不能避免软件或者硬件在设计或者实现上的错误，因为这种策略的各个组件没有差异化的设计 Functional Redundancy（功能冗余）：这些组件是差异化设计和实现的，但是它们对相同的输入，总是应该给出相同的输出 Analytic Redundancy（分析冗余）：这种策略中，不仅组件内部的实现是差异化的，他们的输入输出也是差异化的。这种策略的目的是通过使用单独的需求规范来容忍设计规范的错误。在嵌入式系统中，有些输入源可能失效，这时候分析冗余就可以生效了。 Exception Detection（异常检测） 它通常是监测改变了正常执行流的系统条件，可以分为以下几种： 系统异常（system exception）：不同的处理器硬件架构会有不同的系统异常，例如除零、总线和地址出错、非法程序指令等等 参数围栏（the parameter fence）：它包括一个先验的数据模式（例如0xDEADBEEF），它被放在一个对象的变长参数的后面，这允许在运行时监测到分配给一个对象的变长参数的内存是否被overwrite 参数类型（the parameter typing）：使用一个基类来定义函数，例如add、find等，然后派生类使用基类的函数接口，根据自身不同的参数结构来实现不同的功能。使用强类型来构建和解析消息，比简单的把消息看作一串字节，更能够减少出错、提高可用性，当然也会因此使得系统演化变得复杂 超时（timeout）：当组件没有在时间限制内完成的话，该策略会抛出一个超时异常 一般来说异常检测策略是在一个进程内部操作的，而ping/echo以及heartbeat时在不同进程键进程操作的 Self-test（自检） 组件可以运行一个进程来监测自身操作的正确性，这个自检进程可以由组件自身初始化，也可以由系统监视器初始化。自检技术包括校验和checksum等 错误恢复（Recover from Faults）预备和恢复策略（Preparation and Repair） Active Redundancy（hot spare，主动冗余，热备份） 它将所有的节点（主动节点和冗余备份节点）配置在一个保护组中，它们并行地接收和处理相同的输入（只会才用主动节点的输出，其他的输出会被舍弃），这样可以使得冗余备份节点和主动节点保持同步的状态，因此它们可以在主动节点失效的时候立刻切换和接管工作。最简单的实现方式是1+1冗余（一个主动节点+一个冗余备份节点）。主动冗余可以用来作为基础设施北湖，例如活跃的网络链路和支援的网络链路一起使用可以提高网络连接的高可用性 Passive Redundancy（warm spare，被动冗余，热备用） 在保护组中只有主动成员才处理输入流量，同时给保护组中的冗余备份节点提供周期性的状态更新。当主动节点出错的时候，系统必须确定冗余备份节点的备份状态足够新（即足够接近主动节点出故障时的状态）才能够被作为替补恢复到正常的系统服务体系中，因此恢复的时间可能比主动冗余要慢 Spare（cold spare，候补，冷备用） 这个策略下冗余备份节点在主动节点发生故障前都是不提供服务的，因此当备份节点需要替换到正常系统体系中前，它需要启动一个power-on-reset进程来将自身的状态更新到主动节点出故障前的状态。由于它糟糕的恢复性能，它一般更适用于只有高可靠性需求（而对高可用性需求不高）的系统中 Exception Handling（异常处理） 一旦检测到系统异常，系统必须以某种方式进行处理。异常处理的方式很大程度上取决于所使用的开发环境，从简单的函数返回状态码/错误码，到使用包含了对错误纠正有用的信息的异常类，例如异常的名字、异常源头以及异常的原因，软件可以利用这些信息来掩盖出错，一般来说是纠正出错的原因然后重新尝试操作 Rollback（回退） 重新引入策略（Reintroduction） 这个部分关注将一个失效（但是已经恢复）的组件引入到正常的系统体系中","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"},{"name":"软件系统设计","slug":"笔记/软件系统设计","permalink":"http://QQ876684433.github.io/categories/笔记/软件系统设计/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://QQ876684433.github.io/tags/架构/"}]},{"title":"91.解码方法","slug":"91-解码方法","date":"2019-09-06T11:29:49.000Z","updated":"2019-09-15T05:02:14.662Z","comments":true,"path":"2019/09/06/91-解码方法/","link":"","permalink":"http://QQ876684433.github.io/2019/09/06/91-解码方法/","excerpt":"","text":"91.解码方法原题目如下： 一条包含字母 A-Z 的消息通过以下方式进行了编码： ‘A’ -&gt; 1‘B’ -&gt; 2…‘Z’ -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 输入: “12” 输出: 2 解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。 示例 2: 输入: “226” 输出: 3 解释: 它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/decode-ways著作权归领扣网络所有。 解题思路这道题刚开始做的时候思路是挺清晰的，就是动态规划，从左往右遍历一遍即可。对于一个长度为n的串s，由于编码只有一位数和两位数这两种可能，因此很容易得出 1numDecodings(s[1:n]) = numDecodings(s[1:n-1]) + numDecodings(s[1:n-2]) 当然不是直接相加那么简单，这要分情况讨论一下： （1）如果s[i]非0（由题可知，0不是合法的编码），s[1:n]一定可以按照在s[1:n-1]的所有解码方式后面加上s[i]来解码 （2）如果s[i-1]s[i]是合法的编码（即10&lt;=int(s[i-1]s[i])&lt;=26，大于等于10的是因为01、02等待这种以0开头的两位数不是合法的编码），那么s[1:n]也一定可以按照在s[1:n-2]的所有解码方式后面加上s[i-1]s[i]来得到 （3）否则上面两种情况都不符合，那么s[1:n]无论如何也无法进行解码，比如出现连续两个0的情况 我当时做的时候，因为没有考虑编码串中出现0的情况，所以出现了偏差。另外，由于前面做题的惯性思维，动态规划问题老是想构造数组，后来细细想这道题才发现根本不需要那么大的空间开销，只需要记录dp[i-1]和dp[i-2]即可计算出dp[i]。最终的解决方案如下： 1234567891011121314151617181920class Solution &#123;public: int numDecodings(string s) &#123; int n = s.size(); if(s.empty()) return 0; if(n==1) return s[0]!='0'; unsigned long long prev = 1, target = s[0]=='0'?0:1; for(int i = 1;i&lt;n;i++)&#123; unsigned long long temp = 0; if(s[i]!='0') temp = target; // int val = (s[i-1]-'0')*10+(s[i]-'0'); // if(val&gt;=10&amp;&amp;val&lt;=26) temp+=prev; if(s[i-1]=='1'||s[i-1]=='2'&amp;&amp;(s[i]&lt;='6'))temp+=prev; prev = target; target = temp; &#125; return target; &#125;&#125;; 测评的结果如下，然后我看了一下最高分的解答，思路跟我的差不多，就没必要去优化了 题解题解没什么比较新的角度，跟我的想法差不多，就不再赘述","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"63.不同路径II","slug":"63-不同路径II","date":"2019-09-04T13:20:26.000Z","updated":"2019-09-15T05:02:14.662Z","comments":true,"path":"2019/09/04/63-不同路径II/","link":"","permalink":"http://QQ876684433.github.io/2019/09/04/63-不同路径II/","excerpt":"","text":"63.不同路径II原题目如下： 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1: 输入:[ [0,0,0], [0,1,0], [0,0,0]] 输出: 2 解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径： 123&gt; 1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下&gt; 2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右&gt; 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-paths-ii著作权归领扣网络所有。 解题思路这道题与前一道题的区别只在于输入的二维数组增加了障碍物这一限制条件，只要在之前的思路（详见前面的链接）上稍作修改即可，用m和n分别表示输入的数组的行和列，我自己当时的解题思路如下： 采用自底向上的递推方式，还是采用一位数组来降低空间开销，将dp数组初始化为包含m个元素的数组，然后将最后一个元素设置为1，原因是从最底层走，不考虑障碍物的情况下，只有一条路径能够到达目的地（后来发现出现的问题就是，如果目的地就是障碍物的话，这样是无法AC的，所以在开始推导的最开始直接排除了这种情况if(obstacleGrid[m-1][n-1]==1) return 0;，省事） 推导的核心公式是dp[j] = dp[j]+dp[j+1];，所以存在边界的问题，因此限定0 ≤ j ≤ m-2，而j = m-1的情况（即最底层）单独判断：如果在点obstacleGrid[m-1][i]遇到障碍物，则将dp数组的最后一个元素设置为0，表示从最底层小于等于点i的开始走，必然无法走到目的地 如果不是在最底层遇到障碍物（设为点obstacleGrid[j][i]），则只需要将dp[j]设置为0，表示从该点开始走，无法走到目的地，对其他路径的贡献为0 所以最终的解决方案如下： 12345678910111213141516171819202122class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); if(obstacleGrid[m-1][n-1]==1) return 0; vector&lt;long&gt; dp(m-1, 0); dp.push_back(1); for(int i = n-1;i&gt;=0;i--)&#123; if(obstacleGrid[m-1][i]==1)&#123; dp[m-1] = 0; &#125; for(int j = m-2;j&gt;=0;j--)&#123; if(obstacleGrid[j][i]==0)&#123; dp[j] = dp[j]+dp[j+1]; &#125;else&#123; dp[j] = 0; &#125; &#125; &#125; return dp[0]; &#125;&#125;; 提交之后，虽然AC了，但是感觉有点不够优雅： ps：这里有个坑是大数组的输入，如果使用vector&lt;int&gt;会溢出，改用vector&lt;long&gt;就可以了，这个也是没办法的 题解思路一学习了leetcode官方的题解后发现自己的思路局限在了自底向上的角度，实际上自顶向下和自底向上最终的 结果是一样的，但使用自顶向下似乎更有助于思考问题。 最关键的问题还是集中在遇到障碍物时采取的措施上，因为题目没有要求输入数据不能修改，可以直接使用obstacleGrid作为dp数组，达到最优化空间复杂度，这样dp递推方程就变成了： 1obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]; 而当obstacleGrid[i][j]是障碍物时，可直接将其置0： 如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。 这个可以体现在上面的递推方程上。即使是这样，还是避免不了边界条件的处理，这里就不展开了。 思路二归根结底，解法不优雅的根源是边界问题的处理，所以也可以通过在原有的数组行列上各添加一维全0的数据，这样就比较优雅了。","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"62.不同路径","slug":"62-不同路径","date":"2019-09-04T11:37:53.000Z","updated":"2019-09-15T05:02:14.662Z","comments":true,"path":"2019/09/04/62-不同路径/","link":"","permalink":"http://QQ876684433.github.io/2019/09/04/62-不同路径/","excerpt":"","text":"62.不同路径原题目如下： 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 输入: m = 3, n = 2 输出: 3 解释:从左上角开始，总共有 3 条路径可以到达右下角。 向右 -&gt; 向右 -&gt; 向下 向右 -&gt; 向下 -&gt; 向右 向下 -&gt; 向右 -&gt; 向右 示例 2: 输入: m = 7, n = 3 输出: 28 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/unique-paths 解题思路这道题一看就是很典型的动态规划问题，一般来说都可以从填表入手，动态规划方程： 1dp[i][j] = dp[i-1][j] + dp[i][j-1] 所以可以从初始状态开始（即finish处开始）推导填表，最后得到的就是问题的解。举个简单的例子，m=7，n=3（其实m和n是可以互换的对结果没有影响）： 这样就可以通过一个二维数组来解决问题。一般来说二维数组开销太大，而且往往都能够通过压缩成一维数组来解决，因为dp[i][j]计算出来之后，dp[i-1][j]和dp[i][j-1]的值就不再需要了，所以最终的解答如下： 123456789101112class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;int&gt; dp(m, 1); for(int i = 1;i&lt;n;i++)&#123; for(int j = 1;j&lt;m;j++)&#123; dp[j] = dp[j]+dp[j-1]; &#125; &#125; return dp[m-1]; &#125;&#125;; 一次AC，惊喜满满： 题解题解给出的方案和我的差不多，这里就没必要展开了，但是里面提供了一个数学角度的解决方案： 思路：排列组合 因为机器到底右下角，向下几步，向右几步都是固定的， 比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。 所以有 C_{m+n-2}^{m-1}Cm+n−2m−1 作者：powcai 链接：https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/ 来源：力扣（LeetCode）","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"数据库课堂笔记（2019-09-03）","slug":"数据库课堂笔记（2019-09-03）","date":"2019-09-03T11:53:37.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/09/03/数据库课堂笔记（2019-09-03）/","link":"","permalink":"http://QQ876684433.github.io/2019/09/03/数据库课堂笔记（2019-09-03）/","excerpt":"","text":"数据库课堂笔记 参考资料： 南大软件学院课程《数据管理基础》课程资料 《数据库原理、编程与性能》原书第二版 - Patrick O‘Neil、Elizabeth O’Neil 著 《数据库系统概论》第五版 - 王珊 萨师煊 著 《数据库系统概念》 数据库课堂笔记（2019-09-03）Ch1. Introduction术语 数据库管理系统（DataBase Management System，DBMS） Connolly and Begg define Database Management System (DBMS) as a “software system that enables users to define, create, maintain and control access to the database“. … The core functionality is the storage, retrieval and update of data. The database management system (DBMS) is the software that interacts with end users, applications, and the database itself to capture and analyze the data. —— from wikipedia 简单理解就是，数据库管理系统是终端用户、应用程序同数据库本身交互的软件 数据库（Database） A database is an organized collection of data, generally stored and accessed electronically from a computer system. Where databases are more complex they are often developed using formal design and modeling techniques. —— from wikipedia 简单理解就是，数据库是一个有组织的数据集合 数据库用户（DataBase User） 最终用户——交互式用户 临时用户——用SQL访问DBMS的用户 初级用户——通过菜单访问DBMS的用户 应用程序员——编写菜单程序的程序员 数据库管理员（Database Administrator，DBA）——管理DBMS的专家 数据库系统的架构 主要有两层C/S架构和三层B/S架构两种： 两层C/S架构：数据库和DBMS运行在数据库服务器，数据库应用程序运行在客户机中，两者之间通过局域网实现数据访问（但是更多的时候， 数据库服务器及其应用程序可能分布在距离遥远的不同地方，这是得使用三层B/S架构来解决） 三层B/S架构：数据库和DBMS运行在数据库服务器中，数据库应用程序运行在应用服务器（也称“Web服务器”）中， 用户客户端只需要安装常用的浏览器， 负责接收用户输入和结果展示 数据模型数据模型（data model）是对现实世界数据特征的抽象，它是数据库系统的核心和基础。根据应用的不同目的可以划分为两大类：第一类是概念模型，第二类是逻辑模型和物理模型。 概念模型：按用户的观点来对数据和信息进行建模，主要用于数据库设计 逻辑模型：按计算机系统的观点对数据建模，主要用于数据库管理系统的实现 物理模型：对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法 概念模型 实体（entity）：客观存在并可互相区别的事物 属性（attribute）：实体所具有的某一特性 码（key）：唯一标识实体的属性集 实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体 实体集（entity set）：同一类型实体的集合 联系（relationship）：实体之间的联系通常是指不同实体集之间的联系，具有一对一、一对多和多对多等多种类型 概念模型的表示方法：实体-联系方法（Entity-Relationship approach），E-R方法也称为E-R模型 数据模型的组成要素： 数据结构：数据库的组成对象以及对象之间的联系 数据操作：对数据库汇总各种对象的实例运行执行的操作的集合，包括操作以及有关的操作规则 数据的完整性约束条件：一组完整性规则 常见的数据模型层次数据模型（Hierarchical Data Model ）满足两个条件： 有且只有一个结点没有双亲结点，这个结点称为根结点 根以外的其他结点有且只有一个双亲结点 层次模型中，每个结点表示一个记录类型，记录类型之间的联系用结点之间的有向边表示，这种联系是父子之间的一对多的联系，可以看做有向树结构 网状数据模型（Network Data Model）满足两个条件： 允许一个以上的结点无双亲 一个结点可以有多于一个的双亲 层次模型中子女结点与双亲结点的关系是唯一的，在网状模型中，这种关系可以不唯一 关系模型（Relational Model）从用户的观点看，关系模型由一组关系组成，每个关系的数据结构都是一张规范化的二维表： 关系：一个关系对应通常说的一张表 元组：表中的一行即为一个元组 属性：表中的一列即为一个属性 码：也称为码键，它是表中的某个属性组，可以唯一确定一个元组 域：域是一组具有相同数据类型的值集合，属性的取值范围来自某个域 分量：元组中的一个属性值 关系模式：对关系的描述，通常表示为关系名(属性1，属性2，属性3，...，属性n) 面向对象模型（Object-Oriented Model）对象关系模型（Object-Relational Model）Ch2. The Relational ModelCAP数据库 术语 数据模型（Data Model）：也称为数据库模型 它是一组描述如何用计算机化的信息表示现实世界中的数据的定义 也描述了访问和更新这些信息的操作类型 数据库（Database）：表（Table），或者说关系（Relation）的集合 表的标题（Table Heading）：表的列名（Column Name）集合，又称为模式（Scheme） 表的行（Row）集合：也就是元组（Tuple）的集合，称为表的内容，表的行数称为表的基数 数据库各部分的命名由于数据库的行是经常改变的，而列通常来说不会改变，一般推荐数据库用户使用列来进行数据库查询 程序数据独立性（Program-Data Independence ） when asked to make up a query to answer aquestion, query must still answer thequestion even if all the data changes. 查询语句和表的数据无关，二者是相互独立的，即使数据库中的表数据改变了，原有的查询依然能够执行（但是查询结果可能发生了改变） 域类型（Column type，也称 Domain和 Datatype） 大多数商业数据库系统都不支持有枚举集组成的类型（如city，month等），它体现了数据库的完整性约束（Integrity） 域完整性（Domain Integrity）域完整性是指保证指定列的数据具有正确的数据类型、格式和有效的数据范围。 particular type 例子：Domain(city in CUSTOMERS) vsDomain(city in AGENTS) ? 关系代数（Relational Algebra ）数据表中的列的域类似于大多数编程语言中的枚举类型 笛卡尔积数学上的笛卡尔积定义： 但是数据表的关系——即行的集合并没有包含数据表所有列的笛卡尔积中的所有元素，一般来说有如下关系： 关系规则数据库范式（Database Normalization）：一张数据表的表结构所符合的某种设计标准的级别。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。 数据库三大范式： 第一范式（1NF）：First Normal Form Rule数据表的列不允许有多值属性（重复的域）或者属性具有内部结构，也就是说要求列属性是原子的。 columns that have multi-valued attributes (repeating fields) or have any internal structure (record) are not permitted 以这个数据表为例，name具有内部结构，enrollment是多值属性（重复的域）（实际上enrollment也具有内部结构） 它有两方面的含义： 多值属性（重复的域）意思是某个属性的取值是某些元素的列表或者集合，例如第一行中的enrollment属性取值是((101, No), (108, Yes))，它是元素(cno, major)的列表或集合，解决方法有三种： 将多值属性拆分成多个属性 -&gt;（浪费空间并使得查询变得困难） 将具有多值属性的行（元组），按照多值属性的值集合拆分成多个行（元组）来表示，新的元组不再包含多值属性，这些元组在该属性的取值的集合等于原多值属性取值 -&gt; （包含大量冗余数据，浪费空间） 将多值属性和其他属性分拆到两个不同的表中，通过表的join运算来获得原数据表 -&gt;（最常用的操作） 内部结构意思是某个属性的取值不是原子的，或者是不是基本类型，例如name属性具有内部结构(name.Iname, name.fname)，解决方法是： ps：第一范式规则被对象-关系数据库系统的数据表打破，这些表是非第一范式（NFNF）。 第二范式（2NF）：Access Rows by Content Only Rule只能基于内容存取行的规则，说明我们只可以通过行的内容即每一行中所存在的属性值来检索列 can only retrieve rows by their content, the attribute values that exist in each row. 它暗示了： 行是无序的：即使用行号来访问数据表中指定行是无意义的 列是无序的：2NF中没有指明需要根据一定的属性次序来访问指定行 ps：大多数的关系型数据库产品打破了这条规则，允许用户通过RID-row ID来访问行；而且新的对象-关系数据库产品有refs语法允许某一行上列值指向另一行。 第三范式（3NF）：The Unique Row Rule行唯一性规则，它要求关系中任何两个元组的值在同一时刻不能是完全相同的，也就是说关系是元组的无序集合","categories":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/categories/数据库/"},{"name":"笔记","slug":"数据库/笔记","permalink":"http://QQ876684433.github.io/categories/数据库/笔记/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://QQ876684433.github.io/tags/数据库/"}]},{"title":"J.U.C-深入理解ConcurrentHashMap原理","slug":"J-U-C-深入理解ConcurrentHashMap原理","date":"2019-08-09T04:21:56.000Z","updated":"2019-09-15T05:02:14.662Z","comments":true,"path":"2019/08/09/J-U-C-深入理解ConcurrentHashMap原理/","link":"","permalink":"http://QQ876684433.github.io/2019/08/09/J-U-C-深入理解ConcurrentHashMap原理/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"深入理解红黑树","slug":"深入理解红黑树","date":"2019-08-09T04:20:24.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/08/09/深入理解红黑树/","link":"","permalink":"http://QQ876684433.github.io/2019/08/09/深入理解红黑树/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java NIO学习笔记","slug":"Java NIO学习笔记","date":"2019-07-25T12:51:09.000Z","updated":"2019-09-15T05:02:14.662Z","comments":true,"path":"2019/07/25/Java NIO学习笔记/","link":"","permalink":"http://QQ876684433.github.io/2019/07/25/Java NIO学习笔记/","excerpt":"","text":"Java NIO学习笔记 参考资料：https://nio.hacktons.cn/java-nio-tutorial.html 本文是上述有关Java NIO资料的学习笔记","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"NIO","slug":"NIO","permalink":"http://QQ876684433.github.io/tags/NIO/"}]},{"title":"Linux系统基础","slug":"Linux系统基础","date":"2019-07-25T01:34:24.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/25/Linux系统基础/","link":"","permalink":"http://QQ876684433.github.io/2019/07/25/Linux系统基础/","excerpt":"","text":"Linux系统基础 此文章是根据南大软院曾老师的《Linux系统基础》课程ppt的学习笔记整理 推荐：http://man.linuxde.net/ ，关于Linux命令大全的实用网站 认识Linux系统Linux系统的组成Linux系统一般有4个主要部分：内核、Shell、文件系统 和 应用程序 内核内核是操作系统的核心，Linux内核的主要模块包括：存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等几个部分 shellShell是系统的用户界面，提供了用户与内核进行交互操作的一种接口，它接收用户输入的命令并把它送入内核去执行 文件系统文件系统是文件存放在磁盘等存储设备上的组织方法，Linux系统能支持多种目前流行的文件系统，如ext3、 ext4、 FAT、 FAT32、VFAT和ISO9660等 应用程序包括文本编辑器、编程语言、 X Window、办公软件、 Internet工具和数据库等的程序集 Linux系统与Windows系统的比较共性 多用户操作系统 ​ 这里补充一点，摘录自https://blog.csdn.net/yangkuiwu/article/details/53224239 ​ 1.单用户、多用户。根据在同一时间使用计算机用户的多少，操作系统可分为单用户操作系统和多用户操作系统。单用户操作系统是指一台计算机在同一时间只能由一个用户使用，*一个用户独自享用系统的全部硬件和软件资源，*而如果在同一时间允许多个用户同时使用计算机，则称为多用户操作系统。 ​ 2.单任务、多任务。用户在同一时间可以运行多个应用程序（每个应用程序被称作一个任务），则这样的操作系统被称为多任务操作系统。如果一个用户在同一时间只能运行一个应用程序，则对应的操作系统称为单任务操作系统。 ​ 现代操作系统一般属于多用户、多任务的操作系统，也就是说，同一台机器可以为多个用户建立各自的账户，也允许拥有这些账户的用户同时登录这台计算机，每个账号可以同时运行多个程序。 ​ 多个用户能够同时访问和使用同一台计算机，其中的一个用户具有管理所有这些用户账户和整个计算机的资源的权限，在Windows上，这个具有管理其他用户和计算机资源的用户一般叫administrator，而在Linux上一般叫做root。 ​ 个人计算机操作系统早期一般都是单用户操作系统，其主要特点是在某一时间为单个用户服务。早期的DOS操作系统是单用户单任务操作系统，Windows XP则是单用户多任务操作系统。Linux、UNIX是多用户多任务操作系统。现在常用的Windows操作系统都是多用户、多任务的操作系统，使用最广泛的win7，win10都是多用户，多任务操作系统。 支持多种文件系统 支持多种端口和设备 支持联网功能 服务 区别 总结一下，Linux独有的特点如下： 定位于网络操作系统，Linux的系统配置文件和数据都以文本为基础 可选图形化界面 Linux系统不使用文件扩展名来识别文件的类型，而是使用文件的头内容来识别其类型 除了Linux内核，其他软件的安装、启动、停止和重新配置都不用重新引导系统（即不需要重启） Linux系统下的命令、文件和口令等都区分大小写 Linux版本Linux的版本号分为两部分，即内核版本与发行版本 Linux内核版本内核版本号由3个数字组成： r.x.y r：目前发布的内核主版本。 x：偶数表示稳定版本；奇数表示开发版本。 y：错误修补的次数。 Linux发行版本一些组织和厂家，将Linux系统的内核、应用软件和文档包装起来，并提供一些系统安装界面、系统配置设定管理工具，就构成了Linux发行版本最著名的便是Red Hat公司开发的Red Hat系列以及社区组织开发的Debian系列发行版本 Linux系统的安装与删除Linux系统下硬盘的基本知识分区命名方案Linux系统使用字母和数字的组合来指代硬盘分区，命名方案是基于文件的，文件名的格式为/dev/xxyN /dev/：这是Linux系统下所有设备文件所在的目录名。 xx：分区名的前两个字母表示分区所在设备的类型，通常是hd（ IDE硬盘）或sd（ SCSI硬盘）。 y：这个字母表示分区所在的设备。 N：最后的数字N代表分区。 例如：/dev/sda1表示这个分区在sd类型的设备上，如果有多个sd类型设备，那么该分区是在编号为a的设备上的分区1中 磁盘分区和挂载目录分区是Linux系统上一组文件和目录的存储区，它通过挂载来实现，挂载是将分区关联到某一目录的过程，挂载分区使起始于这个指定目录（通称为挂载目录）的存储区能够被使用 /boot分区：用来存放与Linux系统启动有关的程序，比如启动引导装载程序等 /usr分区：用来存放Linux系统中的应用程序 /var分区：用来存放Linux系统中经常变化的数据以及日志文件 /分区： Linux系统的根目录，所有的目录都挂在这个目录下面 SWAP分区：实现虚拟内存 /home分区：存放普通用户的数据，是普通用户的宿主目录 Linux字符界面操作命令行界面可以通过字符界面、图形界面下的终端以及虚拟控制台等多种方式进入 字符界面很多Linux发行版系统启动默认进入的是图形化界面，可以通过如下指令修改： 1ln -sf 重启后生效，默认进入字符界面，进入字符界面后，超级用户登录后提示符是“ #”，而其他用户登录后提示符是“ $” 虚拟控制台Linux系统提供了虚拟控制台的访问方式使得允许多个用户同时登录，还允许用户进行多次登录 在字符界面下，虚拟控制台的切换可以通过按下[Alt+ F1]~ [Alt+ F6]键来实现 在图形界面下，可以使用[Ctrl+Alt+F2]~[Ctrl+Alt+F6]键切换不同的字符虚拟控制台，再使用[Ctrl+Alt+F1]可以切换回图形界面 关闭和重启系统shutdown 参考原文：https://blog.csdn.net/xmc281141947/article/details/61191212 在Linux中可以用Shutdown命令实现自动定时关机的功能，它在Linux系统关闭之前给系统上的所有登录用户提示一条警告信息 命令语法：shutdown [选项] [时间] [警告信息] -h 关闭计算机 -r 重启计算机 -c 取消正在等待的shutdown命令 精确时间的格式是hh:mm，表示小时和分钟。时间段（延迟）由“+” 和“分钟数”表示。系统执行该命令后会自动进行数据同步的工作。时间部分如果是now，则上述命令则立即执行，否则延迟默认60s或者设定的时间 具体例子： 1、Shutdown -r now 关机后重启 2、Shutdown -h now 关机后不重启 3、Shutdown -r +11 11分钟后重启 4、Shutdown -r 11:00 11点钟重启 5、Shutdown -h +11 11分钟后关机 6、Shutdown -h 11:00 11点钟关机 halt“ halt” 命令就是调用“ shutdown–h”命令执行关闭系统，它是立即执行 reboot“reboot”命令就是调用“shutdown -r”命令来重启系统，它是立即执行 init“ init” 命令是所有进程的祖先，它的进程号始终为“ 1” ，所以发送“ TERM” 信号给“ init” 会终止所有的用户进程和守护进程等。“ shutdown” 命令就是使用这种机制。“init”定义了7个运行级别： 0 Halt Shuts down the system. 1 Single-user mode Mode for administrative tasks.（注意这里，说明系统返回的shell有root权限） 2 Multi-user mode Does not configure network interfaces and does not export networks services. 3 Multi-user mode with networking Starts the system normally. 4 Not used/user-definable For special purposes. 5 Start the system normally with appropriate display manager (with GUI) Same as runlevel 3 + display manager. 6 Reboot Reboots the system. 系统运行级别Linux系统的运行级别由列在/etc/rc.d/rc&lt;x&gt;.d目录中的服务来定义，其中&lt;x&gt;是代表运行级别的符号，七种运行级别的定义如下： 0：停止运行，所有进程中止，关闭系统。 1：单用户模式，用于维护系统，只有少数进程运行。 2：多用户模式，除了NFS服务没有启动外，其他和运行级别3一样。 3：完整的多用户模式，进入Linux系统的字符界面。 4：没有使用（可由用户定义）。 5：完整的多用户模式（带有基于X Window的图形界面）。 6：重新引导计算机。 可以在使用runlevel命令查看当前的运行级别 12steve@ubuntu-17-10:~$ runlevel N 5 表示当前运行级别是5，N表示没有上一次运行级别 其他一些常用命令man获取shell命令的帮助手册，命令语法：man [选项] [命令名称] help可以通过help来获取shell命令的用法，命令语法：[命令] ––help which, whereis, locate, find 来源：https://zhuanlan.zhihu.com/p/35727707 which：常用于查找可直接执行的命令。只能查找可执行文件，该命令基本只在$PATH路径中搜索，查找范围最小，查找速度快。默认只返回第一个匹配的文件路径，通过选项 -a 可以返回所有匹配结果。 whereis：不只可以查找命令，其他文件类型都可以（man中说只能查命令、源文件和man文件，实际测试可以查大多数文件）。在$PATH路径基础上增加了一些系统目录的查找，查找范围比which稍大，查找速度快。可以通过 -b 选项，限定只搜索二进制文件。 locate：超快速查找任意文件。它会从linux内置的索引数据库查找文件的路径，索引速度超快。刚刚新建的文件可能需要一定时间才能加入该索引数据库，可以通过执行updatedb命令来强制更新一次索引，这样确保不会遗漏文件。该命令通常会返回大量匹配项，可以使用 -r 选项通过正则表达式来精确匹配。 find：直接搜索整个文件目录，默认直接从根目录开始搜索，建议在以上命令都无法解决问题时才用它，功能最强大但速度超慢。除非你指定一个很小的搜索范围。通过 -name 选项指定要查找的文件名，支持通配符。 Shell基础通俗地讲，Shell就是位于内核和操作者之间的一层使用者界面。一个Shell命令可能含有一些可选项和参数，其一般格式为：[Shell命令] [可选项] [参数]。目前流行的Shell有sh， csh， ksh， tcsh和bash等。 开始使用bashShell命令可分为如下两大类： （1） bash内置的命令 （2）应用程序 通配符 特殊字符和引号 常用控制组合键 说明： &amp; 使命令在后台运行，不阻塞当前控制台 CTRL+Z停止进程并放入后台 jobs 显示当前暂停的进程 bg %N 使第N个任务在后台运行（%前有空格）（好像也会阻塞控制台？不太懂，在Ubuntu17.10上测试就是，bg执行后，控制台也被占用，但可以使用Ctr+S和Ctr+Q来暂停和恢复屏幕输出） fg %N 使第N个任务在前台运行，阻塞当前控制台 默认bg，fg不带%N时表示对最后一个进程操作！ Ctr+U是清空当前输入的命令行 补充： 控制台可以使用Ctr+Shift+C/V来执行复制粘贴功能 Shell实用功能命令的排列如果希望一次执行多个命令， Shell允许在不同的命令之间，放上特殊的排列字符 使用“; ” 使用“; ”命令时先执行命令1，不管命令1是否出错，接下来就执行命令2。命令语法：命令1; 命令2 使用“ &amp;&amp;” 使用“ &amp;&amp;”命令时只有当命令1正确运行完毕后，才能执行命令2。命令语法：命令1&amp;&amp;命令2 命令替换有两种方式： 命令1 $(命令2) 命令1 `命令2` 意思是将命令2的输出结果与命令1拼接成新的命令执行，例如： 12pidof less //查看less的进程号，假如为4163kill -9 4163 等价于 123kill -9 $(pidof less)// 或者kill -9 `pidof less` 命令别名alias命令用来设置指令的别名。我们可以使用该命令可以将一些较长的命令进行简化。使用alias时，用户必须使用单引号&#39;&#39;将原来的命令引起来，防止特殊字符导致错误。命令语法： alias [别名]＝[需要定义别名的命令] alias命令的作用只局限于该次登入的操作。若要每次登入都能够使用这些命令别名，则可将相应的alias命令存放到bash的初始化文件/etc/bashrc中。 要删除一个别名，可以使用 unalias 命令，如 unalias l。 文件名匹配和输出重定向文件名匹配 “*” 可匹配任意一个或多个字符 “?” 可以匹配任意一个字符 管道管道可以将某个命令的输出信息当作某个命令的输入，由管道符号“|” 来标识，命令语法： [命令1]|[ 命令2]|[ 命令3] 例如：alias tr=&#39;cd / &amp;&amp; tree | more &amp;&amp; cd ~&#39;，就是将tree的输出内容作为more的输入，more的作用是将输出内容分页显示 重定向文件重定向有5种方式，分别是：输出重定向、输入重定向、错误重定向、追加重定向以及同时实现输出和错误的重定向 输出重定向 将command命令的输出保存到文件file中，如果存在相同的文件，则覆盖file文件中的内容。 命令语法：command &gt; file 可以实用echo和输出重定向来创建文本文件：echo hello &gt; hello.txt，即创建文件hello.txt并写入内容“hello” 输入重定向 将文件file的内容作为command命令的输入。 命令语法：command &lt; file 错误重定向 将command命令执行的出错信息输出到文件file中。 命令语法：command 2&gt; file 追加重定向 将command命令执行的输出添加到已存在的文件file中。 命令语法：command &gt;&gt; file 补充：错误重定向和追加重定向可以组合使用，command 2&gt;&gt; file表示command的错误信息追加到file末尾 同时实现输出和错误的重定向 可以同时实现输出重定向和错误重定向的功能。 命令语法：command &amp;&gt; file 补充：同理，该命令可以和追加重定向组合使用，command &amp;&gt;&gt; file表示command的输出和错误信息追加到file末尾 vi编辑器基本使用vim和vi的区别 摘录自：https://blog.csdn.net/allenlinrui/article/details/7269481 简单来说一下vi和vim的区别与联系 首先，它们都是多模式编辑器，但vim是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性。总的来说，vim比vi更具优势的地方在于： 多级撤消 在vi的命令模式里，按 u只能撤消上次命令，而在vim里可以无限制的撤消，几乎等同于windows下的ctrl+z了 多操作系统支持 vi只能运行于unix中，而vim不仅可以运行于unix,还有windows ,mac等操作系统上 语法加亮 作为一名程序员，我觉得这个效果用处最大了- vim可以对代码进行多颜色的语法加亮 可视化操作 因为vim不仅可以在终端运行，也可以运行于x window、 mac os、 windows， 所以说他“可视化” 对vi的完全兼容 某些情况下，vim可以完全被当成vi来使用 vi的工作模式vi编辑器有3种基本工作模式，分别是命令行模式、插入模式和末行模式 命令行模式：控制屏幕光标的移动，字符、字或行的删除，移动、复制某区域，该模式下是不能输入文本数据的 插入模式：只有在插入模式下，才可以做文字输入，按“ Esc” 键可回到命令行模式 末行模式：将文件保存或退出vi编辑器，也可以设置编辑环境，如寻找字符串、列出行号等 vi基本操作进入插入模式 按“ i” ：从光标当前位置开始输入文件 按“ I” ：在光标所在行的行首插入 按“ a” ：从目前光标所在位置的下一个位置开始输入文字 按“ A” ：在光标所在行的行末插入 按“ o” ：在光标所在的行的下面插入一行，从行首开始输入文字 按“ O” ：在光标所在的行的上面插入一行 按“ s” ：删除光标位置的一个字符，然后进入插入模式 按“ S” ：删除光标所在的行，然后进入插入模式 从插入模式切换为命令行模式从插入模式切换为命令行模式只需按“ Esc” 键 移动光标可以使用键盘的方向键移动光标，也可以使用vi定义的移动命令：h、j、k、l分别表示←、↓、↑、→移动一格。如果需要翻页： 按[Ctrl+b]：屏幕往前移动一页（back） 按[Ctrl+f]：屏幕往后移动一页（front） 按[Ctrl+u]：屏幕往前移动半页（up） 按[Ctrl+d]：屏幕往后移动半页（down） 其他的： 按“ G” ：移动到文本的最后一行 按“ $” ：移动到光标所在行的行尾（助记：正则表达式的$） 按“ ^” 或数字“ 0”：移动到光标所在行的行首（助记：正则表达式的^） 按“ w” ：光标跳到下个字的开头 按“ e” ：光标跳到下个字的字尾 按“ b” ：光标回到上个字的开头 解释：”e”和”b”的“下个字”和“上个字”的含义是当前光标停在某个字上，即当前字；而“w”的“下个字”真的就是下一个字，不是当前光标停留的字。举个例子： 12word----↑ 箭头指向的是当前光标位置，如果按”w”，那么结果是： 123word---- ↑// 因为当前字是word，那么对\"w\"来说，下一个字就是\"----\"，因此光标指向\"-\" 而如果按的是”e”，那么结果将是： 123word---- ↑// 因为当前字是word，那么对\"e\"来说，下一个字就是\"word\"，因此光标指向\"d\" 删除文字 “ x” ：每按一次，删除光标所在位置的一个字符 “ nx” ：例如， “ 6x” 表示删除光标所在位置开始的6个字符（包括当前位置的字符） “ X” ：大写的X，每按一次，删除光标所在位置的前面一个字符 “ nX”：例如， “ 20X”表示删除光标所在位置前面20个字符（不包括当前位置的字符） “ dd” ：删除光标所在行 “ ndd”：从光标所在行开始删除n行。例如， “ 4dd” 表示删除从光标所在行开始的4行字符（包括当前行） ”dG“：删除当前后之后的全部行（包括当前行） 复制 “ yw” ：将光标所在之处到字尾的字符复制到缓冲区中（复制的是一个字的内容） “ nyw” ：复制n个字到缓冲区（包括当前字） “ yy” ：复制光标所在行到缓冲区 “nyy” ：例如， “6yy” 表示复制从光标所在行开始的6行字符 “p” ：将缓冲区内的内容写到光标所在的后一个位置（原ppt这里错了，这里写的才是正确的） ”P“：将缓冲区内的内容写到光标所在的前一个位置 解释：”p“后一个位置有两种含义，如果复制的是字，那么写在光标所在位置的后面；如果复制的是行内容，那么写在光标所在行的下一行；”P“同理，替换成上一个位置或者上一行 替换 “ r” ：替换光标所在处的字符 “ R” ：替换光标所到之处的字符，直到按下“ Esc” 键为止 撤销 “ u” ：如果误执行一个命令，可以马上按下“ u” ，回到上一个操作。 按多次“ u” 可以执行多次撤销 补充：vi兼容模式下，多次”u“并不能多次撤销，原因是后一次”u“会把上一次”u“当做操作来撤销，即撤销”撤销操作“，所以”uu“会恢复原样 跳至指定行 [Ctrl+g]：列出光标所在行的行号 “nG” ：例如， “ 15G” ，表示移动光标至该文本的第15行行首 存盘退出 “ZZ” ：存盘退出 不保存退出 “ZQ” ：不存盘退出 末行模式操作在使用末行模式之前，先按“ Esc”键确定已经处于命令行模式后，再按冒号“:”即可进入末行模式 列出行号“set nu” ：在文件中的每一行前面列出行号 取消列出行号“set nonu” ：取消文件中的每一行前面列出的行号 跳到文件中的某一行“n”：输入行号n后回车，光标会跳转到文本的指定行——第n行的行首 查找字符 “/关键字”：向后查找关键字，可以按n往后查找下一个匹配的关键字 “?关键字”：向前查找关键字，可以按n往前查找下一个匹配的关键字 运行Shell命令“!命令” ：运行Shell命令 替换字符 “s /a/b” ：将光标所在行第一个a替换为b “s /a/b/g” ：将光标所在行所有的a替换为b 保存文件“w” ：在冒号后输入字母“w” 就可以将文件保存起来 退出vi “q” ：按“q” 即退出vi，如果无法离开vi，可以在“q” 后跟一个“!” 强制符离开vi “wq” ：一般建议离开时，搭配“w” 一起使用，这样在退出的时候还可以保存文件 文件和目录Linux系统中以目录的形式挂载文件系统，其目录结构是一个分层的树形结构。链接是一种在共享文件和访问它的用户的若干目录项之间建立联系的方法， Linux系统中包括硬链接和软链接两种方式 Linux文件如果一个文件没有扩展名，或者与它的扩展名不相符时，可以使用file命令查看该文件的类型，例如： 123456steve@ubuntu-17-10:~$ file db.json db.json: UTF-8 Unicode text, with very long lines, with no line terminatorssteve@ubuntu-17-10:~$ file _config.yml _config.yml: UTF-8 Unicode textsteve@ubuntu-17-10:~$ file package-lock.json package-lock.json: ASCII text Linux文件类型Linux文件类型常见的有：普通文件、目录文件、字符设备文件、块设备文件和符号链接文件等，可以用ls -lh命令查看某个文件的属性 普通文件 类似“ -rw-r–r–”的属性符号，其属性第一个符号是“ -”，这样的文件在Linux系统中就是普通文件 目录文件（directory） 类似“ drwxr-xr-x”的属性符号，其属性第一个符号是“ d”，这样的文件在Linux系统中就是目录文件 设备文件 Linux系统下的/dev目录中有大量的设备文件 块设备文件（block） 块设备的主要特点是可以随机读写，而最常见的块设备就是磁盘，如/dev/hda1、/dev/sda2等 类似“ brw-rw—-”的属性符号，其属性第一个符号是“ b”，这样的文件在Linux系统中就是块设备文件 字符设备文件（character） 最常见的字符设备文件是打印机和终端，可以接收字符流。 /dev/null是一个非常有用的字符设备文件，送入这个设备的所有内容都被忽略 类似“ crw-r—–”的属性符号，其属性第一个符号是“ c”，这样的文件在Linux系统中就是字符设备文件 管道文件（pipe） 管道文件有时候也被叫做FIFO文件（ FIFO是先进先出的意思），管道文件就是从一头流入，从另一头流出 类似“ prw——-”的属性符号，其属性第一个符号是“ p”，这样的文件在Linux系统中就是管道文件 链接文件（link） 链接文件有点类似于Windows系统中的快捷方式，链接有两种方式：软链接和硬链接 软链接文件 软链接（也叫符号链接），文件用户数据块中存放的内容是另一文件的路径名的指向。软链接就是一个普通文件，只是数据块内容有点特殊。软链接可对文件或目录创建。删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接就变成了死链接 类似“ lrwxrwxrwx”的属性符号，其属性第一个符号是“ l”，这样的文件在Linux系统中就是软链接文件 硬链接文件 硬链接就是同一个文件使用了多个别名（他们有共同的 inode）。由于硬链接是有着相同inode号仅文件名不同的文件，因此，删除一个硬链接文件并不影响其他有相同 inode 号的文件。硬链接不能对目录进行创建，只可对文件创建 用“ ls -l”命令查看某个文件的属性，可以看到第二列的文件硬链接数大于1 ，这样的文件在Linux系统中就是硬链接文件 Linux目录结构Linux系统都有根文件系统，它包含系统引导和使其他文件系统得以挂载所必要的文件，根文件系统需要有单用户状态所必须的足够的内容，还应该包括修复损坏系统、恢复备份等工具。 Linux系统的目录结构是分层的树形结构，都是挂载在根文件系统“ /” 下 文件和目录操作 pwd：显示当前用户所处的工作目录的绝对路径 cd：更改工作目录路径，工作目录路径可以使用绝对或相对路径名，绝对路径从/（根）开始，然后循序到所需的目录下；相对路径从当前目录开始 命令语法：cd [目录名] ls：对于目录而言将列出其中的所有子目录与文件信息；对于文件而言将输出其文件名以及所要求的其他信息 命令语法：ls [选项] [目录或是文件] ls命令显示的详细信息： touch：创建空文件以及更改文件或目录的时间，其中时间格式为MMDDHHmm 命令语法：touch [-acfm] [-d &lt;日期时间&gt;] [-r &lt;参考 文件或目录&gt;] [-t &lt;日期时间&gt;] [文件] mkdir：在Linux系统中创建目录，其默认权限为rwxr-xr-x（ 755） 命令语法：mkdir [选项] [目录名] -m 可以在创建目录时设置其权限，例如mkdir -m 777 newdir，其权限是rwxrwxrwx（ 777） rmdir：删除空目录 命令语法：rmdir [选项] [目录名] -p或–parents：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除 cp：复制文件和目录到其他目录中 命令语法：cp [选项] [源文件或目录] [目标文件或目录] mv：对文件和目录更改名称以及移动文件和目录的路径 命令语法：mv [选项] [源文件或目录] [目标文件或目录] rm：删除系统中的文件或目录 命令语法：rm [选项] [文件或目录] -r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；-f：强制删除文件或目录；-i：在删除文件之前提示信息 wc：统计指定文件中的行数、单词数或字节数，并将统计结果显示输出到屏幕 命令语法：wc [选项] [文件] 选项部分可以有-lwc，即将行数、单词数和字节数都显示出来 链接文件在Linux系统中，内核为每一个新创建的文件分配一个inode（索引节点）号，文件属性保存在索引节点里，在访问文件时，索引节点被复制到内存里，从而实现文件的快速访问 硬链接硬链接是一个指针，指向文件索引节点，系统并不为它重新分配inode，可以用ln命令来建立硬链接。硬链接节省空间，也是Linux系统整合文件系统的传统方式。硬链接文件有两个限制： （ 1）不允许给目录创建硬链接 （ 2）只有在同一文件系统中的文件之间才能创建链接 软链接软链接又称为符号链接，这个文件包含了另一个文件的路径名 硬链接和软链接的区别硬链接记录的是目标的inode，软链接记录的是目标的路径。软链接就像是快捷方式，而硬链接就像是备份。软链接可以做跨分区的链接，而硬链接由于inode的缘故，只能在本分区中做链接。所以，软链接的使用频率要高得多 创建链接ln命令可以创建链接文件（包括软链接文件和硬链接文件） 命令语法：ln [选项] [源文件名] [链接文件名]，默认创建的是硬链接，加上-s后创建的是软链接 使用rm删除源文件后，硬链接文件依然能打开，而软链接变成死链接 Linux常用操作命令这部分挺琐碎的，直接参考http://man.linuxde.net/即可 ，关于Linux命令大全的实用网站 文本显示和处理cat，more，less，head，tail，sort，uniq，cut，comm以及diff等 文件和命令查找grep，find，locate，whereis，file，whatis以及which等 系统信息显示uname， hostname， dmesg， cal以及date等 信息交流echo， mesg， wall以及write等 其他命令clear， sync， uptime以及last等 Shell编程语法基础Shell程序由开头部分、注释部分以及语句执行部分组成 开头Shell程序必须以下面的行开始（必须放在文件的第一行） 1#!/bin/bash 符号“ #!” 用来告诉系统它后面的参数是用来执行该文件的程序，在这个例子中使用/bin/bash来执行程序。当编辑好脚本时，如果要执行该脚本，还必须使其可执行（即赋予可执行权限）： 1chmod u+x [文件名] 如果不设置可执行权限的话，可以手动受用bash命令告诉系统它是一个可执行的脚本，这样也可以执行： 1bash file.sh 注释以“ #” 开头的句子表示注释，直到这一行的结束 执行部分例子： 123456789101112131415161718#!/bin/bash#filename:welcomefirst()&#123;echo \"==========================================\"echo \"Hello! Everyone! Welcome to the Linux world.\"echo \"==========================================\"&#125;second()&#123;echo \"******************************************\"&#125;firstsecondsecondfirst 输出： 12345678==========================================Hello! Everyone! Welcome to the Linux world.==========================================************************************************************************************==========================================Hello! Everyone! Welcome to the Linux world.========================================== 变量对Shell来讲，所有变量的取值都是一个字符， Shell程序采用“ $var” 的形式来引用名为var的变量的值 Shell定义的环境变量Shell在开始执行时就已经定义了一些与系统的工作环境有关的变量，用户还可以重新定义这些变量，常见的环境变量如下： HOME：用于保存用户宿主目录的完全路径名 PATH：默认命令搜索路径 TERM：终端的类型 UID：当前用户的识别号 PWD：当前工作目录的绝对路径名 PS1： 用户平时的提示符 PS2： 第一行没输完，等待第二行输入的提示符 用户定义的变量语法规则：变量名=变量值 在定义变量时，变量名前不应加符号“ $” ；在引用变量的内容时，则应在变量名前加符号“ $”或“ ${变量名}” 。在给变量赋值时，等号两边一定不能留空格，若变量中本身就包含了空格，则整个字符串都要用双引号括起来。在编写Shell程序时，为了使变量名和命令名相区别，建议所有的变量名都用大写字母来表示。 有时需要在说明一个变量并对它设置为一个特定值后就不再改变它的值时，可以用下面的命令来保证一个变量的只读性：readonly 变量名。 在任何时候创建的变量都只是当前Shell的局部变量，所以不能被Shell运行的其他命令或Shell程序所利用，而export命令可以将一个局部变量提供给Shell命令使用，其格式是：export 变量名。也可以在给变量赋值的同时使用export命令：export 变量名=变量值。 位置参数位置参数是一种在调用Shell程序的命令行中按照各自的位置决定的变量，是在程序名之后输入的参数。位置参数之间用空格分隔，Shell取第一个位置参数替换程序文件中的$1，第二个替换$2，依次类推。$0是一个特殊的变量，它的内容是当前这个Shell程序的文件名，所以， $0不是一个位置参数，在显示当前所有的位置参数时是不包括$0的 预定义变量预定义变量和环境变量相类似，也是在Shell一开始时就定义了的变量。所不同的是，用户只能根据Shell的定义来使用这些变量，所有预定义变量都是由符号“ $” 和另一个符号组成的。常见的预定义变量如下： $#：位置参数的数量 $*：所有位置参数的内容 $?：命令执行后返回的状态 $$：当前进程的进程号 $!：后台运行的最后一个进程号 $0：当前执行的进程名。 参数置换的变量Shell提供了参数置换功能以便用户可以根据不同的条件来给变量赋不同的值，下面Variable是变量名， value代表一个具体的值： ${variable:-value}: 如果变量variable存在，则返回variable的值，否则返回值value ${variable:=value}: 如果变量variable存在，则返回variable的值，否则，先将值value赋给变量variable，然后返回值value ${variable:+value}: 如果变量variable存在，则返回value的值，否则返回空值 ${variable:?value}: 如果变量variable存在，则返回variable的值，否则将value送到标准错误输出显示并退出shell程序，这里value通常为一个错误提示消息 ${variable:offset[:length]}:其中offset和length为整数数字，中括号代表可选部分。此引用方式表示返回从变量variable的第(offset+1)个字符开始的、长度为length的子串。如果中括号内的部分省略，则返回其后的所有子串 变量表达式首先要注意的是，这些表达式符号前后都需要有空格，否则会出错 字符串比较测试字符串是否相等，长度是否为零，字符串是否为NULL： =：比较两个字符串是否相同，相同则为“是” （结果显示0） !=：比较两个字符串是否相同，不同则为“是”（结果显示0） -n：比较字符串的长度是否大于0，如果大于0则为“是” （结果显示0） -z：比较字符串的长度是否等于0，如果等于0则为“是” （结果显示0） 补充： 直接测试时，控制台是不会有输出结果的，需要使用$?来获取输出结果 如果变量字符串含有空格，需要使用双引号，否则会出错 1234567891011steve@ubuntu-17-10:~/$ str1=\"ab cd\"steve@ubuntu-17-10:~/$ test $str1 = abbash: test: 参数太多steve@ubuntu-17-10:~/$ test \"$str1\" = absteve@ubuntu-17-10:~/$ echo $?1steve@ubuntu-17-10:~/$ test \"$str1\" = ab cdbash: test: 参数太多steve@ubuntu-17-10:~/$ test \"$str1\" = \"ab cd\"steve@ubuntu-17-10:~/$ echo $?0 数字比较test语句不使用&gt;? 类似的符号来表达大小的比较，而是用参数来表示： -eq：相等 -ge：大于等于 -le：小于等于 -ne：不等于 -gt：大于 -lt：小于 逻辑测试 !：与一个逻辑值相反的逻辑值 -a与（ and）：两个逻辑值都为“是” 返回值才为“是” ，反之为“否” -o或（ or）：两个逻辑值有一个为“是” ，返回值就为“是” 例子： 1234[root@PC-LINUX ~]# test -r empty -a -s empty[root@PC-LINUX ~]# echo $?1// 结果显示1表示文件empty存在且只读以及长度为非0是不对的 文件操作文件测试表达式通常是为了测试文件的文件操作逻辑： -d：对象存在且为目录，则返回值为“是” -f：对象存在且为文件，则返回值为“是” -L：对象存在且为符号连接，则返回值为“是” -r：对象存在且可读，则返回值为“ 是” -s：对象存在且长度非0，则返回值为“是” -w：对象存在且可写，则返回值为“是” -x：对象存在且可执行，则返回值为“是” !：测试条件的否定 Shell程序的执行和跟踪Shell程序的执行和调试程序的第一行一般为#!/bin/bash ，其中“ #” 表示该行是注释，感叹号“ ！ ” 表示Shell运行感叹号之后的命令并用文档的其余部分作为输入，也就是运行/bin/bash并让/bin/bash去执行Shell程序的内容 Shell程序的执行有如下三种方式运行shell程序： 12345678steve@ubuntu-17-10:~/$ vim exe.shsteve@ubuntu-17-10:~/$ bash &lt; exe.sh hello worldsteve@ubuntu-17-10:~/$ bash exe.sh hello worldsteve@ubuntu-17-10:~/$ chmod u+x exe.sh steve@ubuntu-17-10:~/$ ./exe.sh hello world 发现一个问题：使用bash &lt; exe.sh运行程序时，read指令好像不生效，控制台不会等待标准输入，具体原因还不知道 Shell程序的调试调用bash的形式是：bash [选项] [Shell程序文件名] -v：当读入Shell输入行时，把它们显示出来（输出的命令是未经执行的源程序命令） -x：执行命令时把命令和它们的参数显示出来（输出的命令是解释后实际执行的命令） 示例： 12345678910111213141516171819202122232425steve@ubuntu-17-10:~/$ vim exe.sh ; cat exe.sh #!/bin/bashecho \"shell file name is $0\"echo \"hello world\"echo $1echo $2steve@ubuntu-17-10:~/$ bash -x exe.sh a b+ echo 'shell file name is exe.sh'shell file name is exe.sh+ echo 'hello world'hello world+ echo aa+ echo bbsteve@ubuntu-17-10:~/$ bash -v exe.sh a b#!/bin/bashecho \"shell file name is $0\"shell file name is exe.shecho \"hello world\"hello worldecho $1aecho $2b Shell流程控制语句与传统语言不同的是， Shell用于指定条件值的不是布尔运算式，而是命令和字符串 条件判断if条件语句 可以参考：https://blog.csdn.net/doiido/article/details/43966819 Shell程序中的条件分支有如下两种方式： if-then语句 语法如下： 123if [ 命令行1 ];then 命令行2fi 需要注意的是，在 ‘[‘后面 和 ‘]’前面 都必须要有空格，不然会出错，例如要[ $a=a ] if-then-else语句 语法如下： 123456if [ 命令行1 ]then 命令行2else 命令行3fi case条件语句Shell通过计算字符串string的值，将其结果依次与运算式exp-1和exp-2等进行比较，直到找到一个匹配的运算式为止。如果找到了匹配项，则执行它下面的命令直到遇到一对分号;;为止，语法格式： 1234567891011case string inexp-1) 若干个命令行1;;exp-2) 若干个命令行2;;……*) 其他命令行esac 在case运算式中也可以使用Shell的通配符（ * ， ? ， []）。通常用*作为case命令的最后运算式以便在前面找不到任何相应的匹配项时执行“其他命令行” 的命令，样例： 12345678910111213141516steve@ubuntu-17-10:~/$ cat menu.sh #!/bin/bashecho _echo \"1 Restore\"echo \"2 Backup\"echo \"3 Unload\"echo echo -n \"Enter Choice: \"read CHOICEcase \"$CHOICE\" in1) echo \"Restore\";;2) echo \"Backup\";;3) echo \"Unload\";;*) echo \"Sorry $CHOICE is not a valid choice.\"exit 1esac 循环控制for循环语句1234for 变量名 [in数值列表]do 若干个命令行done 如果变量名是var，则在in之后给出的数值将顺序替换循环命令列表中的“ $var” 如果省略了in，则变量var的取值将是位置参数 例子： 123456steve@ubuntu-17-10:~/$ vim mm.sh ; cat mm.sh#!/bin/bash for ab in 1 2 3 4do echo $abdone 输出： 12345steve@ubuntu-17-10:~/$ bash mm.sh 1234 求和示例： 123456789steve@ubuntu-17-10:~/$ cat qqq.sh #!/bin/bash sum=0for INT in $*;do sum=`expr $sum + $INT`done echo $sumsteve@ubuntu-17-10:~/$ bash qqq.sh 1 2 3 4 10 要注意，原ppt中expr指令使用的是单引号&#39;&#39;括起来的，这样不对，应该使用反单引号``才能执行后面的加法计算 while循环语句语法格式： 12345while 若干个命令行1do 若干个命令行2done 只要while的“若干个命令行1” 中最后一个命令的返回状态为真， while循环就继续执行“ do…done” 之间的“ 若干个命令行2”，示例： 12345678910111213141516steve@ubuntu-17-10:~/桌面$ cat zx.sh #!/bin/bash int=1while [ $int -le 5 ]; do sq=`expr $int \\* $int` echo $sq int=`expr $int + 1`doneecho \"Job completed!\"steve@ubuntu-17-10:~/桌面$ bash zx.sh 1491625Job completed! until循环语句语法格式： 12345until 若干个命令行1do 若干个命令行2done until循环和while循环的区别在于：while循环在条件为真时继续执行循环，而until则是在条件为假时继续执行循环。Shell还提供了true和false两条命令用于创建无限循环结构，它们的返回状态分别是总为0或总为非0 break和continue语句用法和传统C语言中的用法无异 source语句source命令用法：source FileName 作用：在当前bash环境下读取并执行FileName中的命令。 注：该命令通常用命令“ .”来替代。如： source .bash_rc 与 . .bash_rc 是等效的。 source命令与shell scripts的区别是， source在当前bash环境下执行命令，而scripts是启动一个子shell来执行命令。这样如果把设置环境变量（或alias等等）的命令写进scripts中，就只会影响子shell,无法改变当前的BASH,所以通过文件设置环境变量时，要用source 命令。 source命令(从 C Shell 而来)是bash shell的内置命令。点命令(从Bourne Shell而来) 是source的另一名称。 source(或点)命令通常用于重新执行刚修改的初始化文档，如 .bash_profile 和.profile 等等。 函数所有函数在使用前必须定义。函数的调用，只需要使用函数名就可以调用已经定义好的函数。 1234567# 定义：[function] 函数名()&#123; 命令&#125;# 引用：函数名 [ 参数1 参数2 ...参数n ] 在函数中得到函数返回值可以使用以下两种方法： 在函数末尾加return，从函数中返回，用最后的命令状态决定返回值（$?） 返回一个数值，如0或1。格式如： return 0或者return 1 示例： 12345678steve@ubuntu-17-10:~/桌面$ cat func.sh #!/bin/bash function func()&#123; echo \"hello\" echo \"world\"&#125;funcecho $? 输出： 1234steve@ubuntu-17-10:~/桌面$ bash func.sh helloworld0 说明获取的是命令状态而不是命令的输出值 用户和组群账户管理用户账户管理Linux用户账户概述用户在Linux系统中是分角色的，用户的角色是通过UID（用户ID号）来标识的，每个用户的UID都是不同的。在Linux系统中主要有root用户、虚拟用户和普通用户这3类用户。 root用户 root用户是Linux系统的内置用户，在系统中的权限最高，也被称之为超级管理用户。在系统中的每个文件、目录和进程都归属于某一个用户，没有用户许可，除root用户外的其它普通用户无法进行操作 虚拟用户 这类用户也被称为伪用户或假用户，这类用户不具有登录系统的能力，但却是系统运行不可缺少的用户，比如bin， daemon， adm，ftp以及mail等用户账户，这类用户都是Linux系统的内置用户 普通用户 这类用户是由系统管理员创建，并且能登录Linux系统。只能操作自己目录内的文件，权限有限 Linux用户账户配置文件用户管理主要是通过修改用户配置文件完成的，使用用户管理控制工具的最终目的也是为了修改用户配置文件。 /etc/passwd文件/etc/passwd是系统识别用户的一个文件，Linux系统中所有的用户都记录在该文件中。任何用户都可以读取该文件内容，在/etc/passwd文件中，每一行表示的是一个用户账户信息，一行有7个段位，每个段位用“:”分隔。 每个用户都对应一个唯一的UID，Linux的用户UID值是非负整数， root的UID是0，拥有系统最高权限。UID的唯一性关系到系统的安全，比如在/etc/passwd文件中把用户zhangsan的UID改为0后， zhangsan这个用户会被确认为root用户。 UID是确认用户权限的标识，用户登录系统所处的角色是通过UID来实现的，而不是用户名。 /etc/shadow文件/etc/shadow文件是/etc/passwd文件的影子文件，这个文件并不是由/etc/passwd文件产生，这两个文件是对应互补的。/etc/shadow文件内容包括用户及被加密的口令及其他/etc/passwd不能包括的信息，比如用户账户的有效期限等。/etc/shadow文件的内容包括9个段位，每个段位之间用“ :”分隔： 字符界面下用户账户的设置创建新账户创建用户账户就是在系统中创建一个新账户，然后为新账户分配用户UID、用户组群、主目录和登录Shell等资源，新创建的用户账户默认是被锁定的，无法使用，需要使用passwd命令设置密码以后才能使用。使用useradd命令可以在Linux系统下创建用户账户。 修改账户使用usermod命令能更改用户的Shell类型、所属的用户组群、用户口令的有效期，还能更改用户的登录名 删除用户账户使用userdel命令可以在Linux系统下删除用户账户：userdel [-r][用户名]，其中-r是指在删除该用户的同时一起删除主目录 组群账户管理Linux组群账户配置文件/etc/gshadow是/etc/group的加密信息文件 /etc/group文件/etc/group文件的内容包括用户组群名、用户组群口令、 GID及该用户组群所包含的用户，每个用户组群都有一条记录。一行有4个段位，每个段位用“:” 分隔。 组群GID和UID类似，是一个从0开始的非负整数， GID为0的组群是root组群。Fedora 17系统会预留1000个GID号给系统虚拟用户组群使用，创建的新组群GID是从1000开始的。 /etc/gshadow文件/etc/gshadow文件是/etc/group的加密文件，比如用户组群管理口令就是存放在这个文件中。/etc/gshadow文件中每个用户组群都有一条记录。一行有4个段位，每个段位之间用“ :”分隔。 字符界面下组群账户的设置在Linux系统字符界面下创建、修改以及删除组群账户主要使用groupadd，groupmod和groupdel这3个命令。 创建组群账户命令语法：groupadd [-g gid [-o]] [-f] [组群名] 默认创建的是用户群组，即默认分配的GID大于等于1000，可以通过-g指定GID；-r选项可以创建系统群组，即默认分配的GID小于1000 修改组群账户命令语法：groupmod [-g &lt;组群识别码&gt; &lt;-o&gt;] [-n &lt;新组群名称&gt;] [组群名称] 删除组群账户命令语法：groupdel [组群名称] 账户相关文件或目录/etc/skel目录/etc/skel目录是存放用户启动文件的目录，这个目录由root用户管理，当管理员创建新用户时，这个目录下的文件会自动复制到新创建的用户的主目录下。/etc/skel目录下的文件都是隐藏文件，也就是类似“ .file” 格式的，可以通过添加、修改和删除/etc/skel目录下的文件，来为用户提供一个统一、标准和默认的用户环境。 /etc/login.defs配置文件/etc/login.defs文件规定了创建新用户时的一些默认设置，比如创建用户时是否需要主目录、 UID和GID的范围、用户账户口令的期限等，这个文件可以通过root用户来修改 /etc/default/useradd文件/etc/default/useradd文件是在使用useradd命令创建用户账户时的规则文件 用户和组群维护命令账户维护命令passwd命令使用passwd命令可以设置或修改用户的口令，普通用户和超级权限用户都可以运行passwd。普通用户只能更改自己的用户口令，root用户可以设置或修改任何用户的口令。如果passwd命令后面不接任何选项或用户名，则表示修改当前用户的口令。 命令语法：passwd [选项] [用户名] 可以使用-l选项来锁住某个用户的口令，这样该用户就无法登录，但是可以从其他用户中通过su切换到被锁定的用户，被锁定的用户口令前面有!标识（Ubuntu系统，其他系统可能会有差异，比如Fedora17系统上是双感叹号!!）： 1test:!$6$N8tiFTQb$ViLVGgYXVKoOIdIcoXVfmug5tOfzwIVoeKia4uY6Wtw6n0sIEs1uTf9Ff6DI1.iOPX6/jzs.CDus8h.x6AonJ.:18106:0:99999:7::: 可以使用-u选项来解锁某用户的口令；-d是直接删除某用户的口令，使其无法登录系统。 gpasswd命令使用gpasswd命令可以设置一个组群的组群密码，或是在组群中添加、删除用户。 命令语法：gpasswd [-r|-R][组群名] gpasswd [选项][用户名][组群名]","categories":[{"name":"linux","slug":"linux","permalink":"http://QQ876684433.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://QQ876684433.github.io/tags/linux/"}]},{"title":"Java分布式应用知识点","slug":"Java分布式应用知识点","date":"2019-07-24T15:10:12.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/24/Java分布式应用知识点/","link":"","permalink":"http://QQ876684433.github.io/2019/07/24/Java分布式应用知识点/","excerpt":"","text":"Java分布式应用知识点相关知识点 来源：问题https://www.zhihu.com/question/22764869下的回答 知乎用户——by 用心阁 软件工程师 网络通讯，网络是分布式的基础，对分布式的理解建立在对网络的理解上，包括： OSI模型的7层 TCP/IP，DNS，NAT HTTP，SPDY/HTTP2 Telnet 网络编程，是通过程序在多个主机之间通信。包括： Socket 多线程 非阻塞IO 网络框架 Netty Mina ZeroMQ 操作系统的网络部分 RPC，Socket使用不是很方便，很多分布式应用是基于RPC的，包括： 同步RPC 异步RPC 主要的一些RPC协议 RMI Rest API Thrift 集群，分布式计算离不开集群。集群就是多台主机被当作一个系统 集群类型 高可用，如主机备机切换，冷备，热备，双活 伸缩性，如Web服务器集群，数据库服务器的Sharding 并行计算，如网格，大数据 集群相关技术，包括： 高可用性，保证服务一直能够被访问，延长MTBF，缩短MTTR 冗余的设备 多副本，为了避免单点失效 负载均衡，如何将大量工作负载分配到多个主机上，最大化吞吐量，最小化平均响应时间，最大化资源利用率。 伸缩性（横向），能够添加计算机和设备来应对增长的计算压力 分片（Sharding），把数据分成多个数据集，由多个服务器来分别处理。 自动分片 容错性，当硬件或软件发生故障，能够继续运转 故障检测，以及故障预测 心跳包 告警 性能预警 故障转移，当出现错误，如何解决，为了高可用性和容错性 分布式一致性，在分布式环境中如何维持状态的一致性，严格一致性，还是最终一致性 集群状态协调，如Zookeeper，etcd等。 分布式锁，在分布式环境中如何进行加锁 选主，当Master宕机，如何选择出新的Master，协议如Raft 一致性哈希，如何将数据分布到集群中的多个主机。 分布式事务，保证在多台服务器上完成的操作符合事务的ACID属性。 安全，网络通常需要保证安全。 身份认证，如何验证人或机器是他们声明的身份 基于用户名/口令 基于数字证书 私密性，如何防止窃听和嗅探 对称加密 非对称加密 完整性，如何保证数据不被篡改 安全散列 消息认证码（MAC） 不可否认性 基于数字证书的数字签名和验签 基于密钥的散列，如HMAC 互联网站的基本架构 页面缓存 负载均衡器，如HAProxy,Nginx 分布式缓存，如Memcache，Redis 消息队列，如ActiveMQ，Kafka 分布式框架 关系型数据库（Sharding，主从同步） NoSQL HBase，基于HDFS和Zookeeper的NoSQL Cassandra，无主集群 大数据 HDFS，分布式文件系统 MapReduce，将数据处理任务拆分为多个工作，通过集群来完成。 Spark，提供分布式的数据集抽象 书籍推荐 大型分布式网站架构设计与实践 大型网站技术架构：核心原理与案例分析 大型网站系统与Java中间件实践 分布式Java应用：基础与实践","categories":[{"name":"分布式","slug":"分布式","permalink":"http://QQ876684433.github.io/categories/分布式/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"分布式","slug":"分布式","permalink":"http://QQ876684433.github.io/tags/分布式/"}]},{"title":"精读Servlet源码-javax.servlet.ServletContext","slug":"精读Servlet源码-javax-servlet-ServletContext","date":"2019-07-19T02:27:59.000Z","updated":"2019-09-15T05:02:14.670Z","comments":true,"path":"2019/07/19/精读Servlet源码-javax-servlet-ServletContext/","link":"","permalink":"http://QQ876684433.github.io/2019/07/19/精读Servlet源码-javax-servlet-ServletContext/","excerpt":"","text":"精读Servlet源码-javax.servlet.ServletContext 参考： https://www.cnblogs.com/smyhvae/p/4140877.html https://blog.csdn.net/gavin_john/article/details/51399425","categories":[{"name":"源码","slug":"源码","permalink":"http://QQ876684433.github.io/categories/源码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"servlet","slug":"servlet","permalink":"http://QQ876684433.github.io/tags/servlet/"}]},{"title":"精读Servlet源码-javax.servlet.ServletConfig","slug":"精读Servlet源码-javax-servlet-ServletConfig","date":"2019-07-19T01:43:08.000Z","updated":"2019-09-15T05:02:14.670Z","comments":true,"path":"2019/07/19/精读Servlet源码-javax-servlet-ServletConfig/","link":"","permalink":"http://QQ876684433.github.io/2019/07/19/精读Servlet源码-javax-servlet-ServletConfig/","excerpt":"","text":"精读Servlet源码-javax.servlet.ServletConfig 参考：https://www.cnblogs.com/smyhvae/p/4140877.html ServletConfig的实例是servlet容器在初始化一个servlet时传递到init()方法的对象，它携带了一个servlet的相关配置以及初始化参数。 12345678910111213141516171819package javax.servlet;import java.util.Enumeration;/** * A servlet configuration object used by a servlet container * to pass information to a servlet during initialization. */ public interface ServletConfig &#123; public String getServletName(); public ServletContext getServletContext(); public String getInitParameter(String name); public Enumeration&lt;String&gt; getInitParameterNames();&#125; 各个接口方法的说明getServletName返回servlet实例的名称，它可能是在web服务器中由服务器管理者提供的，如果servlet没有被注册到服务中，那么它将返回servlet实例的类名。 getServletContextgetServletContext返回ServletContext实例的引用，WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用，并且保存在ServletConfig实例中并传递给对应的servlet，通过它可以允许调用者与servlet容器进行交互。 getInitParameter初始化参数在ServletConfig中是以键值对方式存储的，getInitParameter()可以通过给定的参数名字获取对应的参数值，键和值都是以字符串的形式存储；如果对应的参数名字不存在，则返回null。 getInitParameterNames获取所有的初始化参数，以Enumeration类型返回；如果没有，则返回一个空的Enumeration。Enumeration类似于迭代器，Enumeration接口中定义了一些方法，通过这些方法可以枚举（一次获得一个）对象集合中的元素。 追根溯源：ServletConfig vs ServletContextServletConfig从更本质上来看，ServletConfig实际上代表的是当前Servlet在web.xml中的配置信息，在Servlet的配置文件中，可以使用&lt;servlet&gt;标签下的一个或多个&lt;init-param&gt;标签为servlet配置一些初始化参数。&lt;init-param&gt;标签是为某一个单独的servlet加配置信息，这种配置信息在其他的Servlet中是无法访问到的。 当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。进而，程序员通过ServletConfig对象就可以得到当前servlet的初始化参数信息。 这样做的好处是：如果将数据库信息、编码方式等配置信息放在web.xml中，如果以后数据库的用户名、密码改变了，则直接很方便地修改web.xml就行了，避免了直接修改源代码的麻烦。 ServletContextWEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。 ServletConfig对象中维护了ServletContext对象的引用，它是由servlet容器提供的，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。 由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。 对ServletContext更深入的研究请移步：精读Servlet源码-javax.servlet.ServletContext ServletConfig实例编写Servlet123456789101112131415161718192021222324252627282930313233343536373839404142434445package servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.Enumeration;public class ServletConfigDemo extends HttpServlet &#123; @Override public void init() throws ServletException &#123; super.init(); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletConfig servletConfig = this.getServletConfig(); PrintWriter out = resp.getWriter(); resp.setContentType(\"text/plain\"); String servletName = servletConfig.getServletName(); out.println(\"Servlet name: \" + servletName); String username = servletConfig.getInitParameter(\"username\"); String password = servletConfig.getInitParameter(\"password\"); out.println(\"=================servletConfig.getInitParameter================\"); out.println(\"username: \" + username); out.println(\"password: \" + password); out.println(\"=================servletConfig.getInitParameterNames================\"); Enumeration&lt;String&gt; params = servletConfig.getInitParameterNames(); while (params.hasMoreElements()) &#123; String name = params.nextElement(); out.println(name + \": \" + servletConfig.getInitParameter(name)); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 配置web.xml12345678910111213141516171819202122232425&lt;servlet&gt; &lt;servlet-name&gt;ServletConfigDemo-xxxx&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.ServletConfigDemo&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;steve_chph&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;password&lt;/param-name&gt; &lt;param-value&gt;mypassword123456&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;name1&lt;/param-name&gt; &lt;param-value&gt;value1&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;name2&lt;/param-name&gt; &lt;param-value&gt;value2&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletConfigDemo-xxxx&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServletConfigDemo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 输出结果","categories":[{"name":"源码","slug":"源码","permalink":"http://QQ876684433.github.io/categories/源码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"servlet","slug":"servlet","permalink":"http://QQ876684433.github.io/tags/servlet/"}]},{"title":"精读Servlet源码-javax.servlet.http.HttpServlet","slug":"精读Servlet源码-javax-servlet-http-HttpServlet","date":"2019-07-18T11:57:50.000Z","updated":"2019-09-15T05:02:14.670Z","comments":true,"path":"2019/07/18/精读Servlet源码-javax-servlet-http-HttpServlet/","link":"","permalink":"http://QQ876684433.github.io/2019/07/18/精读Servlet源码-javax-servlet-http-HttpServlet/","excerpt":"","text":"","categories":[{"name":"源码","slug":"源码","permalink":"http://QQ876684433.github.io/categories/源码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"servlet","slug":"servlet","permalink":"http://QQ876684433.github.io/tags/servlet/"}]},{"title":"精读Servlet源码-javax.servlet.GenericServlet","slug":"精读Servlet源码-javax-servlet-GenericServlet","date":"2019-07-18T11:57:19.000Z","updated":"2019-09-15T05:02:14.670Z","comments":true,"path":"2019/07/18/精读Servlet源码-javax-servlet-GenericServlet/","link":"","permalink":"http://QQ876684433.github.io/2019/07/18/精读Servlet源码-javax-servlet-GenericServlet/","excerpt":"","text":"精读Servlet源码-javax.servlet.GenericServletGenericServlet定义了通用的、协议独立的servlet，HTTP协议版的servlet即HttpServlet直接继承了GenericServlet；GenericServlet实现了Servlet和ServletConfig接口，它提供了Servlet接口生命周期方法的简单实现版本（init和destroy），同时对ServletConfig的接口方法作进一步的封装。 ServletConfig作为GenericServlet的私有属性保存，它是在servlet在初始化时init()方法中传递进来的，这样就能在servlet的各个生命周期方法中以及servlet容器中访问到servlet配置及初始化参数。 1234567891011public abstract class GenericServlet implements Servlet, ServletConfig, java.io.Serializable&#123; private static final String LSTRING_FILE = \"javax.servlet.LocalStrings\"; private static ResourceBundle lStrings = ResourceBundle.getBundle(LSTRING_FILE); private transient ServletConfig config; ... ...&#125; 各个方法的说明构造函数因为servlet的初始化工作是由init()完成的，所以在构造函数里什么也不做。 1public GenericServlet() &#123; &#125; Servlet接口方法initGenericServlet除了实现Servlet接口的init()方法外，还提供了一个无参的init()方法： void init(ServletConfig config) 由servlet容器调用，它将ServletConfig实例传递进来，init()的工作是将ServletConfig保存起来以备后用，然后再调用无参的init()来完成开发者自定义的初始化过程 void init() 提供给开发者重写init()的便利方式，开发者可以根据需要在init()中完成servlet的初始化工作 理论上，在开发servlet时重写任何一个init()都是可行的，区别在于如果重写的是带参数的init()，需要手动调用super(config);以将参数ServletConfig保存在servlet内部；如果重写的是无参的init()，那么就没有必要手动调用父类中对应的方法，因为servlet容器始终调用的是带参数的init()，带参数的init()随后又会调用无参的init()，如果开发者重写了无参的init()，那么也能完成自定义的servlet初始化工作。 一般来说推荐重写无参的init()，这样可以避免由于忘记调用super(config);而带来的不必要的麻烦。 12345678public void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init();&#125;public void init() throws ServletException &#123;&#125; service抽象方法，GenericServlet没有提供任何实现，意味着任何一个具体子类必须实现service()方法以完成相应的业务逻辑。 1public abstract void service(ServletRequest req, ServletResponse res)throws ServletException, IOException; destroy实现了一个空方法，由servlet容器调用，开发者可以根据需要重写该方法来完成servlet卸载前的相关资源清理工作。 1public void destroy() &#123;&#125; getServletInfo这是留给开发者自定义的方法，它的作用是用来返回servlet的相关信息比如：作者、版本和版权信息等等；GenericServlet中默认是返回一个空的字符串，因为具体的返回值是由实际的开发者决定的，但是有一个约定是：返回值应该是普通文本而不是标记文本（例如HTML、XML等等）。 1public String getServletInfo() &#123;return \"\"; &#125; getServletConfig返回servlet保存的ServletConfig引用。 1public ServletConfig getServletConfig() &#123;return config; &#125; ServletConfig接口方法这些接口方法实际上只是对ServletConfig的接口方法作了进一步的封装，实际上的工作是由servlet容器传递到init()方法的ServletConfig实例完成的。 123456789101112131415161718192021222324252627282930313233343536373839public String getInitParameter(String name) &#123; ServletConfig sc = getServletConfig(); if (sc == null) &#123; throw new IllegalStateException( lStrings.getString(\"err.servlet_config_not_initialized\")); &#125; return sc.getInitParameter(name);&#125;public Enumeration&lt;String&gt; getInitParameterNames() &#123; ServletConfig sc = getServletConfig(); if (sc == null) &#123; throw new IllegalStateException( lStrings.getString(\"err.servlet_config_not_initialized\")); &#125; return sc.getInitParameterNames();&#125; public ServletContext getServletContext() &#123; ServletConfig sc = getServletConfig(); if (sc == null) &#123; throw new IllegalStateException( lStrings.getString(\"err.servlet_config_not_initialized\")); &#125; return sc.getServletContext();&#125;public String getServletName() &#123; ServletConfig sc = getServletConfig(); if (sc == null) &#123; throw new IllegalStateException( lStrings.getString(\"err.servlet_config_not_initialized\")); &#125; return sc.getServletName();&#125; 扩展方法log这个方法是对getServletContext().log(...)方法的进一步封装，用来向ServletContext输出servlet运行时的日志信息： void log(String msg) 正常运行的日志信息，以对应的servlet名称作为日志信息前缀 void log(String message, Throwable t) 运行时异常的日志信息，信息内容还包含了异常的调用栈追踪信息，以对应的servlet名称作为日志信息前缀 1234567public void log(String msg) &#123; getServletContext().log(getServletName() + \": \"+ msg);&#125;public void log(String message, Throwable t) &#123; getServletContext().log(getServletName() + \": \" + message, t);&#125;","categories":[{"name":"源码","slug":"源码","permalink":"http://QQ876684433.github.io/categories/源码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"servlet","slug":"servlet","permalink":"http://QQ876684433.github.io/tags/servlet/"}]},{"title":"精读Servlet源码-javax.servlet.Servlet","slug":"精读Servlet源码-javax-servlet-Servlet","date":"2019-07-18T08:41:32.000Z","updated":"2019-09-15T05:02:14.670Z","comments":true,"path":"2019/07/18/精读Servlet源码-javax-servlet-Servlet/","link":"","permalink":"http://QQ876684433.github.io/2019/07/18/精读Servlet源码-javax-servlet-Servlet/","excerpt":"","text":"精读Servlet源码-javax.servlet.Servletservlet是运行在Web服务器上面的Java应用程序，Servlet接口类是servlet最核心的一个类，它定义了所有的servlet应该实现的方法，即servlet的生命周期方法，这些声明周期方法是由Web容器比如tomcat来调用的；同时也定义了获取一个servlet配置参数或者信息的方法。 GenericServlet类实现了Servlet类，定义了一个通用的、协议无关的servlet；而HttpServlet类继承了GenericServlet类，定义了HTTP协议下的servlet，它是抽象类，开发者必须继承HttpServlet并实现所有的抽象方法来创建具体的http servlet应用，它们的依赖关系如图： 123456789101112public interface Servlet &#123; public void init(ServletConfig config) throws ServletException; public ServletConfig getServletConfig(); public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; public String getServletInfo(); public void destroy();&#125; 各个接口方法的说明initinit()方法是用来指示一个servlet将被加载到web服务器的服务中，这个方法是在servlet初始化完成之后立即调用的，只有init()被调用并成功返回后，这个servlet才能接受、处理并响应客户端的请求。 当inti()调用过程中发生以下情况时，servlet是不会被加载到服务里面的： init()抛出ServletException异常 init()方法在Web服务器设定的时间内没有返回，即执行超时 一个servlet的init()方法只会在初始化时会且只会被调用一次，它接受ServletConfig类型的参数，ServletConfig包含了servlet的配置和初始化参数，这些参数可以作用域Servlet的整个生命周期，init()方法可以使用这些参数完成相关的初始化工作。 service只有当init()成功调用并将servlet加载进服务中时，service()才能被servlet容器调用用来处理客户端的请求。一般servlet应用都是运行在多线程的servlet容器中，可以并行处理多个客户端请求，servlet每当接收到一个请求时都会产生一个新的线程来处理和该请求，因此就会出现多个servlet 同时访问相同的共享资源（如文件、内存资源等）的情况，这时要注意处理好线程同步的问题。 service()方法由容器调用，service() 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以开发者不用对 service() 方法做任何动作，只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。 它接受两个参数：ServletRequest和ServletResponse，分别对应客户端的请求和servlet对该请求作出的响应。 destroy在servlet被从容器中卸载之前调用，它可以用来清除该servlet占用的资源（例如关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动等）。 destroy()方法仅当该servlet所有的service方法都成功返回之后、或者执行时间超时才能调用，而且destroy()方法一旦调用完成，这个servlet的service()就放就不会被调用了，而且servlet 对象被标记为垃圾回收，会等待JVM回收。 getServletConfig该方法返回一个ServletConfig对象，这个对象恰好是servlet容器初始化servlet时传入init()方法的ServletConfig对象，因此在实现Servlet接口的时候要求init()方法能够将参数ServletConfig对象保存在servlet实例内部，而这个功能已经在Servlet接口实现类GenericServlet中实现了： 12345678public ServletConfig getServletConfig() &#123; return config;&#125;public void init(ServletConfig config) throws ServletException &#123; this.config = config; this.init();&#125; getServletInfo这是留给开发者自定义的方法，它的作用是用来返回servlet的相关信息比如：作者、版本和版权信息等等；这个方法在Servlet接口实现类GenericServlet中默认是返回一个空的字符串，具体的返回值是由实际的开发者决定的，但是有一个约定是：返回值应该是普通文本而不是标记文本（例如HTML、XML等等） 123public String getServletInfo() &#123; return \"\";&#125; Servlet生命周期架构图典型的 Servlet 生命周期方案： 第一个到达服务器的 HTTP 请求被委派到 Servlet 容器 Servlet 容器在调用 service() 方法之前加载 Servlet 然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法","categories":[{"name":"源码","slug":"源码","permalink":"http://QQ876684433.github.io/categories/源码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"servlet","slug":"servlet","permalink":"http://QQ876684433.github.io/tags/servlet/"}]},{"title":"JavaWeb敲门砖-servlet概览","slug":"JavaWeb敲门砖-servlet概览","date":"2019-07-18T07:50:49.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/18/JavaWeb敲门砖-servlet概览/","link":"","permalink":"http://QQ876684433.github.io/2019/07/18/JavaWeb敲门砖-servlet概览/","excerpt":"","text":"JavaWeb敲门砖-Servlet概览Servlet生命周期 来源：https://www.runoob.com/servlet/servlet-life-cycle.html Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 Servlet实例编写Servlet类开发web应用时，通常是继承HttpServlet类来编写自己的Servlet应用，用以处理客户端的HTTP请求。 1234567891011121314151617181920212223242526272829package servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class HelloWorld extends HttpServlet &#123; private String message; @Override public void init() throws ServletException &#123; message = \"Hello World!\"; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(\"text/html\"); PrintWriter pw = resp.getWriter(); pw.println(\"&lt;h1&gt;\"+message+\"&lt;/h1&gt;\"); &#125; @Override public void destroy() &#123; System.out.println(\"end of servlet\"); &#125;&#125; 编译Servlet如果直接javac编译.java文件，会出现依赖问题，因为servlet默认不是标准jdk自带的： 123456789101112import javax.servlet.ServletException; ^HelloWorld.java:4: 错误: 程序包javax.servlet.http不存在import javax.servlet.http.HttpServlet; ^HelloWorld.java:5: 错误: 程序包javax.servlet.http不存在import javax.servlet.http.HttpServletRequest; ^HelloWorld.java:6: 错误: 程序包javax.servlet.http不存在import javax.servlet.http.HttpServletResponse; ^...... 为了方便解决依赖问题，建议使用maven来编译整个项目，然后再在target/classes下面找到需要的class文件： 部署Servlet进入在tomcat目录，在webapps/下面建立项目结构 1234567webapps└── serv ├── index.html* └── WEB-INF ├── classes │ └── HelloWorld.class └── web.xml 其中index.html是可选的，在这里我们只是为了测试我们的servlet，因此可以不用建立这个文件。然后将我们之前编译好的HelloWorld.class复制到classes下，然后编写web.xml文件： 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\" version=\"2.4\"&gt; &lt;display-name&gt;Welcome to my first jsp &lt;/display-name&gt; &lt;description&gt; Welcome to my jsp &lt;/description&gt; &lt;servlet&gt; &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 保存后启动tomcat服务器bin/startup.sh，访问”http://localhost:8080/serv/HelloWorld&quot;就可以了。。。 。。。。。。 wtf？为什么报错了？ 别急，往下看 注意事项如果你细心的话可以发现，我们的HelloWorld类是在servlet包下面的，但是我们的classes结构和web.xml描述是这样的： 1234WEB-INF ├── classes │ └── HelloWorld.class // 看这里 └── web.xml 123456789&lt;servlet&gt; &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; // 看这里&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 但是实际上HelloWorld这个类的完整类名是servlet.HelloWorld，很显然跟我们的配置不匹配，所以我们需要修改： 12345webapps/serv/WEB-INF/├── classes│ └── servlet // 看这里│ └── HelloWorld.class // 看这里└── web.xml 123456789&lt;servlet&gt; &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.HelloWorld&lt;/servlet-class&gt; // 看这里&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 保存后重启tomcat，然后再次访问页面： 这很舒服了！ servlet配置为了让Servlet能响应用户请求，还必须将Servlet配置在web应用中，配置Servlet需要修改web.xml文件。从Servlet3.0开始，配置Servlet有两种方式： 在Servlet类中使用@WebServlet Annotation进行配置。 在web.xml文件中进行配置。 这里面我们用的是web.xml配置的方式。这里只介绍一下最核心的部分，更详细的内容可以参考：https://blog.csdn.net/believejava/article/details/43229361 &lt;servlet&gt;定义一个servlet，它必须含有&lt;servlet-name&gt;和&lt;servlet-class&gt; &lt;servlet-name&gt;：用来定义servlet的名称，该名称在整个应用中必须是惟一的 &lt;servlet-class&gt;：用来指定servlet的完全限定的名称，例如我们定义的servlet全限定名为servlet.HelloWorld &lt;servlet-mapping&gt;用来定义servlet与请求url的匹配规则，它含有&lt;servlet-name&gt;和&lt;url-pattern&gt; &lt;servlet-name&gt;：Servlet的名字，唯一性和一致性，与&lt;servlet&gt;元素中声明的名字一致 &lt;url-pattern&gt;：指定相对于Servlet的URL的路径。该路径相对于web应用程序上下文的根路径，例如我们上面定义了应用的根路径是/serv，那么最后我们访问该servlet的url就是：http://localhost:8080/serv/&lt;url-pattern&gt;。&lt;servlet-mapping&gt;将URL模式映射到某个Servlet，即该Servlet处理的URL","categories":[{"name":"后端","slug":"后端","permalink":"http://QQ876684433.github.io/categories/后端/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"servlet","slug":"servlet","permalink":"http://QQ876684433.github.io/tags/servlet/"}]},{"title":"由String的构造方法引申出来的java字符编码","slug":"由String的构造方法引申出来的java字符编码","date":"2019-07-17T01:39:40.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/17/由String的构造方法引申出来的java字符编码/","link":"","permalink":"http://QQ876684433.github.io/2019/07/17/由String的构造方法引申出来的java字符编码/","excerpt":"","text":"由String的构造方法引申出来的java字符编码 作者：挟天子以令诸侯 出处：http://www.cnblogs.com/gdayq/本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。 在String类的constructors中，有一个constructor是将int数组类型转化为字符串： 123int[] num = &#123;48,49,50,51,52&#125;;String numStr = new String(num,0,4);System.out.println(numStr); 输出结果是： 0123 这个constructor的作用是将int数组中每一位上的数字转化为在Unicode编码中对应的字符。现在来看看它是怎么转化的。 源代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public String(int[] codePoints, int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; codePoints.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; final int end = offset + count; // Pass 1: Compute precise size of char[] int n = count; for (int i = offset; i &lt; end; i++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) continue; else if (Character.isValidCodePoint(c)) n++; else throw new IllegalArgumentException(Integer.toString(c)); &#125; // Pass 2: Allocate and fill in char[] final char[] v = new char[n]; for (int i = offset, j = 0; i &lt; end; i++, j++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) v[j] = (char) c; else Character.toSurrogates(c, v, j++); &#125; this.value = v; this.count = n; this.offset = 0; &#125;&#125; 代码很简单，但是用到了Character类的三个方法： 123Character.isBmpCodePoint(c)Character.isValidCodePoint(c)Character.toSurrogates(c, v, j++) 先来看看第一个方法isBmpCodePoint()： 1234567public static boolean isBmpCodePoint(int codePoint) &#123; return codePoint &gt;&gt;&gt; 16 == 0; // Optimized form of: // codePoint &gt;= MIN_VALUE &amp;&amp; codePoint &lt;= MAX_VALUE // We consistently use logical shift (&gt;&gt;&gt;) to facilitate // additional runtime optimizations.&#125; &gt;&gt;&gt;是移位运算符，codePoint &gt;&gt;&gt; 16 的意思是将codePoint变量无符号右移16位，然后判断是否等于0，这个是在判断什么呢？根据字面意思理解is bmp code point,是否是bmp代码点，也是不明白，然后就去search了一下，于是就引申出了两个概念—-代码点与代码单元。 说到代码点与代码单元，就得先说说Unicode编码的基本概念了。 1、Unicode的基本概念1）编码字符集 编码字符集是一个字符集，它为每一个字符分配一个唯一数字。Unicode 标准的核心是一个编码字符集，字母“A”的编码为0041和字符“€”的编码为20AC。Unicode标准始终使用十六进制数字，而且在书写时在前面加上前缀“U+”，所以“A”的编码书写为“U+0041”。说白了，就是在编码字符集中，每一个字符都有一个自己的一个唯一的ID。 2）代码点与代码单元 Unicode 代码点 U+0041 U+00DF U+6771 U+10400 表示字形 UTF-32 代码单元 00000041 000000DF 00006771 00010400 UTF-16 代码单元 0041 00DF 6771 D801DC00 UTF-8 代码单元 41 C39F E69DB1 F0909080 网摘：“代码点（Code Point）就是指Unicode中为字符分配的编号，一个字符只占一个代码点，例如我们说到字符“汉”，它的代码点是U+6C49.代码单元（Code Unit）则是针对编码方法而言，它指的是编码方法中对一个字符编码以后所占的最小存储单元。例如UTF-8中，代码单元是一个字节，因为一个字符可以被编码为1个，2个或者3个4个字节；在UTF-16中，代码单元变成了两个字节（就是一个char），因为一个字符可以被编码为1个或2个char（你找不到比一个char还小的UTF-16编码的字符，嘿嘿）。说得再罗嗦一点，一个字符，仅仅对应一个代码点，但却可能有多个代码单元（即可能被编码为2个char）。” 说白了，代码点：就是字符所对应的那个“ID”。代码单元：指的是在各种不同的编码方式中（UTF-8,UTF-16），对一个字符编码以后所占的最小存储单元。 3）增补字符 16 位编码的所有 65536 个字符并不能完全表示全世界所有正在使用或曾经使用的字符。于是，Unicode 标准已扩展到包含多达 1112064 个字符。那些超出原来的16 位限制的字符被称作增补字符。 Java的char类型是固定16bits(两个字节)的。代码点在U+0000 — U+FFFF之内到是可以用一个char完整的表示出一个字符。但代码点在U+FFFF之外的，一个char无论如何无法表示一个完整字符。这样用char类型来获取字符串中的那些代码点在U+FFFF之外的字符就会出现问题。 于是，有了增补字符。增补字符是代码点在 U+10000 至 U+10FFFF 范围之间的字符，也就是那些使用原始的 Unicode 的 16 位设计无法表示的字符。从 U+0000 至 U+FFFF 之间的字符集有时候被称为基本多语言面（BMP UBasic Multilingual Plane ）。Unicode的代码点可以分成17个代码级别。第一个代码级别称为基本的多语言级别，代码点从U+0000到U+FFFF，其中包括了经典的Unicode代码，其余的16个附加级别，代码点从U+10000到U+10FFFF，其中包括了一些增补字符。因此，每一个 Unicode 字符要么属于 BMP，要么属于增补字符。 2、基于Unicode的具体编码格式 网摘： UTF-32 即将每一个 Unicode 代码点表示为相同值的32位整数。很明显，它是内部处理最方便的表达方式，但是，如果作为一般字符串表达方式，则要消耗更多的内存。 UTF-16 使用一个或两个未分配的16位代码单元的序列对 Unicode 代码点进行编码。假设U是一个代码点，也就是Unicode编码表中一个字符所对应的Unicode值: (1) 如果在BMP级别中，那么16bits(一个代码单元)就足够表示出字符的Unicode值。 (2)如果U+10FFFF&gt;U&gt;=U+10000，也就是处于增补字符级别中。UTF-16用2个16位来表示出了，并且正好将每个16位都控制在替代区域U+D800-U+DFFF（其中\\uD800-\\uDBFF为高代理项 范围，\\uDC00- \\uDFFF为低代理项 范围） 中。 也就是说，在UTF-16中，增补字符的表示方式是由两个代码单元来表示的，原因就是一个代码单元放不下它。那么在java中是如何处理这些增补字符的呢？ java的处理方式是这样的：对于增补字符U（U+10FFFF&gt;U&gt;=U+10000）。首先，分别初始化2个16位无符号的整数 —— W1和W2。其中W1=110110xxxxxxxxxx（0xD800-0xDBFF）,W2 = 110111xxxxxxxxxx(0xDC00-OxDFFF)。然后，将Unicode的高10位分配给W1的低10位，将Unicode 的低10位分配给W2的低10位。这样就可以将20bits的代码点U拆成两个16bits的代码单元。而且这两个代码点正好落在替代区域U+D800-U+DFFF中。 UTF-16表示的增补字符怎样才能被正确的识别为增补字符，而不是两个普通的字符呢？答案是通过看它的第一个char是不是在高代理范围内，第二个char是不是在低代理范围内来决定，这也意味着，高代理和低代理所占的共2048个码位（从0xD800到0xDFFF）是不能分配给其他字符的。 Unicode的编号中，U+D800到U+DFFF是否有字符分配？答案是也没有！这么做的目的是希望基本多语言面中的字符和一个char型的UTF-16编码的字符能够一一对应。（这里就不写代码验证了） java具体的是怎么来拆分增补字符的呢？看一个例子：通过两个代码点U+11001,U+1D56B（使用4个字节表示的代码点）以U+1D56B来说 0x1D56B= 0001 1101 01-01 0110 1011 将0x1D56B的高10位0001 1101 01分配给W1的低10位组合成110110 0001 1101 01=0xD875 将0x1D56B的低10位01 0110 1011分配给W2的低10位组合成110111 01 0110 1011=0xDD6B 这样代码点U+1D56B采用UTF-16编码方式，用2个连续的代码单元U+D875和U+DD6B表示出了 12345678910int[] codePoints = &#123;0x11001,0x1d56b&#125;; //增补字符 String s = new String(codePoints,0,2); System.out.println(\"s: \" + s); System.out.println(\"s.length: \" + s.length()); //4,说明length()是按代码单元计算的 System.out.println(\"s.charAt(0): \" + Integer.toHexString((int)s.charAt(0)));//输出结果表明增补字符并非简单地把两个代码单元拆开 System.out.println(\"s.charAt(1): \" + Integer.toHexString((int)s.charAt(1)));System.out.println(\"s.charAt(2): \" + Integer.toHexString((int)s.charAt(2)));System.out.println(\"s.charAt(3): \" + Integer.toHexString((int)s.charAt(3)));System.out.println(\"s.codePointAt(0):\" + Integer.toHexString(s.codePointAt(0))); 输出结果是： 1234567s: ??s.length: 4s.charAt(0): d804s.charAt(1): dc01s.charAt(2): d835s.charAt(3): dd6bs.codePointAt(0):11001 可以看到 字符串的长度为4，说明length()是按代码单元计算的，然后我们看看U+1D56B的拆分结果： s.charAt(2): d835s.charAt(3): dd6b 与我们计算的 U+D875 U+DD6B 有出入，该代理代码点不一样，带着这个疑问，我们去看看java代码是如何转化的: 1234567891011121314151617181920212223242526272829303132333435[java.lang.String] for (int i = offset, j = 0; i &lt; end; i++, j++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) //判断是不是BMP级别 v[j] = (char) c; else Character.toSurrogates(c, v, j++);//给出高低代理项&#125;[java.lang.Character]static void toSurrogates(int codePoint, char[] dst, int index) &#123; // We write elements \"backwards\" to guarantee all-or-nothing dst[index+1] = lowSurrogate(codePoint);//给出低代理项 dst[index] = highSurrogate(codePoint);//给出高代理项&#125; [java.lang.Character] public static final char MIN_LOW_SURROGATE = '\\uDC00';//低代理项最小值public static char lowSurrogate(int codePoint) &#123; return (char) ((codePoint &amp; 0x3ff) + MIN_LOW_SURROGATE);&#125; [java.lang.Character] public static final char MIN_HIGH_SURROGATE = '\\uD800';//高代理项最小值public static final int MIN_SUPPLEMENTARY_CODE_POINT = 0x010000;//增补字符最小代码点public static char highSurrogate(int codePoint) &#123; return (char) ((codePoint &gt;&gt;&gt; 10) + (MIN_HIGH_SURROGATE - (MIN_SUPPLEMENTARY_CODE_POINT &gt;&gt;&gt; 10)));&#125; 可以看出低代理项与计算方式一样，所以计算出的结果一致，但是高代理项在移位10bit，加上最小高代理项后，又减去了增值字符最小代码点的移位10bit后的值，其实这就相当于，对于增补字符U+1D56B，其操作是对 U+0D56B进行的操作。这里还没有确定为什么会减去这个位，有待考证！ UTF-8：网摘： 使用一至四个字节的序列对编码 Unicode 代码点进行编码。U+0000 至 U+007F 使用一个字节编码，U+0080 至 U+07FF 使用两个字节，U+0800 至 U+FFFF 使用三个字节，而 U+10000 至 U+10FFFF 使用四个字节。UTF-8 设计原理为：字节值 0x00 至 0x7F 始终表示代码点 U+0000 至 U+007F（Basic Latin 字符子集，它对应 ASCII 字符集）。这些字节值永远不会表示其他代码点，这一特性使 UTF-8 可以很方便地在软件中将特殊的含义赋予某些 ASCII 字符。 以下是Unicode和UTF-8之间的转换关系表： U-00000000 - U-0000007F： 0xxxxxxx U-00000080 - U-000007FF： 110xxxxx 10xxxxxx U-00000800 - U-0000FFFF： 1110xxxx 10xxxxxx 10xxxxxx U-00010000 - U-001FFFFF： 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx U-00200000 - U-03FFFFFF： 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx U-04000000 - U-7FFFFFFF： 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 可以看到： （1）如果一个字节以10开头，一定不是首字节，需要向前查找。 （2）在一个首字节中，如果以0开头，表示是一个ASCII字符，而开头的连续的1的个数也表示了这个字符的字节数。如1110xxxx表示这个字符由三个字节组成。 下面来看一个使用各种编码对字符进行编码的例子，如下： img 分析到这里，结合源码，可以看出： Java 以 UTF-16 作为内存的字符存储格式。 参考： http://blog.csdn.net/u010411264/article/details/45258629http://blog.csdn.net/cumtwyc/article/details/45080679http://blog.csdn.net/mazhimazh/article/details/17708001","categories":[{"name":"转载","slug":"转载","permalink":"http://QQ876684433.github.io/categories/转载/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"}]},{"title":"深入剖析Java序列化与反序列化机制","slug":"深入剖析Java序列化与反序列化机制","date":"2019-07-16T15:10:08.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/16/深入剖析Java序列化与反序列化机制/","link":"","permalink":"http://QQ876684433.github.io/2019/07/16/深入剖析Java序列化与反序列化机制/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"精读Java源码-String类","slug":"精读Java源码-String类","date":"2019-07-16T12:59:00.000Z","updated":"2019-09-15T05:02:14.670Z","comments":true,"path":"2019/07/16/精读Java源码-String类/","link":"","permalink":"http://QQ876684433.github.io/2019/07/16/精读Java源码-String类/","excerpt":"","text":"精读Java源码 - String类 基于jdk1.8 推荐资料： https://www.kaelli.com/33.html http://cmsblogs.com/?p=5256 http://cmsblogs.com/?p=5258 类定义public没什么好说的，final修饰符则决定了String类是不可继承的且对象是不可变的，你无法自己写一个继承自String的类，而String对象的不可变性也是大家耳熟能详的。 实现了java.io.Serializable、Comparable和CharSequence共3个接口： Serializable是用来保证String可以序列化和反序列化的。 Comparable的compareTo(String str)方法则是实现String的对比排序的。 CharSequence的length()方法用来返回字符串长度，charAt(int index)则可以获取到给定位置的单个字符，subSequence(int start, int end)则提供了截取子字符串的功能，toString()方法对于String来说就是返回它自己了 重要属性123456789101112131415161718192021/** The value is used for character storage. */private final char value[];/** Cache the hash code for the string */private int hash; // Default to 0/** use serialVersionUID from JDK 1.0.2 for interoperability */private static final long serialVersionUID = -6849794470754667710L;/** * Class String is special cased within the Serialization Stream Protocol. */private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];/** * A Comparator that orders &#123;@code String&#125; objects as by * &#123;@code compareToIgnoreCase&#125;. This comparator is serializable. */public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator(); value 用于存储字符串对象的值，在jdk1.8里面是char数组，在后面的版本中改成了byte数组；被final修饰说明它是不可变的 hash 为字符串对象的哈希值，默认值为0 serialPersistentFields 看定义，它是一个私有的、静态的、不可改变的ObjectStreamField数组，实际上在JDK源码里有很多类都有这样一个属性，这些类的共同点是都实现了java.io.Serializable接口。在默认情况下一个实现了Serializable接口的类，所有的非 transient 非 static 修饰的字段都会被序列化，但如果还定义了serialPersistentFields字段，则只有serialPersistentFields里添加的字段才会被序列化。当一个字段用transient修饰，但又位于serialPersistentFields数组里时，它依然会被序列化——说明serialPersistentFields的作用优先级是比transient高的。 在String类里，serialPersistentFields是一个容量为0的空数组，显然String的字段都不会被序列化 CASE_INSENSITIVE_ORDER 表示用于排序的比较器 构造函数排除@Deprecated的构造函数，String类提供的构造函数主要有以下几类： 无参构造函数 123public String() &#123; this.value = \"\".value;&#125; 从原有字符串构造新的字符串 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; 直接对参数里的原字符串进行浅拷贝构造新的字符串，由于String类是final的，而且内部的value也是final的，所以字符序列在不同的String实例中共享不会带来任何副作用 通过字符数组构造字符串 1234567891011121314151617181920212223public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125;public String(char value[], int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= value.length) &#123; this.value = \"\".value; return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; this.value = Arrays.copyOfRange(value, offset, offset+count);&#125; 这个也没什么好讲的，它直接对参数里的字节数组进行了拷贝，这样的目的是使得外部的字节数组更改之后不会对字符串的字符序列造成影响。offset &gt; value.length - count的处理是为了防止offset+count的int类型溢出 通过整型数组构造字符串 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public String(int[] codePoints, int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= codePoints.length) &#123; this.value = \"\".value; return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; codePoints.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; //=============================分割线============================ final int end = offset + count; // Pass 1: Compute precise size of char[] int n = count; for (int i = offset; i &lt; end; i++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) continue; else if (Character.isValidCodePoint(c)) n++; else throw new IllegalArgumentException(Integer.toString(c)); &#125; // Pass 2: Allocate and fill in char[] final char[] v = new char[n]; for (int i = offset, j = 0; i &lt; end; i++, j++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) v[j] = (char)c; else Character.toSurrogates(c, v, j++); &#125; this.value = v;&#125; 分割线上部分没什么好讲的，就是常规的参数边界检查，下半部分有点意思，它涉及到了代码点和代码单元的知识以及Java对Unicode字符集的处理方法，具体的可以参考：https://chph.xyz/2019/07/17/%E7%94%B1String%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%B3%E5%87%BA%E6%9D%A5%E7%9A%84java%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/#%E7%94%B1String%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%B3%E5%87%BA%E6%9D%A5%E7%9A%84java%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81 通俗来讲，它的处理分为两个阶段： （1）计算int数组转成char数组后的精确长度，之所以两者不同，是因为Java采用了UTF-16字符编码，而Unicode代码点在不同的编码中的代码单元是不同的，UTF-16的字符编码由基本多语言面（BMP UBasic Multilingual Plane ）和增补字符（Supplementary Character）两部分组成，前者占用一个char，后者占用两个char，因此在遍历int数组时，Character.isBmpCodePoint(c)用来判断c是否是BMP，如果是，则长度不变，如果不是，而且它是有效的代码点Character.isValidCodePoint(c)，那么就要在原来int数组的长度是加一n++ （2）计算出char数组的长度后，就可以分配空间并填充该空间了，道理类似，如果是BMP，则直接将int转为char，否则的话就要使用Character.toSurrogates(c, v, j++)来转换 12345static void toSurrogates(int codePoint, char[] dst, int index) &#123; // We write elements \"backwards\" to guarantee all-or-nothing dst[index+1] = lowSurrogate(codePoint); dst[index] = highSurrogate(codePoint);&#125; 这个涉及到增补字符的高代理项和低代理项的转换，具体的原理在上面的链接里有提到了，这里不再深究，留待精读Character源码时再研究 最后将填充完成的char数组赋值给新的String实例的value即可 通过字节数组构造字符串 1234567891011121314151617181920212223242526272829303132public String(byte bytes[], int offset, int length, String charsetName) throws UnsupportedEncodingException &#123; if (charsetName == null) throw new NullPointerException(\"charsetName\"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charsetName, bytes, offset, length);&#125;public String(byte bytes[], int offset, int length, Charset charset) &#123; if (charset == null) throw new NullPointerException(\"charset\"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charset, bytes, offset, length);&#125;public String(byte bytes[], String charsetName) throws UnsupportedEncodingException &#123; this(bytes, 0, bytes.length, charsetName);&#125;public String(byte bytes[], Charset charset) &#123; this(bytes, 0, bytes.length, charset);&#125;public String(byte bytes[], int offset, int length) &#123; checkBounds(bytes, offset, length); this.value = StringCoding.decode(bytes, offset, length);&#125;public String(byte bytes[]) &#123; this(bytes, 0, bytes.length);&#125; 这几个构造函数的功能类似，根据给定的字符编码，调用StringCoding.decode来对字节数组进行解码来构造字符串，如果不提供字符编码的话，StringCoding.decode内部会调用String csn = Charset.defaultCharset().name();来使用Java默认的字符串编码来解码。 内部类CaseInsensitiveComparatorCaseInsensitiveComparator是String类内部一个大小写不敏感的字符串比较器，被String类内部的方法compareToIgnoreCase使用 12345678910111213141516171819202122232425262728293031private static class CaseInsensitiveComparator implements Comparator&lt;String&gt;, java.io.Serializable &#123; // use serialVersionUID from JDK 1.2.2 for interoperability private static final long serialVersionUID = 8575799808933029326L; public int compare(String s1, String s2) &#123; int n1 = s1.length(); int n2 = s2.length(); int min = Math.min(n1, n2); for (int i = 0; i &lt; min; i++) &#123; char c1 = s1.charAt(i); char c2 = s2.charAt(i); if (c1 != c2) &#123; c1 = Character.toUpperCase(c1); c2 = Character.toUpperCase(c2); if (c1 != c2) &#123; c1 = Character.toLowerCase(c1); c2 = Character.toLowerCase(c2); if (c1 != c2) &#123; // No overflow because of numeric promotion return c1 - c2; &#125; &#125; &#125; &#125; return n1 - n2; &#125; /** Replaces the de-serialized object. */ private Object readResolve() &#123; return CASE_INSENSITIVE_ORDER; &#125;&#125; compareTo方法的主要思路是，循环遍历比较两个字符串长度匹配的部分，如果该部分忽略大小写后相等，那么比较的结果就是两者长度的比较，按照字典序，结果就是长度小的靠前。 长度匹配部分的比较比较有意思，它有三次判断：直接比较、转成大写字母比较、转成小写字母比较。这么做的原因和regionMatches方法的处理方式大致相同，因为对有些语言比如格鲁吉亚字母（Georgian alphabet），它的大小写转换规则有点特殊：大写不等还不一定不等，还需要转小写 比如 ქართული დამწერლობა。因此在退出比较之前还要再次转换成小写字母进行最后一次检查。 关于readResolve，我在stackoverflow找到的解释如下： readResolve is used for replacing the object read from the stream. The only use I’ve ever seen for this is enforcing singletons; when an object is read, replace it with the singleton instance. This ensures that nobody can create another instance by serializing and deserializing the singleton. The readResolve method is called when ObjectInputStream has read an object from the stream and is preparing to return it to the caller. ObjectInputStream checks whether the class of the object defines the readResolve method. If the method is defined, the readResolve method is called to allow the object in the stream to designate the object to be returned. The object returned should be of a type that is compatible with all uses. If it is not compatible, a ClassCastException will be thrown when the type mismatch is discovered. Item 90, Effective Java, 3rd Ed covers readResolve and writeReplace for serial proxies - their main use. The examples do not write out readObject and writeObject methods because they are using default serialisation to read and write fields. readResolve is called after readObject has returned (conversely writeReplace is called before writeObject and probably on a different object). The object the method returns replaces thisobject returned to the user of ObjectInputStream.readObject and any further back references to the object in the stream. Both readResolve and writeReplace may return objects of the same or different types. Returning the same type is useful in some cases where fields must be final and either backward compatibility is required or values must copied and/or validated. Use of readResolve does not enforce the singleton property. …… 源于：https://stackoverflow.com/questions/1168348/java-serialization-readobject-vs-readresolve/24459741 按照我的理解来讲就是当ObjectInputStream读到一个对象时，会检查这个对象的类是否定义了readResolve方法，如果定义了该方法，那么会将该方法的返回值作为对象返回，而不是返回ObjectInputStream在流中读到的对象，这样就可以强制实现单例模式。但是如果流中读到的对象和readResolve方法返回的对象类型不兼容，那么就会抛出ClassCastException。 主要方法regionMatchesregionMatches功能是判断两个字符串指定区间、且具有相同长度的子串是否相等，它有两个重载的方法： 12public boolean regionMatches(int toffset, String other, int ooffset, int len);public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 它们的唯一区别是前者大小写敏感，后者可以指定是否忽略大小写。只有当一下某一个条件满足（即返回值为true）时，该方法的结果是false，即两个子串不相等： 下标越界：toffset&lt;0、ooffset&lt;0、toffset+len&gt;this.length()、ooffset+len&gt;other.length() 下标不越界情况下，两个子串的某一个位置对应的字符不相等 由于两个重载的方法中后者的功能涵盖了前者，因此我们只看后者的源码： 12345678910111213141516171819202122232425262728293031323334353637383940public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false; &#125; while (len-- &gt; 0) &#123; char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) &#123; continue; &#125; if (ignoreCase) &#123; // If characters don't match but case may be ignored, // try converting both characters to uppercase. // If the results match, then the comparison scan should // continue. char u1 = Character.toUpperCase(c1); char u2 = Character.toUpperCase(c2); if (u1 == u2) &#123; continue; &#125; // Unfortunately, conversion to uppercase does not work properly // for the Georgian alphabet, which has strange rules about case // conversion. So we need to make one last check before // exiting. if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123; continue; &#125; &#125; return false; &#125; return true;&#125; 转成大写再转小写这个做法在前面的部分CaseInsensitiveComparator中已经提到了，道理是类似的，我们来看看这个地方： 123456// Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false;&#125; 这个地方的处理比较精妙，-1&gt;&gt;&gt;1等于2147483647，即int类型的上界，它考虑到了toffset和ooffset的值有可能是很靠近甚至等于这个上界的，如果使用toffset + len &gt; (long)value.length来判断的话，有可能出现toffset + len溢出的情况，而源码中的写法就能很好地解决了这个问题。 length直接返回内部字符数组的长度 123public int length() &#123; return value.length;&#125; isEmpty123public boolean isEmpty() &#123; return value.length == 0;&#125; charAt返回String类内部字符数组value在参数索引处的字符，如果该位置的字符是高低代理项，那么它返回的字符也是高低代理项的值 123456public char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return value[index];&#125; codePointAt这个方法和charAt不同的地方在于，它返回的是int型的Unicode代码点，因此他会有两种情况： index位置的字符是BMP的话，则直接返回index位置的字符对应的int值 index位置的字符是在高代理项的范围内，如果index+1&lt;value.length，而且index+1位置的字符在低代理项范围内，那么将会返回(index, index+1)这对字符对应的Unicode增补代码点 123456public int codePointAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointAtImpl(value, index, value.length);&#125; codePointBefore返回参数index位置之前的Unicode代码点，因此它会有如下情况： index-1位置的字符在低代理项范围内，且index-2是非负数，那么返回(index-2, index-1)对应的Unicode代码点 index-1位置的字符是没有配对的高代理项（可能的情况是index-1和index位置的字符是配对的）或者低代理项（这个不是很理解）的话，则直接返回index-1位置字符的int值，不作转换 1234567public int codePointBefore(int index) &#123; int i = index - 1; if ((i &lt; 0) || (i &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointBeforeImpl(value, index, 0);&#125; codePointCount计算[beginIndex, endIndex)范围内的子串的代码点个数，怎么计算的很容易，只需要注意的是，对于该范围内的子串，如果有字符是没有配对的代理项，那么它也当成一个代码点来计数 123456public int codePointCount(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0 || endIndex &gt; value.length || beginIndex &gt; endIndex) &#123; throw new IndexOutOfBoundsException(); &#125; return Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex);&#125; offsetByCodePoints计算从index位置开始，偏移codePointOffset个代码点后的索引位置，注意，这个codePointOffset可以是负数，这种情况下是往左偏移；同理，如果遇到不匹配的代理项，也是当成一个代码点来计数 1234567public int offsetByCodePoints(int index, int codePointOffset) &#123; if (index &lt; 0 || index &gt; value.length) &#123; throw new IndexOutOfBoundsException(); &#125; return Character.offsetByCodePointsImpl(value, 0, value.length, index, codePointOffset);&#125; getChars该方法的主要功能是将字符串读取成字符数组，默认修饰符的getChars是没有任何边界参数检测的，原因很简单，因为它只在类库内部才能使用（concat方法），按照契约式编程原则是不会有意外情况发生的；public修饰的方法，它会对参数进行边界条件检测，用于将指定范围（srcBegin、srcEnd）的子串复制到字符数组参数dst中 12345678910111213141516void getChars(char dst[], int dstBegin) &#123; System.arraycopy(value, 0, dst, dstBegin, value.length);&#125;public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin &gt; srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);&#125; getBytes获取字符串指定编码的字节数组，比如 charsetName 为 utf8，则将字符串转为 utf8 编码后对应的字节数组。如果不传参数则使用 JVM 默认编码，即Charset.defaultCharset() 1234567891011121314public byte[] getBytes(String charsetName) throws UnsupportedEncodingException &#123; if (charsetName == null) throw new NullPointerException(); return StringCoding.encode(charsetName, value, 0, value.length);&#125;public byte[] getBytes(Charset charset) &#123; if (charset == null) throw new NullPointerException(); return StringCoding.encode(charset, value, 0, value.length);&#125;public byte[] getBytes() &#123; return StringCoding.encode(value, 0, value.length);&#125; equals用来判断两个字符串的内容是否相同，但是仔细看可以发现，equals方法的参数其实是Object类型的，其实道理很简单，String类的equals方法是直接继承自Object类的，属于方法重写，参数个数和类型要相同，Object中的equals方法参数就是Object类型，该方法的实现思路如下： 首先判断是不是同一个对象，如果是则返回true 判断参数anObject是否是String类型（防御式编程），如果不是，则直接返回false 最后再逐个字符进行比较，因为这是在String类内部，可以直接访问value 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; contentEqualscontentEquals的功能和equals差不多，都是比较字符串的内容是否相同，区别在于它的参数是StringBuffer或者CharSequence，适用范围更广。 AbstractStringBuilder是StringBuffer和StringBuilder的公共父类，前者是线程安全的，后者是非线程安全的，因此需要分别对他们进行处理，StringBuffer需要加上synchronized同步块；注意到，无论是StringBuffer还是StringBuilder，cs都被强制转换为StringBuilder，最后调用nonSyncContentEquals方法来进行内容比较。 不同类型的字符串内容的比较算法都差不多，基本上都是先比较长度是否相同，这样可以避免不必要的循环遍历比较，如果相同再逐个字符比较 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean contentEquals(StringBuffer sb) &#123; return contentEquals((CharSequence)sb);&#125;private boolean nonSyncContentEquals(AbstractStringBuilder sb) &#123; char v1[] = value; char v2[] = sb.getValue(); int n = v1.length; if (n != sb.length()) &#123; return false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v1[i] != v2[i]) &#123; return false; &#125; &#125; return true;&#125;public boolean contentEquals(CharSequence cs) &#123; // Argument is a StringBuffer, StringBuilder if (cs instanceof AbstractStringBuilder) &#123; if (cs instanceof StringBuffer) &#123; synchronized(cs) &#123; return nonSyncContentEquals((AbstractStringBuilder)cs); &#125; &#125; else &#123; return nonSyncContentEquals((AbstractStringBuilder)cs); &#125; &#125; // Argument is a String if (cs instanceof String) &#123; return equals(cs); &#125; // Argument is a generic CharSequence char v1[] = value; int n = v1.length; if (n != cs.length()) &#123; return false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v1[i] != cs.charAt(i)) &#123; return false; &#125; &#125; return true;&#125; equalsIgnoreCase判断两个字符串在忽略大小写情况下内容是否相同，遇到大小写就应该想到个别字母的大小写转换规则比较特殊，参见CaseInsensitiveComparator部分具体说明，因此对应位置两个字符是否相同条件是以下其中一个： 直接==比较返回true Character.toUpperCase转换成大写字母后==比较相同 Character.toLowerCase转换成小写字母后==比较相同 当然，这部分的判断直接调用了内部的方法regionMatches进行比较了。 这个方法首先判断两个字符串是否是同一个对象，是则返回true，否则再判断参数字符串是否是null（防御式编程），然后再判断两个字符串长度是否相同，最后再比较字符串内容。 123456public boolean equalsIgnoreCase(String anotherString) &#123; return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length);&#125;","categories":[{"name":"源码","slug":"源码","permalink":"http://QQ876684433.github.io/categories/源码/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"}]},{"title":"软件学院大三上教材推荐","slug":"软件学院大三上教材推荐","date":"2019-07-16T03:23:11.000Z","updated":"2019-09-15T05:02:14.670Z","comments":true,"path":"2019/07/16/软件学院大三上教材推荐/","link":"","permalink":"http://QQ876684433.github.io/2019/07/16/软件学院大三上教材推荐/","excerpt":"","text":"软件学院大三上教材推荐 来源：根据某朱姓学长的聊天记录整理 教材推荐建议 课程 教材 备注 计算机与操作系统 操作系统教材，骆斌 原来是第五版，今年可能有第六版 数据库管理基础 数据库原理，编程与性能 数据库换了老师，今年的教材可能不确定 C++高级程序设计 C++程序设计，钱能 有推荐教材，但是老师不会按教材讲 软件系统设计 没有教材 大数据分析 没有教材，可以参考cs246的《大数据互联网大规模数据挖掘与分布式处理》 虽然推荐了cs246，但是老师不会按那个讲 云计算 没有教材 自动化测试 没有教材，可以参考陈振宇的《开发者测试》 除了开发者测试，还要学安卓测试，web测试，ai测试 web前端开发 有教材，但是经常变，去年是《Web开发权威指南》 编译原理 龙书，非常厚，可以买虎书看看，薄一点 龙书叫编译原理，看准翻译老师，是赵建华(计算机系编译原理、算法老师，今年给软院上离散)，郑滔(我们c++老师)，戴新宇(计算机系自然语言处理组老师)翻译的虎书叫现代编译原理 嵌入式系统概论 嵌入式系统软件工程 别买，血亏；很厚，没时间看 商务智能 没有教材 可以买复旦老师的《商务智能》，但是和贝佳的重点不一样，贝佳重点是数据仓库，复旦老师重点是数据挖掘 书籍的pdf资源TODO","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://QQ876684433.github.io/tags/软件工程/"}]},{"title":"Java 技术书籍大全","slug":"Java 技术书籍大全","date":"2019-07-16T01:33:19.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/16/Java 技术书籍大全/","link":"","permalink":"http://QQ876684433.github.io/2019/07/16/Java 技术书籍大全/","excerpt":"","text":"转载原文：https://github.com/sorenduan/awesome-java-books Java 技术书籍大全本文档目前已收录 277本 Java相关领域经典技术书籍，从初级开发者到资深架构师，涵盖 Java 从业者的各个阶段，并持续更新。 涵盖领域：Java入门书籍，Java基础及进阶书籍，框架与中间件，架构设计，设计模式，数学与算法，JVM周边语言，项目管理&amp;领导力&amp;流程，职业素养与个人成长，格局与视野，面试参考书等。 推荐书籍可以点击 -&gt; 点击这里 书籍列表 -&gt; 点击这里 入门书籍 《明解Java》 - 豆瓣评分 8.5 《Java从入门到精通（第4版 附光盘）》 - 豆瓣评分 6 《入门很简单丛书：Java Web开发入门很简单》 《程序员炼成记 从小白到工程师》 《Java从小白到大牛》 《JavaWeb项目开发实战入门（全彩版）》 《Java精彩编程200例（全彩版）》 《Java轻松学》 《大话Java：程序设计从入门到精通（含DVD光盘1张）》 《Java语言袖珍指南（第二版）》 基础书籍 《Java编程思想（第4版） [thinking in java]》 - 豆瓣评分 9.1 《Java核心技术 卷I：基础知识（原书第10版）》 - 豆瓣评分 8.2 《Java核心技术卷II：高级特性（原书第10版）》 - 豆瓣评分 7.7 多线程与并发 《华章专业开发者丛书·Java并发编程实战》 - 豆瓣评分 9.1 《Java多线程编程实战指南（设计模式篇）》 - 豆瓣评分 8.5 《图解Java多线程设计模式》 - 豆瓣评分 8.4 《实战Java高并发程序设计》 - 豆瓣评分 8.3 《Java高并发编程详解：多线程与架构设计》 - 豆瓣评分 7.6 《Java核心技术系列：Java多线程编程核心技术 [Java Multi-thread Programming]》 - 豆瓣评分 5.1 《Java并发编程：核心方法与框架》 《Java多线程与Socket：实战微服务框架》 《NIO与Socket编程技术指南》 《Java并发编程之美》 《实战Java高并发程序设计（第2版）》 网络编程 《Java网络编程（第四版） [Java network programming, forth edition]》 - 豆瓣评分 7.6 数据结构 《数据结构与算法分析：Java语言描述（原书第3版）》 - 豆瓣评分 8.3 《图解数据结构：使用Java》 《数据结构与算法Java语言描述》 语言基础 《Java 8实战》 - 豆瓣评分 9.2 《Java函数式编程》 - 豆瓣评分 8.9 《Java编程的逻辑》 - 豆瓣评分 8.9 《O’Reilly：Head First Java（中文版 第2版 涵盖Java5.0）》 - 豆瓣评分 8.7 《写给大忙人看的Java核心技术》 - 豆瓣评分 7.1 《精通lambda表达式：Java多核编程 [Mastering Lambdas: Java Programming in a Multicore]》 《Java 9模块化开发：核心原则与实践》 《Java JDK 9学习笔记》 《Java 9编程参考官方大全（第10版） [Java：Thte Complete Reference，Tenth Edition]》 《写给大忙人的Java SE 9核心技术》 进阶 《深入分析Java Web技术内幕（修订版）》 - 豆瓣评分 7.5 《Java RESTful Web Service实战（第2版）》 性能优化 《Java性能优化权威指南 [Java performance]》 - 豆瓣评分 8.4 《Java程序性能优化：让你的Java程序更快、更稳定》 - 豆瓣评分 8.1 《Java性能权威指南》 - 豆瓣评分 8.1 《51CTO学院系列丛书·实战Java虚拟机：JVM故障诊断与性能优化》 - 豆瓣评分 8 《Java性能调优指南》 - 豆瓣评分 7 《大话Java性能优化》 - 豆瓣评分 4.4 响应式编程 《响应式架构：消息模式Actor实现与Scala、Akka应用集成》 - 豆瓣评分 8.1 《RxJava响应式编程》 《RxJava 2.x 实战》 JVM虚拟机 《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》 - 豆瓣评分 8.9 《Java核心技术系列：Java虚拟机规范（Java SE 8版） [The Java Virtual Machine Specification Jave SE 8 Edition]》 - 豆瓣评分 8.3 《揭秘Java虚拟机：JVM设计原理与实现》 - 豆瓣评分 7.9 《HotSpot实战》 - 豆瓣评分 7.1 《Java从入门到动手写虚拟机1（套装共2册）》 代码&amp;设计优化 《重构 改善既有代码的设计 Java语言版》 - 豆瓣评分 9.3 《代码大全（第2版）》 - 豆瓣评分 9.3 《Effective Java中文版（原书第3版）》 - 豆瓣评分 9 《代码整洁之道 程序员的职业素养》 - 豆瓣评分 8.8 《代码整洁之道 [Clean Code A Handbook of Agile Software Craftsmanship]》 - 豆瓣评分 8.6 《Spring实战（第4版）》 - 豆瓣评分 8.3 《代码不朽：编写可维护软件的10大要则（Java版）》 - 豆瓣评分 7 《Java代码与架构之完美优化 实战经典》 设计模式 《反应式设计模式》 - 豆瓣评分 9.3 《O’Reilly：Head First设计模式（中文版）》 - 豆瓣评分 9.2 《设计模式：可复用面向对象软件的基础》 - 豆瓣评分 9.1 《实现领域驱动设计 [Implementing Domain-Driven Design]》 - 豆瓣评分 8.7 《原创精品系列：设计模式之禅（第2版）》 - 豆瓣评分 8.7 《图解设计模式》 - 豆瓣评分 8.7 《大话设计模式》 - 豆瓣评分 8.3 《领域驱动设计 软件核心复杂性应对之道 修订版》 - 豆瓣评分 8 《Java测试驱动开发》 - 豆瓣评分 6.6 框架与中间件数据库 《高性能MySQL（第3版）》 - 豆瓣评分 9.3 《MySQL技术内幕：InnoDB存储引擎（第2版）》 - 豆瓣评分 8.6 《大型网站系统与Java中间件实践》 - 豆瓣评分 7.9 《深入浅出MySQL 数据库开发 优化与管理维护 第2版》 - 豆瓣评分 7.5 《PostgreSQL修炼之道：从小工到专家》 - 豆瓣评分 7.3 《PostgreSQL技术内幕：查询优化深度探索》 缓存与NoSQL 《Redis 深度历险：核心原理与应用实践》 - 豆瓣评分 9 《Redis实战》 - 豆瓣评分 8 《Redis入门指南（第2版）》 - 豆瓣评分 7.6 《深入分布式缓存：从原理到实践》 - 豆瓣评分 7.1 《人人都是架构师：分布式系统架构落地与瓶颈突破》 - 豆瓣评分 6.7 《MongoDB应用设计模式》 - 豆瓣评分 6.1 《MongoDB实战 架构、开发与管理》 《NoSQL数据库入门与实践（基于MongoDB、Redis）》 消息队列 《RabbitMQ实战指南》 - 豆瓣评分 9.1 《Kafka权威指南》 - 豆瓣评分 8.9 《Kafka入门与实践》 - 豆瓣评分 7.7 《RocketMQ实战与原理解析》 - 豆瓣评分 7.2 《Kafka技术内幕 图文详解Kafka源码设计与实现》 - 豆瓣评分 6.9 《深入理解Kafka：核心设计与实践原理》 《分布式消息中间件实践》 ORM框架 《MyBatis从入门到精通》 - 豆瓣评分 7.7 Spring家族 《Spring微服务实战》 - 豆瓣评分 8.3 《Spring Cloud微服务实战》 - 豆瓣评分 7.9 《深入理解Spring Cloud与微服务构建》 - 豆瓣评分 7.7 《MyBatis技术内幕》 - 豆瓣评分 7.6 《Spring Boot实战》 - 豆瓣评分 7.2 《深入浅出Spring Boot 2.x》 - 豆瓣评分 7 《JavaEE开发的颠覆者：Spring Boot实战》 - 豆瓣评分 6.3 《Spring技术内幕：深入解析Spring架构与设计原理（第2版）》 - 豆瓣评分 5.9 《Spring Boot 2精髓：从构建小系统到架构分布式大系统》 - 豆瓣评分 4.8 《Spring 5开发大全》 《Spring Cloud微服务架构进阶》 《Spring源码深度解析 第2版》 《Spring MVC实战》 《Spring Boot编程思想（核心篇）（限量版亲笔签名书签 随机发售）》 《互联网轻量级SSM框架解密：Spring、Spring MVC、MyBatis源码深度剖析》 《Spring学习指南 第3版》 《精通Spring MVC 4》 高并发 《Netty实战》 - 豆瓣评分 7.8 《七周七并发模型》 - 豆瓣评分 7.8 《Netty权威指南（第2版）》 - 豆瓣评分 6.9 《Netty进阶之路：跟着案例学Netty》 分布式 《从Paxos到Zookeeper分布式一致性原理与实践》 - 豆瓣评分 7.8 《ZooKeeper：分布式过程协同技术详解》 - 豆瓣评分 7.2 搜索引擎 《从Lucene到Elasticsearch：全文检索实战》 大数据 《Hadoop权威指南：大数据的存储与分析(第4版)》 - 豆瓣评分 8.7 《Hadoop构建数据仓库实践》 - 豆瓣评分 8.3 《HBase权威指南 [HBase： The Definitive Guide]》 - 豆瓣评分 8.1 《图解Spark：核心技术与案例实战》 - 豆瓣评分 7.6 《Hive编程指南 [Programming Hive]》 - 豆瓣评分 7.4 《HBase应用架构》 架构 《Web性能权威指南》 - 豆瓣评分 8.8 《从零开始学架构：照着做，你也能成为架构师》 - 豆瓣评分 8.5 《Java应用架构设计：模块化模式与OSGi》 - 豆瓣评分 6.9 《大型网站技术架构演进与性能优化》 - 豆瓣评分 6.8 《高可用架构（第1卷）》 - 豆瓣评分 6.3 《Java架构师指南》 《大话代码架构（项目实战版）》 《小团队构建大网站：中小研发团队架构实践》 《未来架构 从服务化到云原生(限量签名 随机发放)》 分布式架构 《可伸缩架构：面向增长应用的高可用》 - 豆瓣评分 7.4 《分布式服务架构：原理、设计与实战》 - 豆瓣评分 7.2 《亿级流量网站架构核心技术 跟开涛学搭建高可用高并发系统》 - 豆瓣评分 6.6 《大型分布式网站架构设计与实践》 - 豆瓣评分 6.2 《可伸缩服务架构：框架与中间件》 - 豆瓣评分 5.9 《架构探险：从零开始写分布式服务框架》 - 豆瓣评分 5.9 《Cloud Native分布式架构原理与实践》 《分布式系统常用技术及案例分析（第2版）》 《云原生Java：Spring Boot、Spring Cloud与Cloud Foundry弹性系统设计》 微服务架构 《微服务设计》 - 豆瓣评分 8.2 《生产微服务》 - 豆瓣评分 8 《架构解密：从分布式到微服务》 - 豆瓣评分 5.8 《Java微服务》 - 豆瓣评分 5.3 《Spring Cloud 微服务架构开发实战（全新升级版）》 《微服务实践》 架构方法论 《架构整洁之道》 - 豆瓣评分 8.8 《企业应用架构模式 [Patterns of Enterprise Application Architecture]》 - 豆瓣评分 8.3 《企业IT架构转型之道 阿里巴巴中台战略思想与架构实战》 - 豆瓣评分 8.2 《聊聊“架构”》 - 豆瓣评分 7.6 《架构真经：互联网技术架构的设计原则（原书第2版）》 - 豆瓣评分 7.5 《软件架构设计：程序员向架构师转型必备（第2版）》 - 豆瓣评分 7.4 《恰如其分的软件架构 [Just Enough Software Architecture]》 - 豆瓣评分 7.3 《软件架构设计：大型网站技术架构与业务架构融合之道》 JVM周边语言 《Scala编程（第3版）》 - 豆瓣评分 9.4 《Groovy程序设计》 - 豆瓣评分 8.2 《快学Scala（第2版）》 - 豆瓣评分 8 《Kotlin极简教程》 《Scala集合技术手册》 项目管理&amp;领导力&amp;流程 《构建之法 现代软件工程（第三版）》 - 豆瓣评分 9 《精益思想（白金版）》 - 豆瓣评分 8.2 《给产品经理讲技术》 项目管理 《持续交付：发布可靠软件的系统方法》 - 豆瓣评分 8.7 《名家经典系列：人件（原书第3版） [Peopleware: Productive Projects and Teams]》 - 豆瓣评分 8.4 《硝烟中的Scrum和XP：我们如何实施Scrum》 - 豆瓣评分 8.4 《敏捷软件开发实践 估算与计划》 - 豆瓣评分 8.4 《人月神话（40周年中文纪念版） [The Mythical Man-Month：Essays on Software Engineering Anniversary Edition]》 - 豆瓣评分 8.3 《Scrum敏捷软件开发》 - 豆瓣评分 8 《用户故事与敏捷方法 [User Stories Applied:For Agile Software Development]》 - 豆瓣评分 8 《用户故事地图 [User Story Mapping]》 - 豆瓣评分 7.4 《知行合一 实现价值驱动的敏捷和精益开发》 《互联网项目管理实践精粹》 团队管理 《卓有成效的管理者（珍藏版） [The Effective Executive]》 - 豆瓣评分 8.8 《跃迁：从技术到管理的硅谷路径》 - 豆瓣评分 8.4 《告别失控 软件开发团队管理必读》 - 豆瓣评分 7.9 《赋能：打造应对不确定性的敏捷团队 [Team of Teams]》 - 豆瓣评分 7.6 《OKR工作法：谷歌、领英等顶级公司的高绩效秘籍 [Radical Focus]》 - 豆瓣评分 7.6 《CTO说》 - 豆瓣评分 7.3 《轻流程 IT团队的积分式绩效管理》 - 豆瓣评分 7 《技术领导力：程序员如何才能带团队》 - 豆瓣评分 5.4 《敏捷文化：如何打造优秀的高效能团队 [The Agile Culture: Leading through Trust and Owner]》 数学与算法数学 《数学之美（第二版）》 - 豆瓣评分 8.9 《程序员的数学2 概率统计》 - 豆瓣评分 8.7 《程序员的数学3 线性代数》 - 豆瓣评分 8.6 《程序员的数学》 - 豆瓣评分 7.2 《程序员的数学思维修炼（趣味解读）》 - 豆瓣评分 5.4 《统计之美：人工智能时代的科学思维》 《统计思维：程序员数学之概率统计（第2版）》 算法 《算法导论（原书第3版）/计算机科学丛书 [Introduction to Algorithms, third edition]》 - 豆瓣评分 9.3 《算法图解》 - 豆瓣评分 8.4 《漫画算法：小灰的算法之旅（全彩）》 职业素养与个人成长 《我编程，我快乐：程序员职业规划之道》 - 豆瓣评分 7.9 《程序员的自我修养》 - 豆瓣评分 6.5 职业素养提升 《码农翻身：用故事给技术加点料》 - 豆瓣评分 9.1 《程序员修炼之道：从小工到专家》 - 豆瓣评分 8.8 《极客与团队：软件工程师的团队生存秘笈》 - 豆瓣评分 8.3 《程序员思维修炼(修订版)》 - 豆瓣评分 8.2 《高效能程序员的修炼》 - 豆瓣评分 8.2 《O’Reilly：卓有成效的程序员 [Productive programmer]》 - 豆瓣评分 8.1 《Java工程师修炼之道》 - 豆瓣评分 7.8 《程序员的成长课》 - 豆瓣评分 7.6 《高效程序员的45个习惯：敏捷开发修炼之道(修订版)》 - 豆瓣评分 7.6 《温伯格技术思想三部曲：颠覆完美软件 软件测试必须知道的几件事》 - 豆瓣评分 7.5 《温伯格技术思想三部曲：程序开发心理学（银年纪念版）》 - 豆瓣评分 7.4 《软件开发本质论：追求简约、体现价值、逐步构建》 - 豆瓣评分 7.3 《内外兼修：程序员的成长之路》 - 豆瓣评分 6.6 个人软技能 《把时间当作朋友（第3版 全彩）》 - 豆瓣评分 8.5 《暗时间》 - 豆瓣评分 8.4 《关键对话：如何高效能沟通（原书第2版） [Crucial Conversations: Tools for Talking When Stak]》 - 豆瓣评分 8.1 《温伯格技术思想三部曲：成为技术领导者 掌握全面解决问题的方法》 - 豆瓣评分 8 《软技能 代码之外的生存指南》 - 豆瓣评分 8 《程序员健康指南》 - 豆瓣评分 7.5 《如何把事情做到最好：改变全球9800万人的人生指导书 [Mastery]》 - 豆瓣评分 7.2 《程序员的英语》 - 豆瓣评分 5.9 《高效能人士的七个习惯（30周年纪念版）》 大厂出品阿里巴巴技术丛书 《码出高效：Java开发手册》 - 豆瓣评分 8.8 《大数据之路 阿里巴巴大数据实践》 - 豆瓣评分 7.8 《技术之瞳 阿里巴巴技术笔试心得》 - 豆瓣评分 7.7 《淘宝技术这十年》 - 豆瓣评分 7.3 《尽在双11 阿里巴巴技术演进与超越》 - 豆瓣评分 7.1 《逆流而上：阿里巴巴技术成长之路》 - 豆瓣评分 6.9 京东技术丛书 《京东基础架构建设之路（全彩）》 - 豆瓣评分 6.2 《京东系统质量保障技术实战》 - 豆瓣评分 6.1 《京东技术解密》 - 豆瓣评分 6.1 工具书 《Linux命令行与shell脚本编程大全（第3版）》 - 豆瓣评分 9.1 《阿里巴巴Java开发手册》 - 豆瓣评分 8.3 《SQL即查即用 （全彩版）》 《Linux命令速查手册（第三版）》 面试求职 《剑指Offer：名企面试官精讲典型编程题（第2版）》 - 豆瓣评分 9.1 《编程之美：微软技术面试心得》 - 豆瓣评分 8.4 《Java程序员面试笔试宝典》 - 豆瓣评分 7.6 《Java程序员面试宝典（第4版）》 - 豆瓣评分 5 《编程之法：面试和算法心得》 《Java程序员面试算法宝典》 《Java程序员面试笔试真题库》 《Java程序员面试笔试真题与解析》 《Java核心技术及面试指南》 《解忧程序员：高薪编程、求职面试与成长转型宝典》 格局与视野 《全球科技通史》 - 豆瓣评分 9.4 《浪潮之巅 第三版 套装上下册》 - 豆瓣评分 9.3 《黑客与画家：硅谷创业之父Paul Graham文集 [Hackers and Painters Big Ldeas From the Computer Age]》 - 豆瓣评分 8.8 《软件随想录 卷1》 - 豆瓣评分 8.8 《软件随想录 卷2》 - 豆瓣评分 8.7 《编程人生：15位软件先驱访谈录》 - 豆瓣评分 8.5 《大教堂与集市（最新版） [The Cathedral &amp; the Bazaar]》 - 豆瓣评分 8.4 《硅谷之谜：浪潮之巅 续集》 - 豆瓣评分 8.4 《原则 [Principles]》 - 豆瓣评分 8.4 《精益创业》 - 豆瓣评分 8.4 《态度：吴军博士新书》 - 豆瓣评分 8.1 《见识》 - 豆瓣评分 8.1 《极限创新 35岁之前改变世界的全球科技精英》 - 豆瓣评分 7.3 《大学的终结：泛在大学与高等教育革命》 - 豆瓣评分 7.2 《未来版图 全球聪明公司的科技创新趋势和商业化路径》 - 豆瓣评分 7.1 《你好哇，程序员——漫话程序员面试求职、升职加薪、创业与生活》 - 豆瓣评分 6.5 《图灵和ACM图灵奖（1966-2015 第五版） 纪念计算机诞生70周年》 《文明之光（全彩印刷套装1-4册）入选2014中国好书/第六届中华优秀出版物获奖图书》 《大师访谈录：成就非凡的软件人生》 Java之外 《计算机科学丛书：计算机程序的构造和解释（原书第2版）》 - 豆瓣评分 9.5 《计算机科学丛书：编译原理（第2版） [Compilers:Principle,Techniques and Tools]》 - 豆瓣评分 9.1 《一个APP的诞生——从零开始设计你的手机应用》 - 豆瓣评分 6.3 《大型网站性能优化实战：从前端、网络、CDN到后端、大促的全链路性能优化详解》 网络知识 《图解HTTP》 - 豆瓣评分 8.1 《图解TCP/IP 第5版》 - 豆瓣评分 7.8 安全知识 《白帽子讲Web安全（纪念版）》 - 豆瓣评分 7.4 《Web安全攻防：渗透测试实战指南》 工具 《Maven实战》 - 豆瓣评分 8.2 《大象：Thinking in UML（第2版）》 - 豆瓣评分 8.2 《Git学习指南》 - 豆瓣评分 6.7 《UML基础、案例与应用（第3版 修订版）》 运维&amp;DevOps 《编码：隐匿在计算机软硬件背后的语言 [Code:The Hidden Language of Computer Hardware and Software]》 - 豆瓣评分 9.3 《DevOps实践指南》 - 豆瓣评分 9 《性能之巅：洞悉系统、企业与云计算》 - 豆瓣评分 8.7 《鸟哥的Linux私房菜 基础学习篇 第四版》 - 豆瓣评分 8.2 《DevOps开发运维训练营》","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"转载","slug":"转载","permalink":"http://QQ876684433.github.io/tags/转载/"}]},{"title":"后端架构师技术图谱","slug":"后端架构师技术图谱","date":"2019-07-16T01:33:06.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/16/后端架构师技术图谱/","link":"","permalink":"http://QQ876684433.github.io/2019/07/16/后端架构师技术图谱/","excerpt":"","text":"转载原文：https://github.com/xingshaocheng/architect-awesome 推荐: 《Java技术书籍大全》 - awesome-java-books 从初级开发者到资深架构师，看这些书就够了 数据结构队列 《java队列——queue详细分析》 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。 《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》 集合 《Java Set集合的详解》 链表、数组 《Java集合详解–什么是List》 字典、关联数组 《Java map 详解 - 用法、遍历、排序、常用API等》 栈 《java数据结构与算法之栈（Stack）设计与实现》 《Java Stack 类》 《java stack的详细实现分析》 Stack 是线程安全的。 内部使用数组保存数据，不够时翻倍。 树二叉树每个节点最多有两个叶子节点。 《二叉树》 完全二叉树 《完全二叉树》 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。 平衡二叉树左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 《浅谈数据结构-平衡二叉树》 《浅谈算法和数据结构: 八 平衡查找树之2-3树》 二叉查找树（BST）二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。 《浅谈算法和数据结构: 七 二叉查找树》 红黑树 《最容易懂得红黑树》 添加阶段后，左旋或者右旋从而再次达到平衡。 《浅谈算法和数据结构: 九 平衡查找树之红黑树》 B，B+，B*树MySQL是基于B+树聚集索引组织表 《B-树，B+树，B*树详解》 《B-树，B+树与B*树的优缺点比较》 B+树的叶子节点链表结构相比于 B-树便于扫库，和范围检索。 LSM 树LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的平衡。Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。 《LSM树 VS B+树》 B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能较差。 LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。 《LSM树（Log-Structured Merge Tree）存储引擎》 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。 Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。 BitSet经常用于大规模数据的排重检查。 《Java Bitset类》 《Java BitSet（位集）》 常用算法 《常见排序算法及对应的时间复杂度和空间复杂度》 排序、查找算法 《常见排序算法及对应的时间复杂度和空间复杂度》 选择排序 《Java中的经典算法之选择排序（SelectionSort）》 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。 冒泡排序 《冒泡排序的2种写法》 相邻元素前后交换、把最大的排到最后。 时间复杂度 O(n²) 插入排序 《排序算法总结之插入排序》 快速排序 《坐在马桶上看算法：快速排序》 一侧比另外一侧都大或小。 归并排序 《图解排序算法(四)之归并排序》 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 希尔排序TODO 堆排序 《图解排序算法(三)之堆排序》 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。 计数排序 《计数排序和桶排序》 和桶排序过程比较像，差别在于桶的数量。 桶排序 《【啊哈！算法】最快最简单的排序——桶排序》 《排序算法（三）：计数排序与桶排序》 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。 每个桶单独进行排序，然后再遍历每个桶。 基数排序按照个位、十位、百位、…依次来排。 《排序算法系列：基数排序》 《基数排序》 二分查找 《二分查找(java实现)》 要求待查找的序列有序。 时间复杂度 O(logN)。 《java实现二分查找-两种方式》 while + 递归。 Java 中的排序工具 《Arrays.sort和Collections.sort实现原理解析》 Collections.sort算法调用的是合并排序。 Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。 布隆过滤器常用于大数据的排重，比如email，url 等。核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。优点：空间和时间效率都很高。缺点：随着存入的元素数量增加，误算率随之增加。 《布隆过滤器 – 空间效率很高的数据结构》 《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》 《基于Redis的布隆过滤器的实现》 基于 Redis 的 Bitmap 数据结构。 《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》 使用Java中的 BitSet 类 和 加权和hash算法。 字符串比较KMP 算法KMP：Knuth-Morris-Pratt算法（简称KMP）核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。 《字符串匹配的KMP算法》 深度优先、广度优先 《广度优先搜索BFS和深度优先搜索DFS》 贪心算法 《算法：贪婪算法基础》 《常见算法及问题场景——贪心算法》 回溯算法 《 五大常用算法之四：回溯法》 剪枝算法 《α-β剪枝算法》 动态规划 《详解动态规划——邹博讲动态规划》 《动态规划算法的个人理解》 朴素贝叶斯 《带你搞懂朴素贝叶斯分类算法》 P(B|A)=P(A|B)P(B)/P(A) 《贝叶斯推断及其互联网应用1》 《贝叶斯推断及其互联网应用2》 推荐算法 《推荐算法综述》 《TOP 10 开源的推荐系统简介》 最小生成树算法 《算法导论–最小生成树（Kruskal和Prim算法）》 最短路径算法 《Dijkstra算法详解》 并发Java 并发 Java 并发知识合集 JAVA并发知识图谱 多线程 《40个Java多线程问题总结》 线程安全 《Java并发编程——线程安全及解决机制简介》 一致性、事务事务 ACID 特性 《数据库事务ACID特性》 事务的隔离级别 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。 序列化：所有事物串行处理（牺牲了效率） 《理解事务的4种隔离级别》 数据库事务的四大特性及事务隔离级别 《MySQL的InnoDB的幻读问题 》 幻读的例子非常清楚。 通过 SELECT … FOR UPDATE 解决。 《一篇文章带你读懂MySQL和InnoDB》 图解脏读、不可重复读、幻读问题。 MVCC 《【mysql】关于innodb中MVCC的一些理解》 innodb 中 MVCC 用在 Repeatable-Read 隔离级别。 MVCC 会产生幻读问题（更新时异常。） 《轻松理解MYSQL MVCC 实现机制》 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间 每次只操作比当前版本小（或等于）的 行。 锁Java中的锁和同步类 《Java中的锁分类》 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 《Java并发之AQS详解》 《Java中信号量 Semaphore》 有数量控制 申请用 acquire，申请不要则阻塞；释放用 release。 《java开发中的Mutex vs Semaphore》 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。 公平锁 &amp; 非公平锁公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。 《公平锁与非公平锁》 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。 悲观锁悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。 《【MySQL】悲观锁&amp;乐观锁》 乐观锁的方式：版本号+重试方式 悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。 《Mysql查询语句使用select.. for update导致的数据库死锁分析》 mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。 锁相同数据的不同索引条件可能会引起死锁。 《Mysql并发时经典常见的死锁原因及解决方法》 乐观锁 &amp; CAS 《乐观锁的一种实现方式——CAS》 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。 ABA 问题由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。 《Java CAS 和ABA问题》 《Java 中 ABA问题及避免》 AtomicStampedReference 和 AtomicStampedReference。 CopyOnWrite容器可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。 《JAVA中写时复制(Copy-On-Write)Map实现》 实现读写分离，读取发生在原始数据上，写入发生在副本上。 不用加锁，通过最终一致实现一致性。 《聊聊并发-Java中的Copy-On-Write容器》 RingBuffer 《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》 可重入锁 &amp; 不可重入锁 《可重入锁和不可重入锁》 通过简单代码举例说明可重入锁和不可重入锁。 可重入锁指同一个线程可以再次获得之前已经获得的锁。 可重入锁可以用户避免死锁。 Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock 《ReenTrantLock可重入锁（和synchronized的区别）总结》 synchronized 使用方便，编译器来加锁，是非公平锁。 ReenTrantLock 使用灵活，锁的公平性可以定制。 相同加锁场景下，推荐使用 synchronized。 互斥锁 &amp; 共享锁互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。 《ReadWriteLock场景应用》 死锁 《“死锁”四个必要条件的合理解释》 互斥、持有、不可剥夺、环形等待。 Java如何查看死锁？ JConsole 可以识别死锁。 java多线程系列：死锁及检测 jstack 可以显示死锁。 操作系统计算机原理 《操作系统基础知识——操作系统的原理，类型和结构》 CPU多级缓存典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。 《从Java视角理解CPU缓存和伪共享》 进程TODO 线程 《线程的生命周期及状态转换详解》 协程 《终结python协程—-从yield到actor模型的实现》 线程的调度是由操作系统负责，协程调度是程序自行负责 与线程相比，协程减少了无谓的操作系统切换. 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换. Linux 《Linux 命令大全》 设计模式设计模式的六大原则 《设计模式的六大原则》 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。 合成复用原则：尽量使用合成/聚合,而不是使用继承。 23种常见设计模式 《设计模式》 《23种设计模式全解析》 《设计模式类图与示例》 应用场景 《细数JDK里的设计模式》 结构型模式： 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC； 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy 创建模式: 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。 工厂方法：就是 一个返* 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。 行为模式： 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。 空对象模式：如 java.util.Collections#emptyList()。 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。 《Spring-涉及到的设计模式汇总》 《Mybatis使用的设计模式》 单例模式 《单例模式的三种实现 以及各自的优缺点》 《单例模式－－反射－－防止序列化破坏单例模式》 使用枚举类型。 责任链模式TODO MVC 《MVC 模式》 模型(model)－视图(view)－控制器(controller) IOC 《理解 IOC》 《IOC 的理解与解释》 正向控制：传统通过new的方式。反向控制，通过容器注入对象。 作用：用于模块解耦。 DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。 AOP 《轻松理解AOP(面向切面编程)》 《Spring AOP详解》 《Spring AOP的实现原理》 Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。 《Spring AOP 实现原理与 CGLIB 应用》 Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 UML 《UML教程》 微服务思想 《微服务架构设计》 《微服务架构技术栈选型手册》 康威定律 《微服务架构的理论基础 - 康威定律》 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。 《微服务架构核⼼20讲》 运维 &amp; 统计 &amp; 技术支持常规监控 《腾讯业务系统监控的修炼之路》 监控的方式：主动、被动、旁路(比如舆情监控) 监控类型： 基础监控、服务端监控、客户端监控、监控、用户端监控 监控的目标：全、块、准 核心指标：请求量、成功率、耗时 《开源还是商用？十大云运维监控工具横评》 Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。 《监控报警系统搭建及二次开发经验》 命令行监控工具 《常用命令行监控工具》 top、sar、tsar、nload 《20个命令行工具监控 Linux 系统性能》 《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》 APMAPM — Application Performance Management 《Dapper，大规模分布式系统的跟踪系统》 CNCF OpenTracing，中文版 主要开源软件，按字母排序 Apache SkyWalking CAT CNCF jaeger Pinpoint Zipkin 《开源APM技术选型与实战》 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。 统计分析 《流量统计的基础：埋点》 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度 《APP埋点常用的统计工具、埋点目标和埋点内容》 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。 《美团点评前端无痕埋点实践》 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 持续集成(CI/CD) 《持续集成是什么？》 《8个流行的持续集成工具》 Jenkins 《使用Jenkins进行持续集成》 环境分离开发、测试、生成环境分离。 《开发环境、生产环境、测试环境的基本理解和区》 自动化运维Ansible 《Ansible中文权威指南》 《Ansible基础配置和企业级项目实用案例》 puppet 《自动化运维工具——puppet详解》 chef 《Chef 的安装与使用》 测试TDD 理论 《深度解读 - TDD（测试驱动开发）》 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践. 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； 单元测试 《Java单元测试之JUnit篇》 《JUnit 4 与 TestNG 对比》 TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 《单元测试主要的测试功能点》 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 压力测试 《Apache ab 测试使用指南》 《大型网站压力测试及优化方案》 《10大主流压力/负载/性能测试工具推荐》 《真实流量压测工具 tcpcopy应用浅析》 《nGrinder 简易使用教程》 全链路压测 《京东618：升级全链路压测方案，打造军演机器人ForceBot》 《饿了么全链路压测的探索与实践》 《四大语言，八大框架｜滴滴全链路压测解决之道》 《全链路压测经验》 A/B 、灰度、蓝绿测试 《技术干货 | AB 测试和灰度发布探索及实践》 《nginx 根据IP 进行灰度发布》 《蓝绿部署、A/B 测试以及灰度发布》 虚拟化 《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》 KVM 《KVM详解，太详细太深入了，经典》 《【图文】KVM 虚拟机安装详解》 Xen 《Xen虚拟化基本原理详解》 OpenVZ 《开源Linux容器 OpenVZ 快速上手指南》 容器技术Docker 《几张图帮你理解 docker 基本原理及快速入门》 《Docker 核心技术与实现原理》 《Docker 教程》 云技术OpenStack 《OpenStack构架知识梳理》 DevOps 《一分钟告诉你究竟DevOps是什么鬼？》 《DevOps详解》 文档管理 Confluence-收费文档管理系统 GitLab? Wiki 中间件Web ServerNginx 《Ngnix的基本学习-多进程和Apache的比较》 Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。 《nginx与Apache的对比以及优缺点》 nginx只适合静态和反向代理，不适合处理动态请求。 OpenResty 官方网站 《浅谈 OpenResty》 通过 Lua 模块可以在Nginx上进行开发。 agentzh 的 Nginx 教程 Tengine 官方网站 Apache Httpd 官方网站 Tomcat架构原理 《TOMCAT原理详解及请求过程》 《Tomcat服务器原理详解》 《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》 《四张图带你了解Tomcat系统架构》 《JBoss vs. Tomcat: Choosing A Java Application Server》 Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。 Jboss 实现全部了JEE特性，软件开源免费、文档收费。 调优方案 《Tomcat 调优方案》 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； 《tomcat http协议与ajp协议》 《AJP与HTTP比较和分析》 AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。 并发高时，AJP协议优于HTTP协议。 Jetty 《Jetty 的工作原理以及与 Tomcat 的比较》 《jetty和tomcat优势比较》 架构比较:Jetty的架构比Tomcat的更为简单。 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 缓存 《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》 本地缓存 《HashMap本地缓存》 《EhCache本地缓存》 堆内、堆外、磁盘三级缓存。 可按照缓存空间容量进行设置。 按照时间、次数等过期策略。 《Guava Cache》 简单轻量、无堆外、磁盘缓存。 《Nginx本地缓存》 《Pagespeed—懒人工具，服务器端加速》 客户端缓存 《浏览器端缓存》 主要是利用 Cache-Control 参数。 《H5 和移动端 WebView 缓存机制解析与实战》 服务端缓存Web缓存 nuster - nuster cache varnish - varnish cache squid - squid cache Memcached 《Memcached 教程》 《深入理解Memcached原理》 采用多路复用技术提高并发性。 slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。 《Memcached软件工作原理》 《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》 《memcache 中 add 、 set 、replace 的区别》 区别在于当key存在还是不存在时，返回值是true和false的。 《memcached全面剖析》 Redis 《Redis 教程》 《redis底层原理》 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。 《Redis持久化方式》 RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。 AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。 也可以两者结合使用。 《分布式缓存–序列3–原子操作与CAS乐观锁》 架构 《Redis单线程架构》 回收策略 《redis的回收策略》 Tair 官方网站 《Tair和Redis的对比》 特点：可以配置备份节点数目，通过异步同步到备份节点 一致性Hash算法。 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。 几种存储引擎: MDB，完全内存性，可以用来存储Session等数据。 Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作 LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。 Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。 消息队列 《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》 RabbitMQ 消费者默认是推模式（也支持拉模式）。 Kafka 默认是拉模式。 Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。 Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。 《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》 消息总线消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。 《消息总线VS消息队列》 消息的顺序 《如何保证消费者接收消息的顺序》 RabbitMQ支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。 《RabbitMQ的应用场景以及基本原理介绍》 《消息队列之 RabbitMQ》 《RabbitMQ之消息确认机制（事务+Confirm）》 RocketMQJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。 《RocketMQ 实战之快速入门》 《RocketMQ 源码解析》 ActiveMQ纯Java实现，兼容JMS，可以内嵌于Java应用中。 《ActiveMQ消息队列介绍》 Kafka高吞吐量、采用拉模式。适合高IO场景，比如日志同步。 官方网站 《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》 《Kafka分区机制介绍与示例》 Redis 消息推送生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。 《Redis学习笔记之十：Redis用作消息队列》 ZeroMQ TODO 定时调度单机定时调度 《linux定时任务cron配置》 《Linux cron运行原理》 fork 进程 + sleep 轮询 《Quartz使用总结》 《Quartz源码解析 —- 触发器按时启动原理》 《quartz原理揭秘和源码解读》 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。 分布式定时调度 《这些优秀的国产分布式任务调度系统，你用过几个？》 opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares 《Quartz任务调度的基本实现原理》 Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 《Elastic-Job-Lite 源码解析》 《Elastic-Job-Cloud 源码解析》 RPC 《从零开始实现RPC框架 - RPC原理及实现》 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。 《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》 Dubbo 官方网站 dubbo实现原理简单介绍 ** SPI **TODO Thrift 官方网站 《Thrift RPC详解》 支持多语言，通过中间语言定义接口。 gRPC服务端可以认证加密，在外网环境下，可以保证数据安全。 官方网站 《你应该知道的RPC原理》 数据库中间件Sharding Jdbc 官网 源码解析 日志系统日志搜集 《从零开始搭建一个ELKB日志收集系统》 《用ELK搭建简单的日志收集分析系统》 《日志收集系统-探究》 配置中心 Apollo - 携程开源的配置中心应用 Spring Boot 和 Spring Cloud 支持推、拉模式更新配置 支持多种语言 《基于zookeeper实现统一配置管理》 《 Spring Cloud Config 分布式配置中心使用教程》 servlet 3.0 异步特性可用于配置中心的客户端 《servlet3.0 新特性——异步处理》 API 网关主要职责：请求转发、安全认证、协议转换、容灾。 《API网关那些儿》 《谈API网关的背景、架构以及落地方案》 《使用Zuul构建API Gateway》 《Spring Cloud Gateway 源码解析》 《HTTP API网关选择之一Kong介绍》 网络协议OSI 七层协议 《OSI七层协议模型、TCP/IP四层模型学习笔记》 TCP/IP 《深入浅出 TCP/IP 协议》 《TCP协议中的三次握手和四次挥手》 HTTP 《http协议详解(超详细)》 HTTP2.0 《HTTP 2.0 原理详细分析》 《HTTP2.0的基本单位为二进制帧》 利用二进制帧负责传输。 多路复用。 HTTPS 《https原理通俗了解》 使用非对称加密协商加密算法 使用对称加密方式传输数据 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。 《八大免费SSL证书-给你的网站免费添加Https安全加密》 网络模型 《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。 《select、poll、epoll之间的区别总结》 select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。 select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。 select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。 poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。 《select，poll，epoll比较 》 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。 《深入理解Java NIO》 NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务 《BIO与NIO、AIO的区别》 《两种高效的服务器设计模型：Reactor和Proactor模型》 Epoll 《epoll使用详解（精髓）》 Java NIO 《深入理解Java NIO》 《Java NIO编写Socket服务器的一个例子》 kqueue 《kqueue用法简介》 连接和短连接 《TCP/IP系列——长连接与短连接的区别》 框架 《Netty原理剖析》 Reactor 模式介绍。 Netty 是 Reactor 模式的一种实现。 零拷贝（Zero-copy） 《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。 序列化(二进制协议)Hessian 《Hessian原理分析》Binary-RPC;不仅仅是序列化 Protobuf 《Protobuf协议的Java应用例子》Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写 .proto 文件。 《Protocol Buffers序列化协议及应用》 关于协议的解释；缺点：可读性差; 《简单的使用 protobuf 和 protostuff》 protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。 数据库基础理论关系数据库设计的三大范式 《数据库的三大范式以及五大约束》 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性； 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情； 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）； MySQL原理 《MySQL的InnoDB索引原理详解》 《MySQL存储引擎－－MyISAM与InnoDB区别》 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁 《myisam和innodb索引实现的不同》 InnoDB 《一篇文章带你读懂Mysql和InnoDB》 优化 《MySQL36条军规》 《MYSQL性能优化的最佳20+条经验》 《SQL优化之道》 《mysql数据库死锁的产生原因及解决办法》 《导致索引失效的可能情况》 《 MYSQL分页limit速度太慢优化方法》 原则上就是缩小扫描范围。 索引聚集索引, 非聚集索引 《MySQL 聚集索引/非聚集索引简述》 《MyISAM和InnoDB的索引实现》 MyISAM 是非聚集，InnoDB 是聚集 复合索引 《复合索引的优点和注意事项》 文中有一处错误： 对于复合索引,在查询使用时,最好将条件顺序按找索引的顺序,这样效率最高; select * from table1 where col1=A AND col2=B AND col3=D 如果使用 where col2=B AND col1=A 或者 where col2=B 将不会使用索引 原文中提到索引是按照“col1，col2，col3”的顺序创建的，而mysql在按照最左前缀的索引匹配原则，且会自动优化 where 条件的顺序，当条件中只有 col2=B AND col1=A 时，会自动转化为 col1=A AND col2=B，所以依然会使用索引。 《MySQL查询where条件的顺序对查询效率的影响》 自适应哈希索引(AHI) 《InnoDB存储引擎——自适应哈希索引》 explain 《MySQL 性能优化神器 Explain 使用分析》 NoSQLMongoDB MongoDB 教程 《Mongodb相对于关系型数据库的优缺点》 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越； 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方； Hbase 《简明 HBase 入门教程（开篇）》 《深入学习HBase架构原理》 《传统的行存储和（HBase）列存储的区别》 《Hbase与传统数据库的区别》 空数据不存储，节省空间，且适用于并发。 《HBase Rowkey设计》 rowkey 按照字典顺序排列，便于批量扫描。 通过散列可以避免热点。 搜索引擎搜索引擎原理 《倒排索引–搜索引擎入门》 Lucene 《Lucene入门简介》 Elasticsearch 《Elasticsearch学习，请先看这一篇！》 《Elasticsearch索引原理》 Solr 《 Apache Solr入门教程》 《elasticsearch与solr比较》 sphinx 《Sphinx 的介绍和原理探索》 性能性能优化方法论 《15天的性能优化工作，5方面的调优经验》 代码层面、业务层面、数据库层面、服务器层面、前端优化。 《系统性能优化的几个方面》 容量评估 《联网性能与容量评估的方法论和典型案例》 《互联网架构，如何进行容量设计？》 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS CDN 网络 《CDN加速原理》 《国内有哪些比较好的 CDN？》 连接池 《主流Java数据库连接池比较与开发配置实战》 性能调优 《九大Java性能调试工具，必备至少一款》 大数据流式计算Storm 官方网站 《最详细的Storm入门教程》 Flink 《Flink之一 Flink基本原理介绍》 Kafka Stream 《Kafka Stream调研：一种轻量级流计算模式》 应用场景例如： 广告相关实时统计； 推荐系统用户画像标签实时更新； 线上服务健康状况实时监测； 实时榜单； 实时数据统计。 Hadoop 《用通俗易懂的话说下hadoop是什么,能做什么》 《史上最详细的Hadoop环境搭建》 HDFS 《【Hadoop学习】HDFS基本原理》 MapReduce 《用通俗易懂的大白话讲解Map/Reduce原理》 《 简单的map-reduce的java例子》 Yarn 《初步掌握Yarn的架构及原理》 Spark 《Spark(一): 基本架构及原理》 《子雨大数据之Spark入门教程(Python版)》 安全web 安全XSS 《xss攻击原理与解决方法》 CSRF 《CSRF原理及防范》 SQL 注入 《SQL注入》 Hash Dos 《邪恶的JAVA HASH DOS攻击》 利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。 《一种高级的DoS攻击-Hash碰撞攻击》 《关于Hash Collision DoS漏洞：解析与解决方案》 脚本注入 《上传文件漏洞原理及防范》 漏洞扫描工具 《DVWA》 W3af OpenVAS详解 验证码 《验证码原理分析及实现》 《详解滑动验证码的实现原理》 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。 《淘宝滑动验证码研究》 DDoS 防范 《学习手册：DDoS的攻击方式及防御手段》 《免费DDoS攻击测试工具大合集》 用户隐私信息保护 用户密码非明文保存，加动态salt。 身份证号，手机号如果要显示，用 “*” 替代部分字符。 联系方式在的显示与否由用户自己控制。 TODO 《个人隐私包括哪些》 《在互联网上，隐私的范围包括哪些？》 《用户密码保存》 序列化漏洞 《Lib之过？Java反序列化漏洞通用利用分析》 加密解密对称加密 《常见对称加密算法》 DES、3DES、Blowfish、AES DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。 DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。 哈希算法 《常用的哈希算法》 MD5 和 SHA-1 已经不再安全，已被弃用。 目前 SHA-256 是比较安全的。 《基于Hash摘要签名的公网URL签名验证设计方案》 非对称加密 《常见非对称加密算法》 RSA、DSA、ECDSA(螺旋曲线加密算法) 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。 《区块链的加密技术》 服务器安全 《Linux强化论：15步打造一个安全的Linux服务器》 数据安全数据备份TODO 网络隔离内外网分离TODO 登录跳板机在内外环境中通过跳板机登录到线上主机。 《搭建简易堡垒机》 授权、认证RBAC 《基于组织角色的权限设计》 《权限系统与RBAC模型概述》 《Spring整合Shiro做权限控制模块详细案例分析》 OAuth2.0 《理解OAuth 2.0》 《一张图搞定OAuth2.0》 双因素认证（2FA）2FA - Two-factor authentication，用于加强登录验证 常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key） 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html) 单点登录(SSO) 《单点登录原理与简单实现》 CAS单点登录框架 常用开源框架开源协议 《开源协议的选择》 如何选择一个开源软件协议 日志框架Log4j、Log4j2 《log4j 详细讲解》 《log4j2 实际使用详解》 《Log4j1,Logback以及Log4j2性能测试对比》 Log4J 异步日志性能优异。 Logback 《最全LogBack 详解、含java案例和配置说明》 ORM 《ORM框架使用优缺点》 主要目的是为了提高开发效率。 MyBatis： 《mybatis缓存机制详解》 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。 《MyBatis学习之代码生成器Generator》 网络框架TODO Web 框架Spring 家族Spring Spring 简明教程 Spring Boot 官方网站 《Spring Boot基础教程》 Spring Cloud Spring Boot 中文索引站 Spring Cloud 中文文档 《Spring Cloud基础教程》 工具框架 《Apache Commons 工具类介绍及简单使用》 《Google guava 中文教程》 分布式设计扩展性设计 《架构师不可不知的十大可扩展架构》 总结下来，通用的套路就是分布、缓存及异步处理。 《可扩展性设计之数据切分》 水平切分+垂直切分 利用中间件进行分片如，MySQL Proxy。 利用分片策略进行切分，如按照ID取模。 《说说如何实现可扩展性的大型网站架构》 分布式服务+消息队列。 《大型网站技术架构（七）–网站的可扩展性架构》 稳定性 &amp; 高可用 《系统设计：关于高可用系统的一些技术方案》 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。 自动化测试：通过完善的测试，减少发布引起的故障。 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。 《关于高可用的系统》 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。 硬件负载均衡 《转！！负载均衡器技术Nginx和F5的优缺点对比》 主要是和F5对比。 《软/硬件负载均衡产品 你知多少？》 软件负载均衡 《几种负载均衡算法》轮寻、权重、负载、最少连接、QoS 《DNS负载均衡》 配置简单，更新速度慢。 《Nginx负载均衡》 简单轻量、学习成本低；主要适用于web应用。 《借助LVS+Keepalived实现负载均衡 》 配置比较负载、只支持到4层，性能较高。 《HAProxy用法详解 全网最详细中文文档》 支持到七层（比如HTTP）、功能比较全面，性能也不错。 《Haproxy+Keepalived+MySQL实现读均衡负载》 主要是用户读请求的负载均衡。 《rabbitmq+haproxy+keepalived实现高可用集群搭建》 限流 《谈谈高并发系统的限流》 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。 Nginx 限流：通过 limit_req 等模块限制并发连接数。 应用层容灾 《防雪崩利器：熔断器 Hystrix 的原理与使用》 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。 Hystrix设计原则： 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 《缓存穿透，缓存击穿，缓存雪崩解决方案分析》 《缓存击穿、失效以及热点key问题》 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期； 热点数据：热点数据单独存储；使用本地缓存；分成多个子key； 跨机房容灾 《“异地多活”多机房部署经验谈》 通过自研中间件进行数据同步。 《异地多活（异地双活）实践经验》 注意延迟问题，多次跨机房调用会将延时放大数倍。 建房间专线很大概率会出现问题，做好运维和程序层面的容错。 不能依赖于程序端数据双写，要有自动同步方案。 数据永不在高延迟和较差网络质量下，考虑同步质量问题。 核心业务和次要业务分而治之，甚至只考虑核心业务。 异地多活监控部署、测试也要跟上。 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。 控制跨机房消息体大小，越小越好。 考虑使用docker容器虚拟化技术，提高动态调度能力。 容灾技术及建设经验介绍 容灾演练流程 《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》 常见故障画像 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。 平滑启动 平滑重启应用思路1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用 《JVM安全退出（如何优雅的关闭java服务）》推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。 《常见Java应用如何优雅关闭》Java、Spring、Dubbo 优雅关闭方式。 数据库扩展读写分离模式 《Mysql主从方案的实现》 《搭建MySQL主从复制经典架构》 《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》 《DRBD+Heartbeat+Mysql高可用读写分离架构》 DRDB 进行磁盘复制，避免单点问题。 《MySQL Cluster 方式》 分片模式 《分库分表需要考虑的问题及方案》 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。 问题：事务、Join、迁移、扩容、ID、分页等。 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。 分库策略：数值范围；取模；日期等。 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 《MySql分表和表分区详解》 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。 分表：物理上创建不同的表、客户端需要管理分表路由。 服务治理服务注册与发现 《永不失联！如何实现微服务架构中的服务发现？》 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。 服务器端服务发现模式：客户端通过负载均衡查询服务实例。 《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》 CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap） 作者认为目前 Consul 对 Spring cloud 的支持比较好。 《基于Zookeeper的服务注册与发现》 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 服务路由控制 《分布式服务框架学习笔记4 服务路由》 原则：透明化路由 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接 本地路由优先策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。 配置方式：统一注册表；本地配置；动态下发。 分布式一致CAP 与 BASE 理论 《从分布式一致性谈到CAP理论、BASE理论》 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致) CAP：一致性、可用性、分区容错性(网络故障引起) BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性） BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 分布式锁 《分布式锁的几种实现方式》 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入； 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。 Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。 《基于Zookeeper的分布式锁》 清楚的原理描述 + Java 代码示例。 《jedisLock—redis分布式锁实现》 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。 《Memcached 和 Redis 分布式锁方案》 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。 分布式一致性算法PAXOS 《分布式系列文章——Paxos算法原理与推导》 《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》 《【分布式】Zookeeper与Paxos》 Zab 《Zab：Zookeeper 中的分布式一致性协议介绍》 Raft 《Raft 为什么是更易理解的分布式一致性算法》 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人） 通过随机等待的方式发出投票，得票多的获胜。 Gossip 《Gossip算法》 两阶段提交、多阶段提交 《关于分布式事务、两阶段提交协议、三阶提交协议》 幂等 《分布式系统—幂等性设计》 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 分布式一致方案 《分布式系统事务一致性解决方案》 《保证分布式系统数据一致性的6种方案》 分布式 Leader 节点选举 《利用zookeeper实现分布式leader节点选举》 TCC(Try/Confirm/Cancel) 柔性事务 《传统事务与柔性事务》 基于BASE理论：基本可用、柔性状态、最终一致。 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。 分布式文件系统 说说分布式文件存储系统-基本架构 ？ 《各种分布式文件系统的比较》 ？ HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。 FastDFS：轻量级、适合小文件。 唯一ID 生成全局唯一ID 《高并发分布式系统中生成全局唯一Id汇总》 Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器) Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” UUID：缺点，无序，字符串过长，占用空间，影响检索性能。 MongoDB 方案：利用 ObjectId。缺点：不能自增。 《TDDL 在分布式下的SEQUENCE原理》 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。 一致性Hash算法 《一致性哈希算法》 设计思想 &amp; 开发模式DDD(Domain-driven Design - 领域驱动设计) 《浅谈我对DDD领域驱动设计的理解》 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。 《领域驱动设计的基础知识总结》 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字； 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。 使用的模式： 关联尽量少，尽量单项，尽量降低整体复杂度。 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互； 工厂（Factory）：类似于设计模式中的工厂模式。 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。 《领域驱动设计(DDD)实现之路》 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。 《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》 命令查询职责分离(CQRS)CQRS — Command Query Responsibility Seperation 《领域驱动设计系列 (六)：CQRS》 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。 《DDD CQRS架构和传统架构的优缺点比较》 最终一致的设计理念；依赖于高可用消息中间件。 《CQRS架构简介》 一个实现 CQRS 的抽象案例。 《深度长文：我对CQRS/EventSourcing架构的思考》 CQRS 模式分析 + 12306 抢票案例 贫血，充血模型 《贫血，充血模型的解释以及一些经验》 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重； 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。 作者主张使用贫血模式。 Actor 模式TODO 响应式编程ReactorTODO RxJavaTODO Vert.xTODO DODAF2.0 《DODAF2.0方法论》 《DODAF2.0之能力视角如何落地》 Serverless无需过多关系服务器的服务架构理念。 《什么是Serverless无服务器架构？》 Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。 Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。 Serverless 不代表某个具体的框架。 《如何理解Serverless？》 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service） Service Mesh 《什么是Service Mesh？》 《初识 Service Mesh》 项目管理架构评审 《架构设计之如何评审架构设计说明书》 《人人都是架构师：非功能性需求》 重构 《架构之重构的12条军规》 代码规范 《阿里巴巴Java开发手册》 代码 Review制度还是制度!另外，每个公司需要根据自己的需求和目标制定自己的 check list 《为什么你做不好 Code Review？》 代码 review 做的好，在于制度建设。 《从零开始Code Review》 《Code Review Checklist》 《Java Code Review Checklist》 《如何用 gitlab 做 code review》 RUP 《运用RUP 4+1视图方法进行软件架构设计》 看板管理 《说说看板在项目中的应用》 SCRUMSCRUM - 争球 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图； 五个价值观：专注、勇气、公开、承诺、尊重。 《敏捷项目管理流程-Scrum框架最全总结！》 《敏捷其实很简单3—敏捷方法之scrum》 敏捷开发TODO 极限编程（XP）XP - eXtreme Programming 《主流敏捷开发方法：极限编程XP》 是一种指导开发人员的方法论。 4大价值： 沟通：鼓励口头沟通，提高效率。 简单：够用就好。 反馈：及时反馈、通知相关人。 勇气：提倡拥抱变化，敢于重构。 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。 结对编程边写码，边review。能够增强代码质量、减少bug。 《结对编程》 PDCA 循环质量管理P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进 《PDCA》 FMEA管理模式TODO 通用业务术语TODO 技术趋势TODO 政策、法规法律 《中华人民共和国网络安全法》 2016年11月7日发布，自2017年6月1日起施行 《个人信息保护法》 个人信息保护法是一部保护个人信息的法律条款，现尚在制订中，2019全国两会信息安全相关提案中，有政协委员呼吁关注大数据时代隐私保护，加速立法。 《最高人民法院、最高人民检察院关于办理侵犯公民个人信息刑事案件适用法律若干问题的解释》 《解释》共十三条，自2017年6月1日起施行 1、对于行踪轨迹信息、通信内容、征信信息、财产信息，非法获取、出售或者提供50条以上即算“情节严重”； 2、对于住宿信息、通信记录、健康生理信息、交易信息等其他可能影响人身、财产安全的公民个人信息，标准则是 500条以上； 3、对于其他公民个人信息，标准为 5000条以上。 《中华人民共和国电子商务法》 2018年8月31日，十三届全国人大常委会第五次会议表决通过《电子商务法》，自2019年1月1日起施行 解读电子商务法（一）什么是电商 解读电子商务法（二）电商经营者 解读电子商务法（三）电商行为规范 解读电子商务法（四）电商的法律关系 解读电子商务法（外传）电商挣钱的秘密 解读电子商务法（外传）电商模式 程序员需要知道的法律常识 白话法律42讲-为程序员打造的专属法律武器 严格遵守刑法253法条我国刑法第253条之一规定： 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。 最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪” 《非法获取公民个人信息罪》 避风港原则“避风港”原则是指在发生著作权侵权案件时，当ISP（网络服务提供商）只提供空间服务，并不制作网页内容，如果ISP被告知侵权，则有删除的义务，否则就被视为侵权。如果侵权内容既不在ISP的服务器上存储，又没有被告知哪些内容应该删除，则ISP不承担侵权责任。 后来避风港原则也被应用在搜索引擎、网络存储、在线图书馆等方面。 《避风港原则》 架构师素质 《架构师画像》 业务理解和抽象能力 NB的代码能力 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； 全局：是否考虑到了对上下游的系统的影响。 权衡：权衡投入产出比；优先级和节奏控制； 《关于架构优化和设计，架构师必须知道的事情》 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。 基础设施、配置、测试、开发、运维综合考虑。 考虑人、团队、和组织的影响。 《如何才能真正的提高自己，成为一名出色的架构师？》 《架构师的必备素质和成长途径》 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 《架构设计师—你在哪层楼？》 第一层的架构师看到的只是产品本身 第二层的架构师不仅看到自己的产品，还看到了整体的方案 第三层的架构师看到的是商业价值 团队管理TODO 招聘资讯行业资讯 36kr Techweb 公众号列表TODO 博客团队博客 阿里中间件博客 美团点评技术团队博客 个人博客 阮一峰的网络日志 酷壳 - COOLSHELL-陈皓 hellojava-阿里毕玄 Cm’s Blog 程序猿DD-翟永超-《Spring Cloud微服务实战》作者 综合门户、社区国内： CSDN老牌技术社区、不必解释。 51cto.com ITeye 偏 Java 方向 博客园 ChinaUnix 偏 Linux 方向 开源中国社区 InfoQ 深度开源 伯乐在线 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。 ITPUB 腾讯云— 云+社区 阿里云— 云栖社区 IBM DeveloperWorks 开发者头条 LinkedKeeper 国外： DZone Reddit 问答、讨论类社区 segmentfault 问答+专栏 知乎 stackoverflow 行业数据分析 艾瑞网 QUEST MOBILE 国家数据 TalkingData 专项网站 测试: 领测国际 测试窝 TesterHome 运维: 运维派 Abcdocker Java: ImportNew 专注于 Java 技术分享 HowToDoInJava 英文博客 安全 红黑联盟 FreeBuf 大数据 中国大数据 其他专题网站： InfoQ 偏重于基础架构、运维方向 DockerInfo 专注于 Docker 应用及咨询、教程的网站 Linux公社 Linux 主题社区 其他类 程序员技能图谱 推荐参考书在线电子书 《深入理解Spring Cloud与微服务构建》 《阿里技术参考图册-研发篇》 《阿里技术参考图册-算法篇》 《2018美团点评技术年货（合辑）》70M InfoQ《架构师》月刊 《架构师之路》 纸质书更多架构方面书籍参考: awesome-java-books 开发方面 《阿里巴巴Java开发手册》详情 架构方面 《软件架构师的12项修炼：技术技能篇》详情 《架构之美》详情 《分布式服务架构》详情 《聊聊架构》 详情 《云原生应用架构实践》详情 《亿级流量网站架构核心技术》详情 《淘宝技术这十年》详情 《企业IT架构转型之道-中台战略思想与架构实战》 详情 《高可用架构（第1卷）》详情 技术管理方面 《CTO说》详情 《技术管理之巅》详情 《网易一千零一夜：互联网产品项目管理实战》详情 基础理论 《数学之美》详情 《编程珠玑》详情 工具方面TODO 大数据方面技术资源开源资源 github Apache 软件基金会 手册、文档、教程国内： W3Cschool Runoob.com HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。 Love2.io 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。 gitbook.cn 付费电子书。 ApacheCN AI、大数据方面系列中文文档。 国外： Quick Code 免费在线技术教程。 gitbook.com 有部分中文电子书。 Cheatography Cheat Sheets 大全，单页文档网站。 Tutorialspoint 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。 在线课堂 学徒无忧 极客时间 segmentfault 斯达克学院 牛客网 极客学院 51CTO学院 会议、活动 QCon ArchSummit GITC全球互联网技术大会 活动发布平台: 活动行 常用APP 极客时间 得到 找工作 Boss直聘 拉勾网 猎聘 100Offer 工具 极客搜索 技术文章搜索引擎。 代码托管 Coding 码云 文件服务 七牛 又拍云 综合云服务商 阿里云 腾讯云 百度云 新浪云 金山云 亚马逊云(AWS) 谷歌云 微软云 VPS Linode DigitalOcean Vultr","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"转载","slug":"转载","permalink":"http://QQ876684433.github.io/tags/转载/"}]},{"title":"精通Java之路-学习计划","slug":"精通Java之路-学习计划","date":"2019-07-16T01:22:52.000Z","updated":"2019-09-15T05:02:14.670Z","comments":true,"path":"2019/07/16/精通Java之路-学习计划/","link":"","permalink":"http://QQ876684433.github.io/2019/07/16/精通Java之路-学习计划/","excerpt":"","text":"精通Java之路-学习计划玩好JDK 转载信息 作者：老刘 链接：https://www.zhihu.com/question/328775413/answer/741689212 来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Java运行时环境学习资料：《深入理解Java虚拟机 周志明 第二版》、《Java虚拟机规范 Java SE8版》 目标：对Java虚拟机有深入的理解，能够动手实现Java虚拟机核心功能 方式：阅读书籍并撰写阅读笔记，完成实现Java虚拟机的开源项目 所以，对于JVM，没什么可说的，就是往死里学，往死里研究，能有多深就多深！ Java的基础类库学习资料：jdk源码、各源码类技术博客、Oracle官方Java tutorial、《Java编程思想》 第一级别：精读源码1234java.iojava.langjava.util// 除了Exception和Error这一类的 目标：深入理解jdk源码的设计原则、编程思想，包括里面使用到的数据结构、算法等知识，精通相关API的使用，能够实现上述类库的核心功能 方式：阅读源码并撰写源码阅读笔记，完成类库核心功能的开源项目 第二级别：深刻理解12345java.lang.reflectjava.netjavax.net.*java.nio.*java.util.concurrent.* 目标：熟练掌握类库的使用，对类库的设计有较为深入的理解，包括类库设计背后的计算机基础知识（操作系统、网络等），并对核心功能的源码有深入的研究 方式：研究类库的使用方法及常见并撰写学习笔记 举个例子，反射你要了解清楚的话，你是不是要搞明白JVM的类加载机制？网络IO要搞清楚的话，你是不是要清楚TCP/IP和HTTP、HTTPS？包括并发包，如果你要搞清楚的话，是不是要了解并发的相关知识？因此，这四个包要彻底搞清楚，还是需要花费一定时间和精力的。但是，请相信我，这绝对是值得的，甚至可以说，这四个包用的够不够叼，基本决定了一个Java程序员所处的档次。 第三级别：会用即可1234567891011121314151617181920212223java.lang.annotationjavax.annotation.*java.lang.refjava.mathjava.rmi.*javax.rmi.*java.security.*javax.security.*java.sqljavax.sql.*javax.transaction.*java.textjavax.xml.*org.w3c.dom.*org.xml.sax.*javax.crypto.*javax.imageio.*javax.jws.*java.util.jarjava.util.loggingjava.util.prefsjava.util.regexjava.util.zip 目标：了解上述类库的API及其应用场景 方式：学习常见API的功能并撰写学习笔记 ps：这些类库都是有特定的应用场景的，可以留到实际开发中遇到时再作深入研究 就像sql包和transaction包，就是操作数据库时用到的。而xml、dom和sax这些，都是操作xml时用到的。其它的包也都是类似的，有使用注解时用的，有远程方法调用时用的，也有涉及到加密时用到的等等 四级别：直接无视能走到这一步，应该来说已经达到了熟悉/熟练使用Java的境界了，但是离精通Java还差得远 Java的开发工具 如果你有兴趣的话，也可以自己去JDK的bin目录下找找，看有没有什么更好玩的工具 12345678910steve@ubuntu-17-10:~$ ls /usr/lib/jvm/jdk1.8.0_201/bin/appletviewer javafxpackager jdb jrunscript pack200 unpack200ControlPanel javah jdeps jsadebugd policytool wsgenextcheck javap jhat jstack rmic wsimportidlj javapackager jinfo jstat rmid xjcjar java-rmi.cgi jjs jstatd rmiregistryjarsigner javaws jmap jvisualvm schemagenjava jcmd jmc keytool serialverjavac jconsole jmc.ini native2ascii servertooljavadoc jcontrol jps orbd tnameserv","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"}]},{"title":"JavaWeb开发笔记","slug":"JavaWeb开发笔记","date":"2019-07-14T15:27:20.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/14/JavaWeb开发笔记/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/JavaWeb开发笔记/","excerpt":"","text":"JavaWeb开发学习笔记Java SEJava基础（一）Java正则表达式（1）参考博客：https://segmentfault.com/a/1190000009162306 （2）对于*?这个符号， 如果 ? 是限定符 * 或 + 或 ? 或 {} 后面的第一个字符，那么表示非贪婪模式（尽可能少的匹配字符），而不是默认的贪婪模式 意思是，正则表达式匹配时从左往右扫描，当已扫描的字符串片段已经符合正则规则，则将其提取出来，即使再往后扫描一个字符依然符合这个规则，用代码解释如下： 1234567private static void test2() &#123; String str = \"Hello###, world!\"; String pattern1 = \"([#]&#123;2,&#125;?)\"; String pattern2 = \"([#]&#123;2,&#125;)\"; System.out.println(str.replaceAll(pattern1, \"&amp;\")); System.out.println(str.replaceAll(pattern2, \"%\"));&#125; 输出结果是 12Hello&amp;#, world!Hello%, world! 可以看出，在{}后面使用了?后，正则的匹配是非贪婪模式，扫描到##时，就已经满足pattern1的规则，故不再扫描到第三个#，而pattern2使用贪婪模式，因此匹配的是### （3）分组和反向引用 小括号 () 可以达到对正则表达式进行分组的效果。 在以正则表达式替换字符串的语法中，是通过 $ 来引用分组的反向引用，$0 是匹配完整模式的字符串（注意在 JavaScript 中是用 $&amp; 表示）；$1 是第一个分组的反向引用；$2 是第二个分组的反向引用，以此类推。 String pattern = &quot;(\\\\w)(\\\\s+)([.,])&quot;;使用了 [.] 来匹配普通字符 . 而不需要使用 [\\\\.]。因为正则对于 [] 中的 .，会自动处理为 [\\.]，即普通字符 . 进行匹配。 在小括号 () 内的模式开头加入 ?:，那么表示这个模式仅分组，但不创建反向引用。 在小括号中使用 ?&lt;name&gt; 将小括号中匹配的内容保存为一个名字为 name 的副本。 （4）Matcher、Pattern类的基本用法： 123456789101112String text = \"Hello Regex!\";Pattern pattern = Pattern.compile(\"\\\\w+\");// Java 中忽略大小写，有两种写法：// Pattern pattern = Pattern.compile(\"\\\\w+\", Pattern.CASE_INSENSITIVE);// Pattern pattern = Pattern.compile(\"(?i)\\\\w+\"); // 推荐写法Matcher matcher = pattern.matcher(text);// 遍例所有匹配的序列while (matcher.find()) &#123; System.out.print(\"Start index: \" + matcher.start()); System.out.print(\" End index: \" + matcher.end() + \" \"); System.out.println(matcher.group());&#125; Pattern.compile(正则表达式)返回Pattern对象，Pattern类的构造函数是私有的，不能通过new来创建 pattern.matcher(字符串)使用已经解析出来的pattern对象取匹配要处理的字符串，返回Matcher对象 关于Matcher类和Pattern类，参考：https://blog.csdn.net/yin380697242/article/details/52049999 Pattern类常用方法及介绍 Pattern complie(String regex)由于Pattern的构造函数是私有的,不可以直接创建,所以通过静态方法compile(String regex)方法来创建,将给定的正则表达式编译并赋予给Pattern类 String pattern() 返回正则表达式的字符串形式,其实就是返回Pattern.complile(String regex)的regex参数 Pattern.matcher(CharSequence input) 对指定输入的字符串创建一个Matcher对象 Pattern.quote(String s) 返回给定的字符串的字面量 matches()方法编译给定的正则表达式并且对输入的字串以该正则表达式为模开展匹配,该方法适合于该正则表达式只会使用一次的情况,也就是只进行一次匹配工作,因为这种情况下并不需要生成一个Matcher实例 Matcher类 常用方法及介绍 boolean matches() 最常用方法:尝试对整个目标字符展开匹配检测,也就是只有整个目标字符串完全匹配时才返回真值 boolean lookingAt() 对前面的字符串进行匹配,只有匹配到的字符串在最前面才会返回true boolean find() 对字符串进行匹配,匹配到的字符串可以在任何位置 int start() 返回当前匹配到的字符串在原目标字符串中的位置 int end() 返回当前匹配的字符串的最后一个字符在原目标字符串中的索引位置 String group() 返回匹配到的子字符串 对同一个Matcher对象，如果上一次find()方法调用成功，那么它会记录下上次match的start和end，当再一次执行find时，Matcher会在end后面继续匹配，而不是从头开始 Java正则源码解析参考：https://blog.csdn.net/li20081006/article/details/21999779 Java基本运算符（1）&amp;和&amp;&amp;的异同 电路问题： 对于：&amp; – &gt; 不管怎样，都会执行”&amp;”符号左右两边的程序 对于：&amp;&amp; – &gt; 只有当符号”&amp;&amp;”左边程序为真(true)后，才会执行符号”&amp;&amp;”右边的程序。 运算规则： 对于：&amp; – &gt; 只要左右两边有一个为false，则为false；只有全部都为true的时候，结果为true 对于：&amp;&amp; – &gt; 只要符号左边为false，则结果为false；当左边为true，同时右边也为true，则结果为true ——来源：https://www.cnblogs.com/hongten/p/hongten_java_yu.html 1234567private static void operatorTest(String str) &#123; if (str != null &amp;&amp; !str.equals(\" \")) System.out.println(\"str != null &amp;&amp; !str.equals(\\\"\\\")\"); if (str != null &amp; !str.equals(\" \")) System.out.println(\"str != null &amp; !str.equals(\\\"\\\")\");&#125;/*** 第二个判断条件会抛出异常*/ &amp;可以是按位与运算和逻辑与运算，&amp;&amp;只能是逻辑与运算 （2）|和||的异同 类似于（1）中的&amp;和&amp;&amp;，||和|都是表示“或”，区别是||只要满足第一个条件，后面的条件就不再判断，而|要对所有的条件进行判断 基本数据类型及其包装类（1）参考博客：https://alexyyek.github.io/2014/12/29/wrapperClass/ （2）自动装箱和自动拆箱 简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。 12Integer i = 10; //装箱int index = i; //拆箱 注意： 12Integer test = null;int f = test.intValue(); 这种写法会抛出空指针异常，编译不通过，因为将null赋值给Integer，这个时候不会进行自动装箱，也就没有创建Integer实例 （2）实现机制：在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue()方法。对其他的类型也类似，装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的xxxValue方法实现的。（xxx代表对应的基本数据类型） （3）关于null、void和Void的一些比较 void不是函数，是方法的修饰符，void的意思是该方法没有返回值，意思就是方法只会运行方法中的语句，但是不返回任何东西。 java.lang.Void是一种类型。例如给Void引用赋值null。通过Void类的源代码可以看到，Void类型不可以继承与实例化。 https://blog.csdn.net/f641385712/article/details/80409211 https://blog.csdn.net/claram/article/details/52053798 摘录一些比较重要的知识如下： 如果使用了带有null值的引用类型变量，instanceof操作将会返回false 123// 输出是falseBoxingAndUnboxingTest test = null;System.out.println(test instanceof BoxingAndUnboxingTest); 可以使用或者!=操作来比较null值，但是不能使用其他算法或者逻辑操作，例如小于或者大于 1234Integer i = null;Integer j = null;System.out.println(i == j);System.out.println(i &gt; j); 输出是 1234trueException in thread \"main\" java.lang.NullPointerException at tk.chph.demo.box.BoxingAndUnboxingTest.test5(BoxingAndUnboxingTest.java:16) at tk.chph.demo.box.BoxingAndUnboxingTest.main(BoxingAndUnboxingTest.java:9) class关键字用法 12345System.out.println(Void.class); //class java.lang.VoidSystem.out.println(void.class); //void//类似于下面的System.out.println(Integer.class); //class java.lang.IntegerSystem.out.println(int.class); //int Void类的用法： 用于反射中判断某方法的返回值是否为void 123456for(Method method : Test.class.getMethods()) &#123; //判断返回值类型 用到了Void类 if(method.getReturnType().equals(Void.TYPE)) &#123; System.out.println(method.getName()); &#125;&#125; 因为equals方法中不能传递关键字void，其中Void.TYPE源代码是public static final Class&lt;Void&gt; TYPE = (Class&lt;Void&gt;) Class.getPrimitiveClass(&quot;void&quot;); 使用泛型时函数并不需要返回结果或某个对象不需要值时候这是可以使用java.lang.Void类型表示 ==操作符 123456789class AutoUnboxingTest &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 &#125;&#125; 字符串编码（1）参考博客：https://my.oschina.net/mojiewhy/blog/177473 （2）主要有getBytes(Charset charset)和String(byte bytes[], String charsetName)两个方法： getBytes(Charset charset)：Encodes this {@code String} into a sequence of bytes using the charset, storing the result into a new byte array. String(byte bytes[], String charsetName)：Constructs a new {@code String} by decoding the specified array of bytes using the specified {@linkplain java.nio.charset.Charset charset}. 字符串在java中统一用unicode表示( 即utf-16 LE) Case mapping is based on the Unicode Standard version specified by the {@link java.lang.Character Character} class. 对于String gbkStr = &quot;你好哦!&quot;;这个方法： 如果源码文件是GBK编码, 操作系统（windows）默认的环境编码为GBK，那么编译时, JVM将 按照GBK编码将字节数组解析成字符，然后将字符转换为unicode格式的字节数组，作为内部存储。 当打印这个字符串时，JVM 根据操作系统本地的语言环境，将unicode转换为GBK，然后操作系统将GBK格式的内容显示出来。 str.getBytes(Charset charset)是按照给定的编码方式charset，将str内部存储的字节数据（实际上String类的内部实现里是维护一个私有的byte数组的）转换成一个新的byte数组并返回，这个时候新的byte数组的编码方式就是charset了 new String(bytes, charset)是使用charset这个编码来对字节数组bytes进行解码，得到新的字符串，这个字符串内部依然会维护一个byte数组，编码方式就是charset指定的 getBytes 和 new String() 来进行编码转换，核心工作都是在getbytes这个方法内部实现了，即将原编码方式的byte数组转换成给定的新的编码方式的byte数组，这时候实际上就已经完成了编码转换，new String只是按照新的编码方式将byte数组转出字符串对象而已，便于进行输出 如何正确的将GBK转UTF-8 ? （实际上是unicode转UTF-8) 12345678910111213// 利用getBytes将unicode字符串转成UTF-8格式的字节数组byte[] utf8Bytes = gbkStr.getBytes(\"UTF-8\"); // 然后用utf-8 对这个字节数组解码成新的字符串String utf8Str = new String(utf8Bytes, \"UTF-8\");// 简化后就是:unicodeToUtf8 (String s) &#123; return new String( s.getBytes(\"utf-8\") , \"utf-8\");&#125;// UTF-8 转GBK原理也是一样return new String( s.getBytes(\"GBK\") , \"GBK\"); String类默认的编码是UTF-8（参考：https://blog.csdn.net/sugar_rainbow/article/details/76945323） 1234567891011String str = \"数据结构与算法\";byte[] bytes = str.getBytes(\"utf8\");for (byte b : str.getBytes()) &#123; System.out.print(b);&#125;System.out.println();for (byte b : bytes) &#123; System.out.print(b);&#125;System.out.println();System.out.println(new String(bytes, \"unicode\")); 输出结果是 123-26-107-80-26-115-82-25-69-109-26-98-124-28-72-114-25-82-105-26-77-107-26-107-80-26-115-82-25-69-109-26-98-124-28-72-114-25-82-105-26-77-107냦趮鏦麄軧꺗� 可见，getBytes(&quot;utf8&quot;)和getBytes()返回的byte数组是一样的，而且最后一句可以看到，utf-8和Unicode是不一样的 不同的编码在Java中所占用的字节数：https://www.cnblogs.com/Qian123/p/5799835.html String 、StringBuffer和StringBuilder（1）参考：https://blog.csdn.net/weixin_41101173/article/details/79677982 String StringBuffer StringBuilder String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间 是可变类和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 可变类，速度更快 不可变 可变 可变 线程安全 线程不安全 多线程操作字符串 单线程操作字符串 Java基础（二）数组（Array）和列表（ArrayList）的区别（1）参考：https://blog.csdn.net/m0_37683661/article/details/78778483 Array ArrayList 空间大小 空间大小是固定的，空间不够时也不能再次申请，所以需要事前确定合适的空间大小 动态增长，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够 存储内容 Array数组可以包含基本类型和对象类型；Array数组在存放的时候一定是同种类型的元素 ArrayList却只能包含对象类型；ArrayList可以存储不同类型的对象，因为ArrayList可以存储Object 方法 添加全部addAll()、删除全部removeAll()、返回迭代器iterator()等 应用场景 如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里 如果需要频繁对数组进行增删改查操作，使用ArrayList会很方便；但是如果需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，使用ArrayList的效率很低，而使用Array进行这样的动作很麻烦，那么，我们可以考虑选择LinkedList （2）值得注意的是，Array中的包装类和基本类型可以混用（本质上是自动装箱和自动拆箱） 12345Integer[] arr = new Integer[3];arr[0] = 1;arr[2] = Integer.valueOf(\"2\");arr[1] = null;for (Integer i : arr) System.out.println(i); for循环使用的是Integer，所以null可以正常输出，如果改成int，那么null就会报错，因为没法自动拆箱成基本类型 值传递和引用传递（1）首先，Java内的传递使用的都是值传递，这里面有两层意思： 对于基本数据类型，传递的是变量的值 对于对象的引用传递，传递的只是对象引用的值（即只是传递引用指向的对象的地址，而不是对象本身，也不是对象的引用的引用） 参考博客：https://blog.csdn.net/javazejian/article/details/51192130 1234567891011121314151617181920212223242526public class CallByValue &#123; private static User user=null; private static User stu=null; /** * 交换两个对象 * @param x * @param y */ public static void swap(User x,User y)&#123; User temp =x; x=y; y=temp; &#125; public static void main(String[] args) &#123; user = new User(\"user\",26); stu = new User(\"stu\",18); System.out.println(\"调用前user的值：\"+user.toString()); System.out.println(\"调用前stu的值：\"+stu.toString()); swap(user,stu); System.out.println(\"调用后user的值：\"+user.toString()); System.out.println(\"调用后stu的值：\"+stu.toString()); &#125;&#125; 执行结果如下： 1234567调用前user的值：User [name=user, age=26]调用前stu的值：User [name=stu, age=18]调用后user的值：User [name=user, age=26]调用后stu的值：User [name=stu, age=18] 可以这么理解：Object obj = new Object();变量obj的值是新的对象new Objext()的地址，obj在方法调用时call(Object obj1)传递是值传递，就是把obj的值（新对象的地址）拷贝到了obj1中，这时候obj1持有的引用是new Object()，而不是obj，所以obj所做的任何修改只是对对象的修改，而对obj不会产生任何影响，只是副作用是obj指向的对象自身属性可能被（obj1）修改了 Java8新特性Lambda表达式（1）对于只有一个抽象方法（可以是重载的方法）的接口称为函数式接口，函数式接口与lambda兼容；实际上Java中的lambda表达式能做的也就是转换为函数式接口而已 （2）方法引用：使用::操作符来分隔对象或类与方法 object::instanceMethod（等价于(..)-&gt;object.instanceMethod(..)） Class::staticMethod（等价于(..)-&gt;Class.staticMethod(..)） Class::instanceMethod 特别注意的是第三个方法，它的参数列表中第一个参数会成为方法的目标（即调用该方法的对象），例如：String::compareToIngnoreCase等同于(x, y)-&gt;x.compareToIgnoreCase(y) （3）当有多个同名的重载方法时，编译器会自动选择最符合的那个版本 （4）lambda表达式中可以有this和super关键字 （5）Class::new可以调用一个构造器，具体是哪个构造器会根据上下文进行推导 （6）lambda表达式的三个部分： 一个代码块 参数 自由变量的值，指的是非参数而且不是在代码块中定义的变量 例如： 12345678public static void repeatMessage(String text, int delay)&#123; ActionListener listener = event -&gt; &#123; //注意text变量 System.out.println(text); Toolkit.getDefaultToolkit().beep(); &#125;; new Timer(delay, listener).start();&#125; 这里的text就是自由变量；由于repeatMessage和listener方法不是同步调用的，有可能出现repeatMessage调用结束后，listener才调用，而这时候text这个变量很可能已经被回收了，因此listener要正常运行，必须捕获自由变量的值 （7）闭包 （8）lambda表达式中只能引用值不会改变的变量，而且lambda表达式中捕获的变量必须实际上是最终变量（final或者像String这种不会改变的变量） （9）lambda表达式与嵌套块有相同的作用域，因此lambda表达式中声明一个与局部变量同名的参数或者局部变量是不合法的 123456789101112131415161718// 报错：Variable ‘event’ is already defined in the scopepublic static void repeatMessage(String text, int delay)&#123; int event = 1; ActionListener listener = event -&gt; &#123; System.out.println(text); Toolkit.getDefaultToolkit().beep(); &#125;;&#125;// 报错：Variable ‘i’ is already defined in the scopepublic static void repeatMessage(String text, int delay)&#123; int i = 1; ActionListener listener = event -&gt; &#123; int i; System.out.println(text); Toolkit.getDefaultToolkit().beep(); &#125;;&#125; （10）lambda表达式中的this关键字是指创建这个lambda表达式的方法的this参数： 123456789101112131415161718192021222324252627package tk.chph.demo.lambda;interface Listener &#123; void test(); default void method1()&#123; System.out.println(\"Listener\"); &#125;&#125;public class LambdaTest &#123; public static void main(String[] args) &#123; new LambdaTest().run(); &#125; public void method1() &#123; System.out.println(\"Lambda Test\"); &#125; public void run() &#123; Listener listener = () -&gt; &#123; // 这里的this关键字指的都是LambdaTest这个类的实例的引用，而不是listener的引用 this.method1(); method1(); &#125;; listener.test(); &#125;&#125; 输出结果是： 12Lambda TestLambda Test 各个jdk版本的新特性（1） 线程（1）Java中实现一个线程的方法有： 继承Thread类 实现Runnable接口 事实上，Thread类也实现了Runnable接口，并且自动获得了run方法 （2）为什么通过实现Runnable接口来实现线程的方法好？ 因为Java中类是单继承的，如果使用继承Thread类的方式来实现线程，那么他就不能再继承其他的类了 从面向对象的角度来看，继承一个类的目的更多是在原有类的基础上提供新的特征或者功能；如果我们只是想使用run()方法来使得我们的代码能够和主线程并行运行，实现Runnable接口是个更好的选择 （3）Java线程的生命周期 [ Thread in Java.png](https://i.loli.net/2019/05/20/5ce1fb9627bff98011.png) 当我们创建实现了Runnable接口或者继承了Thread类的实例后，我们只是创建了一个线程对象（处在图中的NEW状态），只有当我们调用start()方法后，这个线程才会启动（这时是在RUNNABLE状态），在start方法内部会调用run方法 处于RUNNABLE状态的线程还不一定在执行，需要等待线程调度器分配CPU资源去运行线程，也就是说，线程的run方法是由JVM调用的 run()方法和start方法的区别 when program calls start() method a new Thread is created and code inside run() method is executed in new Thread if you call run()method directly no new Thread is created and code inside run() will execute on current Thread Another difference between start vs run in Java thread is that you can not call start() method twice on thread object. once started, second call of start() will throw IllegalStateException in Java while you can call run() method twice 小知识点 线程执行完毕的顺序和线程start的顺序并不一致，这取决于jvm的线程调度器 当线程中的run方法运行结束后，线程进入DEAD状态，这时候再调用start方法，线程也无法再次启动 （4）线程与进程的区别 线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务 不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间（堆内存） 每个线程都拥有单独的栈内存用来存储本地数据 （5）Java内存模型(JMM)的Happens-before规则 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。 对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。 （6）volatile变量 参考：https://javarevisited.blogspot.com/2011/06/volatile-keyword-java-example-tutorial.html volatile variable in Java.png Java中的volatile关键字是用来指示Java编译器和线程不要缓存这个变量的值，始终都从主存中读取变量的值 Anyway, the volatile keyword in Java is used as an indicator to Java compiler and Thread that do not cache value of this variable and always read it from main memory 当我们需要使得对某个变量的读或者写操作是原子性的（例如对int或者boolean变量的读或者写），那么我们可以将其声明为volatile So if you want to share any variable in which read and write operation is atomic by implementation e.g. read and write in an int or a boolean variable then you can declare them as volatile variable volatile关键字只能用在变量上，不能用在类或者方法上 The Java volatile keyword cannot be used with method or class and it can only be used with a variable volatile关键字可以用在多线程环境的单例模式中 123456789101112131415public class Singleton&#123;private static volatile Singleton _instance; //volatile variable public static Singleton getInstance()&#123; if(_instance == null)&#123; synchronized(Singleton.class)&#123; if(_instance == null) _instance = new Singleton(); &#125; &#125; return _instance;&#125; 如果不将_instance声明为volatile，其中一个线程在创建了_instance后就失去了CPU资源，这时候其他线程的看到的_instance变量依然是null的，这时候其他线程就有可能再次创建_instance对象，这样Singleton类的实例就有可能不是单例模式的了 （7）如何停止一个线程 JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用 当run方法执行结束或者跑出异常时，线程会自动结束（简单的说，如果线程运行过程中抛出的异常没有被捕获，该线程将会停止执行） 可以通过结合volatile设置标记位来手动中断线程的执行 代码示例 12345678910111213141516171819private class Runner extends Thread&#123; volatile boolean bExit = false; public void exit(boolean bExit)&#123; this.bExit = bExit; &#125; @Override public void run()&#123; while(!bExit)&#123; System.out.println(\"Thread is running\"); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ex) &#123; Logger.getLogger(ThreadTester.class.getName()).log(Level.SEVERE, null, ex); &#125; &#125; &#125;&#125; 当我们调用exit()方法将bExit设置为true时，run方法就会在新一轮迭代开始时检测到，然后终止循环 要注意，每个线程都有自己的本地内存，bExit变量也一样，因此要使得bExit值的改变能够立即被其他线程看到，需要将bExit设置为volatile变量 （8）线程之间的消息传递 生产者消费者模式：where One thread produce and put something on shared bucket, and then tell other thread that there is an item for your interest in shared object, consumer thread than pick than item and do his job 如果不使用wait()和notify()/notifyAll()方式，消费者线程就必须得周期性地轮询bucket（一个共享对象），即使bucket的状态没有发生变化 消费者在检查条件的时候，要使用while循环而不是if判断 主要是为了避免虚假唤醒的情况，这样线程在休眠前和唤醒后都会进行条件的检查；因为有可能有多个线程在条件改变时同时被唤醒，其中的一些线程由于没有得到即使的响应，被其他唤醒的线程将条件改变了，那些没有及时响应的线程在获得CPU资源后，如果使用的是if检查添加，那么它就不会再去检查条件而是直接对共享对象进行操作，导致出错；如果使用的是while检查条件，那么它被唤醒之后，无论如何都回再去检查条件，如果条件没有满足，它会再次进入休眠状态而不是取操作共享对象 While if you call notifyAll method, all threads waiting on that lock will be woken up, but again all woken thread will fight for lock before executing remaining code and that’s why wait is called on loop because if multiple threads are woken up, the thread which will get lock will first execute and it may reset waiting for condition, which will force subsequent threads to wait. （9）notify()和notifyAll()的区别 The main difference between notify and notifyAll is that notify method will only notify one Thread and notifyAll method will notify all Threads which are waiting on that monitor or lock notify()唤醒的线程是哪一个是无法保证的，这由线程调度器来决定 当我们的程序中唤醒休眠中的线程，最终只会有一个线程会获得资源对共享对象进行操作的时候，我们应该使用notify()而不是notifyAll()，而且这样还能够节省CPU资源 You can use notify over notifyAll if all thread are waiting for the same condition and only one Thread at a time can benefit from condition becoming true. In this case, notify is optimized call over notifyAll because waking up all of them because we know that only one thread will benefit and all other will wait again, so calling notifyAll method is just waste of CPU cycles （10）为什么wait、notify和notifyAll是在Object类中定义的而不是Thread类 参考：https://javarevisited.blogspot.com/2012/02/why-wait-notify-and-notifyall-is.html （11）Thread.interrupted和isInterrupted的区别 interrupted() 和 isInterrupted()的主要区别是**前者会将中断状态清除而后者不会*。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()*来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。 （12）如果wait和nofity不在同步块中调用，代码就会抛出IllegalMonitorStateException异常 Java面向对象接口（1）接口中的所有方法自动地属于public ，因此, 在接口中声明方法时 , 不必提供关键字public；但是在实现接口时，必须把方法声明为public，否则编译器认为该方法的访问属性是包可见性 1234567891011interface InterfaceA &#123; void method1();&#125;public class ImplA implements InterfaceA &#123; // 这里会报错 // Error:(4, 10) java: tk.chph.demo.interface_.ImplA中的method1()无法实现tk.chph.demo.interface_.InterfaceA中的method1()正在尝试分配更低的访问权限; 以前为public void method1() &#123; &#125;&#125; （2）接口可以定义常量，但是不能有实例域；在jdk8之前，接口中的方法也不能含有实现 （3）可以使用instanceof检查一个类的实例是否实现了特定的接口 1new ImplA() instanceof InterfaceA; （4）接口中不能包含实例域或者静态方法（1.8之前），但是可以包含常量；接口中的方法自动的设置为public，而接口中的域也自动被设置为public static final （5）使用接口不使用抽象类的原因：Java中的类只能扩展一个抽象类或者超类，而可以实现多个接口；多重继承会使得语言本身变得复杂，同时效率低下 （6）jdk1.8之后interface中允许有静态方法，即static修饰的类方法，但是必须为其提供实现体；同时interface中也允许提供以default修饰的成员方法的默认实现，且默认方法可以调用任何其他的方法 123456789101112public interface InterfaceA &#123; void method1(); static void method2()&#123; &#125; default void method3()&#123; method1(); method2(); &#125;&#125; （7）默认方法冲突：如果一个接口中的一个默认方法和另一个超类或者接口中定义的方法签名相同，这是就产生了默认方法冲突问题，解决方法如下： 超类优先：如果超类提供了一个具体方法（如果是抽象的方法，那么实现类要么是实现该方法，要么是让该方法依旧抽象，从这一点来看，超接口的默认方法依然是被忽略的），且签名和默认方法相同，那么具体的实现是选择超类中的实现，忽略超接口的所有同签名方法不论是否是默认的 （ps：超类优先原则可以保证jdk8之前的代码兼容性，jdk8之后的接口提供签名相同的默认方法并不会造成冲突） （pss：默认方法重新定义Object类中的方法无效，因为所有的类都继承自Object，如果为toString或者equals这样的Object类方法定义默认方法，由于类优先原则，Object.toString或者Objects.equals方法会覆盖该默认方法） 接口冲突：如果是超接口提供了一个同签名的默认方法，那么实现类必须覆盖该默认方法以解决冲突 123456789101112131415161718192021222324252627282930313233343536373839package tk.chph.demo.interface_;public class ImplA extends AbstractA implements InterfaceA, InterfaceB &#123; @Override public void method4() &#123; &#125; public static void main(String[] args) &#123; new ImplA().method5(); &#125;&#125;abstract class AbstractA &#123; public abstract void method4(); public void method5()&#123; System.out.println(\"AbstractA\"); &#125;&#125;interface InterfaceA &#123; void method4(); default void method5()&#123; System.out.println(\"InterfaceA\"); &#125;&#125;interface InterfaceB &#123; void method4(); default void method5()&#123; System.out.println(\"InterfaceB\"); &#125;&#125; 输出为：AbstractA 如果将AbstractA这个抽象类去掉，那么输出结果是： 1Error:(3, 8) java: 类 tk.chph.demo.interface_.ImplA从类型 tk.chph.demo.interface_.InterfaceA 和 tk.chph.demo.interface_.InterfaceB 中继承了method5() 的不相关默认值 必须在ImplA中覆盖method5方法后才能编译通过 123456789101112131415161718package tk.chph.demo.interface_;public class ImplA implements InterfaceA, InterfaceB &#123; @Override public void method4() &#123; &#125; @Override public void method5() &#123; System.out.println(\"ImplA\"); &#125; public static void main(String[] args) &#123; new ImplA().method5(); &#125;&#125; 输出为：ImplA 当然也可以在ImplA中选择超接口的其中一个method5实现： 1234@Overridepublic void method5() &#123; InterfaceA.super.method5();&#125; 这里的例子是两个超接口都的冲突默认方法都提供了实现，然而实际上是，InterfaceA和InterfaceB只要至少一个提供了默认方法，那个实现类都必须覆盖该默认方法了 Comparable 和 Comparator接口（1）参考博客：https://www.cnblogs.com/skywang12345/p/3324788.html （2）若一个类实现了Comparable接口，就意味着“该类支持排序”。 “实现Comparable接口的类的对象的List列表(或数组)”，可以通过 Collections.sort（或 Arrays.sort）进行排序。 1234567package java.lang;import java.util.*;// 通过 x.compareTo(y) 来“比较x和y的大小”。若返回“负数”，意味着“x比y小”；返回“零”，意味着“x等于y”；返回“正数”，意味着“x大于y”。public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; （3）Comparator 是比较器接口，通过实现Comparator构建一个比较器，可以用来对某个没有实现Comparable接口的类进行排序 也就是说，我们可以通过“实现Comparator类来新建一个比较器”，然后通过该比较器对类进行排序。 123456789package java.util;// “比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2); boolean equals(Object obj);&#125; 若一个类要实现Comparator接口：它一定要实现compareTo(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。理由还是“类优先原则”，所有类都继承了Object的equals方法，因此超接口中的equals不用去实现也可以编译通过 （4）Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。 Cloneable接口和clone()方法（1）参考博客：https://www.cnblogs.com/xrq730/p/4858937.html （2）Cloneable接口 实现Cloneable接口（该接口是一个标记接口，内部没有任何方法），以指示Object的clone()方法可以合法地对该类实例进行按字段复制 如果在没有实现Cloneable接口的实例上调用Object的clone()方法，则会导致抛出CloneNotSupporteddException 实现此接口的类应该使用公共方法重写Object的clone()方法，Object的clone()方法在定义时是protected的，即只能在java.lang包下的类和子类能够调用clone()方法，所以在重写clone方法时要将修饰符改成public，以便重写的clone方法能够被其他类调用 （3）clone方法应该满足以下条件： x.clone() != x为true x.clone().getClass() == x.getClass()为true x.clone().equals(x)一般情况下为true，但这并不是必须要满足的要求 （4）clone方法不会调用类的构造函数 （5）浅克隆和深克隆 ​ 浅克隆（shallow clone）和深克隆（deep clone）反映的是，当对象中还有对象的时候，那么： 浅克隆，即很表层的克隆，如果我们要克隆对象，只克隆它自身以及它所包含的所有对象的引用地址 深克隆，克隆除自身对象以外的所有对象，包括自身所包含的所有对象实例 （6）其实Object的clone()方法，提供的是一种浅克隆的机制，如果想要实现对对象的深克隆，在不引入第三方jar包的情况下，可以使用两种办法： 先对对象进行序列化，紧接着马上反序列化出 先调用super.clone()方法克隆出一个新对象来，然后在子类的clone()方法中手动给克隆出来的非基本数据类型（引用类型）赋值，比如ArrayList的clone()方法 内部类（1）内部类的特点： 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据 可以对同一个包中的其他类隐藏起来 当要定义一个回调函数且不想编写大量代码时，可以使用匿名内部类 （2）内部类可以访问自己定义的成员，也可以访问创建它的外围类对象的成员（包括私有的） 123456789101112131415161718192021222324252627282930package tk.chph.demo.inner;public class InnerClassTest &#123; private int a; public class Inner&#123; private void method()&#123; // 访问外围类的成员变量a System.out.println(a); &#125; &#125;&#125;// 反编译class文件后是这样的public class InnerClassTest &#123; private int a; public InnerClassTest() &#123; &#125; public class Inner &#123; public Inner() &#123; &#125; private void method() &#123; // 注意这里 System.out.println(InnerClassTest.this.a); &#125; &#125;&#125; 实际上内部类的对象中有一个隐式的引用指向了创建它的外围类的对象；实际上编译器修改了所有内部类的构造函数，添加了一个外围类引用的参数，如下： 1234// 为了便于说明，将外围对象的引用定义为outerpublic Inner(InnerClassTest test) &#123; this.outer = test;&#125; 当InnerClassTest创建Inner类时，会这样调用构造函数：Inner inner = new Inner(this);将自身的引用传递到内部类对象中 （3）只有内部类可以是私有类, 而常规类只可以具有包可见性 , 或公有可见性 （4）内部类对外围类的引用正式语法是：OuterClass.this （5）外围类对象调用内部类的构造器的正式语法是：outerObject.new InnerClass(construction parameters) （6）在外围类的作用域外，可以这样引用其内部类：OuterClass.InnerClass （7）内部类声明的所有静态域都必须是final，原因是我们希望每一个静态域都只有一个实例，但是对每一个外部对象，它都会被分配一个单独的内部类实例（就是说不同外部对象的内部类实例都是不一样的对象），如果内部类静态域不是final，那么就可能出现不是唯一的情况 123456789101112private class Inner&#123; // 报错：Inner classes cannot have static declarations private static int b = 10; private void method()&#123; System.out.println(a); &#125; // 报错：Inner classes cannot have static declarations private static void test()&#123; &#125;&#125; （8）外围类可以访问内部类的任何成员，包括私有的 （9）局部内部类：定义在一个方法内的类 据不累不能用public或private访问修饰符声明，因为它的作用域被限制在声明这个局部内部类的块中 对外部世界，局部内部类可以完全隐藏起来 12345678910111213141516171819package tk.chph.demo.inner;public class InnerClassTest &#123; &#123; class InnerClass&#123;&#125; &#125; static &#123; class InnerClass&#123;&#125; &#125; void test1()&#123; class InnerClass&#123;&#125; &#125; static void test2()&#123; class InnerClass&#123;&#125; &#125;&#125; （10）局部内部类可以访问其所在块的作用域内的局部变量 12345678void test1(int a)&#123; class InnerClass&#123; private void test()&#123; System.out.println(a); &#125; &#125; new InnerClass().test();&#125; 和lambda的捕获一样，由于可能出现test1方法执行结束后局部变量消失，而内部类还未执行的情况，内部类会在外部块释放局部变量之前，将局部变量进行备份，实际上的实现是这样的： 编译器会修改局部内部类的成员和构造函数，开始时先检测局部内部类对局部变量的访问，为每个局部变量建立相应的数据域，然后将局部变量拷贝到构造器中，以便这些局部内部类的数据域初始化为局部变量的副本 而且，引用的局部变量必须是final的或者是实际上不变的对象： 12345678910void test1(int a)&#123; class InnerClass&#123; private void test()&#123; // 报错：Variable 'a' is accessed from within inner class, needs to be final or effectively final a = 10; System.out.println(a); &#125; &#125; new InnerClass().test();&#125; 因此上面划线部分补充一下，内部类建立的数据域实际上是final的，对它初始化后不能够再进行修改，所以出现a=10时会报错，即使是在内部类外面修改也不行： 1234567891011void test1(int a) &#123; // 这里修改 a = 10; class InnerClass &#123; private void test() &#123; // 报错：Variable 'a' is accessed from within inner class, needs to be final or effectively final System.out.println(a); &#125; &#125; new InnerClass().test();&#125; 总之，只要局部变量被局部内部类引用了，它就必须是final或者实际上的final了： 12345678910void test1(final int a) &#123; final int b = 90; class InnerClass &#123; private void test() &#123; System.out.println(b); System.out.println(a); &#125; &#125; new InnerClass().test();&#125; （11）如果一个类只被创建一个对象，那就不必命名了，这种类称为匿名内部类 如果构造参数的括号后面跟一个大括号，那么正在定义的是一个匿名内部类 由于匿名内部类没有类名，自然就没有构造函数，取而代之的是将构造器参数传递给超类的构造器 123456789101112131415161718192021package tk.chph.demo.inner;abstract public class AbstractClass &#123; protected int i; AbstractClass(int i) &#123; this.i = i; &#125; abstract public void test(String name); public static void main(String[] args) &#123; AbstractClass c = new AbstractClass(10) &#123; @Override public void test(String name) &#123; System.out.println(this.i + \": \" + name); &#125; &#125;; c.test(\"steve\"); &#125;&#125; 由于AbstractClass是抽象类，他不能直接被实例化，new出来的实际上是AbstractClass的一个子类（实现类），这个子类没有类名，是个匿名内部类，没有自己的构造函数，要将构造参数传递给超类的构造器 匿名内部类（子类）进行getClass() != other.getClass()测试时会失败： 12345678910111213141516AbstractClass c = new AbstractClass(10) &#123; @Override public void test(String name) &#123; System.out.println(this.i + \": \" + name); &#125;&#125;;AbstractClass abstractClass = new AbstractClass(10) &#123; @Override public void test(String name) &#123; System.out.println(this.i + \": \" + name); &#125;&#125;;System.out.println(c.getClass() != abstractClass.getClass());StringBuilder sb1 = new StringBuilder();StringBuilder sb2 = new StringBuilder();System.out.println(sb1.getClass() != sb2.getClass()); 输出为： 12true //注意这个false （12）静态内部类 只有内部类可以声明为static，静态内部类除了没有外围类的引用外，其他功能和所有内部类相同 静态内部类的初始化实在静态方法中完成的 静态内部类可以有静态域和方法 声明在接口中的内部类自动成为static和public类 12345678910111213141516171819202122package tk.chph.demo.inner;interface InterfaceA &#123; class InnerClass&#123; void test()&#123; System.out.println(\"InnerClass in InterfaceA\"); &#125; &#125;&#125;public class OuterClassA &#123; static class InnerClassA&#123; // 静态内部类拥有静态域 public static final String name = \"InnerClassA\"; // 静态内部类拥有静态方法，普通的内部类不能拥有静态方法，自然就不能有main方法 public static void main(String[] args) &#123; // 这里直接通过接口名引用接口中定义的内部类 InterfaceA.InnerClass innerClass = new InterfaceA.InnerClass(); &#125; &#125;&#125; 由于方法内部不能用static修饰变量，因此无法在方法内部声明一个静态局部内部类 泛型泛型方法（1）可以通过在修饰符（例如public static）后面、返回类型前面添加类型变量&lt;T&gt;来声明一个泛型方法： 1234567package tk.chph.demo.generic;public class GenericTest &#123; &lt;T&gt; void test1(T t)&#123; System.out.println(t); &#125;&#125; （2）泛型方法的调用是在方法名前面加上&lt;类型变量&gt;： 12345public static void main(String[] args) &#123; new GenericTest().&lt;String&gt;test1(\"string\"); // It's also ok like this // new GenericTest().test1(\"string\");&#125; 当然调用时的类型变量是可以省略的，编译器可以通过上下文推断出来 类型变量的限定（1）可以使用&lt;T extends SuperClass/SuperInterface&gt;的语法来对类型变量T做限定，意思是T是绑定类型的子类型（subtype），这里的extends关键字不是继承的意思，因为绑定类型是接口也是可以的 123456789101112131415161718192021package tk.chph.demo.generic;interface InterfaceA&#123; &#125;public class GenericTest &#123; &lt;T extends InterfaceA&gt; void test1(T t)&#123; System.out.println(t); &#125; public static void main(String[] args) &#123; // 这时候就会报错： // Error:(13, 26) java: 无法将类 tk.chph.demo.generic.GenericTest中的方法 test1应用到给定类型; // 需要: T // 找到: java.lang.String // 原因: 显式类型参数java.lang.String不符合声明的范围tk.chph.demo.generic.InterfaceA new GenericTest().&lt;String&gt;test1(\"string\"); &#125;&#125; （2）一个类型变量或通配符可以有多个限定，限定类型用&amp;分隔，逗号用来分隔类型变量 12345&lt;T extends InterfaceA &amp; Comparable, U extends InterfaceA &amp; Cloneable&gt; void test2(T t, U u) &#123; System.out.println(t); System.out.println(u);&#125; （3）根据Java的继承和实现接口原则，只能够单继承多实现，而且继承在实现前面，所以如果使用类作为限定，它必须是限定列表的第一个 泛型和虚拟机：类型擦除（1）有关 Java 泛型转换的事实 : 虚拟机中没有泛型 , 只有普通的类和方法 所有的类型参数都用它们的限定类型替换 桥方法被合成来保持多态 为保持类型安全性, 必要时插人强制类型转换 Javascript对象的访问方法对象Person的字面量创建方法 123456789101112131415var person = &#123; name : &#123; first : 'Bob', last : 'Smith' &#125;, age : 32, gender : 'male', interests : ['music', 'skiing'], bio : function() &#123; alert(this.name[0] + ' ' + this.name[1] + ' is ' + this.age + ' years old. He likes ' + this.interests[0] + ' and ' + this.interests[1] + '.'); &#125;, greeting: function() &#123; alert('Hi! I\\'m ' + this.name[0] + '.'); &#125;&#125;; 点表示法123person.ageperson.interests[1]person.bio() 括号表示法12person['age']person['name']['first'] 在这个意义上，使用了关联了值的名字，而不是索引去选择元素，因此对象有时被称之为关联数组(associative array)——对象做了字符串到值的映射，而数组做的是数字到值的映射。 创建对象成员123456person['eyes'] = 'hazel' // 括号表示法person.farewell = function() &#123; alert(\"Bye everybody!\") &#125; // 点表示法// 测试新成员person['eyes']person.farewell() 此外，使用括号表示法可以动态设置成员的名字，而点表示法不可以（点表示法只能接受字面量的成员的名字，不接受变量作为名字） 123var myDataName = nameInput.valuevar myDataValue = nameValue.valueperson[myDataName] = myDataValue 这里的nameInput里的值完全可以在运行脚本的时候，通过&lt;input/&gt;标签让用户动态输入 构建函数和对象构建函数JavaScript 用一种称为构建函数的特殊函数来定义对象和它们的特征 123456function Person(name) &#123; this.name = name; this.greeting = function() &#123; alert('Hi! I\\'m ' + this.name + '.'); &#125;;&#125; 这个构建函数是 JavaScript 版本的类。它只定义了对象的属性和方法，除了没有明确创建一个对象和返回任何值和之外，它有了函数所拥有的全部功能 1var person = new Person('Bob'); 这样使用new，通过构建函数创建了类Person的一个实例（*实际的方法，比如greeting()仍然是定义在类里面， 而不是在对象里面*） 创建对象的其他方法使用Object()构造函数来创建一个新对象。一般对象都有构造函数，它创建了一个空的对象 1var person = new Object(); 这样创建了一个空的对象person，然后, 可以根据需要, 使用点或括号表示法向此对象添加属性和方法 12345person.name = 'Chris';person['age'] = 38;person.greeting = function() &#123; alert('Hi! I\\'m ' + this.name + '.');&#125; 可以将对象文本传递给Object() 构造函数作为参数， 以便用属性/方法填充它 1234567var person = new Object(&#123; name : 'Chris', age : 38, greeting : function() &#123; alert('Hi! I\\'m ' + this.name + '.'); &#125;&#125;); 使用create()方法JavaScript有个内嵌的方法Object.create(), 它允许您基于现有对象创建新的对象 1var newPerson = Object.create(person); newPerson和person具有相同的属性和方法，即create方法创建了原对象的一个副本 JavaScript原型链与继承参考资料 https://juejin.im/post/58f94c9bb123db411953691b https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes 确定原型和实例的关系123456789101112131415function Father()&#123; this.property = true;&#125;Father.prototype.getFatherValue = function()&#123; return this.property;&#125;function Son()&#123; this.sonProperty = false;&#125;//继承 FatherSon.prototype = new Father();//Son.prototype被重写,导致Son.prototype.constructor也一同被重写Son.prototype.getSonVaule = function()&#123; return this.sonProperty;&#125;var instance = new Son(); （1）instanceof操作符来测试实例(instance)与原型链中出现过的构造函数，结果就会返回true 123alert(instance instanceof Object);//truealert(instance instanceof Father);//truealert(instance instanceof Son);//true （2）使用 isPrototypeOf() 方法, 同样只要是原型链中出现过的原型，isPrototypeOf() 方法就会返回true 123alert(Object.prototype.isPrototypeOf(instance));//truealert(Father.prototype.isPrototypeOf(instance));//truealert(Son.prototype.isPrototypeOf(instance));//true 借用构造函数即在子类型构造函数的内部调用超类型构造函数，也叫作经典继承 123456789101112function Father()&#123; this.colors = [\"red\",\"blue\",\"green\"];&#125;function Son()&#123; Father.call(this);//继承了Father,且向父类型传递参数&#125;var instance1 = new Son();instance1.colors.push(\"black\");console.log(instance1.colors);//\"red,blue,green,black\"var instance2 = new Son();console.log(instance2.colors);//\"red,blue,green\" 可见引用类型值是独立的 这样就保证了原型链中的引用类型的值是独立的，不会被所有实例共享 这里本质上是Son类通过this来调用Father构造函数中的方法实现，用来构造Son实例，但是Son类、实例和Father类之间不具有任何继承关系，因此Father类中定义的方法对Son是不可见的，因为无法通过原型链到达Father类 组合继承使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性 123456789101112131415function Father(name)&#123; this.name = name; this.colors = [\"red\",\"blue\",\"green\"];&#125;Father.prototype.sayName = function()&#123; alert(this.name);&#125;;function Son(name,age)&#123; Father.call(this,name);//继承实例属性，第一次调用Father() this.age = age;&#125;Son.prototype = new Father();//继承父类方法,第二次调用Father()Son.prototype.sayAge = function()&#123; alert(this.age);&#125; Father.call(this, name)借用构造函数继承了Father类中的属性，如上一小节所说，这样继承的属性在Son类的不同实例中是独立的；Son.prototype = new Father()修改了Son类的原型，这样Son类的实例就能够通过原型链找到Father类中定义的方法 原型继承在object()函数内部, 先创建一个临时性的构造函数, 然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例 12345function object(o)&#123; function F()&#123;&#125; // 创建一个临时性的构造函数 F.prototype = o; // 将传入的对象作为这个构造函数的原型 return new F(); // 返回这个临时类型的一个新实例&#125; 实际上创建的新对象是传入的原对象o的一个浅复制，因为新的对象的原型被设置为了原对象o，所以新对象也就拥有了原对象的引用类型属性，即新对象与原对象的引用类型属性是共享的 前面提到的Object.create()就是原型继承的规范版本： object.create() 接收两个参数: 一个用作新对象原型的对象 (可选的)一个为新对象定义额外属性的对象 只有一个参数时，就是上面实现的object方法，如果接受第二个参数，它会将原来的同名属性覆盖： 123456789var person = &#123; name : \"Van\"&#125;;var anotherPerson = Object.create(person, &#123; name : &#123; value : \"Louis\" &#125;&#125;);alert(anotherPerson.name);//\"Louis\" 寄生式继承类似工厂模式，在原型继承的基础上，对新创建的对象增加了一些功能，然后再返回 1234567function createAnother(original)&#123; var clone = object(original);//通过调用object函数创建一个新对象 clone.sayHi = function()&#123;//以某种方式来增强这个对象 alert(\"hi\"); &#125;; return clone;//返回这个对象&#125; 寄生组合式继承*(不大明白)为了减小组合继承调用两次父类构造函数的开销提出的 12345function extend(subClass,superClass)&#123; var prototype = object(superClass.prototype);//创建对象 prototype.constructor = subClass;//增强对象 subClass.prototype = prototype;//指定对象&#125; 首先通过原型继承创建一个父类的实例，然后通过寄生式继承，为这个实例增加子类的构造函数，最后为子类指定原型为刚刚创建的父类的实例 ？ new运算符new运算符实际上做的工作是： 123var obj = &#123;&#125;; // 创建了一个空对象objobj.__proto__ = F.prototype; // 将这个空对象的__proto__成员指向了F函数对象prototype成员对象F.call(obj); // 将F函数对象的this指针替换成obj，然后再调用F函数 new 操作符调用构造函数的时候，函数内部实际上发生以下变化： 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this. 属性查找（1）当查找某个对象的属性时，JavaScript会沿着原型链一直寻找，直到Object.prototype，如果没有找到的话则会返回undefined （2）如果想避免原型链查找，可以通过hasOwnProperty方法，它不会遍历原型链，只会在对象内部查找 （3）isPrototypeOf功能与instanceof相反，它是用来判断该方法所属的对象是不是参数的原型对象，是则返回true，否则返回false （4）this instanceof arguments.callee 的值如果为 true 表示是作为构造函数被调用的,如果为 false 则表示是作为普通函数被调用 12345678function f()&#123; if(this instanceof arguments.callee) console.log('此处作为构造函数被调用'); else console.log('此处作为普通函数被调用');&#125;f();//此处作为普通函数被调用new f();//此处作为构造函数被调用 （5）typeof 则用以获取一个变量或者表达式的类型，如number，boolean，string，function（函数），object（NULL，数组，对象），undefined 一般的继承实现方式12345678910111213141516171819202122232425function Person(first, last, age, gender, interests) &#123; this.name = &#123; first, last &#125;; this.age = age; this.gender = gender; this.interests = interests; &#125; Person.prototype.greeting = function () &#123; alert('Hi! I\\'m ' + this.name.first + '.'); &#125;; function Teacher(first, last, age, gender, interests, subject) &#123; Person.call(this, first, last, age, gender, interests); this.subject = subject; &#125; Teacher.prototype = Object.create(Person.prototype); // 到这里的时候，Teacher.prototype.contructor === Person，所以下面这一步很有必要，否则就就破坏继承结构 Teacher.prototype.constructor = Teacher; 每一个函数对象（Function）都有一个prototype属性，并且只有函数对象有prototype属性，因为prototype本身就是定义在Function对象下的属性。当我们输入类似var person1=new Person(...)来构造对象时，JavaScript实际上参考的是Person.prototype指向的对象来生成person1。另一方面，Person()函数是Person.prototype的构造函数，也就是说Person===Person.prototype.constructor（不信的话可以试试）。 在定义新的构造函数Teacher时，我们通过function.call来调用父类的构造函数，但是这样无法自动指定Teacher.prototype的值，这样Teacher.prototype就只能包含在构造函数里构造的属性，而没有方法。因此我们利用Object.create()方法将Person.prototype作为Teacher.prototype的原型对象，并改变其构造器指向，使之与Teacher关联。 任何您想要被继承的方法都应该定义在构造函数的prototype对象里，并且永远使用父类的prototype来创造子类的prototype，这样才不会打乱类继承结构。 三种对象成员 那些定义在构造器函数中的、用于给予对象实例的。这些都很容易发现 - 在您自己的代码中，它们是构造函数中使用this.x = x类型的行；在内置的浏览器代码中，它们是可用于对象实例的成员（通常通过使用new关键字调用构造函数来创建，例如var myInstance = new myConstructor()）。 那些直接在构造函数上定义、仅在构造函数上可用的。这些通常仅在内置的浏览器对象中可用，并通过被直接链接到构造函数而不是实例来识别。 例如Object.keys()。 那些在构造函数原型上定义、由所有实例和对象类继承的。这些包括在构造函数的原型属性上定义的任何成员，如myConstructor.prototype.x()。 PromisePromise用法 参考： （1）https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises （2）http://es6.ruanyifeng.com/#docs/promise Promise实现原理 参考：https://juejin.im/post/5b83cb5ae51d4538cc3ec354 Fetch API 参考：https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch fetch与jQuery.ajax() 不同（1）当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject （2）默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项） 进行fetch请求（1）fetch的返回值是一个包含响应结果的Promise（一个Response对象，并非JSON）；为了获取JSON内容，需要使用json()方法 （2）fetch的第一个参数是请求的url，第二个参数是init，它的内容可以如下 12345678910111213141516fetch(url, &#123; body: JSON.stringify(data), // must match 'Content-Type' header cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached credentials: 'same-origin', // include, same-origin, *omit headers: &#123; 'user-agent': 'Mozilla/4.0 MDN Example', 'content-type': 'application/json' &#125;, method: 'POST', // *GET, POST, PUT, DELETE, etc. mode: 'cors', // no-cors, cors, *same-origin redirect: 'follow', // manual, *follow, error referrer: 'no-referrer', // *client, no-referrer&#125;).then(response =&gt; response.json()).then(data =&gt; console.log(data)) // JSON from `response.json()` call.catch(error =&gt; console.error(error)) 通过body设置请求实体，如果要传输json实体，则要在headers里面设置&#39;content-type&#39;: &#39;application/json&#39;，而且请求方式要是method: &#39;POST&#39; fetch返回的Promise对象通过then(response =&gt; response.json())转成json之后，便于后续的处理 如果要上传文件，可以通过FormData()来实现 12345678910111213var formData = new FormData();var fileField = document.querySelector(\"input[type='file']\");formData.append('username', 'abc123');formData.append('avatar', fileField.files[0]);fetch('https://example.com/profile/avatar', &#123; method: 'PUT', body: formData&#125;).then(response =&gt; response.json()).catch(error =&gt; console.error('Error:', error)).then(response =&gt; console.log('Success:', response)); 这里的body不需要转成json；FormData对象实际上就是一个键值对列表 多文件上传可以使用&lt;input type=&quot;file&quot; mutiple/&gt;来配合FormData 12345678910111213var formData = new FormData();var photos = document.querySelector(\"input[type='file'][multiple]\");formData.append('title', 'My Vegas Vacation');formData.append('photos', photos.files);fetch('https://example.com/posts', &#123; method: 'POST', body: formData&#125;).then(response =&gt; response.json()).then(response =&gt; console.log('Success:', JSON.stringify(response))).catch(error =&gt; console.error('Error:', error)); 检测请求是否成功由于返回resolved的Promise不一定是请求成功的，因此首先要判断Response.ok，再决定接下来的处理 123456789101112fetch('flowers.jpg').then(function(response) &#123; if(response.ok) &#123; // 如果response.ok是false的，实际上是取不到response.blob()的 return response.blob(); &#125; throw new Error('Network response was not ok.');&#125;).then(function(myBlob) &#123; var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL; &#125;).catch(function(error) &#123; console.log('There has been a problem with your fetch operation: ', error.message);&#125;); 自定义请求对象fetch还可以直接将第一、第二个参数封装成Request对象后再传递进去 12345678910111213141516// 请求头对象var myHeaders = new Headers();var myInit = &#123; method: 'GET', headers: myHeaders, mode: 'cors', cache: 'default' &#125;;var myRequest = new Request('flowers.jpg', myInit);fetch(myRequest).then(function(response) &#123; return response.blob();&#125;).then(function(myBlob) &#123; var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL;&#125;); Request()和fetch()接受的参数是一样的；由于Request()和Resonse Body被设计成了流的形式，不能被两次请求和读取，但可以通过拷贝再次使用request和response 1var anotherRequest = new Request(myRequest,myInit); 最佳实践是在使用响应的Promise之前检查 content type 是否正确 12345678910fetch(myRequest).then(function(response) &#123; // 判断响应头的contentType是不是json，是的话再将其转为json进行后续处理 if(response.headers.get(\"content-type\") === \"application/json\") &#123; return response.json().then(function(json) &#123; // process your JSON further &#125;); &#125; else &#123; console.log(\"Oops, we haven't got JSON!\"); &#125;&#125;); Response对象Response是fetch()处理完Promise后返回的，常见的属性有： Response.status — 整数(默认值为200) 为response的状态码 Response.statusText — 字符串(默认值为”OK”),该值与HTTP状态码消息对应 Response.ok — 该属性是来检查response的状态是否在200-299(包括200,299)这个范围内.该属性返回一个布尔值 Body实体请求和响应都可以包含Body，常见的类型有：ArrayBuffer、ArrayBufferView、Blob/File、String、URLSearchParams和FormData 可以通过Body类的arrayBuffer()、blob()、json()、text()和formData()方法来获取请求和响应的实体数据 当我们设置了Body实体但是没有在headers中设置contentType时，request和response会进行自动设置 Polyfill在不支持Fetch的浏览器中可以使用Fetch Polyfill 浏览器事件循环机制事件循环机制 参考：https://juejin.im/post/5afbc62151882542af04112d 事件循环可以简单描述为： （1）函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空; （2）在此期间WebAPIs完成这个事件，把回调函数放入CallbackQueue中等待; （3）当执行栈为空时，Event Loop把Callback Queue中的一个任务放入Stack中,回到第1步。 其中第（2）步是由浏览器的线程去完成，不关js引擎的事情 Event Loop是由javascript宿主环境（像浏览器）来实现的; WebAPIs是由C++实现的浏览器创建的线程，处理诸如DOM事件、http请求、定时器等异步事件; JavaScript 的并发模型基于”事件循环”; Callback Queue(Event Queue 或者 Message Queue) 任务队列,存放异步任务的回调函数 例子： 12345var start=new Date();setTimeout(function cb()&#123; console.log(\"时间间隔：\",new Date()-start+'ms');&#125;,500);while(new Date()-start&lt;1000)&#123;&#125;; 执行过程： main(Script) 函数入栈,start变量开始初始化 setTimeout入栈,出栈,丢给WebAPIs,开始定时500ms; while循环入栈,开始阻塞1000ms; 500ms过后,WebAPIs把cb()放入任务队列,此时while循环还在栈中,cb()等待; 又过了500ms,while循环执行完毕从栈中弹出,main()弹出,此时栈为空,Event Loop,cb()进入栈,log()进栈,输出’时间间隔：1003ms’,出栈,cb()出栈 宏任务和微任务（1）宏任务macro-task(Task)：一个event loop有一个或者多个task队列，task任务源有： setTimeout setInterval setImmediate I/O UI rendering （2）微任务micro-task(Job)：一个 event loop里只有一个microtask 队列，任务源有： process.nextTick promises Object.observe MutationObserver （3）例子： 12345678910111213Promise.resolve().then(function promise1 () &#123; console.log('promise1'); &#125;)setTimeout(function setTimeout1 ()&#123; console.log('setTimeout1') Promise.resolve().then(function promise2 () &#123; console.log('promise2'); &#125;)&#125;, 0)setTimeout(function setTimeout2 ()&#123; console.log('setTimeout2')&#125;, 0) 执行过程（脚本代码本身是一个task，会被列入task队列）： 循环1： 【task队列：script ；microtask队列：】 1、从task队列中取出script任务，推入栈中执行。 2、promise1列为microtask，setTimeout1列为task，setTimeout2列为task。 【task队列：setTimeout1 setTimeout2；microtask队列：promise1】 3、script任务执行完毕，执行microtask checkpoint，取出microtask队列的promise1执行。 循环2： 【task队列：setTimeout1 setTimeout2；microtask队列：】 4、从task队列中取出setTimeout1，推入栈中执行，将promise2列为microtask。 【task队列：setTimeout2；microtask队列：promise2】 5、执行microtask checkpoint，取出microtask队列的promise2执行。 循环3： 【task队列：setTimeout2；microtask队列：】 6、从task队列中取出setTimeout2，推入栈中执行。 7.setTimeout2任务执行完毕，执行microtask checkpoint。 【task队列：；microtask队列：】 *8、Update the rendering（更新渲染） 最关键的不同：每次event loop循环执行栈完成后，会继续执行完相应的microtask任务，最后每轮事件执行的最后，浏览器会去决定是否更新视图渲染（Update the rendering，也就是说可能不是每轮事件循环都去更新视图，只在有必要的时候才更新视图） async/await 参考：https://www.jianshu.com/p/ffa5cbe9ab29 JavaScript闭包（Closure） 参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures （1）JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量 （2）在循环中创建闭包的常见错误： 12345678910111213141516171819202122232425&lt;p id=\"help\"&gt;Helpful notes will appear here&lt;/p&gt;&lt;p&gt;E-mail: &lt;input type=\"text\" id=\"email\" name=\"email\"&gt;&lt;/p&gt;&lt;p&gt;Name: &lt;input type=\"text\" id=\"name\" name=\"name\"&gt;&lt;/p&gt;&lt;p&gt;Age: &lt;input type=\"text\" id=\"age\" name=\"age\"&gt;&lt;/p&gt;function showHelp(help) &#123; document.getElementById('help').innerHTML = help;&#125;function setupHelp() &#123; var helpText = [ &#123;'id': 'email', 'help': 'Your e-mail address'&#125;, &#123;'id': 'name', 'help': 'Your full name'&#125;, &#123;'id': 'age', 'help': 'Your age (you must be over 16)'&#125; ]; for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = function() &#123; showHelp(item.help); &#125; &#125;&#125;setupHelp(); 无论焦点在哪个input上，显示的都是关于年龄的信息，原因是赋值给onfocus的闭包是由他们的函数定义以及setupHelp作用域捕获的环境组成的，三个闭包在循环中被创建，但他们共享了同一个词法作用域，在这个作用域中存在一个变量item。当onfocus的回调执行时，item.help的值被决定。由于循环在事件触发之前早已执行完毕，变量对象item（被三个闭包所共享）已经指向了helpText的最后一项； 简单来说就是，三个闭包是共享词法作用域，而不是各自拥有不同的词法作用域，在setupHelp执行完毕时，他们共享的item已经指向了helpText最后一项 （3）解决方法 使用更多的闭包 123456789101112131415161718...function makeHelpCallback(help) &#123; return function() &#123; showHelp(help); &#125;;&#125;function setupHelp() &#123; ... for (var i = 0; i &lt; helpText.length; i++) &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = makeHelpCallback(item.help); &#125;&#125;... 这样赋值给onfocus的三个闭包不再共享词法作用域，而是各自拥有makeHelpCallback(help)中的不同词法作用域 使用匿名闭包 123456789101112...for (var i = 0; i &lt; helpText.length; i++) &#123; (function() &#123; var item = helpText[i]; document.getElementById(item.id).onfocus = function() &#123; showHelp(item.help); &#125; &#125;)(); // 马上把当前循环项的item与事件回调相关联起来 &#125;... 这样每次循环中赋值给onfocus的闭包拥有的此法环境就限制在了匿名函数内部 使用let而不是var关键字 12345678910...for (var i = 0; i &lt; helpText.length; i++) &#123; let item = helpText[i]; document.getElementById(item.id).onfocus = function() &#123; showHelp(item.help); &#125;&#125;... 关于let关键字，查看 1.5.12 节 （4）使用闭包的注意点 滥用闭包，会造成内存泄漏：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 会改变父函数内部变量的值：如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 this、 call、bind和apply 参考：https://juejin.im/post/59bfe84351882531b730bac2 关于thisthis 的指向并不是在创建的时候就可以确定的，在 es5 中，this永远指向最后调用它的那个对象（例子见参考链接） 改变this的指向 可以通过call、bind和apply改变this的指向 使用箭头函数 在函数内部使用_this = this临时保存定义函数的对象的this调用 箭头函数箭头函数的 this 始终指向函数定义时的 this，而非执行时。使用箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined” apply、call、bind 区别 apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数 1fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象 argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组 1fun.call(thisArg[, arg1[, arg2[, ...]]]) bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列；即bind 是创建一个新的函数，我们必须要手动去调用 123456789var a =&#123; name : \"Cherry\", fn : function (a,b) &#123; console.log( a + b) &#125;&#125;var b = a.fn;b.bind(a,1,2)() 再补充一点1234567891011121314151617181920212223242526// 1var a = &#123; name:'steve', b : function()&#123; setTimeout(()=&gt;console.log(this.name),100) &#125;&#125;a.b() //steve// 2var a = &#123; name:'steve', b : function()&#123; setTimeout(function()&#123;console.log(this.name)&#125;,100) &#125;&#125;a.b() //windowsName// 3var a = &#123; name:'steve', b : function()&#123; console.log(this.name) &#125;&#125;a.b() //steve （1）中使用的是箭头函数，由于函数闭包的作用，箭头函数里面的this.name是定义时的a对象的name属性，因此是steve，即使这个箭头函数是延迟执行的 如果没有使用箭头函数，由于setTimeout里面回调函数延迟执行的缘故，this指向的实际上是window对象，因此打印了windowsName 如果没有延迟执行，那么this.name指向的是最后调用的对象，在（3）中是使用a.b()来调用的，因此最后调用的对象是a，所以结果是steve 函数调用函数调用在js中一共有四种，如下 作为一个函数调用12345678var name = \"windowsName\";function a() &#123; var name = \"Cherry\"; console.log(this.name); // windowsName console.log(\"inner:\" + this); // inner: Window&#125;a();console.log(\"outer:\" + this) // outer: Window 这样定义的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined 函数作为（对象的）方法调用 在js中，函数是一个对象，它的内部有自己的属性和方法 12345678var name = \"windowsName\";var a = &#123; name: \"Cherry\", fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn(); 在这里，fn最后调用的对象是a，所以this.name指向的是a的name属性 *note： 123456789101112131415var name = \"windowsName\";var a = &#123; name : \"Cherry\", func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function 这个例子中，由于func2中调用了setTimeout方法，这个方法里面的回调函数不是立即执行的，因此当回调函数执行的时候，它的this指向已经不是对象a了，而是window对象，因此this.func1()函数不存在 （作为构造函数调用123456789// 构造函数:function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125;// This creates a new objectvar a = new myFunction(\"Li\",\"Cherry\");a.lastName; 作为构造函数调用后，创建了对象，自然里面的this也是指向创建的对象的 使用apply、call和bind调用这个就不多解释了 Currying柯里化 参考：https://juejin.im/post/5af13664f265da0ba266efcf （1）Currying的作用之一是 可以实现参数的复用，例如有一个多参数函数，当传递了第一个参数之后，得到一个柯里化后的函数用来接受剩下的参数，这样这个函数在调用时，第一个参数就已经是固定的，即被复用 （2）基于Currying原理的一个函数库lodash，参考：https://www.jianshu.com/p/d46abfa4ddc9 let、var和const 参考：https://www.jianshu.com/p/4e9cd99ecbf5 （1）ES6才添加的let和const （2）js中没有块级作用域，因此在JS函数中的var声明，其作用域是函数体的全部 1234for(var i=0;i&lt;10;i++)&#123; var a = 'a';&#125;console.log(a); （3）在循环中容易出现变量过度共享 12345for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 1000);&#125; 原因是setTimeout中的回调函数是延迟调用的，可以肯定的是必然晚于循环的执行完毕，而当循环调用完毕时，var i其实已经是3了，因此打印的是3 3 3而不是0 1 2 （4）将var换成let可以解决以上两个bug（note：必须声明 ‘use strict’ 后才能使用let声明变量，否则浏览器并不能显示结果） let声明的变量拥有块级作用域 let声明的全局变量不是全局对象的属性 形如for (let x…)的循环在每次迭代时都为x创建新的绑定。 如果一个for (let…)循环执行多次并且循环保持了一个闭包，那么每个闭包将捕捉一个循环变量的不同值作为副本，而不是所有闭包都捕捉循环变量的同一个值 用let重定义变量会抛出一个语法错误（SyntaxError） 12let a = 'a';let a = 'b'; // 报错 （5）let和var都支持解构赋值 （6）const 就是用来定义常量的：只声明不赋值、重复声明常量和修改常量的值都是不允许的 （7）如果在函数体内部声明变量时没有使用var、const或者let，那么声明的变量实际上是一个全局变量，函数体外部也能访问 CSSflex布局 参考：https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb 1.6.2 数据结构与算法数据结构队列（1）实现循环队列： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package tk.chph.demo.ds_alg;class MyCircularQueue &#123; private int[] data; private int front, end; /** * Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) &#123; this.data = new int[k + 1]; front = 0; end = 0; &#125; /** * Insert an element into the circular queue. Return true if the operation is successful. */ public boolean enQueue(int value) &#123; if (isFull()) return false; data[end++] = value; end = end % data.length; return true; &#125; /** * Delete an element from the circular queue. Return true if the operation is successful. */ public boolean deQueue() &#123; if (isEmpty()) return false; front = (++front) % data.length; return true; &#125; /** * Get the front item from the queue. */ public int Front() &#123; if (isEmpty()) return -1; return data[front]; &#125; /** * Get the last item from the queue. */ public int Rear() &#123; if (isEmpty()) return -1; return data[(end - 1+data.length)%data.length]; &#125; /** * Checks whether the circular queue is empty or not. */ public boolean isEmpty() &#123; return front == end; &#125; /** * Checks whether the circular queue is full or not. */ public boolean isFull() &#123; return (end - (front - data.length) +1) % (data.length) == 0; &#125;&#125; 这个实现方法：以长度为k的数组实现，data数组要长度为k+1，原因是要使得front==end能够作为isEmpty的条件，isFull判断条件是：(end - (front - data.length) +1) % (data.length) == 0，enQueue和deQueue时要注意end和front越界，同时由于end指向的元素是空的，因此Rear时要注意end-1可能会出现&lt;1的情况 （2）添加顺序和处理顺序相同时，可以考虑使用队列来解决 SSM+Redis框架Java动态代理技术和设计模式JDK动态代理（1）建立动态代理的步骤： 代理对象和真实对象建立代理关系 实现代理对象的逻辑方法 （2）在 JDK 动态代理中，要实现代理逻辑类必须去实现 java.lang.reflect.InvocationHandler接口，它里面定义了 一个 invoke 方法，并提供接口数组用于下挂代理对象 123456789101112131415161718192021222324252627282930313233343536373839interface HelloWorld &#123; public void sayHelloWorld();&#125;class HelloWorldImpl implements HelloWorld &#123; public void sayHelloWorld() &#123; System.out.println(\"Hello World!\"); &#125;&#125;class JdkProxyExample implements InvocationHandler &#123; // 真实对象 private Object target = null; // 建立代理对象和真是对象的关系，并返回代理对象 Object bind(Object target) &#123; this.target = target; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; // 代理方法的逻辑 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"进入代理逻辑方法\"); System.out.println(\"调度真实对象前的服务\"); Object obj = method.invoke(target, args); System.out.println(\"调度真实对象后的服务\"); return obj; &#125;&#125;public class ProxyTest &#123; public static void main(String[] args) &#123; JdkProxyExample jdk = new JdkProxyExample(); // 进行代理，并获得代理对象，这时候外部只能直接访问代理对象，不能直接访问真实对象 HelloWorld proxy = (HelloWorld) jdk.bind(new HelloWorldImpl()); proxy.sayHelloWorld(); &#125;&#125; 测试方法中返回的HelloWorld对象已经是一个代理对象，proxy.sayHelloWorld();的调用会进入invoke方法中 （3）JDK动态代理必须提供接口才能使用，比如例子中的HelloWorld接口；Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);中的target.getClass().getInterfaces()就是获取真是对象实现的接口，并将真实对象挂靠在接口下，HelloWorld proxy = (HelloWorld) jdk.bind(new HelloWorldImpl());也得通过接口来引用代理对象 CGLIB动态代理（1） CGLIB 动态代理的优势在于不需要提供接口，只要一个非抽象类就能实现动态代理 （2）代码示例 123456789101112131415161718192021222324252627282930313233343536import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodProxy;...// 真实对象class HelloWorldImpl implements HelloWorld &#123; public void sayHelloWorld() &#123; System.out.println(\"Hello World!\"); &#125;&#125;// 代理对象class Interceptor implements MethodInterceptor &#123; public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.err.println(\"调用真实对象前\"); Object result = methodProxy.invokeSuper(proxy, args); System.err.println(\"调用真实对象后\"); return result; &#125;&#125;// 通过Enhancer建立代理对象与真实对象之间的关系public class CglibProxyExample &#123; public Object getProxy(Class cls)&#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(cls); enhancer.setCallback(new Interceptor()); return enhancer.create(); &#125; public static void main(String[] args) &#123; CglibProxyExample cglibProxyExample = new CglibProxyExample(); HelloWorldImpl helloWorld = (HelloWorldImpl) cglibProxyExample.getProxy(HelloWorldImpl.class); helloWorld.sayHelloWorld(); &#125;&#125; 代理类要实现MethodInterceptor接口，并在invoke方法中实现代理逻辑方法 注意，通过反射调用真实对象的方法时是invokeSuper方法，如Object result = methodProxy.invokeSuper(proxy, args);，因为Enhancer建立代理对象与真实对象的关系时是将超类设为真实类，setCallback将代理类设为我们定义的Interceptor 拦截器（1）代码实例 设计者提供的 12345678910111213141516171819202122232425262728293031323334public class InterceptorJdkProxy implements InvocationHandler &#123; private Object target; private String interceptorClass; private InterceptorJdkProxy(Object target, String interceptorClass) &#123; this.target = target; this.interceptorClass = interceptorClass; &#125; public static Object bind(Object target, String interceptorClass) &#123; return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InterceptorJdkProxy(target, interceptorClass)); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (interceptorClass == null) &#123; return method.invoke(target, args); &#125; Object result = null; Interceptor interceptor = (Interceptor) Class.forName(interceptorClass).newInstance(); // 调用前置方法 if (interceptor.before(proxy, target, method, args)) &#123; // 前置方法返回true，反射原对象方法 result = method.invoke(target, args); &#125; else &#123; // 否则执行around方法 interceptor.around(proxy, target, method, args); &#125; // 调用后置方法 interceptor.after(proxy, target, method, args); return result; &#125;&#125; 12345public interface Interceptor &#123; boolean before(Object proxy, Object target, Method method, Object[] args); void after(Object proxy, Object target, Method method, Object[] args); void around(Object proxy, Object target, Method method, Object[] args);&#125; 开发者提供的 1234567891011121314151617public class MyInterceptor implements Interceptor &#123; @Override public boolean before(Object proxy, Object target, Method method, Object[] args) &#123; System.out.println(\"反射方法前逻辑\"); return false; &#125; @Override public void after(Object proxy, Object target, Method method, Object[] args) &#123; System.out.println(\"反射方法后逻辑\"); &#125; @Override public void around(Object proxy, Object target, Method method, Object[] args) &#123; System.out.println(\"取代了被代理对象的方法\"); &#125;&#125; 123456public class InterceptorTest &#123; public static void main(String[] args) &#123; HelloWorld proxy = (HelloWorld) InterceptorJdkProxy.bind(new HelloWorldImpl(), \"tk.chph.demo.proxy.interceptor.MyInterceptor\"); proxy.sayHelloWorld(); &#125;&#125; 这里使用的是JDK动态代理，对开发者来说，只需要实现设计者提供的拦截器接口Interceptor，然后通过bind方法将拦截器（代理对象）和自己的业务对象（真实对象）建立代理关系就可以了；而设计动态代理的代码全部由设计者来实现，开发者无需关心 另外拦截器实例化是被延迟到了代理方法（invoke）调用的时候才进行的，在此之前，代理对象只是保存了拦截器的全限定名 责任链模式（1）说白了就是：当一个对象在一条链上被多个拦截器拦截处理（拦截器也可以选择不拦截处理它）时，我们把这样的设计模式称为责任链模式 （2）责任链模式和拦截器的一点不同在于，要注意责任链模式上每个拦截器的before、after方法的执行顺序；责任链模式实质上是对代理对象进行代理，这样层层叠加： proxy3代理proxy2，proxy2代理proxy1，proxy1代理真实对象 这样在调用的时候，对proxy3来说，proxy2是它的真实对象，因此执行顺序是：proxy3.before-&gt;proxy2-&gt;proxy3.after，而proxy2的真实对象是proxy1，因此执行顺序变成了：proxy3.before-&gt;proxy2.before-&gt;proxy1-&gt;proxy2.after-&gt;proxy3.after，以此类推 观察者模式（发布订阅模式）（1）观察者模式定义了 一种一对多的依赖关系，让多个观察者对象同时监视着被观察者的状态，当被观察者的状态发生变化时 ， 会通知所有观察者 ， 并让其自动更新自己 （2）代码实例 被观察者，要继承Observable类 123456789101112131415161718192021public class ProductList extends Observable &#123; private List&lt;String&gt; productList=null; private static ProductList instance; private ProductList()&#123;&#125; public static ProductList getInstance()&#123; if (instance==null)&#123; instance = new ProductList(); instance.productList = new ArrayList&lt;&gt;(); &#125; return instance; &#125; public void addProduct(String newProduct)&#123; productList.add(newProduct); System.out.println(\"产品列表新增了产品：\"+newProduct); // =====注意这里===== this.setChanged(); this.notifyObservers(newProduct); &#125;&#125; 这里要注意的是，被观察者状态改变后，要调用setChanged将changed变量设为true，否则后面的notifyObservers方法没有效果；同时，notifyObservers方法调用完成后，changed为会被重新设置为false，等待下一次状态更新 观察者，要实现Observer接口及其接口里的update方法，因为被观察者调用notifyObservers方法，实际上是调用所有观察者的update方法 123456789101112131415class JingDongObserver implements Observer &#123; @Override public void update(Observable o, Object product) &#123; String newProduct = (String) product; System.err.println(\"发送新产品【\"+newProduct+\"】到京东商城\"); &#125;&#125;class TaoBaoObserver implements Observer &#123; @Override public void update(Observable o, Object product) &#123; String newProduct = (String) product; System.err.println(\"发送新产品【\"+newProduct+\"】到淘宝商城\"); &#125;&#125; 测试类 12345678public class ObserveTest &#123; public static void main(String[] args) &#123; ProductList productList = ProductList.getInstance(); productList.addObserver(new TaoBaoObserver()); productList.addObserver(new JingDongObserver()); productList.addProduct(\"MacBook Pro\"); &#125;&#125; Builder模式（1）很多时候由于对象的创建比较复杂，这时候就可以使用Builder模式，通过提供配置类来帮助创建复杂对象 （2）Builder 模式是一种分步构建对象的模式 Mybatis框架Mybatis的核心组件（1）mybatis核心组件由四部分组成 SqlSessionFactoryBuilder（构造器）：通过配置或者代码来生成SqlSessionFacotry对象，采用分步构建的Builder模式 SqlSessionFactory（工厂接口）：依靠它来生成SqlSession，使用工厂模式 SqlSession（会话）： 一个既可以发送 SQL 执行返回结果，也可以获取 Mapper 的接口。在现有的技术中， 一般我们会让其在业务逻辑代码中“消失”，而使用的是MyBatis 提供的 SQLMapper 接口编程技术，它能提高代码的可读性和可维护性 SQL Mapper（映射器）：MyBatis 新设计存在的组件，它由一个 Java 接口和 XML文件（或注解）构成，需要给出对应的 SQL 和映射规则。它负责发送 SQL 去执行，并返回结果 *Note：无论是映射器还是 SqlSession 都可以发送 SQL 到数据库执行 （2）SqlSessionFactory （工厂接口） Mybatis提供构造器SqlSessionFactoryBuilder以及配置类org.apache.ibatis.session.Configuration来生产SqlSessionFactory对象 org.apache.ibatis.session.Configuration对象既可以通过读取XML文件来生成，也可以直接通过Java代码来定义，它是整个mybatis的上下文 SqlSessionFactory是一个接口，它的实现类有SqlSessionManager和DefaultSqlSessionFactory；一般而言都是使用DefaultSqlSessionFactory，而SqlSessionManager用在多线程里，它的实现依靠DefaultSqlSessionFactory SqlSessionFactory唯一的作用是生产Mybatis的核心接口对象SqlSession，因此它一般来说是单例模式 使用XML文件描述SqlSessionFactory的配置文件就是mybatis-config.xml，然后就可以创建SqlSessionFactory对象了 12InputStream inputStream = Resource.getResourceAsStream(\"mybatis-config.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 采用XML配置的形式好处是：信息在配置文件中，便于后期维护和修改；同时不需要重新编译代码 （3）SqlSession 有两个实现类：DefaultSqlSession（用于单线程）和SqlSessionManager（用于多线程） SqlSession类似一个JDBC中的一个Connection，管理者一个连接中的资源启用 获取Mapper接口 1RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class); 发送SQL给数据库 控制数据库事务（提交和回滚） 使用SqlsessionFactory创建SqlSession的方法 1SqlSession sqlSession = sqlSessionFactory.openSession(); SqlSession只是一个门面接口，底层真正在工作的是Executor （4）映射器 它由一个接口和对应的XML（或者注解）组成 映射器的主要作用就是将 SQL 查询到的结果映射为一个 POJO，或者将 POJO 的数据插入到数据库中 ， 并定义一些关于缓存等的重要内容 Mybatis使用动态代理技术，根据XML或者注解的描述为接口创建一个代理对象去处理相关的逻辑 同时使用注解和XML创建映射器时，XML的方式会覆盖注解的定义 （5）发送SQL语句到数据库 SqlSession方式 1Role role = (Role) sqlSession.selectOne(\"com.learn.ssm.chapter3.mapper.RoleMapper.getRole\", 11); Mapper接口方式 12RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);Role role = roleMapper.getRole(1L); （6）生命周期 SqlSessionFactoryBuilder：它的作用是创建SqlSessionFactory，创建完后就失去了作用，可以被JVM回收了 SqlSessionFactory：作用相当于一个数据库连接池，一旦创建了 SqlSessionFactory ， 就要长期保存它，直至不再使用 MyBatis 应用，所以可以认为 SqlSessionFactory 的生命周期就等同于 MyBatis 的应用周期；同时一般要求SqlSessionFactory是一个单例，在应用中被共享 SqlSession：SqlSession 就相当于一个数据库连接（ Connection 对象），它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给 SqlSessionFactory ， 否则数据库资源就很快被耗费精光，系统就会瘫痪 Mapper：它由 SqlSession 所创建，所以它的最大生命周期至多和 SqlSession保持一致；但由于SqlSession关闭后，它的数据库连接资源也会消失，所以它的生命周期应该小于等于 SqlSession 的生命周期 ；Mapper 代表的是一个请求中业务处理的一个步骤，所以它应该在一个请求中，一旦处理完了相关的业务，就应该随着SqlSession的关闭而废弃它 MyBatis 的解析和运行原理Spring-Mybatis整合（1）配置数据源 简单数据源SimpleDriverDataSource，没有提供数据库连接池功能 数据库驱动driver 数据库连接url 用户名username 密码password 第三方数据库连接池数据源DBCP（dbcp.BasicDataSource），提供了数据库连接池功能 数据库驱动driver 数据库连接url 用户名username 密码password 数据库连接池配置：maxActive、maxIdle、maxWait等 从web服务器获取数据源JNDI（jndi.JndiObjectFactoryBean） web服务器配置的数据源名称 jndiName （2）配置SqlSessionFactoryBean 数据源datasource mybatis配置文件configLocation （3）配置MapperScannerConfigurer 扫描路径basePackages SqlSessionFactoryBeanName 映射器的注解annotationClass Spring框架Spring IoC（1）控制反转是一种通过描述（在 Java中可以是 XML 或者注解）并通过第三方去产生或获取特定对象的方式。在 Spring 中实现控制反转的是 IoC 容器，其实现方法是依赖注入 （Dependency Injection, DI ） （2）Spring IoC容器主要是基于BeanFactory 和 ApplicationContext 两个接口，其中ApplicationContext 是 BeanFactory 的子接口之一，在绝大部分的工作场景下 ， 都会使用 ApplicationContext 作为Spring IoC 容器 （3）Spring IoC的初始化包括Bean的初始化和依赖注入两个步骤 Bean初始化 Resource 定位，这步是 Spring IoC 容器根据开发者的配置，进行资源定位，在 Spring的开发中，通过 XML 或者注解都是十分常见的方式 BeanDefinition 的载入，这个过程就是 Spring 根据开发者的配置获取对应的 POJO,用以生成对应实例的过程 BeanDefinition 的注册 ，这个步骤就相当于把之前通过 BeanDefinition 载入的 POJO往 Spring IoC 容器中注册，这样就可以使得开发和测试人员都可以通过描述从中得到 SpringIoC 容器的 Bean 了 依赖注入：在完成依赖注入之前的Bean还不能够使用，对于依赖注入，spring中默认的lazy-init（是否初始化Bean）是false，即 Spring IoC 默认会自动初始化 Bean；如果将其设置为 true，那么只有当我们使用 Spring IoC 容器的 getBean 方法获取它时，它才会进行初始化， 完成依赖注入。 （4）Spring Bean的生命周期 （占个坑orz） Spring Bean的装配（1）依赖注入的三种方式 构造器注入 setter注入 接口注入？ （2）将Bean装配进Spring IoC的配置方式（以注解为主，XML为辅） 在XML中显式配置 在Java的接口和类中实现配置 隐式Bean的发现机制和自动装配原则 （3）三种装配Bean方式的优先级 基于约定优于配置的原则，优先选择隐式Bean的发现机制和自动装配原则 在没法使用自动配置原则情况下，优先使用在Java的接口和类中实现配置，这样可以避免XML配置泛滥；同时，当一个父类有多个子类时，如果想通过IoC容器初始化父类，容器将无法决定使用哪个子类去初始化，这时候可以通过Java注解的方式去指定一个子类 最后选用XML方式，因为有时候使用第三方库时，没法取修改这些类库代码，这时候就可以通过XML方式去配置，将第三方类库的Bean装配到Spring IoC容器中 （4）XML装配Bean 1234567&lt;beans&gt; &lt;bean id=\"role2\" class=\"com.ssm.chapter9.pojo.Role\" &gt; &lt;property name=\"id\" value=\"1\"/&gt; &lt;property name=\"roleName\" value=\"高级工程师\"/&gt; &lt;property name=\"note\" value=\"重要人员\"/&gt; &lt;/bean&gt;&lt;/beans&gt; id是spring找到这个Bean的编号，如果没有指定，则spring会自动生成“全限定名#{num}”格式的编号 class是这个Bean的类的全限定名 property是定义类的属性，name是属性名，value是属性值，另外属性的值如果是引用类型，可以通过ref=“{source.id}”来引用定义的其他bean 当property是集合时，可以通过如下方式来定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!-- 列表 --&gt;&lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;value-list-1&lt;/value&gt; &lt;value&gt;value-list-2&lt;/value&gt; &lt;value&gt;value-list-3&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!-- 映射 --&gt;&lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"key1\" value=\"value-key-1\"/&gt; &lt;entry key=\"key2\" value=\"value-key-2\"/&gt; &lt;entry key=\"key3\" value=\"value-key-3\"/&gt; &lt;/map&gt;&lt;/property&gt;&lt;!-- Property --&gt;&lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"prop1\"&gt;value-prop-1&lt;/prop&gt; &lt;prop key=\"prop2\"&gt;value-prop-2&lt;/prop&gt; &lt;prop key=\"prop3\"&gt;value-prop-3&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;!-- 集合 --&gt;&lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;value-set-1&lt;/value&gt; &lt;value&gt;value-set-2&lt;/value&gt; &lt;value&gt;value-set-3&lt;/value&gt; &lt;/set&gt;&lt;/property&gt;&lt;!-- 数组 --&gt;&lt;property name=\"array\"&gt; &lt;array&gt; &lt;value&gt;value-array-1&lt;/value&gt; &lt;value&gt;value-array-2&lt;/value&gt; &lt;value&gt;value-array-3&lt;/value&gt; &lt;/array&gt;&lt;/property&gt; 如果list、map、set和array这些集合的元素是一个类而不是基本数据类型，那么可以将&lt;value/&gt;替换为&lt;ref bean=”xxx”/&gt;（map中&lt;entry/&gt;的key替换为key-ref、value替换为value-ref）来引用别处定义好的bean，这样就完成了类集合的Bean定义 （5）Spring中，Spring IoC容器发现Bean的方式有两中： 组件扫描：通过定义资源的方式 ， 让 Spring IoC 容器扫描对应 的包 ，从而把 Bean装配进来 自动装配：通过注解定义，使得一些依赖关系可以通过注解完成 常见的注解如下： @Component 1234567891011@Component(value = \"role\")public class Role&#123; @Value(\"1\") private Long id; @Value(\"role_name_1\") private String roleName; @Value(\"role_note_1\") private String note; // setters and getters&#125; 其中@Component表示Spring IoC会将这个类扫描成Bean实例，value后面的值是Bean在Spring中的id编号；如果不知道value，Spring会自动生成编号 @Value代表的是值的注入 @ComponentScan 123@ComponentScanpublic class PojoConfig&#123;&#125; 只有@Component还不行，还得设置@ComponentScan告诉Spring要扫描的包路径，这里没有设置值，则默认是扫描PojoConfig所在包下的类，所以上面的Role要和PojoConfig放在一起才能被Spring扫描到 @ComponentScan有两个配置项：basePackages，接受一个Java包数组，Spring会根据配置来扫描对于的包和这些包下面的子包；basePackagesClasses，它接受一个类的数组，Spring会根据这些类所在的包，为包和子包进行扫描装配对应配置的Bean 要注意的是： 如果定义了多个@ComponentScan，每个@ComponentScan都会对扫描到的Bean生成一个实例，这就可能出现很多重复的实例 但是对于同一个@ComponentScan里面的basePackages和basePackagesClasses，两者如果有出现扫描重复的Bean，也只会生成一个Bean实例 123ApplicationContext context =new AnnotationConfigApplicationContext(PojoConfig.class);Role role= context.getBean(Role.class); 接下来只需要将配置类PojoConfig添加到context中，就能通过context来获取Spring IoC扫描到的Bean实例了 自动装配@Autowired Spring在生成所有Bean后，如果发现有这个注解，就会根据类型在Bean容器中查找对应的Bean，将其注入进来，这就是依赖注入 如果IoC容器寻找失败，默认情况下会抛出异常，如果有些字段的实例可有可无，可以设置@Autowired(require = false)，这样IoC在没有找到对应的Bean实例的时候就不会抛出异常了 根据类型注入的问题在于：当Java中的一个接口（或者抽象类）有多个实现类的时候，这样就会造成通过类型（ by type ）获取 Bean 的不唯一 ， 从而导致 Spring IoC 类似于按类型的方法无法获得唯一的实例化类，这就是自动装配的歧义性。解决歧义性的方法是@Primary和@Qualifier： ＠Primary 注解告诉 Spring IoC 容器，如果存在某个类型的多个子类型，无法判断注入哪个的时候，优先将注解有@Primary 的实例注入 @Qualifier 注解是告诉Spring IoC容器根据Bean的名称而不是类型来进行注入，由于Bean的id的唯一性，这样就消除了歧义性 注意，@Primary是注解到Bean上的，@Quality是注解到Bean的引用变量上的 123456789@Component(\"roleService3\")@Primarypublic class RoleServiceimpl implements RoleService&#123; ...&#125;@Autowired@Qualifier(\"roleService3\")private RoleService roleService = null ; @Qualifier和@Autowired这两个注解可以注解到参数变量上 @Component只能注解到类上，不能注解到方法上；可以通过注解@Bean注解到方法上（但不能注解到类上），将方法的返回值作为Spring的Bean存放到IoC容器中 @Bean有四个配置项 name ： 是一个字符串数组，允许配置多个 BeanName autowire：标志是否是一个引用的 Bean 对象，默认值是 Autowire.NO initMethod ： 自定义初始化方法 destroyMethod ： 自定义销毁方法。 ＠ImportResource 如果使用XML和注解混用的方式配置Bean的时候，可以在配置类上面使用＠ImportResource来引入XML定义的Bean，这样就能将XML定义的Bean扫描进IoC容器 123@ImportResource(&#123;\"classpath:spring-dataSource.xml\", \"...\", ...&#125;)//接受一个数组public class ApplicationConfig&#123;&#125; @Import 如果配置分散到多个配置类中，那么就可以在主配置类上使用@Import来引入其他的配置类 1234@ComponentScan@Import(&#123;ApplicationConfig2.class, ApplicationConfig3.class, ...&#125;)//接受一个数组public class ApplicationConfig &#123;&#125; （6）使用Profile @Profile注解主要是配置Spring Bean的作用环境的（dev环境、test环境还是prod环境等） @Profile注解在Bean上 1234567891011@Bean(name = \"devDataSource\")@Profile(\"dev\")public DataSource getDevDataSource()&#123; ...&#125;@Bean(name = \"testDataSource\")@Profile(\"test\")public DataSource getDevDataSource()&#123; ...&#125; 激活Profile 在使用 Spring MVC 的情况下可以配置Web上下文参数 ，或者 DispatchServlet 参数 作为 JNDI 条目 配置环境变量 配置 JVM 启动参数 在集成测试环境中使用＠ActiveProfiles （9）加载属性（properties）文件 使用注解@PropertySource来加载属性文件，它有四个配置项： name ： 字符串，配置这次属性配置的名称 value ： 字符串数组，可以配置多个属性文件 ignoreResourceNotFound : boolean 值，默认为false，其含义为如果找不到对应的属性文件是否进行忽略处理，由于默认值为 false，所以在默认的情况下找不到对应的配置文件会抛出异常 encoding：编码，默认为”” 12345@Configuration@PropertySource(value=&#123;\"classpath:database-config.properties\"&#125;,ignoreResourceNotFound=true)public class ApplicationConfig &#123;&#125; 使用配置文件的属性 加载属性文件后，就可以通过context.getEnvironment().getProperty(&quot;xxx&quot;)来获得属性文件中的属性值，xxx是属性名 1String url = context.getEnvironment().getProperty(\"jdbc.database.url\"); 属性文件解析类PropertySourcesPlaceholderConfigurer 123456789@Configuration@PropertySource(value=&#123;\"classpath:database-config.properties\"&#125;,ignoreResourceNotFound=true)public class ApplicationConfig&#123; @Bean public PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer()&#123; return new PropertySourcesPlaceholderConfigurer(); &#125;&#125; 这样就可以直接使用@Value来引用配置的属性和占位符了 12345678910@Componentpublic clss DataSourceBean&#123; @Value(\"$&#123;jdbc.datasource.driver&#125;\") private String driver = null; @Value(\"$&#123;jdbc.datasource.url&#125;\") private String driver = url; ...&#125; （10）条件化装配Bean @Conditional可以配置一个或者多个类，这些类都得实现接口Condition 12345@Bean(name = \"dataSource\")@Conditional(&#123;DataSourceCondition.class, ...&#125;)public DataSource getDataSource()&#123; ...&#125; 1234567public class DataSourceCondition implements Condition&#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata)&#123; Environment env = context.getEnvironment(); return env.containsProperty(\"jdbc.database.driver\") &amp;&amp; ...; &#125;&#125; 可以通过context获得Spring的运行环境，当matches方法返回值为true时则装配Bean，返回false则不会创建对应Bean 这样的作用是，如果属性配置文件的属性没有配置完整的话，可能会导致对应的Bean初始化失败，配置了@Conditional之后，可以自定义在属性配置完整后才初始化Bean （11）Bean的作用域 默认情况下，Spring IoC容器会为配置的Bean生成一个实例，而不是多个 Spring 提供了 4 种作用域，它会根据情况来决定是否生成新的对象： 单例（ singleton ）：它是默认的选项，在整个应用中 ， Spring 只为其生成一个 Bean的实例 原型（ prototype ） ： 当每次注入，或者通过 Spring IoC 容器获取 Bean 时， Spring 都会为它创建一个新的实例 会话（ session ） ： 在 Web 应用中使用，就是在会话过程中 Spring 只创建一个实例 请求（ request ） ： 在 Web 应用中使用的，就是在一次请求中 Spring 会创建一个实例，但是不同的请求会创建不同的实例（和会话不同的是，一次会话中可能会有多次请求） 使用@Scope注解在Bean上面来配置Bean的作用域 1@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) Spring AOP（1）AOP的流程 （2）常见术语 切面（Aspect）：整个工作环境，想当一个拦截器 通知（Advice）：通知是切面开启后，切面的方法。它根据在代理对象真实方法调用前、后的顺序和逻辑区分 引入（Introduction）：引入允许我们在现有的类里添加自定义的类和方法 切点（Pointcut）：动态代理中，被切面拦截的方法就是一个切点 连接点（join point）：连接点是一个判断条件，由它可以指定哪些是切点。对于指定的切点， Spring 会生成代理对象去使用对应的切面对其拦截，否则就不会拦截它 织入（Weaving）：生成代理对象的过程，Spring中使用JDK动态代理技术来织入 （3） SpringAOP 是一种基于方法拦截的 AOP，换句话说 Spring 只能支持方法拦截的 AOP （4）Spring 中有 4 种方式去实现 AOP 的拦截功能： 使用 ProxyFactoryBean 和对应的接口实现 AOP 使用 XML 配置 AOP 使用＠AspectJ 注解驱动切面（最常用） 使用 AspectJ 注入切面 （5）使用＠AspectJ 注解驱动切面 创建切面 Spring中只需要使用@Aspect注解一个类，那么Spring IoC容器就会认为这是一个切面 添加通知（各个通知的调用顺序如下图） 连接点：连接点是添加在通知注解里的 1234@Before(\"execution(*com.ssm.chapter11.aop.service.impl.RoleService.printRole(...))\")public void before()&#123; ...&#125; @Before里面的正则表达式就是连接点 execution ： 代表执行方法的时候会触发 *： 代表任意返回类型的方法 com.ssm.chapter11.aop .service.impl.RoleServicelmpl：代表类的全限定名 printRole ： 被拦截方法名称 (…) ： 任意的参数 切点：如果每个通知里面都重复写一样的连接点会很麻烦，这时候可以使用切点@Pointcut来解决 1234567891011121314@Pointcut(\"execution(*com.ssm.chapter11.aop.service.impl.RoleService.printRole(...))\")public void print()&#123; // 可以是空的&#125;@Before(\"print()\")public void before()&#123; ...&#125;@After(\"print()\")public void after()&#123; ...&#125; 这样print()就变成了这个切面的切点了，在通知中只需要将切点方法作为连接点就行了，避免重复书写冗长的正则表达式 启用AspectJ自动代理 123456789@Configuration@EnableAspectJAutoProxy@ComponentScanpublic class AppConfig&#123; @Bean public RoleAspect getRoleAspect()&#123; return new RoleAspect(); &#125;&#125; @EnableAspectJAutoProxy代表着启用 AspectJ 框架的 自动代理，这个时候 Spring 才会生成动态代理对象，进而可以使用 AOP；然后将我们定义的RoleAspect这个切面通过@Bean初始化到IoC容器中，这样就可以拦截printRole方法了 环绕通知 123456@Around(\"print()\")public void around(ProceedingJoinPoint jp)&#123; ... // 语句1 jp.proceed(); ... // 语句2&#125; 环绕通知Spring会提供一个参数ProceedingJoinPoint用来反射调用被代理对象的原有方法，这样实际上环绕通知可以在jp.proceed()前后实现@Before和@After一样的功能了; 假如也实现了@Before和@After通知的话，Spring调用的顺序是： ​ 语句1-&gt;@Before-&gt;print()-&gt;语句2-&gt;@After-&gt;@AtfterReturning/@AfterThrowing 织入 织入是生成代理对象的过程，在上述的代码中，切点方法所在的类都是拥有接口的类，而事实上即使没有接口 ， Spring 也能提供 AOP 的功能 当类的实现存在接口的时候， Spring 将提供 JDK 动态代理，从而织入各个通知 当类不存在接口的时候没有办法使用 JDK 动态代理，Spring 会采用 CGLIB 来生成代理对象 给通知传递参数 使用args()函数来给各类通知传递切点方法的参数 1234@Before(\"execution(*com.ssm.chapter11.aop.service.impl.RoleService.printRole(...)) &amp;&amp; args(role, sort)\")public void before(Role role, int sort)&#123; ...&#125; 注意这里，传给通知的参数是和传递给通知方法printRole(role, sort)一样的，这样就能够在前置方法中对传递的参数进行检查，不合法的话可以拦截下来，从而不调用拦截方法 引入 可以通过定义一个接口，在生成动态代理对象时将被拦截对象挂靠在这个接口上，就可以为被拦截对象添加新的功能了 1234567891011121314interface RoleVerifier&#123; boolean verify(Role role);&#125;class RoleVerifierImpl implements RoleVerifier&#123; @Override public boolean verify(Role role)&#123; return role != null; &#125;&#125;// 然后在切面类中添加如下代码@DeclareParents(value = \"com.ssm.chapter11.aop.service.impl.RoleServiceImpl+\", defaultImpl = RoleVerifierImpl.class)public RoleVerifier roleVerifier; @DeclareParents配置项： value=”com.ssm.chapter11.aop.service.impl.RoleServiceImpl+”： 表示对 RoleServicelmpl类进行增强，也就是在 RoleServicelmpl 中引入一个新的接口 defaultlmpl：代表其默认的实现类，这里是 RoleVerifierlmpl 实现的原理其实是在生成代理对象时， 1return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this) obj.getClass().getInterfaces()是用来给被代理对象添加挂靠接口的，只要生成代理对象时将它挂靠在我们声明的RoleVerifier接口上面，这样我们就能够通过强制类型装换将被代理对象转化为RoleVerifier，进而调用我们引入的方法（CGLIB动态代理也一样，Enhancer也有个提供挂靠接口的方法） 123456RoleService roleService = ctx.getBean(RoleService.class );RoleVerifier roleVerifier = (RoleVerifier) roleService;// 调用引入的方法if(roleVerifier.verify(role))&#123; ...&#125; 一个方法有多个切面时，这些切面的调用顺序是根据切面在配置类中的配置顺序来调用的；也可以通过注解@Order来在切面声明时给这些切面设置优先级（优先级一样时，依旧是按照配置顺序来调用的）；这其实就是一种责任链模式 12345@Aspect@Order(1)public class Aspect1&#123; ...&#125; 当然也可以通过实现Ordered接口，在gerOrder()方法中返回优先级也可以实现和@Order注解一样的效果 1234567@Aspectpublic class Aspect1 implements Ordered&#123; @Override public int getOrder() &#123; return 1; &#125;&#125; Spring数据库事务管理（1） MyBatis 框架用得最多的事务管理器是 DataSourceTransactionManager，配置事务管理器要提供数据源 123&lt;bean id＝\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; （2）数据库资源的产生和释放如果没有委托给数据库管理器，那么就由 jdbcTemplate 管理 ，但是此时已经委托给了事务管理器，所以jdbcTemplate 的数据库资源和事务己经由事务管理器处理了 （3）在配置类中使用注解＠EnableTransactionManagement后 ， 在 Spring 上下文中使用事务注解＠Transactional, Spring 就会知道使用这个数据库事务管理器管理事务了 （4）用 Java 配置的方式来实现 Spring 数据库事务，需要在配置类中实现接口TransactionManagementConfigurer 的 annotationDrivenTransactionManager 方法 。 Spring 会把annotationDrivenTransactionManager 方法返回的事务管理器作为程序中的事务管理器 123456789// 实现接口方法 ， 使得返回数据库事务管理器@Override@Bean(name=\"transactionManager\")public PlatformTransactionManager annotationDrivenTransactionManager()&#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); // initDataSource()是配置类中配置的数据源Bean transactionManager.setDataSource(initDataSource()); return transactionManager;&#125; （5）声明式事务（一种约定式事务） 如果使用的是声明式事务，那么当你的业务方法不发生异常（或者发生异常 ， 但该异常也被配置信息允许提交事务）时， Spring 就会让事务管理器提交事务 发生异常（并且该异常不被你的配置信息所允许提交事务）时，则让事务管理器回滚事务。 （6）＠Transactional （7）数据库事务 ACID特性 原子性：一个事务中的操作要么全部成功，要么全部失败，不可能停滞在中间的某个状态 一致性：事务可以修改数据库封装的状态，但是无论并发的事务有多少，数据库封装的状态都是一致的 隔离性：不同事务之间的隔离程度 持久性：事务一旦执行成功，那么该事务对数据库所做的修改就是永久保存的，不会被回滚 丢失更新 第一类丢失更新：一个事务提交、一个事务回滚导致的提交事务的更新丢失（当前主流数据库已经克服了此类更新） 第二类丢失更新：由于无法探知其他事务中的操作，导致两个或多个事务都提交后的更新丢失（即一个事务将之前事务的更新给覆盖掉） 隔离级别 脏读：允许一个事务去读取其他事务中已经修改但尚未提交的数据（如果被脏读的事务回滚了，这属于第一类更新丢失的情况，但是主流数据库已经克服了此类更新丢失，这样回滚的事务不会覆盖成功提交的事务，出现的问题就是相当于回滚的事务不起作用，成功提交的事务使用了脏读的数据进行数据库更新导致数据库最终的状态是保存了错误的数据） 读/写提交：一个事务只能读或者写另一个事务已经提交的数据（这样在一个事务成功提交、一个事务回滚的情况下，成功提交的事务没有脏读，回滚的事务由于第一类更新丢失被数据库的设计克服了，不会覆盖成功提交的事务；但是会出现的一个情况是，如果另一个事务B没有回滚，而是在另一个事务成功提交前也成功提交了，会导致最后提交的事务A出现不可重复读的现象，即 A在B提交前和B提交后读取的数据不一致） 可重复读：可重复读是针对同一条记录而言的，即不同事务对同一条记录的读/写按照一个序列化进行操作，不会产生交叉现象，保证了同一条数据的一致性（这个级别的隔离会导致幻读现象，幻读是针对多条记录而言的，即事务A在查询数据库多条记录，同时事务B往数据库添加或者删除了一条记录并成功提交后，事务A在提交时会幻读多出/少掉一条） 序列化：让SQL按照序列化的顺序进行读写操作，即所有事务对数据库的读写操作都是按照顺序执行的，不会产生交叉，这样就可以克服幻读现象了 （8）隔离级别和传播行为的选择 选择隔离级别的出发点在于两点 ： 性能和数据一致性，从脏读到序列化，系统性能直线下降，例如序列化，直接就抑制了并发，导致大量的请求被挂起 @Transactional通过Isolation设置隔离级别，通过propagation设置传播行为 ＠Transactional 隔离级别的默认值为 Isolation .DEFAULT，其含义是默认的，随数据库默认值的变化而变化 传播行为是指方法之间的调用事务策略的问题，一个方法调度另外一个方法时，可以对事务的特性进行传播配置；即当一个事务中是由多个数据库操作完成的（不同的方法），而这些操作之间是相互独立的，那么其中一个操作失败时，没必要回滚整个事务，而只需要将失败的那个操作回滚就可以了，因为这个回滚操作对其他的独立的操作不会造成数据不一致性的影响 （9）@Transactional 的自调用失效问题 注解＠Transaction 的底层实现是 SpringAOP 技术，而 SpringAOP 技术使用 的是动态代理 。 这就意味着对于静态（ static ）方法和非 public 方法 ， 注解＠Transactional 是失效的 由于＠Transactional 的实现原理是AOP ，而 AOP 的实现原理是动态代理 ，如果是自己调用自己的过程，并不存在代理对象的调用，这样就不会产生 AOP 去为我们设置＠Transactional配置的参数，这样就出现了自调用注解失效的 问题；解决的方法时，不直接进行自调用，而是通过从容器中获取代理对象来间接进行自调用，这样就能够启用AOP技术了 12// 从容器中获取 RoleService 对象 ，实际是一个代理对象RoleService service = ctx.getBean(RoleService.class); （10）使用@Transactional时的一些注意点 如果前后调用带有@Transactional的方法，那么这两次调用不在同一个事务中 不要长时间占用事务，比如在事务中长时间处理和数据库事务无关的东西，这样会严重浪费数据库资源 在@Transactional方法中捕获到异常时一定要再将其抛出，让Spring的事务管理器去处理；否则如果没有抛出，事务管理器就会任务代码运行正常，不会对出错的事务进行回滚 SpringMVC框架SpringMVC的组件和流程 （1）Servlet在初始化时，SpringMVC会根据配置获取配置信息，从而得到统一资源标识符URI和处理器Handler之间的映射关系（HandlerMapping）；同时为了更加灵活和增强功能，SpringMVC还给处理器加入了拦截器Interceptor，可以在处理器执行前后加入自己的功能，这样就构成了一个处理器执行链（HandlerExecutionChain）（拦截器+处理器） （2）当一个请求过来时，DispatchServlet首先通过请求和实现解析好的HandlerMapping，找到对应的处理器Handler，然后就准备开始执行拦截器和处理器 （3）由于运行处理器需要有一个对应的环境，它可以通过请求类型找到处理器适配器HandlerAdapter来运行对应的处理器及其拦截器，然后处理器将模型和视图ModalAndView返回给DispatchServlet （4）如果是逻辑视图，那么DispatchServlet就会将它传递给视图解析器ViewResolver解析它，将模型渲染到视图中去；如果不是逻辑视图，则不会进行处理，直接通过视图渲染数据模型 （5）最后将渲染好的视图返回给客户端 SpringMVC的初始化（1）初始化 Spring IoC 容器上下文 12345678910111213public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123; public void contextInitialized(ServletContextEvent event) &#123; // 初始化Spring IoC容器，使用的是满足ApplicationContext接口的Spring Web IoC容器 this.initWebApplicationContext(event.getServletContext()); &#125; public void contextDestroyed(ServletContextEvent event) &#123; // 关闭Web IoC容器 this.closeWebApplicationContext(event.getServletContext()); // 清除相关参数 ContextCleanupListener.cleanupAttributes(event.getServletContext()); &#125;&#125; DispatcherServlet 初始化前完成 Spring IoC 容器的初始化 在结束期完成对Spring IoC 容器的销毁 （2）初始化映射请求上下文 （略orz，SSM框架书籍P379页） （3）使用注解配置方式初始化 继承一个名字比较长的类 AbstractAnnotationConfigDispatcherServletlnitializer，然后实现它所定义的方法 12345678910111213141516171819202122public class MyWebAppinitializer extends AbstractAnnotationConfigDispatcherServletinitializer &#123; // Spring IoC 容器配置 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; // 可以返回 Spring 的 Java 配置文件数组 return new Class&lt;?&gt; [] &#123;&#125; ; &#125; //DispatcherServlet 的 URI 映射关系配置 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; // 可以返回 Spring 的 Java 配置文件数组 return new Class&lt;?&gt;[] &#123; WebConfig.class &#125;; &#125; // DispatcherServlet 拦截内容 @Override protected String[] getServletMappings () &#123; return new String[]&#123;\"*.do\"&#125;； &#125;&#125; 只要实现了 WebApplicationlnitializer 接口的 onStartup 方法，Spring MVC 就会把类当作一个初始化器加载进来；上面代码继承的是AbstractAnnotationConfigDispatcherServletlnitializer，它们的关系如下： 这就是只要继承 AbstractAnnotationConfigDispatcherServletlnitializer 类就完成了DispatcherServlet 映射关系和 Spring IoC 容器的初始化工作的原因。 MyWebApplnitializer 配置类 getRootConfigClasses 获取 Spring IoC 容器的 Java 配置类，用以装载各类 Spring Bean getRootConfigClasses 方法返回为空，就不加载自定义的 Bean 到 Spring IoC 容器中 getServletConfigClasses 获取各类 Spring MVC 的 URI 和控制器的配置关系类，用以生成 Web 请求的上下文 getServletConfigClasses 加载了 WebConfig，则它就是一个 URI和控制器的映射关系类 getServletMappings 定义 DispatcherServlet 拦截的请求 WebConfig配置类 123456789101112131415161718@Configuration//定义扫描的包，加载控制器@ComponentScan (\"com.*\")//启用 Spring Web MVC@EnableWebMvcpublic class WebConfig &#123; /*** * 创建视图解析器 * @return 视图解析器 */ @Bean(name=\"\"viewResolver\") public ViewResolver initViewResolver () &#123; InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); viewResolver.setPrefix(\"/WEB-INF/jsp/\") ; viewResolver.setSuffix (\".jsp\") ; return viewResolver ; &#125;&#125; 和 Spring IoC 使用 Java 的配置也是一样的， 只是多 了一个注解＠EnableWebMvc,它代表启动 Spring MVC 框架的配置 SpringMVC开发流程（1）@RequestMapping ＠RequestMapping 可以配置在类或者方法之上，它的作用是指定 URI 和哪个类（或者方法）作为一个处理请求的处理器； Spring MVC 还定义了处理器的拦截器 ， 当启动 Spring MVC 的 时候 ， Spring MVC 就会去解析＠Controller 中的@RequestMapping 的配置 ， 再结合所配置的拦截器，这样它就会组成多个拦截器和一个控制器的形式 ， 存放到一个 HandlerMapping 中去 如果没有配置@RequestMapping中的method属性，那么它会响应所有类型请求 （2）控制器开发 获取请求参数 @RequestParam 获取请求参数，默认情况下不为空，设置required为false实可以为空；为空时，可以通过设置defaultValue来设置默认值 Spring MVC 还提供了注解＠SessionAtrribute 去从 Session 中获取对应的数据 处理业务逻辑 绑定模型和视图 Spring MVC 会默认使用 JstlView 进行渲染，也就是它将查询出来的模型绑定到 JSTL （JSP 标准标签库）模型中 使用JSON视图MappingJackson2JsonView（非逻辑视图，井不需要视图解析器进行解析）可以将模型转化成JSON字符串返回到前端，一般用于Ajax请求 123ModelAndView mv = new ModelAndView();mv.setObject(\"role\", role);mv.setView(new MappingJackson2JsonView()); 这样SpringMVC就会将对象role转成json字符串；但是也可以使用@ResponseBody使得返回结果变成JSON 深入SpringMVC组件开发（1）控制器接收各类请求参数 接受普通参数 如果请求的参数名和控制器的参数名一致，则无需任何注解都能够正确接收；这种方式允许参数为空（基本数据类型除外，因为基本数据类型没有null这种值） 在没有任何注解的情况下，SpringMVC有映射POJO的能力，直接将请求参数与POJO内部的属性对应来生成POJO参数实例 使用＠RequestParam 注解获取参数 如果参数被＠RequestParam 注解，那么默认的情况下该参数不能为空，如果为空则系统会抛出异常。如果希望允许它为空，那么要修改它的配置项 required 为 false ＠RequestParam(“xxx”)中的xxx与请求的参数名对应 使用 ＠RequestMapping 和 ＠PathVariable 两个注解共同协作传递URL参数 ＠PathVariable允许对应的参数为空 传递JSON参数 控制器使用@RequestBody接收JSON参数，而且一个控制器只能有一个@RequestBody，如果有多个会报错，大概是第二个之后的@RequestBody要解析时，输入流已经关闭 @RequestBody也具备映射POJO的能力 客户端请求时要将json转为字符串传递JSON.stringify(data)，同时要蛇者ContentType为”application/json” 如果是手写json来请求的话，不能使用单引号，而是要使用双引号，否则SpringMVC会解析失败 接收列表数据和表单序列化 Spring MVC 将传递过来的 JSON 数组数据（基本类型或者POJO都可以，只要请求的数据格式和控制器的参数一致即可） ， 转换为对应的 Java 集合类型。 把 List 转化为数组（ Long[] ）也是可行的 将 form 数据序列化，传递给后台，则数据将以 roleName=xxx &amp;&amp; note=xxx 传递 1$(\"form\").serialize() 这样控制器只需要像接收普通参数一样接收即可（@RequestParam或者不用任何注解，具有解析POJO能力） （2）重定向 给数据模型Model附上对应的数据（作为重定向的控制器的参数），然后返回带有redirect的字符串来实现重定向功能 123456public String addRole(Model model, ...)&#123; ... model.addAttribute(\"roleName\", roleName); ... return \"redirect:./showRoleJsonInfo.do\";&#125; SpringMVC有个约定：当返回的字符串带有 redirect 的时候，它就会认为需要的是一个重定向，重定向redirect后面的内容是要重定向的url 通过返回视图来实现重定向 123456public ModelAndView addRole2(ModelAndView mv, ...)&#123; ... mv.addObject(\"roleName\", roleName); mv.setViewName(\"redirect:./showRoleJsonInfo.do\"); return mv;&#125; HTTP的重定向以字符串来传递参数，因此不能有效传递对象，这个时候 SpringMVC提供了 一个方法——flash 属性，需要提供的数据模型就是一个 RedirectAttribute 12345public String addRole3(RedirectAttributes ra, ...)&#123; ... ra.addFlashAttribute(\"role\", role); return \"redirect:./showRoleJsonInfo.do\";&#125; 这样就能给重定向的地址传递POJO对象参数了 使用addFlashAttribute 方法后， Spring MVC 会将数据保存到 Session 中 （Session 在一个会话期有效），重定向后就会将其清除，这样就能够传递数据给下一个地址了 （3）拦截器 拦截器可以在请求进入控制器前、后以及视图渲染完成后进行相关的操作 Spring 要求 处 理器 的 拦截器 都 要实 现 接 口 org.springframework. web.servlet.HandlerInterceptor，也可以继承HandlerInterceptorAdapter（实现了HandlerInterceptor接口） preHandle：在处理器之前执行的前置方法，这样 SpringMVC 可以在进入处理器前处理一些方法了。注意，它将返回一个 boolean 值，会影响到后面 Spring MVC的流程 postHandle：在处理器之后执行的后置方法，处理器的逻辑完成后运行它 afterCompletion：无论是否产生异常都会在渲染视图后执行的方法 springboot中使用拦截器，只需要在配置类（继承了WebMvcConfigurer且注解了@Configuration类）中重写addInterceptors方法即可，使用InterceptorRegistry来添加拦截器及拦截规则 1234567891011121314151617@Configurationpublic class InterceptorConfiguration implements WebMvcConfigurer &#123; public final static String SESSION_KEY = \"user\"; @Autowired AudienceInteceptor audienceInteceptor; @Autowired AdminInterceptor adminInterceptor; @Autowired ManagerInterceptor managerInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(audienceInteceptor).addPathPatterns(\"/user/**\"); registry.addInterceptor(adminInterceptor).addPathPatterns(\"/admin/**\"); registry.addInterceptor(managerInterceptor).addPathPatterns(\"/manager/**\"); &#125;&#125; 多个拦截器的执行顺序和责任链模式的执行顺序一致 当其中的一个 preHandle 方法返回为 false 后，按配置顺序，后面的 preHandle方法都不会运行了，而控制器和所有的后置方法 postHandle 也不会再运行。执行过 preHandle方法且该方法返回为 true 的拦截器的完成方法 （afterCompletion）会按照配置的逆序运行 附：随手记Java1.1、Java接口多继承 第一次注意到这个玩意是springMVC框架源码里面出现的接口多继承： 123456789101112131415/** * A &#123;@link GenericConverter&#125; that may conditionally execute based on attributes * of the &#123;@code source&#125; and &#123;@code target&#125; &#123;@link TypeDescriptor&#125;. * * &lt;p&gt;See &#123;@link ConditionalConverter&#125; for details. * * @author Keith Donald * @author Phillip Webb * @since 3.0 * @see GenericConverter * @see ConditionalConverter */public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter &#123;&#125; 搜了一下，摘录如下： 先从Java 8之前说起。要区分“声明多继承”与“实现多继承”。Java是不允许“实现多继承”，简称不允许“多继承”。但是Java支持“声明多继承”——Java的接口的多继承——一个类可以实现多个接口（“继承”了多个接口上的方法声明），而一个接口可以继承多个接口（同样是“继承”了多个接口上的方法声明）。接口只允许有方法声明而不允许有实现，因而不会出现像C++那样的实现多继承的决议问题；抽象类可以有方法实现，但要遵循Java类的单继承限制，也避免了实现多继承的问题。这是早期Java为了与C++区分开的一个决定。 然后，从Java 8开始，接口允许为方法提供“默认实现”了——默认方法（default method）。因而实质上Java 8的接口多继承其实也会涉及到实现多继承，并且语言层面有专门规定去解决实现多继承时选择哪个版本的问题——哪个都不选择，而是在发现会继承多个默认方法实现并且没有override时报错，逼使用户显式override可能冲突的方法。这使得Java 8开始接口可以当作traits来使用，达到实现多继承的目的。 作者：RednaxelaFX 链接：https://www.zhihu.com/question/24317891/answer/65097560 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1.2、Java中的byte，short，char进行计算时都会提升为int类型。（来源：https://www.nowcoder.com/test/question/done?tid=23696962&amp;qid=25211#summary） 1.3、依赖倒置原则 参考：https://zhuanlan.zhihu.com/p/24175489 1.4、Spring循环依赖问题 参考：https://zhuanlan.zhihu.com/p/34923466 jQuery2.1 GET与POST的区别 GET 基本上用于从服务器获得（取回）数据。注释：GET 方法可能返回缓存数据。 POST 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据。 2.2 同源策略 参见：https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy 2.3 jsonp 参考：https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html 2.4 jQuery.validate插件 12345if ( typeof define === \"function\" &amp;&amp; define.amd ) &#123; define( [\"jquery\"], factory );&#125; else &#123; factory( jQuery );&#125; 代码解释：https://stackoverflow.com/questions/30953589/what-is-typeof-define-function-defineamd-used-for 2.5 require.js模块开发 参见：https://javascript.ruanyifeng.com/tool/requirejs.html 2.6 jQuery 库中的 $() 是什么？ $() 函数是 jQuery() 函数的别称。$() 函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你可以将一个选择器字符串传入 $() 函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象 2.7 $(document).ready()方法和window.onload有什么区别？ window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。 $(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数。 2.8 jquery中$.get()提交和$.post()提交有区别吗？ 相同点：都是异步请求的方式来获取服务端的数据； 异同点： 请求方式不同：$.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。 参数传递方式不同：get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。 数据传输大小不同：get方式传输的数据大小不能超过2KB 而POST要大的多 安全问题： GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。 2.9 简单的$.ajax()的请求方式（$.ajax()接受的参数是键值对列表） 1234567891011$.ajax(&#123; url:'http://www.baidu.com', type:'POST', data:data, cache:true, headers:&#123;&#125;, beforeSend：function()&#123;&#125;, success:function()&#123;&#125;, error:function()&#123;&#125;, complete:function()&#123;&#125;&#125;); JavaScript面试题（1）参考自：https://www.cnblogs.com/wdlhao/p/8290436.html#_label1 （2）比较typeof与instanceof？ 相同点：JavaScript 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。 typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。 细节： (1)、typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。 (2)、typeof 来获取一个变量是否存在，如 if(typeof a!=”undefined”){alert(“ok”)}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错。 (3)、对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。 Instanceof定义和用法：instanceof 用于判断一个变量是否属于某个对象的实例。 （3）细节： ​ 如下，得到的结果为‘N’,这里的 instanceof 测试的 object 是指 js 语法中的 object，不是指 dom 模型对象。 1if (window instanceof Object)&#123; alert('Y')&#125; else &#123; alert('N');&#125; // 'N' （4）跨域访问 什么是跨域：由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域 存在跨域的情况： 网络协议不同，如http协议访问https协议。 端口不同，如80端口访问8080端口。 域名不同，如qianduanblog.com访问baidu.com。 子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。 域名和域名对应ip,如www.a.com访问20.205.28.90. Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）；客户端请求js文件获取到本地之后会立即执行 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了 Mysql（1）限制查询范围时，offset要和limit配合使用，单独使用offset会报错 （2）mysql中不等号使用&lt;&gt;, !=均可；但如果是在mybatis中书写mysql查询语句时，由于&lt;&gt;得进行转义，使用不方便，因此推荐使用!=；mysql中的等号是=而不是== （3）mysql中的比较符号可以直接用在时间类型的字段比较中；current_timestamp()函数可以返回当前的时间戳 （4）mysql更新语句的update是和set一起配合使用的 1UPDATE table_name SET field1=new-value1, field2=new-value2 [WHERE Clause] （5）删除记录的语法是delete from 1DELETE FROM table_name [WHERE Clause] （6）插入记录的语法是insert into 123INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); （7）MySQL LIKE 子句 LIKE 通常与 % 一同使用，类似于一个元字符的搜索，%字符表示匹配任意字符 like语句用在where条件中，用于进行模糊匹配 123SELECT field1, field2,...fieldN FROM table_nameWHERE field1 LIKE condition1 [AND [OR]] filed2 = &apos;somevalue&apos; （8）MySQL UNION 操作符 MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中；多个 SELECT 语句会删除重复的数据 语法格式 1234567SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]UNION [ALL | DISTINCT]SELECT expression1, expression2, ... expression_nFROM tables[WHERE conditions]; distinct：删除结果集中重复的数据【这是默认值】 all：返回所有结果集，包含重复数据 另外，union的结果集必须含有相同的列数，属性不同可以，但是会以第一个结果集的列属性为准；如果列属性不一样，那么distinct就会起作用了，它会根据数据的值来判断是否一致而不是属性类型来判断 123456789101112131415161718192021222324mysql&gt; select * from demo;+----+------+------+| id | name | note |+----+------+------+| 1 | test | test |+----+------+------+1 row in set (0.00 sec)mysql&gt; select id, name from demo union select id, note from demo;+----+------+| id | name |+----+------+| 1 | test |+----+------+1 row in set (0.00 sec)mysql&gt; select id, name from demo union all select id, note from demo;+----+------+| id | name |+----+------+| 1 | test || 1 | test |+----+------+2 rows in set (0.00 sec) 可以看到，union的两个结果集的列不一致，但是合并之后，以第一个结果集的属性最终结果集的属性（id name），然后使用union distinct时，它判断的是数据的值，发现name=’test’和note=’test’值相同，因此只有最终结果集中只有一条记录返回 （9）排序 12SELECT field1, field2,...fieldN table_name1, table_name2...ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]] 通过order by设置排序的字段，可以有多个；默认按照升序排序ASC，也可以设置DESC设置降序排列 （10）分组 在MYSQL中使用GROUP BY对表中的数据进行分组时： GROUP BY X意思是将所有具有相同X字段值的记录放到一个分组里， GROUP BY X, Y意思是将所有具有相同X字段值和Y字段值的记录放到一个分组里。 分组之后需要对分组进行操作，这时候需要用到 COUNT, SUM, AVG,等函数 1234SELECT column_name, function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name; function指的就是COUNT, SUM, AVG,等函数，函数里面的列是select后面的列中的一个或者多个，也可以是全部列(*) GROUP BY column_name后面在使用rollup关键字可以在分组统计数据的基础上在进行相同的统计（SUM,AVG,COUNT…） 12345678910mysql&gt; SELECT name, SUM(singin) as singin_count FROM employee_tbl GROUP BY name WITH ROLLUP;+--------+--------------+| name | singin_count |+--------+--------------+| 小丽 | 2 || 小明 | 7 || 小王 | 7 || NULL | 16 |+--------+--------------+4 rows in set (0.00 sec) 这个就是在计算了每个分组的sum之后，对所有的分组进行sum，即将所有分组看成一个大的分组进行sum （11）JOIN INNER JOIN（或者JOIN）：获取两个表中字段匹配关系的记录 LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录（（没有记录的字段为NULL）） RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录（没有记录的字段为NULL） 示例代码 1select a.runoob_id, a.runoob_author, a.runoob_title, b.runoob_count from runoob_tbl a right join tcount_tbl b on a.runoob_author = b.runoob_author; 使用... left join/join/right ... on [条件] 的语法 （12）NULL值比较 IS NULL: 当列的值是 NULL,此运算符返回 true。 IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。 &lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。 &lt;=&gt;可以代替=运算符，好处是当其中一个值为null时返回false，都为null时返回true，即使得null可以进行比较 NULL 值与任何其它值的比较（即使是 NULL）永远返回 false，即 NULL = NULL 返回false ，同时NULL != NULL也返回false （13）正则表达式 ​ 在Mysql中可以使用REGEXP操作符来进行正则表达式匹配，可以起到和LIKE操作符模糊匹配一样的功能 12mysql&gt; SELECT name FROM person_tbl WHERE name REGEXP &apos;^st&apos;;mysql&gt; select * from runoob_tbl where runoob_author regexp &apos;^[^a-zA-Z]+$&apos;; （14）alter命令 ALTER TABLE testalter_tbl DROP i;用于删除表的i字段；如果标准只有一个字段，drop命令会失败 ALTER TABLE testalter_tbl ADD i INT;用于添加表字段；新添加的字段i会追加在原有表字段的末尾 如果你需要指定新增字段的位置，可以使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后） 1234ALTER TABLE testalter_tbl DROP i;ALTER TABLE testalter_tbl ADD i INT FIRST;ALTER TABLE testalter_tbl DROP i;ALTER TABLE testalter_tbl ADD i INT AFTER c; ALTER TABLE testalter_tbl MODIFY c CHAR(10);用于修改现有表字段的描述，新的描述直接覆盖原有字段的描述； modify不能修改字段名，而change可以修改字段名 1ALTER TABLE testalter_tbl CHANGE i j BIGINT; 这个表示将原字段i修改名称为j，并且描述是BIGINT 也可以直接修改表的类型，ALTER TABLE testalter_tbl ENGINE = MYISAM;这个是修改数据表的存储引擎，可以通过SHOW TABLE STATUS LIKE &#39;testalter_tbl&#39;\\G来查看表的类型 123456789101112131415161718192021mysql&gt; show table status like &apos;runoob_tbl&apos;\\G*************************** 1. row *************************** Name: runoob_tbl Engine: MyISAM Version: 10 Row_format: Dynamic Rows: 5 Avg_row_length: 3276 Data_length: 16384Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: 6 Create_time: 2019-05-24 16:04:59 Update_time: 2019-05-24 15:10:46 Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment: 1 row in set (0.00 sec) 可以使用rename to来修改数据表的名称 1ALTER TABLE testalter_tbl RENAME TO alter_tbl; HTML+CSS（1）盒子模型 在网页中，一个元素占有空间的大小由几个部分构成，其中包括元素的内容（content），元素的内边距（padding），元素的边框（border），元素的外边距（margin）四个部分。这四个部分占有的空间中，有的部分可以显示相应的内容，而有的部分只用来分隔相邻的区域或区域。4个部分一起构成了css中元素的盒模型。 （2）src与href的区别 href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。 src是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕（如果是js文件的话，会将js文件里面的代码执行完再接着往下处理），图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 （3）同步和异步的区别 同步是阻塞模式，异步是非阻塞模式 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 （4）px和em的区别 相同点：px和em都是长度单位； 异同点：px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。 px、em、rem区别介绍，参考：http://www.runoob.com/w3cnote/px-em-rem-different.html （5）sessionStorage 、localStorage 和 cookie 之间的区别 Web Storage 包含如下两种机制： sessionStorage 为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。 localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。 共同点：用于浏览器端存储的缓存数据 不同点： 存储内容是否发送到服务器端 当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费； web storage,会将数据保存到本地，不会造成宽带浪费； 数据存储大小不同 Cookie数据不能超过4K,适用于会话标识； web storage数据存储可以达到5M; 数据存储的有效期限不同 cookie只在设置了Cookid过期时间之前一直有效，即使关闭窗口或者浏览器； sessionStorage,仅在关闭浏览器之前有效； localStorage,数据存储永久有效； 作用域不同 cookie和localStorage是在同源同窗口中都是共享的； sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面； （6）请指出document load和document ready的区别？ 共同点：这两种事件都代表的是页面文档加载时触发。 异同点： ready 事件的触发，表示文档结构已经加载完成（不包含图片等非文字媒体文件）。 onload 事件的触发，表示页面包含图片等文件在内的所有元素都加载完成。 HTTP面试题 参考：https://juejin.im/post/5a8102e0f265da4e710f5910 web前端面试题前端攻击方式/前端安全XSS攻击：跨站脚本攻击 CSRF攻击：跨站请求伪造攻击 网站性能优化/js性能优化https://juejin.im/post/59672fbff265da6c3f70cd53 跨浏览器兼容react性能优化（1）重写shouldComponentUpdate来避免不必要的dom操作。 （2）使用 production 版本的react.js。 （3）使用key来帮助React识别列表中所有子组件的最小变化。 virtualDOM、合成事件系统 事件冒泡机制get和post有什么区别？其实，GET和POST本质上两者没有任何区别。他们都是HTTP协议中的请求方法。底层实现都是基于TCP/IP协议。所谓区别，只是浏览器厂家根据约定，做得限制而已。 get是通过明文发送数据请求，而post是通过密文； get传输的数据量有限，因为url的长度有限，post则不受限； GET请求的参数只能是ASCII码，所以中文需要URL编码，而POST请求传参没有这个限制 GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 document.onload和document.ready两个事件的区别页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页面包含图片等文件在内的所有元素都加载完成。 计算机网络部分DNS解析过程 1） 浏览器缓存 当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）； 2） 系统缓存 当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP； 3） 路由器缓存 当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存； 4） ISP（互联网服务提供商）DNS缓存 当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找； 5） 根域名服务器 当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器； 6） 顶级域名服务器 顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器； 7） 主域名服务器 主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录； 8）保存结果至缓存 本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。 算法与数据结构","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://QQ876684433.github.io/tags/Java/"},{"name":"javascript","slug":"javascript","permalink":"http://QQ876684433.github.io/tags/javascript/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://QQ876684433.github.io/tags/JavaWeb/"},{"name":"Spring","slug":"Spring","permalink":"http://QQ876684433.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://QQ876684433.github.io/tags/SpringMVC/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://QQ876684433.github.io/tags/Mybatis/"},{"name":"HTML","slug":"HTML","permalink":"http://QQ876684433.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://QQ876684433.github.io/tags/CSS/"},{"name":"jQuery","slug":"jQuery","permalink":"http://QQ876684433.github.io/tags/jQuery/"},{"name":"面试","slug":"面试","permalink":"http://QQ876684433.github.io/tags/面试/"}]},{"title":"64.最小路径和","slug":"64-最小路径和","date":"2019-07-14T15:23:52.000Z","updated":"2019-09-15T05:02:14.662Z","comments":true,"path":"2019/07/14/64-最小路径和/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/64-最小路径和/","excerpt":"","text":"64. 最小路径和原题目如下： 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入:[[1,3,1],[1,5,1],[4,2,1]] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路这道题比较简单，也是填表的问题，递推公式如下：$$dp[i][j] = dp[i][j]+min{dp[i+1][j]+dp[i][j+1]}$$意思是：从点(i, j)到终点有两个选择，从下边(i+1, j)或者右边(i, j+1)走，所以最短路径是下边或者右边走的最小值加上当前点的值，因此可以从右下角开始填表，注意处理好边界条件： 12345678910111213141516/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var minPathSum = function(grid) &#123; for(let i = grid.length-1;i&gt;=0;i--)&#123; for(let j = grid[0].length-1;j&gt;=0;j--)&#123; if(i==grid.length-1 &amp;&amp; j==grid[0].length-1) continue; let right = Infinity, bottom = Infinity; if(i!=grid.length-1) bottom = grid[i+1][j]; if(j!=grid[0].length-1) right = grid[i][j+1]; grid[i][j] = grid[i][j]+Math.min(bottom, right); &#125; &#125; return grid[0][0];&#125;; 复杂度分析 时间复杂度 ：O(m*n)。遍历整个矩阵恰好一次。 空间复杂度 ：O(1)O(1)。不需要额外空间。 题解官方给的题解其实思路都差不多，只是具体实现有区别 比如递归暴力解法，也是上面的思路，只是空间和时间开销巨大，我刚开始想的时候就直接拒绝了这种不优雅的做法； 二维数组动态规划和我的解法的唯一区别是它另外开辟了新的数组，这在一定情况下是必要的，当要求不能修改原数组时，就只能这么做； 针对二维数组动态规划的优化算法就是官解给出的一维动态规划，从我自己的解法中已经可以看出，我是从最下面一层开始往上面填表的，填完之后，下面的行就不再需要用了，所以可以复用一下： 12345678910111213var minPathSum = function(grid)&#123; const res = grid[grid.length-1]; for(let i = grid.length-1;i&gt;=0;i--)&#123; for(let j = grid[0].length-1;j&gt;=0;j--)&#123; if(i==grid.length-1 &amp;&amp; j==grid[0].length-1) continue; let right = Infinity, bottom = Infinity; if(i!=grid.length-1) bottom = res[j]; if(j!=grid[0].length-1) right = res[j+1]; res[j] = grid[i][j]+Math.min(bottom, right); &#125; &#125; return res[0];&#125;; ####","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"877.石子游戏","slug":"877-石子游戏","date":"2019-07-14T15:22:39.000Z","updated":"2019-09-15T05:02:14.662Z","comments":true,"path":"2019/07/14/877-石子游戏/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/877-石子游戏/","excerpt":"","text":"877. 石子游戏原题目如下： 亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。 示例： 输入：[5,3,4,5] 输出：true 解释： 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 提示： 2 &lt;= piles.length &lt;= 500piles.length 是偶数。1 &lt;= piles[i] &lt;= 500sum(piles) 是奇数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/stone-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 一个TLE的解法举个栗子，假设初始堆是：[1，2，3，4，5]，那么第一回合（即两个各拿一堆）后，会出现三种状态： 亚4,李1，剩下[2，3] ps：这里其实会出现“亚1,李4，剩下[2，3]”的情况，但是想想就知道，这两种情况的子问题都是[2，3]，如果“亚4,李1”不能保证亚赢的话，那“亚1,李4”就更不可能了，所以这种情况可以排除了 亚4,李3，剩下[1，2] 亚1,李2，剩下[3，4] 然后接下来就是递归求解了，最后当剩下两堆时，可以保证亚取得最优解，直接返回两人的分差（亚-李）；然后递归计算完上面三个子问题之后，取最优的一种情况返回，最优的情况指的是两人得分差别最大的那种取法 代码不仅冗长，甚至还超时了orz： 123456789101112131415161718192021222324252627282930313233343536373839/** * @param &#123;number[]&#125; piles * @return &#123;boolean&#125; */const sub = (left, right, piles)=&gt;&#123; const l = piles[left], r = piles[right]; if(right-left == 1)&#123; if(l&gt;r) return [l, r]; else return [r, l]; &#125;else&#123; const subRes1 = sub(left+1,right-1,piles); if (l&gt;r)&#123; subRes1[0] += l; subRes1[1] += r; &#125;else&#123; subRes1[0] += r; subRes1[1] += l; &#125; const subRes2 = sub(left+2, right, piles); subRes2[0] += l; subRes2[1] += piles[left+1]; const subRes3 = sub(left, right-2, piles); subRes3[0] += r; subRes3[1] += piles[right-1]; let res = subRes1; if (subRes2[0]-subRes2[1]&gt;res[0]-res[1]) res = subRes2; if (subRes3[0]- subRes3[1]&gt;res[0]-res[1]) res = subRes3; return res; &#125;&#125;;var stoneGame = function(piles) &#123; const res = sub(0, piles.length-1, piles); return res[0]&gt;res[1];&#125;; 题解让我们来见证一下真正的动态规划长啥样 参考：https://leetcode-cn.com/problems/stone-game/solution/dong-tai-gui-hua-by-cliant/ 首先将问题转换为先手所能拿到的石子总数减去对手能拿到的石子总数是否为正数，用f(i,j)来表示第i堆到第j堆的石子，先手比对手多拿的石子总数，那么有如下的递推关系式：$$\\begin{equation} \\left{ \\begin{array}{} f(i,j)=max(piles[i]-f(i+1,j),;piles[j]-f(i,j-1)),&amp;i\\ne j \\ f(i,j)=f(i),&amp;i==j\\end{array} \\right.\\end{equation}$$所以问题的解决过程就变成了已知对角线值的二维数组的填表，二维数组用dp[i][j]表示，dp[0][n-1]即为问题的解，n是石子的堆数 （1）初始条件，只有对角线的值已知，且是各堆石子的个数 （2）数组值的生成关系如图，红色星号是问题的解： （3）最终的计算顺序如红色箭头所示： 这样是为了保证不会产生重复计算问题，也便于编码 （4）代码如下： 12345678910111213var stoneGame = function(piles) &#123; const dp = []; for(let i = piles.length-1;i&gt;=0;i--)&#123; dp[i] = []; dp[i][i] = piles[i]; // 填表 for(let j = i+1;j&lt;piles.length;j++)&#123; dp[i][j] = Math.max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1]) &#125; &#125; return dp[0][piles.length-1]&gt;0;&#125;; （5）这里其实可以优化一下，因为这个二维数组其实只有一半有数，而且随着填表的进行，之前的值不会再被使用到了： 123456789101112var stoneGame = function(piles) &#123; const dp = []; for(let i = piles.length-1;i&gt;=0;i--)&#123; dp[i] = piles[i]; // 填表 for(let j = i+1;j&lt;piles.length;j++)&#123; dp[j] = Math.max(piles[i]-dp[j], piles[j]-dp[j-1]) &#125; &#125; return dp[piles.length-1]&gt;0;&#125;; 主要的思想是，第i-1行的值可以覆盖到第i行上去，因为一旦第i-1行计算出来，第i行就不再需要了，计算i-2行只用到了第i-1行和第i-2行；所以填表的那个循环，只是单纯将dp数组与i有关的索引去掉 12原来的：dp[i][j] = Math.max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1])优化后：dp [j] = Math.max(piles[i]-dp [j], piles[j]-dp [j-1]) 歪门邪道这道题可以钻空子，直接return true就可以AC了，不要问我为什么。。。 其实这是数学规律来的，leetcode官方已经给出了解释，但我还是根据自己的理解说一下： 首先只有两堆（假设是x1，y1）的时候，一定可以保证先手胜（假设x1&gt;y1，那么先手可选x1） 然后当有四堆（假设是y2，x1，y1，x2）的时候，那么先手一定可以保证取到y1+y2或者x1+x2（因为取y2时，可以保证y1可以取到，x同理），所以先手只需取总和最大的一组即可 那么显然，先手可以保证取到奇数位置的堆或者偶数位置的堆，先手从总和大的堆下手即可保证稳赢，所以结果是true","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"338.比特位计数","slug":"338-比特位计数","date":"2019-07-14T15:20:49.000Z","updated":"2019-09-15T05:02:14.662Z","comments":true,"path":"2019/07/14/338-比特位计数/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/338-比特位计数/","excerpt":"","text":"338. 比特位计数原题目如下： 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 输入: 2 输出: [0,1,1] 示例 2: 输入: 5 输出: [0,1,1,2,1,2] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/counting-bits著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路其实这道题还算简单，看到题目的第一个想法就是首先列举一下，找找规律： 1234567891011121314二进制 十进制 1的个数0000 0 00001 1 10010 2 10011 3 20100 4 10101 5 20110 6 20111 7 31000 8 1... 我给上面的结果分了个组，其实很容易看出来，每组的1的个数就是该组前面所有数的1的个数加一，所以答案已经很明显了： 12345678910111213141516/** * @param &#123;number&#125; num * @return &#123;number[]&#125; */var countBits = function(num) &#123; let res = [0]; for(let i =0;i&lt;num;i++)&#123; let j = 0; const len = res.length; for(;j&lt;len;j++)&#123; if(res.length==num+1) return res; res.push(res[j]+1); &#125; &#125; return res;&#125;; 这是我的第一个版本的代码，一次过： 执行结果： 通过 显示详情 执行用时 :116 ms, 在所有 JavaScript 提交中击败了100.00%的用户 内存消耗 :39.9 MB, 在所有 JavaScript 提交中击败了30.30%的用户 其他解法然后我看了一下其他的答案，感觉还是有些地方可以学习的 1234567891011121314151617// 奇数一定比上一个偶数多个 1，多的就是最低位的 1 // 偶数中 1 的个数一定和除以 2 之后的那个数一样多。// 因为最低位是0，除以 2 就是右移一位，也就是把那个0抹掉而已，所以1的个数是不变的。var countBits = function (num) &#123; let result = [] result[0] = 0; for (let i = 1; i &lt;= num; i++) &#123; if (i % 2 === 1) &#123; result[i] = result[i - 1] + 1; &#125; else &#123; result[i] = result[i / 2]; &#125; &#125; return result;&#125; 上面这个解释的已经很清晰了，就不多说了，这位老哥还提供了另一个更优化的解法： 1234567891011// Time: O(n), Space: O(1)// i &amp; (i-1) 消除二进制最低位的 1 var countBits = function (num) &#123; let result = [] result[0] = 0 for (let i = 1; i &lt;= num; i++) &#123; result[i] = result[i &amp; (i - 1)] + 1; &#125; return result;&#125; 我发现有不少解法里有这个东西：i &amp; (i - 1)，他说的消除二进制最低位的1是什么意思？举两个例子： 当i是奇数（例如xxx111），i &amp; (i - 1)很显然就是类似xxx111 &amp; xxx110 = xxx110，把xxx111的最低位1消去，效果相当于-1，和上上一个解法的这个说法 奇数一定比上一个偶数多个 1 道理一样 当i是偶数（例如xxx110），i &amp; (i - 1)类似于xxx110 &amp; xxx101 = xxx100，也是把最低位的1消掉，xxx110中1的个数和xxx100中1的个数相差1，这个是和上上个解法 偶数中 1 的个数一定和除以 2 之后的那个数一样多 有点不一样","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"},{"name":"leetcode","slug":"leetcode","permalink":"http://QQ876684433.github.io/tags/leetcode/"}]},{"title":"动态规划算法介绍","slug":"动态规划算法介绍","date":"2019-07-14T15:16:37.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/14/动态规划算法介绍/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/动态规划算法介绍/","excerpt":"","text":"动态规划算法介绍 参考：https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html 基本概念动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。 基本思想与策略基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 适用的情况能采用动态规划求解的问题的一般要具有3个性质： (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 (3)有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 求解的基本步骤动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 ​ 图1 动态规划决策过程示意图 (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。 (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。 (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。 实际应用中可以按以下几个简化的步骤进行设计： （1）分析最优解的性质，并刻画其结构特征。 （2）递归的定义最优解。 （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 （4）根据计算最优值时得到的信息，构造问题的最优解 算法实现的说明动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。 使用动态规划求解问题，最重要的就是确定动态规划三要素： （1）问题的阶段 （2）每个阶段的状态 （3）从前一个阶段转化到后一个阶段之间的递推关系。 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。 1f(n,m)=max&#123;f(n-1,m), f(n-1,m-w[n])+P(n,m)&#125; 动态规划算法基本框架12345678910111213141516171819for(j=1; j&lt;=m; j=j+1) // 第一个阶段 xn[j] = 初始值;for(i=n-1; i&gt;=1; i=i-1)// 其他n-1个阶段 for(j=1; j&gt;=f(i); j=j+1)//f(i)与i有关的表达式 xi[j]=j=max（或min）&#123;g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])&#125;;t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for(i=2; i&lt;=n-1; i=i+1）&#123; t = t-xi-1[ji]; for(j=1; j&gt;=f(i); j=j+1) if(t=xi[ji]) break;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://QQ876684433.github.io/tags/动态规划/"}]},{"title":"数据结构与算法笔记","slug":"数据结构与算法笔记","date":"2019-07-14T15:13:50.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/14/数据结构与算法笔记/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/数据结构与算法笔记/","excerpt":"","text":"数据结构与算法动态规划动态规划算法介绍 参考：https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741374.html 基本概念动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。 基本思想与策略基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。 适用的情况能采用动态规划求解的问题的一般要具有3个性质： (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 (3)有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 求解的基本步骤动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 ​ 图1 动态规划决策过程示意图 (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。 (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。 (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。 实际应用中可以按以下几个简化的步骤进行设计： （1）分析最优解的性质，并刻画其结构特征。 （2）递归的定义最优解。 （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 （4）根据计算最优值时得到的信息，构造问题的最优解 算法实现的说明动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。 使用动态规划求解问题，最重要的就是确定动态规划三要素： （1）问题的阶段 （2）每个阶段的状态 （3）从前一个阶段转化到后一个阶段之间的递推关系。 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。 确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。 1f(n,m)=max&#123;f(n-1,m), f(n-1,m-w[n])+P(n,m)&#125; 动态规划算法基本框架12345678910111213141516171819for(j=1; j&lt;=m; j=j+1) // 第一个阶段 xn[j] = 初始值;for(i=n-1; i&gt;=1; i=i-1)// 其他n-1个阶段 for(j=1; j&gt;=f(i); j=j+1)//f(i)与i有关的表达式 xi[j]=j=max（或min）&#123;g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])&#125;;t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for(i=2; i&lt;=n-1; i=i+1）&#123; t = t-xi-1[ji]; for(j=1; j&gt;=f(i); j=j+1) if(t=xi[ji]) break;&#125; LeetCode刷题338. 比特位计数我的解法原题目如下： 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 输入: 2 输出: [0,1,1] 示例 2: 输入: 5 输出: [0,1,1,2,1,2] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/counting-bits著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 其实这道题还算简单，看到题目的第一个想法就是首先列举一下，找找规律： 1234567891011121314二进制 十进制 1的个数0000 0 00001 1 10010 2 10011 3 20100 4 10101 5 20110 6 20111 7 31000 8 1... 我给上面的结果分了个组，其实很容易看出来，每组的1的个数就是该组前面所有数的1的个数加一，所以答案已经很明显了： 12345678910111213141516/** * @param &#123;number&#125; num * @return &#123;number[]&#125; */var countBits = function(num) &#123; let res = [0]; for(let i =0;i&lt;num;i++)&#123; let j = 0; const len = res.length; for(;j&lt;len;j++)&#123; if(res.length==num+1) return res; res.push(res[j]+1); &#125; &#125; return res;&#125;; 这是我的第一个版本的代码，一次过： 执行结果： 通过 显示详情 执行用时 :116 ms, 在所有 JavaScript 提交中击败了100.00%的用户 内存消耗 :39.9 MB, 在所有 JavaScript 提交中击败了30.30%的用户 其他解法然后我看了一下其他的答案，感觉还是有些地方可以学习的 1234567891011121314151617// 奇数一定比上一个偶数多个 1，多的就是最低位的 1 // 偶数中 1 的个数一定和除以 2 之后的那个数一样多。// 因为最低位是0，除以 2 就是右移一位，也就是把那个0抹掉而已，所以1的个数是不变的。var countBits = function (num) &#123; let result = [] result[0] = 0; for (let i = 1; i &lt;= num; i++) &#123; if (i % 2 === 1) &#123; result[i] = result[i - 1] + 1; &#125; else &#123; result[i] = result[i / 2]; &#125; &#125; return result;&#125; 上面这个解释的已经很清晰了，就不多说了，这位老哥还提供了另一个更优化的解法： 1234567891011// Time: O(n), Space: O(1)// i &amp; (i-1) 消除二进制最低位的 1 var countBits = function (num) &#123; let result = [] result[0] = 0 for (let i = 1; i &lt;= num; i++) &#123; result[i] = result[i &amp; (i - 1)] + 1; &#125; return result;&#125; 我发现有不少解法里有这个东西：i &amp; (i - 1)，他说的消除二进制最低位的1是什么意思？举两个例子： 当i是奇数（例如xxx111），i &amp; (i - 1)很显然就是类似xxx111 &amp; xxx110 = xxx110，把xxx111的最低位1消去，效果相当于-1，和上上一个解法的这个说法 奇数一定比上一个偶数多个 1 道理一样 当i是偶数（例如xxx110），i &amp; (i - 1)类似于xxx110 &amp; xxx101 = xxx100，也是把最低位的1消掉，xxx110中1的个数和xxx100中1的个数相差1，这个是和上上个解法 偶数中 1 的个数一定和除以 2 之后的那个数一样多 有点不一样 877. 石子游戏原题目如下： 亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。 示例： 输入：[5,3,4,5] 输出：true 解释： 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。 提示： 2 &lt;= piles.length &lt;= 500piles.length 是偶数。1 &lt;= piles[i] &lt;= 500sum(piles) 是奇数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/stone-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 一个TLE的解法举个栗子，假设初始堆是：[1，2，3，4，5]，那么第一回合（即两个各拿一堆）后，会出现三种状态： 亚4,李1，剩下[2，3] ps：这里其实会出现“亚1,李4，剩下[2，3]”的情况，但是想想就知道，这两种情况的子问题都是[2，3]，如果“亚4,李1”不能保证亚赢的话，那“亚1,李4”就更不可能了，所以这种情况可以排除了 亚4,李3，剩下[1，2] 亚1,李2，剩下[3，4] 然后接下来就是递归求解了，最后当剩下两堆时，可以保证亚取得最优解，直接返回两人的分差（亚-李）；然后递归计算完上面三个子问题之后，取最优的一种情况返回，最优的情况指的是两人得分差别最大的那种取法 代码不仅冗长，甚至还超时了orz： 123456789101112131415161718192021222324252627282930313233343536373839/** * @param &#123;number[]&#125; piles * @return &#123;boolean&#125; */const sub = (left, right, piles)=&gt;&#123; const l = piles[left], r = piles[right]; if(right-left == 1)&#123; if(l&gt;r) return [l, r]; else return [r, l]; &#125;else&#123; const subRes1 = sub(left+1,right-1,piles); if (l&gt;r)&#123; subRes1[0] += l; subRes1[1] += r; &#125;else&#123; subRes1[0] += r; subRes1[1] += l; &#125; const subRes2 = sub(left+2, right, piles); subRes2[0] += l; subRes2[1] += piles[left+1]; const subRes3 = sub(left, right-2, piles); subRes3[0] += r; subRes3[1] += piles[right-1]; let res = subRes1; if (subRes2[0]-subRes2[1]&gt;res[0]-res[1]) res = subRes2; if (subRes3[0]- subRes3[1]&gt;res[0]-res[1]) res = subRes3; return res; &#125;&#125;;var stoneGame = function(piles) &#123; const res = sub(0, piles.length-1, piles); return res[0]&gt;res[1];&#125;; 题解让我们来见证一下真正的动态规划长啥样 参考：https://leetcode-cn.com/problems/stone-game/solution/dong-tai-gui-hua-by-cliant/ 首先将问题转换为先手所能拿到的石子总数减去对手能拿到的石子总数是否为正数，用f(i,j)来表示第i堆到第j堆的石子，先手比对手多拿的石子总数，那么有如下的递推关系式：$$\\begin{equation} \\left{ \\begin{array}{} f(i,j)=max(piles[i]-f(i+1,j),;piles[j]-f(i,j-1)),&amp;i\\ne j \\ f(i,j)=f(i),&amp;i==j\\end{array} \\right.\\end{equation}$$所以问题的解决过程就变成了已知对角线值的二维数组的填表，二维数组用dp[i][j]表示，dp[0][n-1]即为问题的解，n是石子的堆数 （1）初始条件，只有对角线的值已知，且是各堆石子的个数 （2）数组值的生成关系如图，红色星号是问题的解： （3）最终的计算顺序如红色箭头所示： 这样是为了保证不会产生重复计算问题，也便于编码 （4）代码如下： 12345678910111213var stoneGame = function(piles) &#123; const dp = []; for(let i = piles.length-1;i&gt;=0;i--)&#123; dp[i] = []; dp[i][i] = piles[i]; // 填表 for(let j = i+1;j&lt;piles.length;j++)&#123; dp[i][j] = Math.max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1]) &#125; &#125; return dp[0][piles.length-1]&gt;0;&#125;; （5）这里其实可以优化一下，因为这个二维数组其实只有一半有数，而且随着填表的进行，之前的值不会再被使用到了： 123456789101112var stoneGame = function(piles) &#123; const dp = []; for(let i = piles.length-1;i&gt;=0;i--)&#123; dp[i] = piles[i]; // 填表 for(let j = i+1;j&lt;piles.length;j++)&#123; dp[j] = Math.max(piles[i]-dp[j], piles[j]-dp[j-1]) &#125; &#125; return dp[piles.length-1]&gt;0;&#125;; 主要的思想是，第i-1行的值可以覆盖到第i行上去，因为一旦第i-1行计算出来，第i行就不再需要了，计算i-2行只用到了第i-1行和第i-2行；所以填表的那个循环，只是单纯将dp数组与i有关的索引去掉 12原来的：dp[i][j] = Math.max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1])优化后：dp [j] = Math.max(piles[i]-dp [j], piles[j]-dp [j-1]) 歪门邪道这道题可以钻空子，直接return true就可以AC了，不要问我为什么。。。 其实这是数学规律来的，leetcode官方已经给出了解释，但我还是根据自己的理解说一下： 首先只有两堆（假设是x1，y1）的时候，一定可以保证先手胜（假设x1&gt;y1，那么先手可选x1） 然后当有四堆（假设是y2，x1，y1，x2）的时候，那么先手一定可以保证取到y1+y2或者x1+x2（因为取y2时，可以保证y1可以取到，x同理），所以先手只需取总和最大的一组即可 那么显然，先手可以保证取到奇数位置的堆或者偶数位置的堆，先手从总和大的堆下手即可保证稳赢，所以结果是true 64. 最小路径和原题目如下： 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入:[[1,3,1],[1,5,1],[4,2,1]] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 我的解法这道题比较简单，也是填表的问题，递推公式如下：$$dp[i][j] = dp[i][j]+min{dp[i+1][j]+dp[i][j+1]}$$意思是：从点(i, j)到终点有两个选择，从下边(i+1, j)或者右边(i, j+1)走，所以最短路径是下边或者右边走的最小值加上当前点的值，因此可以从右下角开始填表，注意处理好边界条件： 12345678910111213141516/** * @param &#123;number[][]&#125; grid * @return &#123;number&#125; */var minPathSum = function(grid) &#123; for(let i = grid.length-1;i&gt;=0;i--)&#123; for(let j = grid[0].length-1;j&gt;=0;j--)&#123; if(i==grid.length-1 &amp;&amp; j==grid[0].length-1) continue; let right = Infinity, bottom = Infinity; if(i!=grid.length-1) bottom = grid[i+1][j]; if(j!=grid[0].length-1) right = grid[i][j+1]; grid[i][j] = grid[i][j]+Math.min(bottom, right); &#125; &#125; return grid[0][0];&#125;; 复杂度分析 时间复杂度 ：O(m*n)。遍历整个矩阵恰好一次。 空间复杂度 ：O(1)O(1)。不需要额外空间。 题解官方给的题解其实思路都差不多，只是具体实现有区别 比如递归暴力解法，也是上面的思路，只是空间和时间开销巨大，我刚开始想的时候就直接拒绝了这种不优雅的做法； 二维数组动态规划和我的解法的唯一区别是它另外开辟了新的数组，这在一定情况下是必要的，当要求不能修改原数组时，就只能这么做； 针对二维数组动态规划的优化算法就是官解给出的一维动态规划，从我自己的解法中已经可以看出，我是从最下面一层开始往上面填表的，填完之后，下面的行就不再需要用了，所以可以复用一下： 12345678910111213var minPathSum = function(grid)&#123; const res = grid[grid.length-1]; for(let i = grid.length-1;i&gt;=0;i--)&#123; for(let j = grid[0].length-1;j&gt;=0;j--)&#123; if(i==grid.length-1 &amp;&amp; j==grid[0].length-1) continue; let right = Infinity, bottom = Infinity; if(i!=grid.length-1) bottom = res[j]; if(j!=grid[0].length-1) right = res[j+1]; res[j] = grid[i][j]+Math.min(bottom, right); &#125; &#125; return res[0];&#125;; 96. 不同的二叉搜索树我的解法贪婪算法分治算法随机化算法回溯算法","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://QQ876684433.github.io/tags/算法/"}]},{"title":"在React项目中使用Docz遇到的问题","slug":"在React项目中使用Docz遇到的问题","date":"2019-07-14T14:53:48.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/14/在React项目中使用Docz遇到的问题/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/在React项目中使用Docz遇到的问题/","excerpt":"","text":"在React项目中使用Docz遇到的问题（1）按照官网的Getting Start添加依赖后执行yarnpkg add docz，出现的问题如下： 1234567891011121314Failed to compile../node_modules/docz/dist/index.esm.js 23:38Module parse failed: Unexpected token (23:38)Failed to compile../node_modules/docz/dist/index.esm.js 23:38Module parse failed: Unexpected token (23:38)You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders| import &#123; MDXProvider &#125; from '@mdx-js/react';| &gt; const BasePlayground = loadable(() =&gt; import('./Playground.esm.js'));| const Playground = props =&gt; typeof window !== 'undefined' ? createElement(Suspense, &#123;| fallback: null Github上面的相关issue是：https://github.com/pedronauck/docz/issues/596 最关键的是这一个： 他给出的解决方案是对webpack降级： 1npm i -D webpack@4.28.4 问题解决！ 然而，事情远远没有那么简单，当再次运行yarn start启动项目时，爆炸了： 显然是docz和creact-react-app的webpack版本冲突了，我又在github搜罗了一番，解决方案是给docz单独指定一个webpack版本： 启动成功，舒服了","categories":[{"name":"项目","slug":"项目","permalink":"http://QQ876684433.github.io/categories/项目/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://QQ876684433.github.io/tags/项目/"},{"name":"React","slug":"React","permalink":"http://QQ876684433.github.io/tags/React/"}]},{"title":"Github开源项目license选择问题","slug":"Github开源项目license选择问题","date":"2019-07-14T14:52:31.000Z","updated":"2019-09-15T05:02:14.662Z","comments":true,"path":"2019/07/14/Github开源项目license选择问题/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/Github开源项目license选择问题/","excerpt":"","text":"Github开源项目license选择问题简单一点，借用阮一峰博客上面的一张图：","categories":[{"name":"项目","slug":"项目","permalink":"http://QQ876684433.github.io/categories/项目/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://QQ876684433.github.io/tags/项目/"}]},{"title":"将React项目部署到GithubPages","slug":"将React项目部署到GithubPages","date":"2019-07-14T14:50:59.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/14/将React项目部署到GithubPages/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/将React项目部署到GithubPages/","excerpt":"","text":"将React项目部署到Github Pages 参考：https://segmentfault.com/a/1190000019290048 一些注意事项： （1）Github Pages自定义域名问题 往gh-pages分支添加CNAME记录 将要添加的域名写入CNAME，但是注意不要加入http:// 这里还有个问题就是，由于gh-pages分支是将编译之后的内容上传的，如果直接在gh-pages分支添加CNAME文件，会导致出现重新部署的时候CNAME被删除，这时后如果再次访问自定义域名，就会出现Content Security Policy问题（参见：https://stackoverflow.com/questions/54380373/content-security-policy-while-deploying-to-github-pages-using-gatsby） 1Refused to load the image 'http://www.alexingberg.com/favicon.ico' because it violates the following Content Security Policy directive: \"img-src data:\". 你可以按照stackoverflow上面的方案解决（我没试过），但我这里提供一个简单的解决方案，就是将CNAME添加在项目的public文件夹下面，编译之后CNAME就会在build目录生成，这样就不会出现Content Security Policy问题了 （2）自定义域名后出现资源路径不正确的问题 网上一些教程都是教你把Github Pages生成的那一串链接地址设置到&quot;homepages&quot;中 这样会出现的问题就是，编译完成后，会在静态资源的路径前面都加上/chph-blog，这样肯定是找不到对应的资源的 可以通过把&quot;homepages&quot;设置成&quot;./&quot;即可","categories":[{"name":"项目","slug":"项目","permalink":"http://QQ876684433.github.io/categories/项目/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://QQ876684433.github.io/tags/项目/"},{"name":"React","slug":"React","permalink":"http://QQ876684433.github.io/tags/React/"}]},{"title":"ES6、ES7、ES8、ES9、ES10新特性一览","slug":"ES6、ES7、ES8、ES9、ES10新特性一览","date":"2019-07-14T14:49:42.000Z","updated":"2019-09-15T05:02:14.662Z","comments":true,"path":"2019/07/14/ES6、ES7、ES8、ES9、ES10新特性一览/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/ES6、ES7、ES8、ES9、ES10新特性一览/","excerpt":"","text":"ES6、ES7、ES8、ES9、ES10新特性一览 参考：https://juejin.im/post/5ca2e1935188254416288eb2","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://QQ876684433.github.io/tags/javascript/"}]},{"title":"async/await的基础用法","slug":"async-await的基础用法","date":"2019-07-14T14:47:48.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/14/async-await的基础用法/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/async-await的基础用法/","excerpt":"","text":"async/await的基础用法 参考：https://www.jianshu.com/p/ffa5cbe9ab29 推荐阅读：https://segmentfault.com/a/1190000007535316 另外补充：进程、线程和协程的理解 参考https://blog.csdn.net/hairetz/article/details/16119911 进程、线程和协程 堆 栈 调度 进程 独立 独立 操作系统 线程 共享 独立 操作系统 协程 共享 独立 程序员在代码中显式调度 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。 进程和其他两个的区别还是很明显的。 协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。 async/await的特点 Promise主要用then函数的链式调用，一直点点点，是一种从左向右的横向写法。async/await从上到下，顺序执行，就像写同步代码一样。这更符合人编写代码的习惯 Promise的then函数只能传递一个参数，虽然可以通过包装成对象，但是这会导致传递冗余信息，频繁的解析又重新组合参数，比较麻烦。async/await没有这个限制，就当做普通的局部变量来处理好了，用let或者const定义的块级变量，想怎么用就怎么用，想定义几个就定义几个，完全没有限制，也没有冗余的工作。 Promise在使用的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰。async/await整个书写习惯都是同步的，不需要纠结同步和异步的区别。当然，异步过程需要包装成一个Promise对象，放在await关键字后面，这点还是要牢记的。 Promise是根据函数式编程的范式，对异步过程进行了一层封装。async/await是基于协程的机制，是真正的“保存上下文，控制权切换 … … 控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述。 async/await是基于Promise的，是进一步的一种优化。不过再写代码的时候，Promise本身的API出现得很少，很接近同步代码的写法。 await关键字使用的注意点 只能放在async函数内部使用，不能放在普通函数里面，否则会报错。 后面放Promise对象，在Pending状态时，相应的协程会交出控制权，进入等待状态。这个是本质。 await是async wait的意思，wait的是resolve(data)消息，并把数据data返回。比如，下面代码中，当Promise对象由Pending变为Resolved的时候，变量a就等于data；然后再顺序执行下面的语句console.log(a);这真的是等待，真的是顺序执行，表现和同步代码几乎一模一样。 12345const a = await new Promise((resolve, reject) =&gt; &#123; // async process ... return resolve(data);&#125;);console.log(a); await后面也可以跟同步代码，不过系统会自动转化成一个Promise对象。比如const a = await &#39;hello world&#39;;其实就相当于const a = await Promise.resolve(&#39;hello world&#39;);这跟同步代码const a = &#39;hello world&#39;;是一样的，还不如省点事，去掉这里的await关键字。 await只关心异步过程成功的消息resolve(data)，拿到相应的数据data。至于失败消息reject(error)，不关心，不处理。当然对于错误消息的处理，有以下几种方法供选择：（1）让await后面的Promise对象自己catch（2）也可以让外面的async函数返回的Promise对象统一catch（3）像同步代码一样，放在一个try...catch结构中 async关键字使用的注意点 有了这个async关键字，只是表明里面可能有异步过程，里面可以有await关键字。当然，全部是同步代码也没关系。当然，这时候这个async关键字就显得多余了。不是不能加，而是不应该加。 async函数，如果里面有异步过程，会等待；但是async函数本身会马上返回，不会阻塞当前线程。 可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染。async函数内部由async关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回。 async函数的返回值是一个Promise对象，这个是和普通函数本质不同的地方。这也是使用时重点注意的地方（1）return newPromise();这个符合async函数本意；（2）return data;这个是同步函数的写法，这里是要特别注意的。这个时候，其实就相当于Promise.resolve(data);还是一个Promise对象。在调用async函数的地方通过简单的=是拿不到这个data的。那么怎么样拿到这个data呢？很简单，返回值是一个Promise对象，用.then(data =&gt; { })函数就可以。（3）如果没有返回，相当于返回了Promise.resolve(undefined); await是不管异步过程的reject(error)消息的，async函数返回的这个Promise对象的catch函数就负责统一抓取内部所有异步过程的错误。async函数内部只要有一个异步过程发生错误，整个执行过程就中断，这个返回的Promise对象的catch就能抓到这个错误。 async函数执行和普通函数一样，函数名带个()就可以了，参数个数随意，没有限制；也需要有async关键字。只是返回值是一个Promise对象，可以用then函数得到返回值，用catch抓去整个流程中发生的错误。","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://QQ876684433.github.io/tags/javascript/"}]},{"title":"less的一个变量多次定义","slug":"less的一个变量多次定义","date":"2019-07-14T14:46:30.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/14/less的一个变量多次定义/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/less的一个变量多次定义/","excerpt":"","text":"一个变量多次定义首先一个变量不需要在使用之前就定义，而且也可以在不同地方重复定义同一个变量，下面两个编译的结果一样： 123456.lazy-eval&#123; width: @var;&#125;@var:@a;@a:9%; 123456789.lazy-eval&#123; width: @var; @a:9%;&#125;@var:@a;@a:100%;// 定义在块级作用域里的@a(9%)覆盖了全局作用域里的@a(100%) 编译出来的css是： 123.lazy-eval &#123; width: 9%;&#125; 官网里的原话是： When defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value. 更经典的例子是： 12345678910@var: 0;.class &#123; @var: 1; .brass &#123; @var: 2; three: @var; @var: 3; &#125; one: @var;&#125; 编译结果： 123456.class &#123; one: 1;&#125;.class .brass &#123; three: 3;&#125; 可以看出，three首先被赋值@var: 2;，然后被下面定义的@var: 3;覆盖；而one的作用域内看不到@var: 2;和@var: 3;，因此最后被赋值为1","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"less","slug":"less","permalink":"http://QQ876684433.github.io/tags/less/"}]},{"title":"css中常见的选择符","slug":"css中常见的选择符","date":"2019-07-14T14:45:02.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/14/css中常见的选择符/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/css中常见的选择符/","excerpt":"","text":"css中常见的选择符 参考：https://yanhaijing.com/css/2014/01/04/the-30-css-selectors-you-must-memorize/ 官网：https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors#Simple_selectors 基本选择器 Type（类型）选择器 这种基本选择器会选择所有匹配给定元素名的元素。 语法：elename 例子：input 将会选择所有的 input 元素。 Class（类）选择器 这种基本选择器会基于类属性的值来选择元素。 语法： .classname 例子： .index 会匹配所有包含 index 类的元素 (由类似于class=&quot;index&quot;这样的属性定义的). ID选择器 这种基本选择器会选择所有id属性与之匹配的元素。需要注意的是一个文档中每个id都应该是唯一的。 语法：#idname 例子：#toc 将会匹配所有id属性为 toc 的元素 (类似于这样的定义 id=&quot;toc&quot;). 通用选择器 这个基本选择器选择所有节点。它也常常和一个名词空间配合使用，用来选择该空间下的所有元素。 语法： * ns|* *|* 例子：* （通配符）将会选择所有元素。 属性选择器 这个基本的选择器根据元素的属性来进行选择。（具体参考：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors） 语法：[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value] 例子：[autoplay] 将会选择所有具有 autoplay 属性的元素（不论这个属性的值是什么） 组合选择器 紧邻兄弟选择器 &#39;+&#39; 操作符选择相邻元素，即第二个节点紧邻着第一个节点，并且拥有共同的父节点。 语法: A + B 例子: ul + li 会匹配任何 ul 元素后紧邻的 li 元素。 一般兄弟选择器 &#39;~&#39; 操作符选择兄弟元素，也就是说，第二个节点在第一个节点后面的任意位置，并且这俩节点的父节点相同。 语法: A ~ B 例子: p ~ span 将会匹配同一父元素下，p 元素后的所有 span 元素。 子选择器 &#39;&gt;&#39; 操作符选择第一个元素的直接子节点。 语法: A &gt; B 例子: ul &gt; li 将会匹配直接嵌套在 ul 元素内的所有 li 元素。 后代选择器 &#39; &#39; (空格) 操作符将选择第一个元素的子代节点。 语法: A B 例子: div span 将匹配 div 元素内所有的 span 元素。","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://QQ876684433.github.io/tags/css/"}]},{"title":"withRouter的作用和用法","slug":"withRouter的作用和用法","date":"2019-07-14T14:43:29.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/14/withRouter的作用和用法/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/withRouter的作用和用法/","excerpt":"","text":"withRouter的作用和用法 参考：https://www.cnblogs.com/luowenshuai/p/9526341.html 作用把不是通过路由切换过来的组件中，将react-router 的 history、location、match 三个对象传入props对象上 默认情况下必须是经过路由匹配渲染的组件才存在this.props，才拥有路由参数，才能使用编程式导航的写法，执行this.props.history.push(‘/detail’)跳转到对应路由的页面 然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用withRouter就可以给此组件传入路由参数，此时就可以使用this.props 如何使用withRouter比如app.js这个组件，一般是首页，不是通过路由跳转过来的，而是直接从浏览器中输入地址打开的，如果不使用withRouter此组件的this.props为空，没法执行props中的history、location、match等方法。 我就通过在App.js组件中使用withRouter来简单介绍一下： 设置withRouter很简单只需要两步：（1）引入 （2）将App组件 withRouter() 一下 12345678910111213141516171819import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom' //引入withRouterimport One from './One'import NotFound from './NotFound'class App extends Component&#123; //此时才能获取this.props,包含（history, match, location）三个对象 console.log(this.props); //输出&#123;match: &#123;…&#125;, location: &#123;…&#125;, history: &#123;…&#125;, 等&#125; render()&#123;return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); //这里要执行一下WithRouter 介绍一个简单应用可以根据路由切换浏览器的title属性，对props.history进行监听，切换路由的时候获取当前的路由路径，同时可以根据不同的路由设置不同的浏览器title标题。 仍然是App.js组件： 1234567891011121314151617181920212223242526272829import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom'import One from './One'import NotFound from './NotFound'class App extends Component&#123; constructor(props)&#123; super(props); props.history.listen((location)=&gt;&#123; //在这里监听location对象 console.log(location.pathname); //切换路由的时候输出\"/one/users\"和\"/one/companies\" switch(location.pathname)&#123; //根据路径不同切换不同的浏览器title case '/one/users' : document.title = '用户列表'; break; case '/one/companies' : document.title = '公司列表'; break; default : break; &#125; &#125;) &#125; render()&#123; return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); 如果使用编程式导航this.props.history.push(‘/detail’) 去跳转页面，但是报 this.props.history 错误 undefined，请在此组件中使用 withRouter 将 history 传入到 props上。","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://QQ876684433.github.io/tags/React/"},{"name":"React-Router","slug":"React-Router","permalink":"http://QQ876684433.github.io/tags/React-Router/"}]},{"title":"区别React-Router中match的path和url","slug":"区别React-Router中match的path和url","date":"2019-07-14T14:41:21.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/14/区别React-Router中match的path和url/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/区别React-Router中match的path和url/","excerpt":"","text":"区别React-Router中match的path和url 参考：https://blog.51cto.com/zhuxianzhong/2120738 官方描述如下： path - (string) The path pattern used to match. Useful for building nested &lt;Route&gt;s url - (string) The matched portion of the URL. Useful for building nested &lt;Link&gt;s path用来标识路由匹配的URL部分。React Router使用了Path-to-RegExp库将路径字符串转为正则表达式。然后正则表达式会匹配当前路径。 当路由路径和当前路径成功匹配，会生成一个对象match。match对象有更多关于URL和path的信息。这些信息可以通过它的属性获取，如下所示： match.url.返回URL中匹配部分的字符串。用于创建嵌套的&lt;Link&gt;很有用。 match.path.用于匹配路径模式。用来创建嵌套的&lt;Route&gt;。 match.isExact.返回布尔值，如果准确（没有任何多余字符）匹配则返回true。 match.params.返回一个对象包含Path-to-RegExp包从URL解析的键值对。","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://QQ876684433.github.io/tags/React/"},{"name":"React-Router","slug":"React-Router","permalink":"http://QQ876684433.github.io/tags/React-Router/"}]},{"title":"PureComponent简介","slug":"PureComponent简介","date":"2019-07-14T14:39:59.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/14/PureComponent简介/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/PureComponent简介/","excerpt":"","text":"PureComponent 参考：https://juejin.im/entry/5934c9bc570c35005b556e1a 为什么使用？React15.3中新加了一个 PureComponent 类，顾名思义， pure 是纯的意思，PureComponent 也就是纯组件，取代其前身 PureRenderMixin ,PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可，可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码。 原理当组件更新时，如果组件的 props 和 state 都没发生改变，render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较： 1234if (this._compositeType === CompositeTypes.PureClass) &#123; shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);&#125; 而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。","categories":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://QQ876684433.github.io/tags/React/"}]},{"title":"前端笔记","slug":"前端笔记","date":"2019-07-14T13:49:44.000Z","updated":"2019-09-15T05:02:14.666Z","comments":true,"path":"2019/07/14/前端笔记/","link":"","permalink":"http://QQ876684433.github.io/2019/07/14/前端笔记/","excerpt":"","text":"前端笔记摘要ReactPureComponent 参考：https://juejin.im/entry/5934c9bc570c35005b556e1a 为什么使用？React15.3中新加了一个 PureComponent 类，顾名思义， pure 是纯的意思，PureComponent 也就是纯组件，取代其前身 PureRenderMixin ,PureComponent 是优化 React 应用程序最重要的方法之一，易于实施，只要把继承类从 Component 换成 PureComponent 即可，可以减少不必要的 render 操作的次数，从而提高性能，而且可以少写 shouldComponentUpdate 函数，节省了点代码。 原理当组件更新时，如果组件的 props 和 state 都没发生改变，render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较： 1234if (this._compositeType === CompositeTypes.PureClass) &#123; shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);&#125; 而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。 React ReduxReact Router区别React-Router中match的path和url 参考：https://blog.51cto.com/zhuxianzhong/2120738 官方描述如下： path - (string) The path pattern used to match. Useful for building nested &lt;Route&gt;s url - (string) The matched portion of the URL. Useful for building nested &lt;Link&gt;s path用来标识路由匹配的URL部分。React Router使用了Path-to-RegExp库将路径字符串转为正则表达式。然后正则表达式会匹配当前路径。 当路由路径和当前路径成功匹配，会生成一个对象match。match对象有更多关于URL和path的信息。这些信息可以通过它的属性获取，如下所示： match.url.返回URL中匹配部分的字符串。用于创建嵌套的&lt;Link&gt;很有用。 match.path.用于匹配路径模式。用来创建嵌套的&lt;Route&gt;。 match.isExact.返回布尔值，如果准确（没有任何多余字符）匹配则返回true。 match.params.返回一个对象包含Path-to-RegExp包从URL解析的键值对。 withRouter的作用和用法 参考：https://www.cnblogs.com/luowenshuai/p/9526341.html 作用把不是通过路由切换过来的组件中，将react-router 的 history、location、match 三个对象传入props对象上 默认情况下必须是经过路由匹配渲染的组件才存在this.props，才拥有路由参数，才能使用编程式导航的写法，执行this.props.history.push(‘/detail’)跳转到对应路由的页面 然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用withRouter就可以给此组件传入路由参数，此时就可以使用this.props 如何使用withRouter比如app.js这个组件，一般是首页，不是通过路由跳转过来的，而是直接从浏览器中输入地址打开的，如果不使用withRouter此组件的this.props为空，没法执行props中的history、location、match等方法。 我就通过在App.js组件中使用withRouter来简单介绍一下： 设置withRouter很简单只需要两步：（1）引入 （2）将App组件 withRouter() 一下 12345678910111213141516171819import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom' //引入withRouterimport One from './One'import NotFound from './NotFound'class App extends Component&#123; //此时才能获取this.props,包含（history, match, location）三个对象 console.log(this.props); //输出&#123;match: &#123;…&#125;, location: &#123;…&#125;, history: &#123;…&#125;, 等&#125; render()&#123;return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); //这里要执行一下WithRouter 介绍一个简单应用可以根据路由切换浏览器的title属性，对props.history进行监听，切换路由的时候获取当前的路由路径，同时可以根据不同的路由设置不同的浏览器title标题。 仍然是App.js组件： 1234567891011121314151617181920212223242526272829import React,&#123;Component&#125; from 'react'import &#123;Switch,Route,NavLink,Redirect,withRouter&#125; from 'react-router-dom'import One from './One'import NotFound from './NotFound'class App extends Component&#123; constructor(props)&#123; super(props); props.history.listen((location)=&gt;&#123; //在这里监听location对象 console.log(location.pathname); //切换路由的时候输出\"/one/users\"和\"/one/companies\" switch(location.pathname)&#123; //根据路径不同切换不同的浏览器title case '/one/users' : document.title = '用户列表'; break; case '/one/companies' : document.title = '公司列表'; break; default : break; &#125; &#125;) &#125; render()&#123; return (&lt;div className='app'&gt; &lt;NavLink to='/one/users'&gt;用户列表&lt;/NavLink&gt; &lt;NavLink to='/one/companies'&gt;公司列表&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path='/one/:type?' component=&#123;One&#125; /&gt; &lt;Redirect from='/' to='/one' exact /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/div&gt;) &#125;&#125;export default withRouter(App); 如果使用编程式导航this.props.history.push(‘/detail’) 去跳转页面，但是报 this.props.history 错误 undefined，请在此组件中使用 withRouter 将 history 传入到 props上。 HTMLCSS传统csscss中常见的选择符 参考：https://yanhaijing.com/css/2014/01/04/the-30-css-selectors-you-must-memorize/ 官网：https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Selectors#Simple_selectors 基本选择器 Type（类型）选择器 这种基本选择器会选择所有匹配给定元素名的元素。 语法：elename 例子：input 将会选择所有的 input 元素。 Class（类）选择器 这种基本选择器会基于类属性的值来选择元素。 语法： .classname 例子： .index 会匹配所有包含 index 类的元素 (由类似于class=&quot;index&quot;这样的属性定义的). ID选择器 这种基本选择器会选择所有id属性与之匹配的元素。需要注意的是一个文档中每个id都应该是唯一的。 语法：#idname 例子：#toc 将会匹配所有id属性为 toc 的元素 (类似于这样的定义 id=&quot;toc&quot;). 通用选择器 这个基本选择器选择所有节点。它也常常和一个名词空间配合使用，用来选择该空间下的所有元素。 语法： * ns|* *|* 例子：* （通配符）将会选择所有元素。 属性选择器 这个基本的选择器根据元素的属性来进行选择。（具体参考：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors） 语法：[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value] 例子：[autoplay] 将会选择所有具有 autoplay 属性的元素（不论这个属性的值是什么） 组合选择器 紧邻兄弟选择器 &#39;+&#39; 操作符选择相邻元素，即第二个节点紧邻着第一个节点，并且拥有共同的父节点。 语法: A + B 例子: ul + li 会匹配任何 ul 元素后紧邻的 li 元素。 一般兄弟选择器 &#39;~&#39; 操作符选择兄弟元素，也就是说，第二个节点在第一个节点后面的任意位置，并且这俩节点的父节点相同。 语法: A ~ B 例子: p ~ span 将会匹配同一父元素下，p 元素后的所有 span 元素。 子选择器 &#39;&gt;&#39; 操作符选择第一个元素的直接子节点。 语法: A &gt; B 例子: ul &gt; li 将会匹配直接嵌套在 ul 元素内的所有 li 元素。 后代选择器 &#39; &#39; (空格) 操作符将选择第一个元素的子代节点。 语法: A B 例子: div span 将匹配 div 元素内所有的 span 元素。 Sass (Syntactically Awesome StyleSheets)Less(Leaner Style Sheets)一个变量多次定义首先一个变量不需要在使用之前就定义，而且也可以在不同地方重复定义同一个变量，下面两个编译的结果一样： 123456.lazy-eval&#123; width: @var;&#125;@var:@a;@a:9%; 123456789.lazy-eval&#123; width: @var; @a:9%;&#125;@var:@a;@a:100%;// 定义在块级作用域里的@a(9%)覆盖了全局作用域里的@a(100%) 编译出来的css是： 123.lazy-eval &#123; width: 9%;&#125; 官网里的原话是： When defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value. 更经典的例子是： 12345678910@var: 0;.class &#123; @var: 1; .brass &#123; @var: 2; three: @var; @var: 3; &#125; one: @var;&#125; 编译结果： 123456.class &#123; one: 1;&#125;.class .brass &#123; three: 3;&#125; 可以看出，three首先被赋值@var: 2;，然后被下面定义的@var: 3;覆盖；而one的作用域内看不到@var: 2;和@var: 3;，因此最后被赋值为1 父选择器&amp;&amp;指的是所有的父选择器，而不单单指最近的一个父选择器： 12 JavaScriptasync/await的基础用法 参考：https://www.jianshu.com/p/ffa5cbe9ab29 推荐阅读：https://segmentfault.com/a/1190000007535316 另外补充：进程、线程和协程的理解 参考https://blog.csdn.net/hairetz/article/details/16119911 进程、线程和协程 堆 栈 调度 进程 独立 独立 操作系统 线程 共享 独立 操作系统 协程 共享 独立 程序员在代码中显式调度 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。 进程和其他两个的区别还是很明显的。 协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。 async/await的特点 Promise主要用then函数的链式调用，一直点点点，是一种从左向右的横向写法。async/await从上到下，顺序执行，就像写同步代码一样。这更符合人编写代码的习惯 Promise的then函数只能传递一个参数，虽然可以通过包装成对象，但是这会导致传递冗余信息，频繁的解析又重新组合参数，比较麻烦。async/await没有这个限制，就当做普通的局部变量来处理好了，用let或者const定义的块级变量，想怎么用就怎么用，想定义几个就定义几个，完全没有限制，也没有冗余的工作。 Promise在使用的时候最好将同步代码和异步代码放在不同的then节点中，这样结构更加清晰。async/await整个书写习惯都是同步的，不需要纠结同步和异步的区别。当然，异步过程需要包装成一个Promise对象，放在await关键字后面，这点还是要牢记的。 Promise是根据函数式编程的范式，对异步过程进行了一层封装。async/await是基于协程的机制，是真正的“保存上下文，控制权切换 … … 控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述。 async/await是基于Promise的，是进一步的一种优化。不过再写代码的时候，Promise本身的API出现得很少，很接近同步代码的写法。 await关键字使用的注意点 只能放在async函数内部使用，不能放在普通函数里面，否则会报错。 后面放Promise对象，在Pending状态时，相应的协程会交出控制权，进入等待状态。这个是本质。 await是async wait的意思，wait的是resolve(data)消息，并把数据data返回。比如，下面代码中，当Promise对象由Pending变为Resolved的时候，变量a就等于data；然后再顺序执行下面的语句console.log(a);这真的是等待，真的是顺序执行，表现和同步代码几乎一模一样。 12345const a = await new Promise((resolve, reject) =&gt; &#123; // async process ... return resolve(data);&#125;);console.log(a); await后面也可以跟同步代码，不过系统会自动转化成一个Promise对象。比如const a = await &#39;hello world&#39;;其实就相当于const a = await Promise.resolve(&#39;hello world&#39;);这跟同步代码const a = &#39;hello world&#39;;是一样的，还不如省点事，去掉这里的await关键字。 await只关心异步过程成功的消息resolve(data)，拿到相应的数据data。至于失败消息reject(error)，不关心，不处理。当然对于错误消息的处理，有以下几种方法供选择：（1）让await后面的Promise对象自己catch（2）也可以让外面的async函数返回的Promise对象统一catch（3）像同步代码一样，放在一个try...catch结构中 async关键字使用的注意点 有了这个async关键字，只是表明里面可能有异步过程，里面可以有await关键字。当然，全部是同步代码也没关系。当然，这时候这个async关键字就显得多余了。不是不能加，而是不应该加。 async函数，如果里面有异步过程，会等待；但是async函数本身会马上返回，不会阻塞当前线程。 可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染。async函数内部由async关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回。 async函数的返回值是一个Promise对象，这个是和普通函数本质不同的地方。这也是使用时重点注意的地方（1）return newPromise();这个符合async函数本意；（2）return data;这个是同步函数的写法，这里是要特别注意的。这个时候，其实就相当于Promise.resolve(data);还是一个Promise对象。在调用async函数的地方通过简单的=是拿不到这个data的。那么怎么样拿到这个data呢？很简单，返回值是一个Promise对象，用.then(data =&gt; { })函数就可以。（3）如果没有返回，相当于返回了Promise.resolve(undefined); await是不管异步过程的reject(error)消息的，async函数返回的这个Promise对象的catch函数就负责统一抓取内部所有异步过程的错误。async函数内部只要有一个异步过程发生错误，整个执行过程就中断，这个返回的Promise对象的catch就能抓到这个错误。 async函数执行和普通函数一样，函数名带个()就可以了，参数个数随意，没有限制；也需要有async关键字。只是返回值是一个Promise对象，可以用then函数得到返回值，用catch抓去整个流程中发生的错误。 ES6、ES7、ES8、ES9、ES10新特性一览 参考：https://juejin.im/post/5ca2e1935188254416288eb2 前端项目将React项目部署到Github Pages 参考：https://segmentfault.com/a/1190000019290048 一些注意事项： （1）Github Pages自定义域名问题 往gh-pages分支添加CNAME记录 将要添加的域名写入CNAME，但是注意不要加入http:// 这里还有个问题就是，由于gh-pages分支是将编译之后的内容上传的，如果直接在gh-pages分支添加CNAME文件，会导致出现重新部署的时候CNAME被删除，这时后如果再次访问自定义域名，就会出现Content Security Policy问题（参见：https://stackoverflow.com/questions/54380373/content-security-policy-while-deploying-to-github-pages-using-gatsby） 1Refused to load the image 'http://www.alexingberg.com/favicon.ico' because it violates the following Content Security Policy directive: \"img-src data:\". 你可以按照stackoverflow上面的方案解决（我没试过），但我这里提供一个简单的解决方案，就是将CNAME添加在项目的public文件夹下面，编译之后CNAME就会在build目录生成，这样就不会出现Content Security Policy问题了 （2）自定义域名后出现资源路径不正确的问题 网上一些教程都是教你把Github Pages生成的那一串链接地址设置到&quot;homepages&quot;中 这样会出现的问题就是，编译完成后，会在静态资源的路径前面都加上/chph-blog，这样肯定是找不到对应的资源的 可以通过把&quot;homepages&quot;设置成&quot;./&quot;即可 Github开源项目license选择问题简单一点，借用阮一峰博客上面的一张图： 在React项目中使用Docz遇到的问题（1）按照官网的Getting Start添加依赖后执行yarnpkg add docz，出现的问题如下： 1234567891011121314Failed to compile../node_modules/docz/dist/index.esm.js 23:38Module parse failed: Unexpected token (23:38)Failed to compile../node_modules/docz/dist/index.esm.js 23:38Module parse failed: Unexpected token (23:38)You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders| import &#123; MDXProvider &#125; from '@mdx-js/react';| &gt; const BasePlayground = loadable(() =&gt; import('./Playground.esm.js'));| const Playground = props =&gt; typeof window !== 'undefined' ? createElement(Suspense, &#123;| fallback: null Github上面的相关issue是：https://github.com/pedronauck/docz/issues/596 最关键的是这一个： 他给出的解决方案是对webpack降级： 1npm i -D webpack@4.28.4 问题解决！ 然而，事情远远没有那么简单，当再次运行yarn start启动项目时，爆炸了： 显然是docz和creact-react-app的webpack版本冲突了，我又在github搜罗了一番，解决方案是给docz单独指定一个webpack版本： 启动成功，舒服了 在React中使用Scss 参考：https://segmentfault.com/a/1190000016571839 前端工具使用webpack","categories":[{"name":"笔记","slug":"笔记","permalink":"http://QQ876684433.github.io/categories/笔记/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://QQ876684433.github.io/tags/前端/"}]}]}